
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model CrisisSession
 * 
 */
export type CrisisSession = $Result.DefaultSelection<Prisma.$CrisisSessionPayload>
/**
 * Model CrisisMessage
 * 
 */
export type CrisisMessage = $Result.DefaultSelection<Prisma.$CrisisMessagePayload>
/**
 * Model CrisisEscalation
 * 
 */
export type CrisisEscalation = $Result.DefaultSelection<Prisma.$CrisisEscalationPayload>
/**
 * Model TetherLink
 * 
 */
export type TetherLink = $Result.DefaultSelection<Prisma.$TetherLinkPayload>
/**
 * Model TetherPulse
 * 
 */
export type TetherPulse = $Result.DefaultSelection<Prisma.$TetherPulsePayload>
/**
 * Model TetherEmergency
 * 
 */
export type TetherEmergency = $Result.DefaultSelection<Prisma.$TetherEmergencyPayload>
/**
 * Model Volunteer
 * 
 */
export type Volunteer = $Result.DefaultSelection<Prisma.$VolunteerPayload>
/**
 * Model VolunteerTraining
 * 
 */
export type VolunteerTraining = $Result.DefaultSelection<Prisma.$VolunteerTrainingPayload>
/**
 * Model VolunteerSession
 * 
 */
export type VolunteerSession = $Result.DefaultSelection<Prisma.$VolunteerSessionPayload>
/**
 * Model VolunteerFeedback
 * 
 */
export type VolunteerFeedback = $Result.DefaultSelection<Prisma.$VolunteerFeedbackPayload>
/**
 * Model CrisisResourceUsage
 * 
 */
export type CrisisResourceUsage = $Result.DefaultSelection<Prisma.$CrisisResourceUsagePayload>
/**
 * Model SafetyReport
 * 
 */
export type SafetyReport = $Result.DefaultSelection<Prisma.$SafetyReportPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model AnalyticsEvent
 * 
 */
export type AnalyticsEvent = $Result.DefaultSelection<Prisma.$AnalyticsEventPayload>
/**
 * Model PerformanceMetric
 * 
 */
export type PerformanceMetric = $Result.DefaultSelection<Prisma.$PerformanceMetricPayload>
/**
 * Model SystemHealth
 * 
 */
export type SystemHealth = $Result.DefaultSelection<Prisma.$SystemHealthPayload>
/**
 * Model CrisisResource
 * 
 */
export type CrisisResource = $Result.DefaultSelection<Prisma.$CrisisResourcePayload>
/**
 * Model PublicMetrics
 * 
 */
export type PublicMetrics = $Result.DefaultSelection<Prisma.$PublicMetricsPayload>
/**
 * Model EmergencyContact
 * 
 */
export type EmergencyContact = $Result.DefaultSelection<Prisma.$EmergencyContactPayload>
/**
 * Model EmergencyNotification
 * 
 */
export type EmergencyNotification = $Result.DefaultSelection<Prisma.$EmergencyNotificationPayload>
/**
 * Model WebSocketConnection
 * 
 */
export type WebSocketConnection = $Result.DefaultSelection<Prisma.$WebSocketConnectionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model MoodEntry
 * 
 */
export type MoodEntry = $Result.DefaultSelection<Prisma.$MoodEntryPayload>
/**
 * Model SafetyPlan
 * 
 */
export type SafetyPlan = $Result.DefaultSelection<Prisma.$SafetyPlanPayload>
/**
 * Model SafetyPlanVersion
 * 
 */
export type SafetyPlanVersion = $Result.DefaultSelection<Prisma.$SafetyPlanVersionPayload>
/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model UserAchievement
 * 
 */
export type UserAchievement = $Result.DefaultSelection<Prisma.$UserAchievementPayload>
/**
 * Model Challenge
 * 
 */
export type Challenge = $Result.DefaultSelection<Prisma.$ChallengePayload>
/**
 * Model UserChallenge
 * 
 */
export type UserChallenge = $Result.DefaultSelection<Prisma.$UserChallengePayload>
/**
 * Model UserActivity
 * 
 */
export type UserActivity = $Result.DefaultSelection<Prisma.$UserActivityPayload>
/**
 * Model JournalEntry
 * 
 */
export type JournalEntry = $Result.DefaultSelection<Prisma.$JournalEntryPayload>
/**
 * Model BreathingExercise
 * 
 */
export type BreathingExercise = $Result.DefaultSelection<Prisma.$BreathingExercisePayload>
/**
 * Model BreathingSession
 * 
 */
export type BreathingSession = $Result.DefaultSelection<Prisma.$BreathingSessionPayload>
/**
 * Model GroundingTechnique
 * 
 */
export type GroundingTechnique = $Result.DefaultSelection<Prisma.$GroundingTechniquePayload>
/**
 * Model GroundingSession
 * 
 */
export type GroundingSession = $Result.DefaultSelection<Prisma.$GroundingSessionPayload>
/**
 * Model SelfHelpResource
 * 
 */
export type SelfHelpResource = $Result.DefaultSelection<Prisma.$SelfHelpResourcePayload>
/**
 * Model SelfHelpInteraction
 * 
 */
export type SelfHelpInteraction = $Result.DefaultSelection<Prisma.$SelfHelpInteractionPayload>
/**
 * Model AITherapist
 * 
 */
export type AITherapist = $Result.DefaultSelection<Prisma.$AITherapistPayload>
/**
 * Model AITherapySession
 * 
 */
export type AITherapySession = $Result.DefaultSelection<Prisma.$AITherapySessionPayload>
/**
 * Model AITherapyMessage
 * 
 */
export type AITherapyMessage = $Result.DefaultSelection<Prisma.$AITherapyMessagePayload>
/**
 * Model AIPersonalization
 * 
 */
export type AIPersonalization = $Result.DefaultSelection<Prisma.$AIPersonalizationPayload>
/**
 * Model AIExerciseSession
 * 
 */
export type AIExerciseSession = $Result.DefaultSelection<Prisma.$AIExerciseSessionPayload>
/**
 * Model AITherapyInsight
 * 
 */
export type AITherapyInsight = $Result.DefaultSelection<Prisma.$AITherapyInsightPayload>
/**
 * Model AITherapyGoal
 * 
 */
export type AITherapyGoal = $Result.DefaultSelection<Prisma.$AITherapyGoalPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CrisisStatus: {
  ACTIVE: 'ACTIVE',
  ASSIGNED: 'ASSIGNED',
  RESOLVED: 'RESOLVED',
  ESCALATED: 'ESCALATED',
  ABANDONED: 'ABANDONED'
};

export type CrisisStatus = (typeof CrisisStatus)[keyof typeof CrisisStatus]


export const EscalationType: {
  AUTOMATIC_KEYWORD: 'AUTOMATIC_KEYWORD',
  MANUAL_VOLUNTEER: 'MANUAL_VOLUNTEER',
  USER_REQUEST: 'USER_REQUEST',
  SYSTEM_TIMEOUT: 'SYSTEM_TIMEOUT',
  EMERGENCY_SERVICES: 'EMERGENCY_SERVICES'
};

export type EscalationType = (typeof EscalationType)[keyof typeof EscalationType]


export const MessageSender: {
  ANONYMOUS_USER: 'ANONYMOUS_USER',
  VOLUNTEER: 'VOLUNTEER',
  SYSTEM: 'SYSTEM',
  AI_ASSISTANT: 'AI_ASSISTANT'
};

export type MessageSender = (typeof MessageSender)[keyof typeof MessageSender]


export const MessageType: {
  TEXT: 'TEXT',
  VOICE_NOTE: 'VOICE_NOTE',
  IMAGE: 'IMAGE',
  SYSTEM_MESSAGE: 'SYSTEM_MESSAGE',
  RESOURCE_SHARE: 'RESOURCE_SHARE'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const MessagePriority: {
  LOW: 'LOW',
  NORMAL: 'NORMAL',
  HIGH: 'HIGH',
  URGENT: 'URGENT',
  EMERGENCY: 'EMERGENCY'
};

export type MessagePriority = (typeof MessagePriority)[keyof typeof MessagePriority]


export const EscalationTrigger: {
  KEYWORD_DETECTION: 'KEYWORD_DETECTION',
  SEVERITY_INCREASE: 'SEVERITY_INCREASE',
  VOLUNTEER_REQUEST: 'VOLUNTEER_REQUEST',
  USER_REQUEST: 'USER_REQUEST',
  TIMEOUT: 'TIMEOUT',
  AI_ASSESSMENT: 'AI_ASSESSMENT'
};

export type EscalationTrigger = (typeof EscalationTrigger)[keyof typeof EscalationTrigger]


export const EscalationSeverity: {
  MODERATE: 'MODERATE',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL',
  EMERGENCY: 'EMERGENCY'
};

export type EscalationSeverity = (typeof EscalationSeverity)[keyof typeof EscalationSeverity]


export const EscalationOutcome: {
  RESOLVED_INTERNALLY: 'RESOLVED_INTERNALLY',
  REFERRED_TO_PROFESSIONAL: 'REFERRED_TO_PROFESSIONAL',
  EMERGENCY_SERVICES_CONTACTED: 'EMERGENCY_SERVICES_CONTACTED',
  USER_DISCONNECTED: 'USER_DISCONNECTED',
  ONGOING: 'ONGOING'
};

export type EscalationOutcome = (typeof EscalationOutcome)[keyof typeof EscalationOutcome]


export const TetherDataSharing: {
  MINIMAL: 'MINIMAL',
  MODERATE: 'MODERATE',
  FULL: 'FULL'
};

export type TetherDataSharing = (typeof TetherDataSharing)[keyof typeof TetherDataSharing]


export const PulseType: {
  HEARTBEAT: 'HEARTBEAT',
  CHECK_IN: 'CHECK_IN',
  MOOD_UPDATE: 'MOOD_UPDATE',
  EMERGENCY: 'EMERGENCY',
  CUSTOM: 'CUSTOM'
};

export type PulseType = (typeof PulseType)[keyof typeof PulseType]


export const UserStatus: {
  NORMAL: 'NORMAL',
  STRUGGLING: 'STRUGGLING',
  CRISIS: 'CRISIS',
  EMERGENCY: 'EMERGENCY',
  OFFLINE: 'OFFLINE'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const UrgencyLevel: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type UrgencyLevel = (typeof UrgencyLevel)[keyof typeof UrgencyLevel]


export const EmergencyType: {
  MENTAL_HEALTH_CRISIS: 'MENTAL_HEALTH_CRISIS',
  SELF_HARM_RISK: 'SELF_HARM_RISK',
  SUICIDAL_IDEATION: 'SUICIDAL_IDEATION',
  PANIC_ATTACK: 'PANIC_ATTACK',
  MEDICAL_EMERGENCY: 'MEDICAL_EMERGENCY',
  SAFETY_CONCERN: 'SAFETY_CONCERN'
};

export type EmergencyType = (typeof EmergencyType)[keyof typeof EmergencyType]


export const EmergencySeverity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL',
  LIFE_THREATENING: 'LIFE_THREATENING'
};

export type EmergencySeverity = (typeof EmergencySeverity)[keyof typeof EmergencySeverity]


export const EmergencyOutcome: {
  RESOLVED: 'RESOLVED',
  ESCALATED: 'ESCALATED',
  EMERGENCY_SERVICES: 'EMERGENCY_SERVICES',
  ONGOING: 'ONGOING',
  USER_SAFE: 'USER_SAFE'
};

export type EmergencyOutcome = (typeof EmergencyOutcome)[keyof typeof EmergencyOutcome]


export const VolunteerStatus: {
  PENDING: 'PENDING',
  TRAINING: 'TRAINING',
  BACKGROUND_CHECK: 'BACKGROUND_CHECK',
  VERIFIED: 'VERIFIED',
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED',
  REVOKED: 'REVOKED'
};

export type VolunteerStatus = (typeof VolunteerStatus)[keyof typeof VolunteerStatus]


export const VerificationStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED'
};

export type VerificationStatus = (typeof VerificationStatus)[keyof typeof VerificationStatus]


export const TrainingStatus: {
  NOT_STARTED: 'NOT_STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  EXPIRED: 'EXPIRED'
};

export type TrainingStatus = (typeof TrainingStatus)[keyof typeof TrainingStatus]


export const TrainingType: {
  CRISIS_INTERVENTION: 'CRISIS_INTERVENTION',
  ACTIVE_LISTENING: 'ACTIVE_LISTENING',
  DE_ESCALATION: 'DE_ESCALATION',
  PLATFORM_TRAINING: 'PLATFORM_TRAINING',
  SPECIALIZED_TOPIC: 'SPECIALIZED_TOPIC',
  ONGOING_EDUCATION: 'ONGOING_EDUCATION'
};

export type TrainingType = (typeof TrainingType)[keyof typeof TrainingType]


export const VolunteerSessionType: {
  CRISIS_RESPONSE: 'CRISIS_RESPONSE',
  PEER_SUPPORT: 'PEER_SUPPORT',
  GROUP_MODERATION: 'GROUP_MODERATION',
  TRAINING_SESSION: 'TRAINING_SESSION',
  SUPERVISION: 'SUPERVISION'
};

export type VolunteerSessionType = (typeof VolunteerSessionType)[keyof typeof VolunteerSessionType]


export const SessionOutcome: {
  SUCCESSFUL_RESOLUTION: 'SUCCESSFUL_RESOLUTION',
  REFERRED_TO_PROFESSIONAL: 'REFERRED_TO_PROFESSIONAL',
  USER_DISCONNECTED: 'USER_DISCONNECTED',
  ESCALATED_TO_EMERGENCY: 'ESCALATED_TO_EMERGENCY',
  ONGOING: 'ONGOING'
};

export type SessionOutcome = (typeof SessionOutcome)[keyof typeof SessionOutcome]


export const ResourceCategory: {
  CRISIS_HOTLINE: 'CRISIS_HOTLINE',
  EMERGENCY_SERVICE: 'EMERGENCY_SERVICE',
  SELF_HELP_TOOL: 'SELF_HELP_TOOL',
  BREATHING_EXERCISE: 'BREATHING_EXERCISE',
  GROUNDING_TECHNIQUE: 'GROUNDING_TECHNIQUE',
  SAFETY_PLANNING: 'SAFETY_PLANNING',
  PROFESSIONAL_HELP: 'PROFESSIONAL_HELP',
  PEER_SUPPORT: 'PEER_SUPPORT'
};

export type ResourceCategory = (typeof ResourceCategory)[keyof typeof ResourceCategory]


export const MetricStatus: {
  NORMAL: 'NORMAL',
  WARNING: 'WARNING',
  CRITICAL: 'CRITICAL',
  UNKNOWN: 'UNKNOWN'
};

export type MetricStatus = (typeof MetricStatus)[keyof typeof MetricStatus]


export const HealthStatus: {
  HEALTHY: 'HEALTHY',
  DEGRADED: 'DEGRADED',
  UNHEALTHY: 'UNHEALTHY',
  DOWN: 'DOWN'
};

export type HealthStatus = (typeof HealthStatus)[keyof typeof HealthStatus]


export const FeedbackType: {
  GENERAL: 'GENERAL',
  SESSION_QUALITY: 'SESSION_QUALITY',
  RESPONSE_TIME: 'RESPONSE_TIME',
  PROFESSIONALISM: 'PROFESSIONALISM',
  EMPATHY: 'EMPATHY',
  EFFECTIVENESS: 'EFFECTIVENESS',
  TECHNICAL_ISSUES: 'TECHNICAL_ISSUES',
  COMMUNICATION: 'COMMUNICATION',
  COMPLAINT: 'COMPLAINT',
  SUGGESTION: 'SUGGESTION',
  APPRECIATION: 'APPRECIATION',
  OTHER: 'OTHER'
};

export type FeedbackType = (typeof FeedbackType)[keyof typeof FeedbackType]


export const FeedbackSource: {
  USER: 'USER',
  SYSTEM: 'SYSTEM',
  PEER_REVIEW: 'PEER_REVIEW',
  SUPERVISOR: 'SUPERVISOR',
  AUTOMATED: 'AUTOMATED',
  ANONYMOUS: 'ANONYMOUS',
  OTHER: 'OTHER'
};

export type FeedbackSource = (typeof FeedbackSource)[keyof typeof FeedbackSource]


export const ReportType: {
  CONTENT_VIOLATION: 'CONTENT_VIOLATION',
  HARASSMENT: 'HARASSMENT',
  SPAM: 'SPAM',
  SELF_HARM_CONTENT: 'SELF_HARM_CONTENT',
  INAPPROPRIATE_BEHAVIOR: 'INAPPROPRIATE_BEHAVIOR',
  TECHNICAL_ISSUE: 'TECHNICAL_ISSUE',
  PRIVACY_CONCERN: 'PRIVACY_CONCERN',
  OTHER: 'OTHER'
};

export type ReportType = (typeof ReportType)[keyof typeof ReportType]


export const ReportSeverity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL',
  EMERGENCY: 'EMERGENCY'
};

export type ReportSeverity = (typeof ReportSeverity)[keyof typeof ReportSeverity]


export const ReportStatus: {
  PENDING: 'PENDING',
  UNDER_REVIEW: 'UNDER_REVIEW',
  RESOLVED: 'RESOLVED',
  DISMISSED: 'DISMISSED',
  ESCALATED: 'ESCALATED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const UserDataSharing: {
  MINIMAL: 'MINIMAL',
  ANONYMOUS_ANALYTICS: 'ANONYMOUS_ANALYTICS',
  COMMUNITY_FEATURES: 'COMMUNITY_FEATURES',
  FULL_RESEARCH: 'FULL_RESEARCH'
};

export type UserDataSharing = (typeof UserDataSharing)[keyof typeof UserDataSharing]


export const AchievementCategory: {
  MOOD_TRACKING: 'MOOD_TRACKING',
  CONSISTENCY: 'CONSISTENCY',
  SELF_CARE: 'SELF_CARE',
  CRISIS_MANAGEMENT: 'CRISIS_MANAGEMENT',
  COMMUNITY: 'COMMUNITY',
  PERSONAL_GROWTH: 'PERSONAL_GROWTH',
  WELLNESS_MILESTONES: 'WELLNESS_MILESTONES'
};

export type AchievementCategory = (typeof AchievementCategory)[keyof typeof AchievementCategory]


export const AchievementRarity: {
  COMMON: 'COMMON',
  UNCOMMON: 'UNCOMMON',
  RARE: 'RARE',
  EPIC: 'EPIC',
  LEGENDARY: 'LEGENDARY'
};

export type AchievementRarity = (typeof AchievementRarity)[keyof typeof AchievementRarity]


export const ChallengeType: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  MILESTONE: 'MILESTONE',
  COMMUNITY: 'COMMUNITY',
  SEASONAL: 'SEASONAL'
};

export type ChallengeType = (typeof ChallengeType)[keyof typeof ChallengeType]


export const ChallengeDifficulty: {
  EASY: 'EASY',
  MEDIUM: 'MEDIUM',
  HARD: 'HARD',
  EXPERT: 'EXPERT'
};

export type ChallengeDifficulty = (typeof ChallengeDifficulty)[keyof typeof ChallengeDifficulty]


export const ActivityType: {
  MOOD_LOG: 'MOOD_LOG',
  SAFETY_PLAN_UPDATE: 'SAFETY_PLAN_UPDATE',
  ACHIEVEMENT_UNLOCK: 'ACHIEVEMENT_UNLOCK',
  CHALLENGE_COMPLETE: 'CHALLENGE_COMPLETE',
  LEVEL_UP: 'LEVEL_UP',
  COMMUNITY_INTERACTION: 'COMMUNITY_INTERACTION',
  SELF_CARE_ACTIVITY: 'SELF_CARE_ACTIVITY',
  CRISIS_RESOURCE_ACCESS: 'CRISIS_RESOURCE_ACCESS'
};

export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType]


export const EmergencyNotificationType: {
  CRISIS_ESCALATION: 'CRISIS_ESCALATION',
  SAFETY_PLAN_ACTIVATION: 'SAFETY_PLAN_ACTIVATION',
  EMERGENCY_ALERT: 'EMERGENCY_ALERT',
  WELLNESS_CHECK: 'WELLNESS_CHECK',
  MEDICAL_EMERGENCY: 'MEDICAL_EMERGENCY',
  SELF_HARM_DETECTED: 'SELF_HARM_DETECTED',
  SUICIDE_RISK: 'SUICIDE_RISK',
  PANIC_ATTACK: 'PANIC_ATTACK',
  CUSTOM_ALERT: 'CUSTOM_ALERT'
};

export type EmergencyNotificationType = (typeof EmergencyNotificationType)[keyof typeof EmergencyNotificationType]


export const NotificationStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  ACKNOWLEDGED: 'ACKNOWLEDGED',
  FAILED: 'FAILED',
  RETRYING: 'RETRYING',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]


export const JournalType: {
  FREEFORM: 'FREEFORM',
  GUIDED: 'GUIDED',
  GRATITUDE: 'GRATITUDE',
  REFLECTION: 'REFLECTION',
  GOAL_SETTING: 'GOAL_SETTING',
  MOOD_LOG: 'MOOD_LOG',
  DREAM: 'DREAM',
  THERAPY_NOTES: 'THERAPY_NOTES'
};

export type JournalType = (typeof JournalType)[keyof typeof JournalType]


export const BreathingTechnique: {
  FOUR_SEVEN_EIGHT: 'FOUR_SEVEN_EIGHT',
  BOX_BREATHING: 'BOX_BREATHING',
  BELLY_BREATHING: 'BELLY_BREATHING',
  ALTERNATE_NOSTRIL: 'ALTERNATE_NOSTRIL',
  COHERENT: 'COHERENT',
  LION_BREATH: 'LION_BREATH',
  COOLING_BREATH: 'COOLING_BREATH',
  FIRE_BREATH: 'FIRE_BREATH'
};

export type BreathingTechnique = (typeof BreathingTechnique)[keyof typeof BreathingTechnique]


export const GroundingType: {
  SENSORY: 'SENSORY',
  PHYSICAL: 'PHYSICAL',
  MENTAL: 'MENTAL',
  SPIRITUAL: 'SPIRITUAL',
  CREATIVE: 'CREATIVE',
  MOVEMENT: 'MOVEMENT'
};

export type GroundingType = (typeof GroundingType)[keyof typeof GroundingType]


export const GroundingCategory: {
  PANIC_ATTACK: 'PANIC_ATTACK',
  DISSOCIATION: 'DISSOCIATION',
  FLASHBACK: 'FLASHBACK',
  ANXIETY: 'ANXIETY',
  ANGER: 'ANGER',
  OVERWHELM: 'OVERWHELM',
  TRAUMA_RESPONSE: 'TRAUMA_RESPONSE'
};

export type GroundingCategory = (typeof GroundingCategory)[keyof typeof GroundingCategory]


export const ExerciseDifficulty: {
  BEGINNER: 'BEGINNER',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED',
  EXPERT: 'EXPERT'
};

export type ExerciseDifficulty = (typeof ExerciseDifficulty)[keyof typeof ExerciseDifficulty]


export const EvidenceLevel: {
  HIGH: 'HIGH',
  MODERATE: 'MODERATE',
  LOW: 'LOW',
  EMERGING: 'EMERGING'
};

export type EvidenceLevel = (typeof EvidenceLevel)[keyof typeof EvidenceLevel]


export const SelfHelpCategory: {
  MOOD_TRACKING: 'MOOD_TRACKING',
  JOURNALING: 'JOURNALING',
  BREATHING: 'BREATHING',
  GROUNDING: 'GROUNDING',
  MEDITATION: 'MEDITATION',
  EXERCISE: 'EXERCISE',
  SLEEP: 'SLEEP',
  NUTRITION: 'NUTRITION',
  SOCIAL: 'SOCIAL',
  CREATIVE: 'CREATIVE',
  EDUCATIONAL: 'EDUCATIONAL'
};

export type SelfHelpCategory = (typeof SelfHelpCategory)[keyof typeof SelfHelpCategory]


export const ResourceType: {
  ARTICLE: 'ARTICLE',
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO',
  INTERACTIVE: 'INTERACTIVE',
  PDF: 'PDF',
  WORKSHEET: 'WORKSHEET',
  APP: 'APP',
  WEBSITE: 'WEBSITE'
};

export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType]


export const InteractionType: {
  VIEW: 'VIEW',
  START: 'START',
  COMPLETE: 'COMPLETE',
  SAVE: 'SAVE',
  SHARE: 'SHARE',
  RATE: 'RATE'
};

export type InteractionType = (typeof InteractionType)[keyof typeof InteractionType]


export const AISessionType: {
  CRISIS: 'CRISIS',
  SCHEDULED: 'SCHEDULED',
  CHECK_IN: 'CHECK_IN',
  INTENSIVE: 'INTENSIVE',
  FOLLOWUP: 'FOLLOWUP',
  ASSESSMENT: 'ASSESSMENT'
};

export type AISessionType = (typeof AISessionType)[keyof typeof AISessionType]


export const AISessionStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  ABANDONED: 'ABANDONED',
  ESCALATED: 'ESCALATED'
};

export type AISessionStatus = (typeof AISessionStatus)[keyof typeof AISessionStatus]


export const AIMessageType: {
  TEXT: 'TEXT',
  AUDIO: 'AUDIO',
  ASSESSMENT: 'ASSESSMENT',
  INTERVENTION: 'INTERVENTION',
  EXERCISE: 'EXERCISE',
  RESOURCE: 'RESOURCE'
};

export type AIMessageType = (typeof AIMessageType)[keyof typeof AIMessageType]


export const AIMessageSender: {
  USER: 'USER',
  THERAPIST: 'THERAPIST',
  SYSTEM: 'SYSTEM'
};

export type AIMessageSender = (typeof AIMessageSender)[keyof typeof AIMessageSender]


export const AIExerciseType: {
  CBT_WORKSHEET: 'CBT_WORKSHEET',
  THOUGHT_RECORD: 'THOUGHT_RECORD',
  BREATHING: 'BREATHING',
  MEDITATION: 'MEDITATION',
  GROUNDING: 'GROUNDING',
  JOURNALING: 'JOURNALING',
  MOOD_CHECK: 'MOOD_CHECK',
  PMR: 'PMR',
  VISUALIZATION: 'VISUALIZATION',
  BEHAVIORAL_ACTIVATION: 'BEHAVIORAL_ACTIVATION',
  VALUES_CLARIFICATION: 'VALUES_CLARIFICATION',
  EXPOSURE_THERAPY: 'EXPOSURE_THERAPY'
};

export type AIExerciseType = (typeof AIExerciseType)[keyof typeof AIExerciseType]


export const AIInsightType: {
  MOOD_TREND: 'MOOD_TREND',
  TRIGGER_PATTERN: 'TRIGGER_PATTERN',
  PROGRESS_REPORT: 'PROGRESS_REPORT',
  BREAKTHROUGH: 'BREAKTHROUGH',
  WARNING_SIGN: 'WARNING_SIGN',
  RECOMMENDATION: 'RECOMMENDATION',
  WEEKLY_SUMMARY: 'WEEKLY_SUMMARY',
  MONTHLY_REPORT: 'MONTHLY_REPORT'
};

export type AIInsightType = (typeof AIInsightType)[keyof typeof AIInsightType]


export const AIGoalStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  ABANDONED: 'ABANDONED',
  REVISED: 'REVISED'
};

export type AIGoalStatus = (typeof AIGoalStatus)[keyof typeof AIGoalStatus]

}

export type CrisisStatus = $Enums.CrisisStatus

export const CrisisStatus: typeof $Enums.CrisisStatus

export type EscalationType = $Enums.EscalationType

export const EscalationType: typeof $Enums.EscalationType

export type MessageSender = $Enums.MessageSender

export const MessageSender: typeof $Enums.MessageSender

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type MessagePriority = $Enums.MessagePriority

export const MessagePriority: typeof $Enums.MessagePriority

export type EscalationTrigger = $Enums.EscalationTrigger

export const EscalationTrigger: typeof $Enums.EscalationTrigger

export type EscalationSeverity = $Enums.EscalationSeverity

export const EscalationSeverity: typeof $Enums.EscalationSeverity

export type EscalationOutcome = $Enums.EscalationOutcome

export const EscalationOutcome: typeof $Enums.EscalationOutcome

export type TetherDataSharing = $Enums.TetherDataSharing

export const TetherDataSharing: typeof $Enums.TetherDataSharing

export type PulseType = $Enums.PulseType

export const PulseType: typeof $Enums.PulseType

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type UrgencyLevel = $Enums.UrgencyLevel

export const UrgencyLevel: typeof $Enums.UrgencyLevel

export type EmergencyType = $Enums.EmergencyType

export const EmergencyType: typeof $Enums.EmergencyType

export type EmergencySeverity = $Enums.EmergencySeverity

export const EmergencySeverity: typeof $Enums.EmergencySeverity

export type EmergencyOutcome = $Enums.EmergencyOutcome

export const EmergencyOutcome: typeof $Enums.EmergencyOutcome

export type VolunteerStatus = $Enums.VolunteerStatus

export const VolunteerStatus: typeof $Enums.VolunteerStatus

export type VerificationStatus = $Enums.VerificationStatus

export const VerificationStatus: typeof $Enums.VerificationStatus

export type TrainingStatus = $Enums.TrainingStatus

export const TrainingStatus: typeof $Enums.TrainingStatus

export type TrainingType = $Enums.TrainingType

export const TrainingType: typeof $Enums.TrainingType

export type VolunteerSessionType = $Enums.VolunteerSessionType

export const VolunteerSessionType: typeof $Enums.VolunteerSessionType

export type SessionOutcome = $Enums.SessionOutcome

export const SessionOutcome: typeof $Enums.SessionOutcome

export type ResourceCategory = $Enums.ResourceCategory

export const ResourceCategory: typeof $Enums.ResourceCategory

export type MetricStatus = $Enums.MetricStatus

export const MetricStatus: typeof $Enums.MetricStatus

export type HealthStatus = $Enums.HealthStatus

export const HealthStatus: typeof $Enums.HealthStatus

export type FeedbackType = $Enums.FeedbackType

export const FeedbackType: typeof $Enums.FeedbackType

export type FeedbackSource = $Enums.FeedbackSource

export const FeedbackSource: typeof $Enums.FeedbackSource

export type ReportType = $Enums.ReportType

export const ReportType: typeof $Enums.ReportType

export type ReportSeverity = $Enums.ReportSeverity

export const ReportSeverity: typeof $Enums.ReportSeverity

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type UserDataSharing = $Enums.UserDataSharing

export const UserDataSharing: typeof $Enums.UserDataSharing

export type AchievementCategory = $Enums.AchievementCategory

export const AchievementCategory: typeof $Enums.AchievementCategory

export type AchievementRarity = $Enums.AchievementRarity

export const AchievementRarity: typeof $Enums.AchievementRarity

export type ChallengeType = $Enums.ChallengeType

export const ChallengeType: typeof $Enums.ChallengeType

export type ChallengeDifficulty = $Enums.ChallengeDifficulty

export const ChallengeDifficulty: typeof $Enums.ChallengeDifficulty

export type ActivityType = $Enums.ActivityType

export const ActivityType: typeof $Enums.ActivityType

export type EmergencyNotificationType = $Enums.EmergencyNotificationType

export const EmergencyNotificationType: typeof $Enums.EmergencyNotificationType

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

export type JournalType = $Enums.JournalType

export const JournalType: typeof $Enums.JournalType

export type BreathingTechnique = $Enums.BreathingTechnique

export const BreathingTechnique: typeof $Enums.BreathingTechnique

export type GroundingType = $Enums.GroundingType

export const GroundingType: typeof $Enums.GroundingType

export type GroundingCategory = $Enums.GroundingCategory

export const GroundingCategory: typeof $Enums.GroundingCategory

export type ExerciseDifficulty = $Enums.ExerciseDifficulty

export const ExerciseDifficulty: typeof $Enums.ExerciseDifficulty

export type EvidenceLevel = $Enums.EvidenceLevel

export const EvidenceLevel: typeof $Enums.EvidenceLevel

export type SelfHelpCategory = $Enums.SelfHelpCategory

export const SelfHelpCategory: typeof $Enums.SelfHelpCategory

export type ResourceType = $Enums.ResourceType

export const ResourceType: typeof $Enums.ResourceType

export type InteractionType = $Enums.InteractionType

export const InteractionType: typeof $Enums.InteractionType

export type AISessionType = $Enums.AISessionType

export const AISessionType: typeof $Enums.AISessionType

export type AISessionStatus = $Enums.AISessionStatus

export const AISessionStatus: typeof $Enums.AISessionStatus

export type AIMessageType = $Enums.AIMessageType

export const AIMessageType: typeof $Enums.AIMessageType

export type AIMessageSender = $Enums.AIMessageSender

export const AIMessageSender: typeof $Enums.AIMessageSender

export type AIExerciseType = $Enums.AIExerciseType

export const AIExerciseType: typeof $Enums.AIExerciseType

export type AIInsightType = $Enums.AIInsightType

export const AIInsightType: typeof $Enums.AIInsightType

export type AIGoalStatus = $Enums.AIGoalStatus

export const AIGoalStatus: typeof $Enums.AIGoalStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more CrisisSessions
 * const crisisSessions = await prisma.crisisSession.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more CrisisSessions
   * const crisisSessions = await prisma.crisisSession.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.crisisSession`: Exposes CRUD operations for the **CrisisSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrisisSessions
    * const crisisSessions = await prisma.crisisSession.findMany()
    * ```
    */
  get crisisSession(): Prisma.CrisisSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crisisMessage`: Exposes CRUD operations for the **CrisisMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrisisMessages
    * const crisisMessages = await prisma.crisisMessage.findMany()
    * ```
    */
  get crisisMessage(): Prisma.CrisisMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crisisEscalation`: Exposes CRUD operations for the **CrisisEscalation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrisisEscalations
    * const crisisEscalations = await prisma.crisisEscalation.findMany()
    * ```
    */
  get crisisEscalation(): Prisma.CrisisEscalationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tetherLink`: Exposes CRUD operations for the **TetherLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TetherLinks
    * const tetherLinks = await prisma.tetherLink.findMany()
    * ```
    */
  get tetherLink(): Prisma.TetherLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tetherPulse`: Exposes CRUD operations for the **TetherPulse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TetherPulses
    * const tetherPulses = await prisma.tetherPulse.findMany()
    * ```
    */
  get tetherPulse(): Prisma.TetherPulseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tetherEmergency`: Exposes CRUD operations for the **TetherEmergency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TetherEmergencies
    * const tetherEmergencies = await prisma.tetherEmergency.findMany()
    * ```
    */
  get tetherEmergency(): Prisma.TetherEmergencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.volunteer`: Exposes CRUD operations for the **Volunteer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Volunteers
    * const volunteers = await prisma.volunteer.findMany()
    * ```
    */
  get volunteer(): Prisma.VolunteerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.volunteerTraining`: Exposes CRUD operations for the **VolunteerTraining** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VolunteerTrainings
    * const volunteerTrainings = await prisma.volunteerTraining.findMany()
    * ```
    */
  get volunteerTraining(): Prisma.VolunteerTrainingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.volunteerSession`: Exposes CRUD operations for the **VolunteerSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VolunteerSessions
    * const volunteerSessions = await prisma.volunteerSession.findMany()
    * ```
    */
  get volunteerSession(): Prisma.VolunteerSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.volunteerFeedback`: Exposes CRUD operations for the **VolunteerFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VolunteerFeedbacks
    * const volunteerFeedbacks = await prisma.volunteerFeedback.findMany()
    * ```
    */
  get volunteerFeedback(): Prisma.VolunteerFeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crisisResourceUsage`: Exposes CRUD operations for the **CrisisResourceUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrisisResourceUsages
    * const crisisResourceUsages = await prisma.crisisResourceUsage.findMany()
    * ```
    */
  get crisisResourceUsage(): Prisma.CrisisResourceUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.safetyReport`: Exposes CRUD operations for the **SafetyReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SafetyReports
    * const safetyReports = await prisma.safetyReport.findMany()
    * ```
    */
  get safetyReport(): Prisma.SafetyReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsEvent`: Exposes CRUD operations for the **AnalyticsEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsEvents
    * const analyticsEvents = await prisma.analyticsEvent.findMany()
    * ```
    */
  get analyticsEvent(): Prisma.AnalyticsEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performanceMetric`: Exposes CRUD operations for the **PerformanceMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceMetrics
    * const performanceMetrics = await prisma.performanceMetric.findMany()
    * ```
    */
  get performanceMetric(): Prisma.PerformanceMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemHealth`: Exposes CRUD operations for the **SystemHealth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemHealths
    * const systemHealths = await prisma.systemHealth.findMany()
    * ```
    */
  get systemHealth(): Prisma.SystemHealthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crisisResource`: Exposes CRUD operations for the **CrisisResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrisisResources
    * const crisisResources = await prisma.crisisResource.findMany()
    * ```
    */
  get crisisResource(): Prisma.CrisisResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.publicMetrics`: Exposes CRUD operations for the **PublicMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PublicMetrics
    * const publicMetrics = await prisma.publicMetrics.findMany()
    * ```
    */
  get publicMetrics(): Prisma.PublicMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emergencyContact`: Exposes CRUD operations for the **EmergencyContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmergencyContacts
    * const emergencyContacts = await prisma.emergencyContact.findMany()
    * ```
    */
  get emergencyContact(): Prisma.EmergencyContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emergencyNotification`: Exposes CRUD operations for the **EmergencyNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmergencyNotifications
    * const emergencyNotifications = await prisma.emergencyNotification.findMany()
    * ```
    */
  get emergencyNotification(): Prisma.EmergencyNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webSocketConnection`: Exposes CRUD operations for the **WebSocketConnection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebSocketConnections
    * const webSocketConnections = await prisma.webSocketConnection.findMany()
    * ```
    */
  get webSocketConnection(): Prisma.WebSocketConnectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moodEntry`: Exposes CRUD operations for the **MoodEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MoodEntries
    * const moodEntries = await prisma.moodEntry.findMany()
    * ```
    */
  get moodEntry(): Prisma.MoodEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.safetyPlan`: Exposes CRUD operations for the **SafetyPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SafetyPlans
    * const safetyPlans = await prisma.safetyPlan.findMany()
    * ```
    */
  get safetyPlan(): Prisma.SafetyPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.safetyPlanVersion`: Exposes CRUD operations for the **SafetyPlanVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SafetyPlanVersions
    * const safetyPlanVersions = await prisma.safetyPlanVersion.findMany()
    * ```
    */
  get safetyPlanVersion(): Prisma.SafetyPlanVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAchievement`: Exposes CRUD operations for the **UserAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAchievements
    * const userAchievements = await prisma.userAchievement.findMany()
    * ```
    */
  get userAchievement(): Prisma.UserAchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challenge`: Exposes CRUD operations for the **Challenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Challenges
    * const challenges = await prisma.challenge.findMany()
    * ```
    */
  get challenge(): Prisma.ChallengeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userChallenge`: Exposes CRUD operations for the **UserChallenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserChallenges
    * const userChallenges = await prisma.userChallenge.findMany()
    * ```
    */
  get userChallenge(): Prisma.UserChallengeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userActivity`: Exposes CRUD operations for the **UserActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserActivities
    * const userActivities = await prisma.userActivity.findMany()
    * ```
    */
  get userActivity(): Prisma.UserActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalEntry`: Exposes CRUD operations for the **JournalEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalEntries
    * const journalEntries = await prisma.journalEntry.findMany()
    * ```
    */
  get journalEntry(): Prisma.JournalEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.breathingExercise`: Exposes CRUD operations for the **BreathingExercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BreathingExercises
    * const breathingExercises = await prisma.breathingExercise.findMany()
    * ```
    */
  get breathingExercise(): Prisma.BreathingExerciseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.breathingSession`: Exposes CRUD operations for the **BreathingSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BreathingSessions
    * const breathingSessions = await prisma.breathingSession.findMany()
    * ```
    */
  get breathingSession(): Prisma.BreathingSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groundingTechnique`: Exposes CRUD operations for the **GroundingTechnique** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroundingTechniques
    * const groundingTechniques = await prisma.groundingTechnique.findMany()
    * ```
    */
  get groundingTechnique(): Prisma.GroundingTechniqueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groundingSession`: Exposes CRUD operations for the **GroundingSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroundingSessions
    * const groundingSessions = await prisma.groundingSession.findMany()
    * ```
    */
  get groundingSession(): Prisma.GroundingSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.selfHelpResource`: Exposes CRUD operations for the **SelfHelpResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SelfHelpResources
    * const selfHelpResources = await prisma.selfHelpResource.findMany()
    * ```
    */
  get selfHelpResource(): Prisma.SelfHelpResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.selfHelpInteraction`: Exposes CRUD operations for the **SelfHelpInteraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SelfHelpInteractions
    * const selfHelpInteractions = await prisma.selfHelpInteraction.findMany()
    * ```
    */
  get selfHelpInteraction(): Prisma.SelfHelpInteractionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aITherapist`: Exposes CRUD operations for the **AITherapist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AITherapists
    * const aITherapists = await prisma.aITherapist.findMany()
    * ```
    */
  get aITherapist(): Prisma.AITherapistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aITherapySession`: Exposes CRUD operations for the **AITherapySession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AITherapySessions
    * const aITherapySessions = await prisma.aITherapySession.findMany()
    * ```
    */
  get aITherapySession(): Prisma.AITherapySessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aITherapyMessage`: Exposes CRUD operations for the **AITherapyMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AITherapyMessages
    * const aITherapyMessages = await prisma.aITherapyMessage.findMany()
    * ```
    */
  get aITherapyMessage(): Prisma.AITherapyMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIPersonalization`: Exposes CRUD operations for the **AIPersonalization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIPersonalizations
    * const aIPersonalizations = await prisma.aIPersonalization.findMany()
    * ```
    */
  get aIPersonalization(): Prisma.AIPersonalizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIExerciseSession`: Exposes CRUD operations for the **AIExerciseSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIExerciseSessions
    * const aIExerciseSessions = await prisma.aIExerciseSession.findMany()
    * ```
    */
  get aIExerciseSession(): Prisma.AIExerciseSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aITherapyInsight`: Exposes CRUD operations for the **AITherapyInsight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AITherapyInsights
    * const aITherapyInsights = await prisma.aITherapyInsight.findMany()
    * ```
    */
  get aITherapyInsight(): Prisma.AITherapyInsightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aITherapyGoal`: Exposes CRUD operations for the **AITherapyGoal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AITherapyGoals
    * const aITherapyGoals = await prisma.aITherapyGoal.findMany()
    * ```
    */
  get aITherapyGoal(): Prisma.AITherapyGoalDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.1
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    CrisisSession: 'CrisisSession',
    CrisisMessage: 'CrisisMessage',
    CrisisEscalation: 'CrisisEscalation',
    TetherLink: 'TetherLink',
    TetherPulse: 'TetherPulse',
    TetherEmergency: 'TetherEmergency',
    Volunteer: 'Volunteer',
    VolunteerTraining: 'VolunteerTraining',
    VolunteerSession: 'VolunteerSession',
    VolunteerFeedback: 'VolunteerFeedback',
    CrisisResourceUsage: 'CrisisResourceUsage',
    SafetyReport: 'SafetyReport',
    AuditLog: 'AuditLog',
    AnalyticsEvent: 'AnalyticsEvent',
    PerformanceMetric: 'PerformanceMetric',
    SystemHealth: 'SystemHealth',
    CrisisResource: 'CrisisResource',
    PublicMetrics: 'PublicMetrics',
    EmergencyContact: 'EmergencyContact',
    EmergencyNotification: 'EmergencyNotification',
    WebSocketConnection: 'WebSocketConnection',
    User: 'User',
    MoodEntry: 'MoodEntry',
    SafetyPlan: 'SafetyPlan',
    SafetyPlanVersion: 'SafetyPlanVersion',
    UserProfile: 'UserProfile',
    Achievement: 'Achievement',
    UserAchievement: 'UserAchievement',
    Challenge: 'Challenge',
    UserChallenge: 'UserChallenge',
    UserActivity: 'UserActivity',
    JournalEntry: 'JournalEntry',
    BreathingExercise: 'BreathingExercise',
    BreathingSession: 'BreathingSession',
    GroundingTechnique: 'GroundingTechnique',
    GroundingSession: 'GroundingSession',
    SelfHelpResource: 'SelfHelpResource',
    SelfHelpInteraction: 'SelfHelpInteraction',
    AITherapist: 'AITherapist',
    AITherapySession: 'AITherapySession',
    AITherapyMessage: 'AITherapyMessage',
    AIPersonalization: 'AIPersonalization',
    AIExerciseSession: 'AIExerciseSession',
    AITherapyInsight: 'AITherapyInsight',
    AITherapyGoal: 'AITherapyGoal'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "crisisSession" | "crisisMessage" | "crisisEscalation" | "tetherLink" | "tetherPulse" | "tetherEmergency" | "volunteer" | "volunteerTraining" | "volunteerSession" | "volunteerFeedback" | "crisisResourceUsage" | "safetyReport" | "auditLog" | "analyticsEvent" | "performanceMetric" | "systemHealth" | "crisisResource" | "publicMetrics" | "emergencyContact" | "emergencyNotification" | "webSocketConnection" | "user" | "moodEntry" | "safetyPlan" | "safetyPlanVersion" | "userProfile" | "achievement" | "userAchievement" | "challenge" | "userChallenge" | "userActivity" | "journalEntry" | "breathingExercise" | "breathingSession" | "groundingTechnique" | "groundingSession" | "selfHelpResource" | "selfHelpInteraction" | "aITherapist" | "aITherapySession" | "aITherapyMessage" | "aIPersonalization" | "aIExerciseSession" | "aITherapyInsight" | "aITherapyGoal"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      CrisisSession: {
        payload: Prisma.$CrisisSessionPayload<ExtArgs>
        fields: Prisma.CrisisSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrisisSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrisisSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisSessionPayload>
          }
          findFirst: {
            args: Prisma.CrisisSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrisisSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisSessionPayload>
          }
          findMany: {
            args: Prisma.CrisisSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisSessionPayload>[]
          }
          create: {
            args: Prisma.CrisisSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisSessionPayload>
          }
          createMany: {
            args: Prisma.CrisisSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrisisSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisSessionPayload>[]
          }
          delete: {
            args: Prisma.CrisisSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisSessionPayload>
          }
          update: {
            args: Prisma.CrisisSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisSessionPayload>
          }
          deleteMany: {
            args: Prisma.CrisisSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrisisSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CrisisSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisSessionPayload>[]
          }
          upsert: {
            args: Prisma.CrisisSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisSessionPayload>
          }
          aggregate: {
            args: Prisma.CrisisSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrisisSession>
          }
          groupBy: {
            args: Prisma.CrisisSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrisisSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrisisSessionCountArgs<ExtArgs>
            result: $Utils.Optional<CrisisSessionCountAggregateOutputType> | number
          }
        }
      }
      CrisisMessage: {
        payload: Prisma.$CrisisMessagePayload<ExtArgs>
        fields: Prisma.CrisisMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrisisMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrisisMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisMessagePayload>
          }
          findFirst: {
            args: Prisma.CrisisMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrisisMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisMessagePayload>
          }
          findMany: {
            args: Prisma.CrisisMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisMessagePayload>[]
          }
          create: {
            args: Prisma.CrisisMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisMessagePayload>
          }
          createMany: {
            args: Prisma.CrisisMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrisisMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisMessagePayload>[]
          }
          delete: {
            args: Prisma.CrisisMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisMessagePayload>
          }
          update: {
            args: Prisma.CrisisMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisMessagePayload>
          }
          deleteMany: {
            args: Prisma.CrisisMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrisisMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CrisisMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisMessagePayload>[]
          }
          upsert: {
            args: Prisma.CrisisMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisMessagePayload>
          }
          aggregate: {
            args: Prisma.CrisisMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrisisMessage>
          }
          groupBy: {
            args: Prisma.CrisisMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrisisMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrisisMessageCountArgs<ExtArgs>
            result: $Utils.Optional<CrisisMessageCountAggregateOutputType> | number
          }
        }
      }
      CrisisEscalation: {
        payload: Prisma.$CrisisEscalationPayload<ExtArgs>
        fields: Prisma.CrisisEscalationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrisisEscalationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisEscalationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrisisEscalationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisEscalationPayload>
          }
          findFirst: {
            args: Prisma.CrisisEscalationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisEscalationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrisisEscalationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisEscalationPayload>
          }
          findMany: {
            args: Prisma.CrisisEscalationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisEscalationPayload>[]
          }
          create: {
            args: Prisma.CrisisEscalationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisEscalationPayload>
          }
          createMany: {
            args: Prisma.CrisisEscalationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrisisEscalationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisEscalationPayload>[]
          }
          delete: {
            args: Prisma.CrisisEscalationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisEscalationPayload>
          }
          update: {
            args: Prisma.CrisisEscalationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisEscalationPayload>
          }
          deleteMany: {
            args: Prisma.CrisisEscalationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrisisEscalationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CrisisEscalationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisEscalationPayload>[]
          }
          upsert: {
            args: Prisma.CrisisEscalationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisEscalationPayload>
          }
          aggregate: {
            args: Prisma.CrisisEscalationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrisisEscalation>
          }
          groupBy: {
            args: Prisma.CrisisEscalationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrisisEscalationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrisisEscalationCountArgs<ExtArgs>
            result: $Utils.Optional<CrisisEscalationCountAggregateOutputType> | number
          }
        }
      }
      TetherLink: {
        payload: Prisma.$TetherLinkPayload<ExtArgs>
        fields: Prisma.TetherLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TetherLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TetherLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherLinkPayload>
          }
          findFirst: {
            args: Prisma.TetherLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TetherLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherLinkPayload>
          }
          findMany: {
            args: Prisma.TetherLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherLinkPayload>[]
          }
          create: {
            args: Prisma.TetherLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherLinkPayload>
          }
          createMany: {
            args: Prisma.TetherLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TetherLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherLinkPayload>[]
          }
          delete: {
            args: Prisma.TetherLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherLinkPayload>
          }
          update: {
            args: Prisma.TetherLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherLinkPayload>
          }
          deleteMany: {
            args: Prisma.TetherLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TetherLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TetherLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherLinkPayload>[]
          }
          upsert: {
            args: Prisma.TetherLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherLinkPayload>
          }
          aggregate: {
            args: Prisma.TetherLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTetherLink>
          }
          groupBy: {
            args: Prisma.TetherLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<TetherLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.TetherLinkCountArgs<ExtArgs>
            result: $Utils.Optional<TetherLinkCountAggregateOutputType> | number
          }
        }
      }
      TetherPulse: {
        payload: Prisma.$TetherPulsePayload<ExtArgs>
        fields: Prisma.TetherPulseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TetherPulseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherPulsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TetherPulseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherPulsePayload>
          }
          findFirst: {
            args: Prisma.TetherPulseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherPulsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TetherPulseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherPulsePayload>
          }
          findMany: {
            args: Prisma.TetherPulseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherPulsePayload>[]
          }
          create: {
            args: Prisma.TetherPulseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherPulsePayload>
          }
          createMany: {
            args: Prisma.TetherPulseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TetherPulseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherPulsePayload>[]
          }
          delete: {
            args: Prisma.TetherPulseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherPulsePayload>
          }
          update: {
            args: Prisma.TetherPulseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherPulsePayload>
          }
          deleteMany: {
            args: Prisma.TetherPulseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TetherPulseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TetherPulseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherPulsePayload>[]
          }
          upsert: {
            args: Prisma.TetherPulseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherPulsePayload>
          }
          aggregate: {
            args: Prisma.TetherPulseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTetherPulse>
          }
          groupBy: {
            args: Prisma.TetherPulseGroupByArgs<ExtArgs>
            result: $Utils.Optional<TetherPulseGroupByOutputType>[]
          }
          count: {
            args: Prisma.TetherPulseCountArgs<ExtArgs>
            result: $Utils.Optional<TetherPulseCountAggregateOutputType> | number
          }
        }
      }
      TetherEmergency: {
        payload: Prisma.$TetherEmergencyPayload<ExtArgs>
        fields: Prisma.TetherEmergencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TetherEmergencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherEmergencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TetherEmergencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherEmergencyPayload>
          }
          findFirst: {
            args: Prisma.TetherEmergencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherEmergencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TetherEmergencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherEmergencyPayload>
          }
          findMany: {
            args: Prisma.TetherEmergencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherEmergencyPayload>[]
          }
          create: {
            args: Prisma.TetherEmergencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherEmergencyPayload>
          }
          createMany: {
            args: Prisma.TetherEmergencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TetherEmergencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherEmergencyPayload>[]
          }
          delete: {
            args: Prisma.TetherEmergencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherEmergencyPayload>
          }
          update: {
            args: Prisma.TetherEmergencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherEmergencyPayload>
          }
          deleteMany: {
            args: Prisma.TetherEmergencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TetherEmergencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TetherEmergencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherEmergencyPayload>[]
          }
          upsert: {
            args: Prisma.TetherEmergencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TetherEmergencyPayload>
          }
          aggregate: {
            args: Prisma.TetherEmergencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTetherEmergency>
          }
          groupBy: {
            args: Prisma.TetherEmergencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<TetherEmergencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.TetherEmergencyCountArgs<ExtArgs>
            result: $Utils.Optional<TetherEmergencyCountAggregateOutputType> | number
          }
        }
      }
      Volunteer: {
        payload: Prisma.$VolunteerPayload<ExtArgs>
        fields: Prisma.VolunteerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VolunteerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VolunteerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerPayload>
          }
          findFirst: {
            args: Prisma.VolunteerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VolunteerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerPayload>
          }
          findMany: {
            args: Prisma.VolunteerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerPayload>[]
          }
          create: {
            args: Prisma.VolunteerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerPayload>
          }
          createMany: {
            args: Prisma.VolunteerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VolunteerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerPayload>[]
          }
          delete: {
            args: Prisma.VolunteerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerPayload>
          }
          update: {
            args: Prisma.VolunteerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerPayload>
          }
          deleteMany: {
            args: Prisma.VolunteerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VolunteerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VolunteerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerPayload>[]
          }
          upsert: {
            args: Prisma.VolunteerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerPayload>
          }
          aggregate: {
            args: Prisma.VolunteerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVolunteer>
          }
          groupBy: {
            args: Prisma.VolunteerGroupByArgs<ExtArgs>
            result: $Utils.Optional<VolunteerGroupByOutputType>[]
          }
          count: {
            args: Prisma.VolunteerCountArgs<ExtArgs>
            result: $Utils.Optional<VolunteerCountAggregateOutputType> | number
          }
        }
      }
      VolunteerTraining: {
        payload: Prisma.$VolunteerTrainingPayload<ExtArgs>
        fields: Prisma.VolunteerTrainingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VolunteerTrainingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerTrainingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VolunteerTrainingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerTrainingPayload>
          }
          findFirst: {
            args: Prisma.VolunteerTrainingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerTrainingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VolunteerTrainingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerTrainingPayload>
          }
          findMany: {
            args: Prisma.VolunteerTrainingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerTrainingPayload>[]
          }
          create: {
            args: Prisma.VolunteerTrainingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerTrainingPayload>
          }
          createMany: {
            args: Prisma.VolunteerTrainingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VolunteerTrainingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerTrainingPayload>[]
          }
          delete: {
            args: Prisma.VolunteerTrainingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerTrainingPayload>
          }
          update: {
            args: Prisma.VolunteerTrainingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerTrainingPayload>
          }
          deleteMany: {
            args: Prisma.VolunteerTrainingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VolunteerTrainingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VolunteerTrainingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerTrainingPayload>[]
          }
          upsert: {
            args: Prisma.VolunteerTrainingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerTrainingPayload>
          }
          aggregate: {
            args: Prisma.VolunteerTrainingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVolunteerTraining>
          }
          groupBy: {
            args: Prisma.VolunteerTrainingGroupByArgs<ExtArgs>
            result: $Utils.Optional<VolunteerTrainingGroupByOutputType>[]
          }
          count: {
            args: Prisma.VolunteerTrainingCountArgs<ExtArgs>
            result: $Utils.Optional<VolunteerTrainingCountAggregateOutputType> | number
          }
        }
      }
      VolunteerSession: {
        payload: Prisma.$VolunteerSessionPayload<ExtArgs>
        fields: Prisma.VolunteerSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VolunteerSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VolunteerSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerSessionPayload>
          }
          findFirst: {
            args: Prisma.VolunteerSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VolunteerSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerSessionPayload>
          }
          findMany: {
            args: Prisma.VolunteerSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerSessionPayload>[]
          }
          create: {
            args: Prisma.VolunteerSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerSessionPayload>
          }
          createMany: {
            args: Prisma.VolunteerSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VolunteerSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerSessionPayload>[]
          }
          delete: {
            args: Prisma.VolunteerSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerSessionPayload>
          }
          update: {
            args: Prisma.VolunteerSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerSessionPayload>
          }
          deleteMany: {
            args: Prisma.VolunteerSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VolunteerSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VolunteerSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerSessionPayload>[]
          }
          upsert: {
            args: Prisma.VolunteerSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerSessionPayload>
          }
          aggregate: {
            args: Prisma.VolunteerSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVolunteerSession>
          }
          groupBy: {
            args: Prisma.VolunteerSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<VolunteerSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.VolunteerSessionCountArgs<ExtArgs>
            result: $Utils.Optional<VolunteerSessionCountAggregateOutputType> | number
          }
        }
      }
      VolunteerFeedback: {
        payload: Prisma.$VolunteerFeedbackPayload<ExtArgs>
        fields: Prisma.VolunteerFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VolunteerFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VolunteerFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerFeedbackPayload>
          }
          findFirst: {
            args: Prisma.VolunteerFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VolunteerFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerFeedbackPayload>
          }
          findMany: {
            args: Prisma.VolunteerFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerFeedbackPayload>[]
          }
          create: {
            args: Prisma.VolunteerFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerFeedbackPayload>
          }
          createMany: {
            args: Prisma.VolunteerFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VolunteerFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerFeedbackPayload>[]
          }
          delete: {
            args: Prisma.VolunteerFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerFeedbackPayload>
          }
          update: {
            args: Prisma.VolunteerFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.VolunteerFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VolunteerFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VolunteerFeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerFeedbackPayload>[]
          }
          upsert: {
            args: Prisma.VolunteerFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteerFeedbackPayload>
          }
          aggregate: {
            args: Prisma.VolunteerFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVolunteerFeedback>
          }
          groupBy: {
            args: Prisma.VolunteerFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<VolunteerFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.VolunteerFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<VolunteerFeedbackCountAggregateOutputType> | number
          }
        }
      }
      CrisisResourceUsage: {
        payload: Prisma.$CrisisResourceUsagePayload<ExtArgs>
        fields: Prisma.CrisisResourceUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrisisResourceUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourceUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrisisResourceUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourceUsagePayload>
          }
          findFirst: {
            args: Prisma.CrisisResourceUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourceUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrisisResourceUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourceUsagePayload>
          }
          findMany: {
            args: Prisma.CrisisResourceUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourceUsagePayload>[]
          }
          create: {
            args: Prisma.CrisisResourceUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourceUsagePayload>
          }
          createMany: {
            args: Prisma.CrisisResourceUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrisisResourceUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourceUsagePayload>[]
          }
          delete: {
            args: Prisma.CrisisResourceUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourceUsagePayload>
          }
          update: {
            args: Prisma.CrisisResourceUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourceUsagePayload>
          }
          deleteMany: {
            args: Prisma.CrisisResourceUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrisisResourceUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CrisisResourceUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourceUsagePayload>[]
          }
          upsert: {
            args: Prisma.CrisisResourceUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourceUsagePayload>
          }
          aggregate: {
            args: Prisma.CrisisResourceUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrisisResourceUsage>
          }
          groupBy: {
            args: Prisma.CrisisResourceUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrisisResourceUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrisisResourceUsageCountArgs<ExtArgs>
            result: $Utils.Optional<CrisisResourceUsageCountAggregateOutputType> | number
          }
        }
      }
      SafetyReport: {
        payload: Prisma.$SafetyReportPayload<ExtArgs>
        fields: Prisma.SafetyReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SafetyReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SafetyReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyReportPayload>
          }
          findFirst: {
            args: Prisma.SafetyReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SafetyReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyReportPayload>
          }
          findMany: {
            args: Prisma.SafetyReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyReportPayload>[]
          }
          create: {
            args: Prisma.SafetyReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyReportPayload>
          }
          createMany: {
            args: Prisma.SafetyReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SafetyReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyReportPayload>[]
          }
          delete: {
            args: Prisma.SafetyReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyReportPayload>
          }
          update: {
            args: Prisma.SafetyReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyReportPayload>
          }
          deleteMany: {
            args: Prisma.SafetyReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SafetyReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SafetyReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyReportPayload>[]
          }
          upsert: {
            args: Prisma.SafetyReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyReportPayload>
          }
          aggregate: {
            args: Prisma.SafetyReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSafetyReport>
          }
          groupBy: {
            args: Prisma.SafetyReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<SafetyReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.SafetyReportCountArgs<ExtArgs>
            result: $Utils.Optional<SafetyReportCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsEvent: {
        payload: Prisma.$AnalyticsEventPayload<ExtArgs>
        fields: Prisma.AnalyticsEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          findMany: {
            args: Prisma.AnalyticsEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          create: {
            args: Prisma.AnalyticsEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          createMany: {
            args: Prisma.AnalyticsEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          update: {
            args: Prisma.AnalyticsEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsEvent>
          }
          groupBy: {
            args: Prisma.AnalyticsEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsEventCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEventCountAggregateOutputType> | number
          }
        }
      }
      PerformanceMetric: {
        payload: Prisma.$PerformanceMetricPayload<ExtArgs>
        fields: Prisma.PerformanceMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          findFirst: {
            args: Prisma.PerformanceMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          findMany: {
            args: Prisma.PerformanceMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>[]
          }
          create: {
            args: Prisma.PerformanceMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          createMany: {
            args: Prisma.PerformanceMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerformanceMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>[]
          }
          delete: {
            args: Prisma.PerformanceMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          update: {
            args: Prisma.PerformanceMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PerformanceMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>[]
          }
          upsert: {
            args: Prisma.PerformanceMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          aggregate: {
            args: Prisma.PerformanceMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceMetric>
          }
          groupBy: {
            args: Prisma.PerformanceMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceMetricCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceMetricCountAggregateOutputType> | number
          }
        }
      }
      SystemHealth: {
        payload: Prisma.$SystemHealthPayload<ExtArgs>
        fields: Prisma.SystemHealthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemHealthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemHealthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>
          }
          findFirst: {
            args: Prisma.SystemHealthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemHealthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>
          }
          findMany: {
            args: Prisma.SystemHealthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>[]
          }
          create: {
            args: Prisma.SystemHealthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>
          }
          createMany: {
            args: Prisma.SystemHealthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemHealthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>[]
          }
          delete: {
            args: Prisma.SystemHealthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>
          }
          update: {
            args: Prisma.SystemHealthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>
          }
          deleteMany: {
            args: Prisma.SystemHealthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemHealthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemHealthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>[]
          }
          upsert: {
            args: Prisma.SystemHealthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>
          }
          aggregate: {
            args: Prisma.SystemHealthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemHealth>
          }
          groupBy: {
            args: Prisma.SystemHealthGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemHealthGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemHealthCountArgs<ExtArgs>
            result: $Utils.Optional<SystemHealthCountAggregateOutputType> | number
          }
        }
      }
      CrisisResource: {
        payload: Prisma.$CrisisResourcePayload<ExtArgs>
        fields: Prisma.CrisisResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrisisResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrisisResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourcePayload>
          }
          findFirst: {
            args: Prisma.CrisisResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrisisResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourcePayload>
          }
          findMany: {
            args: Prisma.CrisisResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourcePayload>[]
          }
          create: {
            args: Prisma.CrisisResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourcePayload>
          }
          createMany: {
            args: Prisma.CrisisResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrisisResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourcePayload>[]
          }
          delete: {
            args: Prisma.CrisisResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourcePayload>
          }
          update: {
            args: Prisma.CrisisResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourcePayload>
          }
          deleteMany: {
            args: Prisma.CrisisResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrisisResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CrisisResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourcePayload>[]
          }
          upsert: {
            args: Prisma.CrisisResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrisisResourcePayload>
          }
          aggregate: {
            args: Prisma.CrisisResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrisisResource>
          }
          groupBy: {
            args: Prisma.CrisisResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrisisResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrisisResourceCountArgs<ExtArgs>
            result: $Utils.Optional<CrisisResourceCountAggregateOutputType> | number
          }
        }
      }
      PublicMetrics: {
        payload: Prisma.$PublicMetricsPayload<ExtArgs>
        fields: Prisma.PublicMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PublicMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PublicMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicMetricsPayload>
          }
          findFirst: {
            args: Prisma.PublicMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PublicMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicMetricsPayload>
          }
          findMany: {
            args: Prisma.PublicMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicMetricsPayload>[]
          }
          create: {
            args: Prisma.PublicMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicMetricsPayload>
          }
          createMany: {
            args: Prisma.PublicMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PublicMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicMetricsPayload>[]
          }
          delete: {
            args: Prisma.PublicMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicMetricsPayload>
          }
          update: {
            args: Prisma.PublicMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicMetricsPayload>
          }
          deleteMany: {
            args: Prisma.PublicMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PublicMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PublicMetricsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicMetricsPayload>[]
          }
          upsert: {
            args: Prisma.PublicMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicMetricsPayload>
          }
          aggregate: {
            args: Prisma.PublicMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublicMetrics>
          }
          groupBy: {
            args: Prisma.PublicMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PublicMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PublicMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<PublicMetricsCountAggregateOutputType> | number
          }
        }
      }
      EmergencyContact: {
        payload: Prisma.$EmergencyContactPayload<ExtArgs>
        fields: Prisma.EmergencyContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmergencyContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmergencyContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          findFirst: {
            args: Prisma.EmergencyContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmergencyContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          findMany: {
            args: Prisma.EmergencyContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>[]
          }
          create: {
            args: Prisma.EmergencyContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          createMany: {
            args: Prisma.EmergencyContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmergencyContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>[]
          }
          delete: {
            args: Prisma.EmergencyContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          update: {
            args: Prisma.EmergencyContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          deleteMany: {
            args: Prisma.EmergencyContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmergencyContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmergencyContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>[]
          }
          upsert: {
            args: Prisma.EmergencyContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          aggregate: {
            args: Prisma.EmergencyContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmergencyContact>
          }
          groupBy: {
            args: Prisma.EmergencyContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmergencyContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmergencyContactCountArgs<ExtArgs>
            result: $Utils.Optional<EmergencyContactCountAggregateOutputType> | number
          }
        }
      }
      EmergencyNotification: {
        payload: Prisma.$EmergencyNotificationPayload<ExtArgs>
        fields: Prisma.EmergencyNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmergencyNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmergencyNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyNotificationPayload>
          }
          findFirst: {
            args: Prisma.EmergencyNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmergencyNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyNotificationPayload>
          }
          findMany: {
            args: Prisma.EmergencyNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyNotificationPayload>[]
          }
          create: {
            args: Prisma.EmergencyNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyNotificationPayload>
          }
          createMany: {
            args: Prisma.EmergencyNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmergencyNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyNotificationPayload>[]
          }
          delete: {
            args: Prisma.EmergencyNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyNotificationPayload>
          }
          update: {
            args: Prisma.EmergencyNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyNotificationPayload>
          }
          deleteMany: {
            args: Prisma.EmergencyNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmergencyNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmergencyNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyNotificationPayload>[]
          }
          upsert: {
            args: Prisma.EmergencyNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyNotificationPayload>
          }
          aggregate: {
            args: Prisma.EmergencyNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmergencyNotification>
          }
          groupBy: {
            args: Prisma.EmergencyNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmergencyNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmergencyNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<EmergencyNotificationCountAggregateOutputType> | number
          }
        }
      }
      WebSocketConnection: {
        payload: Prisma.$WebSocketConnectionPayload<ExtArgs>
        fields: Prisma.WebSocketConnectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebSocketConnectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSocketConnectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebSocketConnectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSocketConnectionPayload>
          }
          findFirst: {
            args: Prisma.WebSocketConnectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSocketConnectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebSocketConnectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSocketConnectionPayload>
          }
          findMany: {
            args: Prisma.WebSocketConnectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSocketConnectionPayload>[]
          }
          create: {
            args: Prisma.WebSocketConnectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSocketConnectionPayload>
          }
          createMany: {
            args: Prisma.WebSocketConnectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebSocketConnectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSocketConnectionPayload>[]
          }
          delete: {
            args: Prisma.WebSocketConnectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSocketConnectionPayload>
          }
          update: {
            args: Prisma.WebSocketConnectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSocketConnectionPayload>
          }
          deleteMany: {
            args: Prisma.WebSocketConnectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebSocketConnectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebSocketConnectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSocketConnectionPayload>[]
          }
          upsert: {
            args: Prisma.WebSocketConnectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSocketConnectionPayload>
          }
          aggregate: {
            args: Prisma.WebSocketConnectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebSocketConnection>
          }
          groupBy: {
            args: Prisma.WebSocketConnectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebSocketConnectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebSocketConnectionCountArgs<ExtArgs>
            result: $Utils.Optional<WebSocketConnectionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      MoodEntry: {
        payload: Prisma.$MoodEntryPayload<ExtArgs>
        fields: Prisma.MoodEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MoodEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MoodEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          findFirst: {
            args: Prisma.MoodEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MoodEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          findMany: {
            args: Prisma.MoodEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>[]
          }
          create: {
            args: Prisma.MoodEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          createMany: {
            args: Prisma.MoodEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MoodEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>[]
          }
          delete: {
            args: Prisma.MoodEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          update: {
            args: Prisma.MoodEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          deleteMany: {
            args: Prisma.MoodEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MoodEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MoodEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>[]
          }
          upsert: {
            args: Prisma.MoodEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          aggregate: {
            args: Prisma.MoodEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMoodEntry>
          }
          groupBy: {
            args: Prisma.MoodEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MoodEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MoodEntryCountArgs<ExtArgs>
            result: $Utils.Optional<MoodEntryCountAggregateOutputType> | number
          }
        }
      }
      SafetyPlan: {
        payload: Prisma.$SafetyPlanPayload<ExtArgs>
        fields: Prisma.SafetyPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SafetyPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SafetyPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanPayload>
          }
          findFirst: {
            args: Prisma.SafetyPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SafetyPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanPayload>
          }
          findMany: {
            args: Prisma.SafetyPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanPayload>[]
          }
          create: {
            args: Prisma.SafetyPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanPayload>
          }
          createMany: {
            args: Prisma.SafetyPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SafetyPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanPayload>[]
          }
          delete: {
            args: Prisma.SafetyPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanPayload>
          }
          update: {
            args: Prisma.SafetyPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanPayload>
          }
          deleteMany: {
            args: Prisma.SafetyPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SafetyPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SafetyPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanPayload>[]
          }
          upsert: {
            args: Prisma.SafetyPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanPayload>
          }
          aggregate: {
            args: Prisma.SafetyPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSafetyPlan>
          }
          groupBy: {
            args: Prisma.SafetyPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<SafetyPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.SafetyPlanCountArgs<ExtArgs>
            result: $Utils.Optional<SafetyPlanCountAggregateOutputType> | number
          }
        }
      }
      SafetyPlanVersion: {
        payload: Prisma.$SafetyPlanVersionPayload<ExtArgs>
        fields: Prisma.SafetyPlanVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SafetyPlanVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SafetyPlanVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanVersionPayload>
          }
          findFirst: {
            args: Prisma.SafetyPlanVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SafetyPlanVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanVersionPayload>
          }
          findMany: {
            args: Prisma.SafetyPlanVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanVersionPayload>[]
          }
          create: {
            args: Prisma.SafetyPlanVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanVersionPayload>
          }
          createMany: {
            args: Prisma.SafetyPlanVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SafetyPlanVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanVersionPayload>[]
          }
          delete: {
            args: Prisma.SafetyPlanVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanVersionPayload>
          }
          update: {
            args: Prisma.SafetyPlanVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanVersionPayload>
          }
          deleteMany: {
            args: Prisma.SafetyPlanVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SafetyPlanVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SafetyPlanVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanVersionPayload>[]
          }
          upsert: {
            args: Prisma.SafetyPlanVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyPlanVersionPayload>
          }
          aggregate: {
            args: Prisma.SafetyPlanVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSafetyPlanVersion>
          }
          groupBy: {
            args: Prisma.SafetyPlanVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SafetyPlanVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SafetyPlanVersionCountArgs<ExtArgs>
            result: $Utils.Optional<SafetyPlanVersionCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      UserAchievement: {
        payload: Prisma.$UserAchievementPayload<ExtArgs>
        fields: Prisma.UserAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findFirst: {
            args: Prisma.UserAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findMany: {
            args: Prisma.UserAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          create: {
            args: Prisma.UserAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          createMany: {
            args: Prisma.UserAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          delete: {
            args: Prisma.UserAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          update: {
            args: Prisma.UserAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          deleteMany: {
            args: Prisma.UserAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          upsert: {
            args: Prisma.UserAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          aggregate: {
            args: Prisma.UserAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAchievement>
          }
          groupBy: {
            args: Prisma.UserAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementCountAggregateOutputType> | number
          }
        }
      }
      Challenge: {
        payload: Prisma.$ChallengePayload<ExtArgs>
        fields: Prisma.ChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findFirst: {
            args: Prisma.ChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findMany: {
            args: Prisma.ChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          create: {
            args: Prisma.ChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          createMany: {
            args: Prisma.ChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          delete: {
            args: Prisma.ChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          update: {
            args: Prisma.ChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          upsert: {
            args: Prisma.ChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          aggregate: {
            args: Prisma.ChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallenge>
          }
          groupBy: {
            args: Prisma.ChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeCountAggregateOutputType> | number
          }
        }
      }
      UserChallenge: {
        payload: Prisma.$UserChallengePayload<ExtArgs>
        fields: Prisma.UserChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          findFirst: {
            args: Prisma.UserChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          findMany: {
            args: Prisma.UserChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>[]
          }
          create: {
            args: Prisma.UserChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          createMany: {
            args: Prisma.UserChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>[]
          }
          delete: {
            args: Prisma.UserChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          update: {
            args: Prisma.UserChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          deleteMany: {
            args: Prisma.UserChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserChallengeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>[]
          }
          upsert: {
            args: Prisma.UserChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          aggregate: {
            args: Prisma.UserChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserChallenge>
          }
          groupBy: {
            args: Prisma.UserChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<UserChallengeCountAggregateOutputType> | number
          }
        }
      }
      UserActivity: {
        payload: Prisma.$UserActivityPayload<ExtArgs>
        fields: Prisma.UserActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          findFirst: {
            args: Prisma.UserActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          findMany: {
            args: Prisma.UserActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>[]
          }
          create: {
            args: Prisma.UserActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          createMany: {
            args: Prisma.UserActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>[]
          }
          delete: {
            args: Prisma.UserActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          update: {
            args: Prisma.UserActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          deleteMany: {
            args: Prisma.UserActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>[]
          }
          upsert: {
            args: Prisma.UserActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          aggregate: {
            args: Prisma.UserActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserActivity>
          }
          groupBy: {
            args: Prisma.UserActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserActivityCountArgs<ExtArgs>
            result: $Utils.Optional<UserActivityCountAggregateOutputType> | number
          }
        }
      }
      JournalEntry: {
        payload: Prisma.$JournalEntryPayload<ExtArgs>
        fields: Prisma.JournalEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          findFirst: {
            args: Prisma.JournalEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          findMany: {
            args: Prisma.JournalEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          create: {
            args: Prisma.JournalEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          createMany: {
            args: Prisma.JournalEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          delete: {
            args: Prisma.JournalEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          update: {
            args: Prisma.JournalEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          deleteMany: {
            args: Prisma.JournalEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          upsert: {
            args: Prisma.JournalEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          aggregate: {
            args: Prisma.JournalEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalEntry>
          }
          groupBy: {
            args: Prisma.JournalEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalEntryCountArgs<ExtArgs>
            result: $Utils.Optional<JournalEntryCountAggregateOutputType> | number
          }
        }
      }
      BreathingExercise: {
        payload: Prisma.$BreathingExercisePayload<ExtArgs>
        fields: Prisma.BreathingExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BreathingExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BreathingExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingExercisePayload>
          }
          findFirst: {
            args: Prisma.BreathingExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BreathingExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingExercisePayload>
          }
          findMany: {
            args: Prisma.BreathingExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingExercisePayload>[]
          }
          create: {
            args: Prisma.BreathingExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingExercisePayload>
          }
          createMany: {
            args: Prisma.BreathingExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BreathingExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingExercisePayload>[]
          }
          delete: {
            args: Prisma.BreathingExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingExercisePayload>
          }
          update: {
            args: Prisma.BreathingExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingExercisePayload>
          }
          deleteMany: {
            args: Prisma.BreathingExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BreathingExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BreathingExerciseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingExercisePayload>[]
          }
          upsert: {
            args: Prisma.BreathingExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingExercisePayload>
          }
          aggregate: {
            args: Prisma.BreathingExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBreathingExercise>
          }
          groupBy: {
            args: Prisma.BreathingExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<BreathingExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.BreathingExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<BreathingExerciseCountAggregateOutputType> | number
          }
        }
      }
      BreathingSession: {
        payload: Prisma.$BreathingSessionPayload<ExtArgs>
        fields: Prisma.BreathingSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BreathingSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BreathingSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingSessionPayload>
          }
          findFirst: {
            args: Prisma.BreathingSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BreathingSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingSessionPayload>
          }
          findMany: {
            args: Prisma.BreathingSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingSessionPayload>[]
          }
          create: {
            args: Prisma.BreathingSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingSessionPayload>
          }
          createMany: {
            args: Prisma.BreathingSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BreathingSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingSessionPayload>[]
          }
          delete: {
            args: Prisma.BreathingSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingSessionPayload>
          }
          update: {
            args: Prisma.BreathingSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingSessionPayload>
          }
          deleteMany: {
            args: Prisma.BreathingSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BreathingSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BreathingSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingSessionPayload>[]
          }
          upsert: {
            args: Prisma.BreathingSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreathingSessionPayload>
          }
          aggregate: {
            args: Prisma.BreathingSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBreathingSession>
          }
          groupBy: {
            args: Prisma.BreathingSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BreathingSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BreathingSessionCountArgs<ExtArgs>
            result: $Utils.Optional<BreathingSessionCountAggregateOutputType> | number
          }
        }
      }
      GroundingTechnique: {
        payload: Prisma.$GroundingTechniquePayload<ExtArgs>
        fields: Prisma.GroundingTechniqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroundingTechniqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingTechniquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroundingTechniqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingTechniquePayload>
          }
          findFirst: {
            args: Prisma.GroundingTechniqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingTechniquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroundingTechniqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingTechniquePayload>
          }
          findMany: {
            args: Prisma.GroundingTechniqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingTechniquePayload>[]
          }
          create: {
            args: Prisma.GroundingTechniqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingTechniquePayload>
          }
          createMany: {
            args: Prisma.GroundingTechniqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroundingTechniqueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingTechniquePayload>[]
          }
          delete: {
            args: Prisma.GroundingTechniqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingTechniquePayload>
          }
          update: {
            args: Prisma.GroundingTechniqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingTechniquePayload>
          }
          deleteMany: {
            args: Prisma.GroundingTechniqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroundingTechniqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroundingTechniqueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingTechniquePayload>[]
          }
          upsert: {
            args: Prisma.GroundingTechniqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingTechniquePayload>
          }
          aggregate: {
            args: Prisma.GroundingTechniqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroundingTechnique>
          }
          groupBy: {
            args: Prisma.GroundingTechniqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroundingTechniqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroundingTechniqueCountArgs<ExtArgs>
            result: $Utils.Optional<GroundingTechniqueCountAggregateOutputType> | number
          }
        }
      }
      GroundingSession: {
        payload: Prisma.$GroundingSessionPayload<ExtArgs>
        fields: Prisma.GroundingSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroundingSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroundingSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingSessionPayload>
          }
          findFirst: {
            args: Prisma.GroundingSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroundingSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingSessionPayload>
          }
          findMany: {
            args: Prisma.GroundingSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingSessionPayload>[]
          }
          create: {
            args: Prisma.GroundingSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingSessionPayload>
          }
          createMany: {
            args: Prisma.GroundingSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroundingSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingSessionPayload>[]
          }
          delete: {
            args: Prisma.GroundingSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingSessionPayload>
          }
          update: {
            args: Prisma.GroundingSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingSessionPayload>
          }
          deleteMany: {
            args: Prisma.GroundingSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroundingSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroundingSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingSessionPayload>[]
          }
          upsert: {
            args: Prisma.GroundingSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroundingSessionPayload>
          }
          aggregate: {
            args: Prisma.GroundingSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroundingSession>
          }
          groupBy: {
            args: Prisma.GroundingSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroundingSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroundingSessionCountArgs<ExtArgs>
            result: $Utils.Optional<GroundingSessionCountAggregateOutputType> | number
          }
        }
      }
      SelfHelpResource: {
        payload: Prisma.$SelfHelpResourcePayload<ExtArgs>
        fields: Prisma.SelfHelpResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SelfHelpResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SelfHelpResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpResourcePayload>
          }
          findFirst: {
            args: Prisma.SelfHelpResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SelfHelpResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpResourcePayload>
          }
          findMany: {
            args: Prisma.SelfHelpResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpResourcePayload>[]
          }
          create: {
            args: Prisma.SelfHelpResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpResourcePayload>
          }
          createMany: {
            args: Prisma.SelfHelpResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SelfHelpResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpResourcePayload>[]
          }
          delete: {
            args: Prisma.SelfHelpResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpResourcePayload>
          }
          update: {
            args: Prisma.SelfHelpResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpResourcePayload>
          }
          deleteMany: {
            args: Prisma.SelfHelpResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SelfHelpResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SelfHelpResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpResourcePayload>[]
          }
          upsert: {
            args: Prisma.SelfHelpResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpResourcePayload>
          }
          aggregate: {
            args: Prisma.SelfHelpResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSelfHelpResource>
          }
          groupBy: {
            args: Prisma.SelfHelpResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SelfHelpResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SelfHelpResourceCountArgs<ExtArgs>
            result: $Utils.Optional<SelfHelpResourceCountAggregateOutputType> | number
          }
        }
      }
      SelfHelpInteraction: {
        payload: Prisma.$SelfHelpInteractionPayload<ExtArgs>
        fields: Prisma.SelfHelpInteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SelfHelpInteractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpInteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SelfHelpInteractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpInteractionPayload>
          }
          findFirst: {
            args: Prisma.SelfHelpInteractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpInteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SelfHelpInteractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpInteractionPayload>
          }
          findMany: {
            args: Prisma.SelfHelpInteractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpInteractionPayload>[]
          }
          create: {
            args: Prisma.SelfHelpInteractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpInteractionPayload>
          }
          createMany: {
            args: Prisma.SelfHelpInteractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SelfHelpInteractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpInteractionPayload>[]
          }
          delete: {
            args: Prisma.SelfHelpInteractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpInteractionPayload>
          }
          update: {
            args: Prisma.SelfHelpInteractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpInteractionPayload>
          }
          deleteMany: {
            args: Prisma.SelfHelpInteractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SelfHelpInteractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SelfHelpInteractionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpInteractionPayload>[]
          }
          upsert: {
            args: Prisma.SelfHelpInteractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfHelpInteractionPayload>
          }
          aggregate: {
            args: Prisma.SelfHelpInteractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSelfHelpInteraction>
          }
          groupBy: {
            args: Prisma.SelfHelpInteractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SelfHelpInteractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SelfHelpInteractionCountArgs<ExtArgs>
            result: $Utils.Optional<SelfHelpInteractionCountAggregateOutputType> | number
          }
        }
      }
      AITherapist: {
        payload: Prisma.$AITherapistPayload<ExtArgs>
        fields: Prisma.AITherapistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AITherapistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AITherapistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapistPayload>
          }
          findFirst: {
            args: Prisma.AITherapistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AITherapistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapistPayload>
          }
          findMany: {
            args: Prisma.AITherapistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapistPayload>[]
          }
          create: {
            args: Prisma.AITherapistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapistPayload>
          }
          createMany: {
            args: Prisma.AITherapistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AITherapistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapistPayload>[]
          }
          delete: {
            args: Prisma.AITherapistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapistPayload>
          }
          update: {
            args: Prisma.AITherapistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapistPayload>
          }
          deleteMany: {
            args: Prisma.AITherapistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AITherapistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AITherapistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapistPayload>[]
          }
          upsert: {
            args: Prisma.AITherapistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapistPayload>
          }
          aggregate: {
            args: Prisma.AITherapistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAITherapist>
          }
          groupBy: {
            args: Prisma.AITherapistGroupByArgs<ExtArgs>
            result: $Utils.Optional<AITherapistGroupByOutputType>[]
          }
          count: {
            args: Prisma.AITherapistCountArgs<ExtArgs>
            result: $Utils.Optional<AITherapistCountAggregateOutputType> | number
          }
        }
      }
      AITherapySession: {
        payload: Prisma.$AITherapySessionPayload<ExtArgs>
        fields: Prisma.AITherapySessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AITherapySessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapySessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AITherapySessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapySessionPayload>
          }
          findFirst: {
            args: Prisma.AITherapySessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapySessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AITherapySessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapySessionPayload>
          }
          findMany: {
            args: Prisma.AITherapySessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapySessionPayload>[]
          }
          create: {
            args: Prisma.AITherapySessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapySessionPayload>
          }
          createMany: {
            args: Prisma.AITherapySessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AITherapySessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapySessionPayload>[]
          }
          delete: {
            args: Prisma.AITherapySessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapySessionPayload>
          }
          update: {
            args: Prisma.AITherapySessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapySessionPayload>
          }
          deleteMany: {
            args: Prisma.AITherapySessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AITherapySessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AITherapySessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapySessionPayload>[]
          }
          upsert: {
            args: Prisma.AITherapySessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapySessionPayload>
          }
          aggregate: {
            args: Prisma.AITherapySessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAITherapySession>
          }
          groupBy: {
            args: Prisma.AITherapySessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AITherapySessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AITherapySessionCountArgs<ExtArgs>
            result: $Utils.Optional<AITherapySessionCountAggregateOutputType> | number
          }
        }
      }
      AITherapyMessage: {
        payload: Prisma.$AITherapyMessagePayload<ExtArgs>
        fields: Prisma.AITherapyMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AITherapyMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AITherapyMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyMessagePayload>
          }
          findFirst: {
            args: Prisma.AITherapyMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AITherapyMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyMessagePayload>
          }
          findMany: {
            args: Prisma.AITherapyMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyMessagePayload>[]
          }
          create: {
            args: Prisma.AITherapyMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyMessagePayload>
          }
          createMany: {
            args: Prisma.AITherapyMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AITherapyMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyMessagePayload>[]
          }
          delete: {
            args: Prisma.AITherapyMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyMessagePayload>
          }
          update: {
            args: Prisma.AITherapyMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyMessagePayload>
          }
          deleteMany: {
            args: Prisma.AITherapyMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AITherapyMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AITherapyMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyMessagePayload>[]
          }
          upsert: {
            args: Prisma.AITherapyMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyMessagePayload>
          }
          aggregate: {
            args: Prisma.AITherapyMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAITherapyMessage>
          }
          groupBy: {
            args: Prisma.AITherapyMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<AITherapyMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.AITherapyMessageCountArgs<ExtArgs>
            result: $Utils.Optional<AITherapyMessageCountAggregateOutputType> | number
          }
        }
      }
      AIPersonalization: {
        payload: Prisma.$AIPersonalizationPayload<ExtArgs>
        fields: Prisma.AIPersonalizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIPersonalizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPersonalizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIPersonalizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPersonalizationPayload>
          }
          findFirst: {
            args: Prisma.AIPersonalizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPersonalizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIPersonalizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPersonalizationPayload>
          }
          findMany: {
            args: Prisma.AIPersonalizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPersonalizationPayload>[]
          }
          create: {
            args: Prisma.AIPersonalizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPersonalizationPayload>
          }
          createMany: {
            args: Prisma.AIPersonalizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIPersonalizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPersonalizationPayload>[]
          }
          delete: {
            args: Prisma.AIPersonalizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPersonalizationPayload>
          }
          update: {
            args: Prisma.AIPersonalizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPersonalizationPayload>
          }
          deleteMany: {
            args: Prisma.AIPersonalizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIPersonalizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIPersonalizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPersonalizationPayload>[]
          }
          upsert: {
            args: Prisma.AIPersonalizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPersonalizationPayload>
          }
          aggregate: {
            args: Prisma.AIPersonalizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIPersonalization>
          }
          groupBy: {
            args: Prisma.AIPersonalizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIPersonalizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIPersonalizationCountArgs<ExtArgs>
            result: $Utils.Optional<AIPersonalizationCountAggregateOutputType> | number
          }
        }
      }
      AIExerciseSession: {
        payload: Prisma.$AIExerciseSessionPayload<ExtArgs>
        fields: Prisma.AIExerciseSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIExerciseSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIExerciseSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIExerciseSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIExerciseSessionPayload>
          }
          findFirst: {
            args: Prisma.AIExerciseSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIExerciseSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIExerciseSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIExerciseSessionPayload>
          }
          findMany: {
            args: Prisma.AIExerciseSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIExerciseSessionPayload>[]
          }
          create: {
            args: Prisma.AIExerciseSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIExerciseSessionPayload>
          }
          createMany: {
            args: Prisma.AIExerciseSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIExerciseSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIExerciseSessionPayload>[]
          }
          delete: {
            args: Prisma.AIExerciseSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIExerciseSessionPayload>
          }
          update: {
            args: Prisma.AIExerciseSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIExerciseSessionPayload>
          }
          deleteMany: {
            args: Prisma.AIExerciseSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIExerciseSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIExerciseSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIExerciseSessionPayload>[]
          }
          upsert: {
            args: Prisma.AIExerciseSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIExerciseSessionPayload>
          }
          aggregate: {
            args: Prisma.AIExerciseSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIExerciseSession>
          }
          groupBy: {
            args: Prisma.AIExerciseSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIExerciseSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIExerciseSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AIExerciseSessionCountAggregateOutputType> | number
          }
        }
      }
      AITherapyInsight: {
        payload: Prisma.$AITherapyInsightPayload<ExtArgs>
        fields: Prisma.AITherapyInsightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AITherapyInsightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyInsightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AITherapyInsightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyInsightPayload>
          }
          findFirst: {
            args: Prisma.AITherapyInsightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyInsightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AITherapyInsightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyInsightPayload>
          }
          findMany: {
            args: Prisma.AITherapyInsightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyInsightPayload>[]
          }
          create: {
            args: Prisma.AITherapyInsightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyInsightPayload>
          }
          createMany: {
            args: Prisma.AITherapyInsightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AITherapyInsightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyInsightPayload>[]
          }
          delete: {
            args: Prisma.AITherapyInsightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyInsightPayload>
          }
          update: {
            args: Prisma.AITherapyInsightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyInsightPayload>
          }
          deleteMany: {
            args: Prisma.AITherapyInsightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AITherapyInsightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AITherapyInsightUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyInsightPayload>[]
          }
          upsert: {
            args: Prisma.AITherapyInsightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyInsightPayload>
          }
          aggregate: {
            args: Prisma.AITherapyInsightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAITherapyInsight>
          }
          groupBy: {
            args: Prisma.AITherapyInsightGroupByArgs<ExtArgs>
            result: $Utils.Optional<AITherapyInsightGroupByOutputType>[]
          }
          count: {
            args: Prisma.AITherapyInsightCountArgs<ExtArgs>
            result: $Utils.Optional<AITherapyInsightCountAggregateOutputType> | number
          }
        }
      }
      AITherapyGoal: {
        payload: Prisma.$AITherapyGoalPayload<ExtArgs>
        fields: Prisma.AITherapyGoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AITherapyGoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyGoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AITherapyGoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyGoalPayload>
          }
          findFirst: {
            args: Prisma.AITherapyGoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyGoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AITherapyGoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyGoalPayload>
          }
          findMany: {
            args: Prisma.AITherapyGoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyGoalPayload>[]
          }
          create: {
            args: Prisma.AITherapyGoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyGoalPayload>
          }
          createMany: {
            args: Prisma.AITherapyGoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AITherapyGoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyGoalPayload>[]
          }
          delete: {
            args: Prisma.AITherapyGoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyGoalPayload>
          }
          update: {
            args: Prisma.AITherapyGoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyGoalPayload>
          }
          deleteMany: {
            args: Prisma.AITherapyGoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AITherapyGoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AITherapyGoalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyGoalPayload>[]
          }
          upsert: {
            args: Prisma.AITherapyGoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITherapyGoalPayload>
          }
          aggregate: {
            args: Prisma.AITherapyGoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAITherapyGoal>
          }
          groupBy: {
            args: Prisma.AITherapyGoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<AITherapyGoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.AITherapyGoalCountArgs<ExtArgs>
            result: $Utils.Optional<AITherapyGoalCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    crisisSession?: CrisisSessionOmit
    crisisMessage?: CrisisMessageOmit
    crisisEscalation?: CrisisEscalationOmit
    tetherLink?: TetherLinkOmit
    tetherPulse?: TetherPulseOmit
    tetherEmergency?: TetherEmergencyOmit
    volunteer?: VolunteerOmit
    volunteerTraining?: VolunteerTrainingOmit
    volunteerSession?: VolunteerSessionOmit
    volunteerFeedback?: VolunteerFeedbackOmit
    crisisResourceUsage?: CrisisResourceUsageOmit
    safetyReport?: SafetyReportOmit
    auditLog?: AuditLogOmit
    analyticsEvent?: AnalyticsEventOmit
    performanceMetric?: PerformanceMetricOmit
    systemHealth?: SystemHealthOmit
    crisisResource?: CrisisResourceOmit
    publicMetrics?: PublicMetricsOmit
    emergencyContact?: EmergencyContactOmit
    emergencyNotification?: EmergencyNotificationOmit
    webSocketConnection?: WebSocketConnectionOmit
    user?: UserOmit
    moodEntry?: MoodEntryOmit
    safetyPlan?: SafetyPlanOmit
    safetyPlanVersion?: SafetyPlanVersionOmit
    userProfile?: UserProfileOmit
    achievement?: AchievementOmit
    userAchievement?: UserAchievementOmit
    challenge?: ChallengeOmit
    userChallenge?: UserChallengeOmit
    userActivity?: UserActivityOmit
    journalEntry?: JournalEntryOmit
    breathingExercise?: BreathingExerciseOmit
    breathingSession?: BreathingSessionOmit
    groundingTechnique?: GroundingTechniqueOmit
    groundingSession?: GroundingSessionOmit
    selfHelpResource?: SelfHelpResourceOmit
    selfHelpInteraction?: SelfHelpInteractionOmit
    aITherapist?: AITherapistOmit
    aITherapySession?: AITherapySessionOmit
    aITherapyMessage?: AITherapyMessageOmit
    aIPersonalization?: AIPersonalizationOmit
    aIExerciseSession?: AIExerciseSessionOmit
    aITherapyInsight?: AITherapyInsightOmit
    aITherapyGoal?: AITherapyGoalOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CrisisSessionCountOutputType
   */

  export type CrisisSessionCountOutputType = {
    messages: number
    escalations: number
    resources: number
  }

  export type CrisisSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | CrisisSessionCountOutputTypeCountMessagesArgs
    escalations?: boolean | CrisisSessionCountOutputTypeCountEscalationsArgs
    resources?: boolean | CrisisSessionCountOutputTypeCountResourcesArgs
  }

  // Custom InputTypes
  /**
   * CrisisSessionCountOutputType without action
   */
  export type CrisisSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisSessionCountOutputType
     */
    select?: CrisisSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CrisisSessionCountOutputType without action
   */
  export type CrisisSessionCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrisisMessageWhereInput
  }

  /**
   * CrisisSessionCountOutputType without action
   */
  export type CrisisSessionCountOutputTypeCountEscalationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrisisEscalationWhereInput
  }

  /**
   * CrisisSessionCountOutputType without action
   */
  export type CrisisSessionCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrisisResourceUsageWhereInput
  }


  /**
   * Count Type TetherLinkCountOutputType
   */

  export type TetherLinkCountOutputType = {
    pulses: number
    emergencies: number
  }

  export type TetherLinkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pulses?: boolean | TetherLinkCountOutputTypeCountPulsesArgs
    emergencies?: boolean | TetherLinkCountOutputTypeCountEmergenciesArgs
  }

  // Custom InputTypes
  /**
   * TetherLinkCountOutputType without action
   */
  export type TetherLinkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherLinkCountOutputType
     */
    select?: TetherLinkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TetherLinkCountOutputType without action
   */
  export type TetherLinkCountOutputTypeCountPulsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TetherPulseWhereInput
  }

  /**
   * TetherLinkCountOutputType without action
   */
  export type TetherLinkCountOutputTypeCountEmergenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TetherEmergencyWhereInput
  }


  /**
   * Count Type VolunteerCountOutputType
   */

  export type VolunteerCountOutputType = {
    training: number
    sessions: number
    feedback: number
  }

  export type VolunteerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | VolunteerCountOutputTypeCountTrainingArgs
    sessions?: boolean | VolunteerCountOutputTypeCountSessionsArgs
    feedback?: boolean | VolunteerCountOutputTypeCountFeedbackArgs
  }

  // Custom InputTypes
  /**
   * VolunteerCountOutputType without action
   */
  export type VolunteerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerCountOutputType
     */
    select?: VolunteerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VolunteerCountOutputType without action
   */
  export type VolunteerCountOutputTypeCountTrainingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolunteerTrainingWhereInput
  }

  /**
   * VolunteerCountOutputType without action
   */
  export type VolunteerCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolunteerSessionWhereInput
  }

  /**
   * VolunteerCountOutputType without action
   */
  export type VolunteerCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolunteerFeedbackWhereInput
  }


  /**
   * Count Type EmergencyContactCountOutputType
   */

  export type EmergencyContactCountOutputType = {
    notifications: number
  }

  export type EmergencyContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | EmergencyContactCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * EmergencyContactCountOutputType without action
   */
  export type EmergencyContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContactCountOutputType
     */
    select?: EmergencyContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmergencyContactCountOutputType without action
   */
  export type EmergencyContactCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyNotificationWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    moodEntries: number
    safetyPlans: number
    achievements: number
    challenges: number
    activities: number
    emergencyContacts: number
    journalEntries: number
    breathingSessions: number
    groundingSessions: number
    selfHelpInteractions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moodEntries?: boolean | UserCountOutputTypeCountMoodEntriesArgs
    safetyPlans?: boolean | UserCountOutputTypeCountSafetyPlansArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    challenges?: boolean | UserCountOutputTypeCountChallengesArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    emergencyContacts?: boolean | UserCountOutputTypeCountEmergencyContactsArgs
    journalEntries?: boolean | UserCountOutputTypeCountJournalEntriesArgs
    breathingSessions?: boolean | UserCountOutputTypeCountBreathingSessionsArgs
    groundingSessions?: boolean | UserCountOutputTypeCountGroundingSessionsArgs
    selfHelpInteractions?: boolean | UserCountOutputTypeCountSelfHelpInteractionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMoodEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoodEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSafetyPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SafetyPlanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserChallengeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmergencyContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJournalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBreathingSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreathingSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroundingSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroundingSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSelfHelpInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SelfHelpInteractionWhereInput
  }


  /**
   * Count Type SafetyPlanCountOutputType
   */

  export type SafetyPlanCountOutputType = {
    versions: number
  }

  export type SafetyPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | SafetyPlanCountOutputTypeCountVersionsArgs
  }

  // Custom InputTypes
  /**
   * SafetyPlanCountOutputType without action
   */
  export type SafetyPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlanCountOutputType
     */
    select?: SafetyPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SafetyPlanCountOutputType without action
   */
  export type SafetyPlanCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SafetyPlanVersionWhereInput
  }


  /**
   * Count Type AchievementCountOutputType
   */

  export type AchievementCountOutputType = {
    userAchievements: number
  }

  export type AchievementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAchievements?: boolean | AchievementCountOutputTypeCountUserAchievementsArgs
  }

  // Custom InputTypes
  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeCountUserAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }


  /**
   * Count Type ChallengeCountOutputType
   */

  export type ChallengeCountOutputType = {
    userChallenges: number
  }

  export type ChallengeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userChallenges?: boolean | ChallengeCountOutputTypeCountUserChallengesArgs
  }

  // Custom InputTypes
  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeCountOutputType
     */
    select?: ChallengeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountUserChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserChallengeWhereInput
  }


  /**
   * Count Type BreathingExerciseCountOutputType
   */

  export type BreathingExerciseCountOutputType = {
    sessions: number
  }

  export type BreathingExerciseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | BreathingExerciseCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * BreathingExerciseCountOutputType without action
   */
  export type BreathingExerciseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingExerciseCountOutputType
     */
    select?: BreathingExerciseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BreathingExerciseCountOutputType without action
   */
  export type BreathingExerciseCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreathingSessionWhereInput
  }


  /**
   * Count Type GroundingTechniqueCountOutputType
   */

  export type GroundingTechniqueCountOutputType = {
    sessions: number
  }

  export type GroundingTechniqueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | GroundingTechniqueCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * GroundingTechniqueCountOutputType without action
   */
  export type GroundingTechniqueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingTechniqueCountOutputType
     */
    select?: GroundingTechniqueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroundingTechniqueCountOutputType without action
   */
  export type GroundingTechniqueCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroundingSessionWhereInput
  }


  /**
   * Count Type SelfHelpResourceCountOutputType
   */

  export type SelfHelpResourceCountOutputType = {
    interactions: number
  }

  export type SelfHelpResourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interactions?: boolean | SelfHelpResourceCountOutputTypeCountInteractionsArgs
  }

  // Custom InputTypes
  /**
   * SelfHelpResourceCountOutputType without action
   */
  export type SelfHelpResourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpResourceCountOutputType
     */
    select?: SelfHelpResourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SelfHelpResourceCountOutputType without action
   */
  export type SelfHelpResourceCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SelfHelpInteractionWhereInput
  }


  /**
   * Count Type AITherapistCountOutputType
   */

  export type AITherapistCountOutputType = {
    sessions: number
    personalizations: number
  }

  export type AITherapistCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | AITherapistCountOutputTypeCountSessionsArgs
    personalizations?: boolean | AITherapistCountOutputTypeCountPersonalizationsArgs
  }

  // Custom InputTypes
  /**
   * AITherapistCountOutputType without action
   */
  export type AITherapistCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapistCountOutputType
     */
    select?: AITherapistCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AITherapistCountOutputType without action
   */
  export type AITherapistCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AITherapySessionWhereInput
  }

  /**
   * AITherapistCountOutputType without action
   */
  export type AITherapistCountOutputTypeCountPersonalizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIPersonalizationWhereInput
  }


  /**
   * Count Type AITherapySessionCountOutputType
   */

  export type AITherapySessionCountOutputType = {
    messages: number
    exercises: number
  }

  export type AITherapySessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | AITherapySessionCountOutputTypeCountMessagesArgs
    exercises?: boolean | AITherapySessionCountOutputTypeCountExercisesArgs
  }

  // Custom InputTypes
  /**
   * AITherapySessionCountOutputType without action
   */
  export type AITherapySessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapySessionCountOutputType
     */
    select?: AITherapySessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AITherapySessionCountOutputType without action
   */
  export type AITherapySessionCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AITherapyMessageWhereInput
  }

  /**
   * AITherapySessionCountOutputType without action
   */
  export type AITherapySessionCountOutputTypeCountExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIExerciseSessionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model CrisisSession
   */

  export type AggregateCrisisSession = {
    _count: CrisisSessionCountAggregateOutputType | null
    _avg: CrisisSessionAvgAggregateOutputType | null
    _sum: CrisisSessionSumAggregateOutputType | null
    _min: CrisisSessionMinAggregateOutputType | null
    _max: CrisisSessionMaxAggregateOutputType | null
  }

  export type CrisisSessionAvgAggregateOutputType = {
    severity: number | null
    responseTimeMs: number | null
    handoffTime: number | null
    resolutionTime: number | null
  }

  export type CrisisSessionSumAggregateOutputType = {
    severity: number | null
    responseTimeMs: number | null
    handoffTime: number | null
    resolutionTime: number | null
  }

  export type CrisisSessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    anonymousId: string | null
    severity: number | null
    status: $Enums.CrisisStatus | null
    responderId: string | null
    startedAt: Date | null
    endedAt: Date | null
    responseTimeMs: number | null
    outcome: string | null
    encryptedData: Uint8Array | null
    keyDerivationSalt: Uint8Array | null
    handoffTime: number | null
    resolutionTime: number | null
    emergencyTriggered: boolean | null
    escalatedAt: Date | null
    escalationType: $Enums.EscalationType | null
  }

  export type CrisisSessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    anonymousId: string | null
    severity: number | null
    status: $Enums.CrisisStatus | null
    responderId: string | null
    startedAt: Date | null
    endedAt: Date | null
    responseTimeMs: number | null
    outcome: string | null
    encryptedData: Uint8Array | null
    keyDerivationSalt: Uint8Array | null
    handoffTime: number | null
    resolutionTime: number | null
    emergencyTriggered: boolean | null
    escalatedAt: Date | null
    escalationType: $Enums.EscalationType | null
  }

  export type CrisisSessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    anonymousId: number
    severity: number
    status: number
    responderId: number
    startedAt: number
    endedAt: number
    responseTimeMs: number
    outcome: number
    encryptedData: number
    keyDerivationSalt: number
    handoffTime: number
    resolutionTime: number
    emergencyTriggered: number
    escalatedAt: number
    escalationType: number
    _all: number
  }


  export type CrisisSessionAvgAggregateInputType = {
    severity?: true
    responseTimeMs?: true
    handoffTime?: true
    resolutionTime?: true
  }

  export type CrisisSessionSumAggregateInputType = {
    severity?: true
    responseTimeMs?: true
    handoffTime?: true
    resolutionTime?: true
  }

  export type CrisisSessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    anonymousId?: true
    severity?: true
    status?: true
    responderId?: true
    startedAt?: true
    endedAt?: true
    responseTimeMs?: true
    outcome?: true
    encryptedData?: true
    keyDerivationSalt?: true
    handoffTime?: true
    resolutionTime?: true
    emergencyTriggered?: true
    escalatedAt?: true
    escalationType?: true
  }

  export type CrisisSessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    anonymousId?: true
    severity?: true
    status?: true
    responderId?: true
    startedAt?: true
    endedAt?: true
    responseTimeMs?: true
    outcome?: true
    encryptedData?: true
    keyDerivationSalt?: true
    handoffTime?: true
    resolutionTime?: true
    emergencyTriggered?: true
    escalatedAt?: true
    escalationType?: true
  }

  export type CrisisSessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    anonymousId?: true
    severity?: true
    status?: true
    responderId?: true
    startedAt?: true
    endedAt?: true
    responseTimeMs?: true
    outcome?: true
    encryptedData?: true
    keyDerivationSalt?: true
    handoffTime?: true
    resolutionTime?: true
    emergencyTriggered?: true
    escalatedAt?: true
    escalationType?: true
    _all?: true
  }

  export type CrisisSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrisisSession to aggregate.
     */
    where?: CrisisSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisSessions to fetch.
     */
    orderBy?: CrisisSessionOrderByWithRelationInput | CrisisSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrisisSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrisisSessions
    **/
    _count?: true | CrisisSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrisisSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrisisSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrisisSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrisisSessionMaxAggregateInputType
  }

  export type GetCrisisSessionAggregateType<T extends CrisisSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateCrisisSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrisisSession[P]>
      : GetScalarType<T[P], AggregateCrisisSession[P]>
  }




  export type CrisisSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrisisSessionWhereInput
    orderBy?: CrisisSessionOrderByWithAggregationInput | CrisisSessionOrderByWithAggregationInput[]
    by: CrisisSessionScalarFieldEnum[] | CrisisSessionScalarFieldEnum
    having?: CrisisSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrisisSessionCountAggregateInputType | true
    _avg?: CrisisSessionAvgAggregateInputType
    _sum?: CrisisSessionSumAggregateInputType
    _min?: CrisisSessionMinAggregateInputType
    _max?: CrisisSessionMaxAggregateInputType
  }

  export type CrisisSessionGroupByOutputType = {
    id: string
    sessionToken: string
    anonymousId: string
    severity: number
    status: $Enums.CrisisStatus
    responderId: string | null
    startedAt: Date
    endedAt: Date | null
    responseTimeMs: number | null
    outcome: string | null
    encryptedData: Uint8Array | null
    keyDerivationSalt: Uint8Array | null
    handoffTime: number | null
    resolutionTime: number | null
    emergencyTriggered: boolean
    escalatedAt: Date | null
    escalationType: $Enums.EscalationType | null
    _count: CrisisSessionCountAggregateOutputType | null
    _avg: CrisisSessionAvgAggregateOutputType | null
    _sum: CrisisSessionSumAggregateOutputType | null
    _min: CrisisSessionMinAggregateOutputType | null
    _max: CrisisSessionMaxAggregateOutputType | null
  }

  type GetCrisisSessionGroupByPayload<T extends CrisisSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrisisSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrisisSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrisisSessionGroupByOutputType[P]>
            : GetScalarType<T[P], CrisisSessionGroupByOutputType[P]>
        }
      >
    >


  export type CrisisSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    anonymousId?: boolean
    severity?: boolean
    status?: boolean
    responderId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    responseTimeMs?: boolean
    outcome?: boolean
    encryptedData?: boolean
    keyDerivationSalt?: boolean
    handoffTime?: boolean
    resolutionTime?: boolean
    emergencyTriggered?: boolean
    escalatedAt?: boolean
    escalationType?: boolean
    messages?: boolean | CrisisSession$messagesArgs<ExtArgs>
    escalations?: boolean | CrisisSession$escalationsArgs<ExtArgs>
    resources?: boolean | CrisisSession$resourcesArgs<ExtArgs>
    _count?: boolean | CrisisSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crisisSession"]>

  export type CrisisSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    anonymousId?: boolean
    severity?: boolean
    status?: boolean
    responderId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    responseTimeMs?: boolean
    outcome?: boolean
    encryptedData?: boolean
    keyDerivationSalt?: boolean
    handoffTime?: boolean
    resolutionTime?: boolean
    emergencyTriggered?: boolean
    escalatedAt?: boolean
    escalationType?: boolean
  }, ExtArgs["result"]["crisisSession"]>

  export type CrisisSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    anonymousId?: boolean
    severity?: boolean
    status?: boolean
    responderId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    responseTimeMs?: boolean
    outcome?: boolean
    encryptedData?: boolean
    keyDerivationSalt?: boolean
    handoffTime?: boolean
    resolutionTime?: boolean
    emergencyTriggered?: boolean
    escalatedAt?: boolean
    escalationType?: boolean
  }, ExtArgs["result"]["crisisSession"]>

  export type CrisisSessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    anonymousId?: boolean
    severity?: boolean
    status?: boolean
    responderId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    responseTimeMs?: boolean
    outcome?: boolean
    encryptedData?: boolean
    keyDerivationSalt?: boolean
    handoffTime?: boolean
    resolutionTime?: boolean
    emergencyTriggered?: boolean
    escalatedAt?: boolean
    escalationType?: boolean
  }

  export type CrisisSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "anonymousId" | "severity" | "status" | "responderId" | "startedAt" | "endedAt" | "responseTimeMs" | "outcome" | "encryptedData" | "keyDerivationSalt" | "handoffTime" | "resolutionTime" | "emergencyTriggered" | "escalatedAt" | "escalationType", ExtArgs["result"]["crisisSession"]>
  export type CrisisSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | CrisisSession$messagesArgs<ExtArgs>
    escalations?: boolean | CrisisSession$escalationsArgs<ExtArgs>
    resources?: boolean | CrisisSession$resourcesArgs<ExtArgs>
    _count?: boolean | CrisisSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CrisisSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CrisisSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CrisisSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrisisSession"
    objects: {
      messages: Prisma.$CrisisMessagePayload<ExtArgs>[]
      escalations: Prisma.$CrisisEscalationPayload<ExtArgs>[]
      resources: Prisma.$CrisisResourceUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      anonymousId: string
      severity: number
      status: $Enums.CrisisStatus
      responderId: string | null
      startedAt: Date
      endedAt: Date | null
      responseTimeMs: number | null
      outcome: string | null
      encryptedData: Uint8Array | null
      keyDerivationSalt: Uint8Array | null
      handoffTime: number | null
      resolutionTime: number | null
      emergencyTriggered: boolean
      escalatedAt: Date | null
      escalationType: $Enums.EscalationType | null
    }, ExtArgs["result"]["crisisSession"]>
    composites: {}
  }

  type CrisisSessionGetPayload<S extends boolean | null | undefined | CrisisSessionDefaultArgs> = $Result.GetResult<Prisma.$CrisisSessionPayload, S>

  type CrisisSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CrisisSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: CrisisSessionCountAggregateInputType | true
    }

  export interface CrisisSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrisisSession'], meta: { name: 'CrisisSession' } }
    /**
     * Find zero or one CrisisSession that matches the filter.
     * @param {CrisisSessionFindUniqueArgs} args - Arguments to find a CrisisSession
     * @example
     * // Get one CrisisSession
     * const crisisSession = await prisma.crisisSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrisisSessionFindUniqueArgs>(args: SelectSubset<T, CrisisSessionFindUniqueArgs<ExtArgs>>): Prisma__CrisisSessionClient<$Result.GetResult<Prisma.$CrisisSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CrisisSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CrisisSessionFindUniqueOrThrowArgs} args - Arguments to find a CrisisSession
     * @example
     * // Get one CrisisSession
     * const crisisSession = await prisma.crisisSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrisisSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, CrisisSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrisisSessionClient<$Result.GetResult<Prisma.$CrisisSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrisisSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisSessionFindFirstArgs} args - Arguments to find a CrisisSession
     * @example
     * // Get one CrisisSession
     * const crisisSession = await prisma.crisisSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrisisSessionFindFirstArgs>(args?: SelectSubset<T, CrisisSessionFindFirstArgs<ExtArgs>>): Prisma__CrisisSessionClient<$Result.GetResult<Prisma.$CrisisSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrisisSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisSessionFindFirstOrThrowArgs} args - Arguments to find a CrisisSession
     * @example
     * // Get one CrisisSession
     * const crisisSession = await prisma.crisisSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrisisSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, CrisisSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrisisSessionClient<$Result.GetResult<Prisma.$CrisisSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CrisisSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrisisSessions
     * const crisisSessions = await prisma.crisisSession.findMany()
     * 
     * // Get first 10 CrisisSessions
     * const crisisSessions = await prisma.crisisSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crisisSessionWithIdOnly = await prisma.crisisSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrisisSessionFindManyArgs>(args?: SelectSubset<T, CrisisSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CrisisSession.
     * @param {CrisisSessionCreateArgs} args - Arguments to create a CrisisSession.
     * @example
     * // Create one CrisisSession
     * const CrisisSession = await prisma.crisisSession.create({
     *   data: {
     *     // ... data to create a CrisisSession
     *   }
     * })
     * 
     */
    create<T extends CrisisSessionCreateArgs>(args: SelectSubset<T, CrisisSessionCreateArgs<ExtArgs>>): Prisma__CrisisSessionClient<$Result.GetResult<Prisma.$CrisisSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CrisisSessions.
     * @param {CrisisSessionCreateManyArgs} args - Arguments to create many CrisisSessions.
     * @example
     * // Create many CrisisSessions
     * const crisisSession = await prisma.crisisSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrisisSessionCreateManyArgs>(args?: SelectSubset<T, CrisisSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrisisSessions and returns the data saved in the database.
     * @param {CrisisSessionCreateManyAndReturnArgs} args - Arguments to create many CrisisSessions.
     * @example
     * // Create many CrisisSessions
     * const crisisSession = await prisma.crisisSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrisisSessions and only return the `id`
     * const crisisSessionWithIdOnly = await prisma.crisisSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrisisSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, CrisisSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CrisisSession.
     * @param {CrisisSessionDeleteArgs} args - Arguments to delete one CrisisSession.
     * @example
     * // Delete one CrisisSession
     * const CrisisSession = await prisma.crisisSession.delete({
     *   where: {
     *     // ... filter to delete one CrisisSession
     *   }
     * })
     * 
     */
    delete<T extends CrisisSessionDeleteArgs>(args: SelectSubset<T, CrisisSessionDeleteArgs<ExtArgs>>): Prisma__CrisisSessionClient<$Result.GetResult<Prisma.$CrisisSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CrisisSession.
     * @param {CrisisSessionUpdateArgs} args - Arguments to update one CrisisSession.
     * @example
     * // Update one CrisisSession
     * const crisisSession = await prisma.crisisSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrisisSessionUpdateArgs>(args: SelectSubset<T, CrisisSessionUpdateArgs<ExtArgs>>): Prisma__CrisisSessionClient<$Result.GetResult<Prisma.$CrisisSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CrisisSessions.
     * @param {CrisisSessionDeleteManyArgs} args - Arguments to filter CrisisSessions to delete.
     * @example
     * // Delete a few CrisisSessions
     * const { count } = await prisma.crisisSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrisisSessionDeleteManyArgs>(args?: SelectSubset<T, CrisisSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrisisSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrisisSessions
     * const crisisSession = await prisma.crisisSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrisisSessionUpdateManyArgs>(args: SelectSubset<T, CrisisSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrisisSessions and returns the data updated in the database.
     * @param {CrisisSessionUpdateManyAndReturnArgs} args - Arguments to update many CrisisSessions.
     * @example
     * // Update many CrisisSessions
     * const crisisSession = await prisma.crisisSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CrisisSessions and only return the `id`
     * const crisisSessionWithIdOnly = await prisma.crisisSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CrisisSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, CrisisSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CrisisSession.
     * @param {CrisisSessionUpsertArgs} args - Arguments to update or create a CrisisSession.
     * @example
     * // Update or create a CrisisSession
     * const crisisSession = await prisma.crisisSession.upsert({
     *   create: {
     *     // ... data to create a CrisisSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrisisSession we want to update
     *   }
     * })
     */
    upsert<T extends CrisisSessionUpsertArgs>(args: SelectSubset<T, CrisisSessionUpsertArgs<ExtArgs>>): Prisma__CrisisSessionClient<$Result.GetResult<Prisma.$CrisisSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CrisisSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisSessionCountArgs} args - Arguments to filter CrisisSessions to count.
     * @example
     * // Count the number of CrisisSessions
     * const count = await prisma.crisisSession.count({
     *   where: {
     *     // ... the filter for the CrisisSessions we want to count
     *   }
     * })
    **/
    count<T extends CrisisSessionCountArgs>(
      args?: Subset<T, CrisisSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrisisSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrisisSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrisisSessionAggregateArgs>(args: Subset<T, CrisisSessionAggregateArgs>): Prisma.PrismaPromise<GetCrisisSessionAggregateType<T>>

    /**
     * Group by CrisisSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrisisSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrisisSessionGroupByArgs['orderBy'] }
        : { orderBy?: CrisisSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrisisSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrisisSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrisisSession model
   */
  readonly fields: CrisisSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrisisSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrisisSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends CrisisSession$messagesArgs<ExtArgs> = {}>(args?: Subset<T, CrisisSession$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    escalations<T extends CrisisSession$escalationsArgs<ExtArgs> = {}>(args?: Subset<T, CrisisSession$escalationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisEscalationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resources<T extends CrisisSession$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, CrisisSession$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisResourceUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrisisSession model
   */
  interface CrisisSessionFieldRefs {
    readonly id: FieldRef<"CrisisSession", 'String'>
    readonly sessionToken: FieldRef<"CrisisSession", 'String'>
    readonly anonymousId: FieldRef<"CrisisSession", 'String'>
    readonly severity: FieldRef<"CrisisSession", 'Int'>
    readonly status: FieldRef<"CrisisSession", 'CrisisStatus'>
    readonly responderId: FieldRef<"CrisisSession", 'String'>
    readonly startedAt: FieldRef<"CrisisSession", 'DateTime'>
    readonly endedAt: FieldRef<"CrisisSession", 'DateTime'>
    readonly responseTimeMs: FieldRef<"CrisisSession", 'Int'>
    readonly outcome: FieldRef<"CrisisSession", 'String'>
    readonly encryptedData: FieldRef<"CrisisSession", 'Bytes'>
    readonly keyDerivationSalt: FieldRef<"CrisisSession", 'Bytes'>
    readonly handoffTime: FieldRef<"CrisisSession", 'Int'>
    readonly resolutionTime: FieldRef<"CrisisSession", 'Int'>
    readonly emergencyTriggered: FieldRef<"CrisisSession", 'Boolean'>
    readonly escalatedAt: FieldRef<"CrisisSession", 'DateTime'>
    readonly escalationType: FieldRef<"CrisisSession", 'EscalationType'>
  }
    

  // Custom InputTypes
  /**
   * CrisisSession findUnique
   */
  export type CrisisSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisSession
     */
    select?: CrisisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisSession
     */
    omit?: CrisisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisSessionInclude<ExtArgs> | null
    /**
     * Filter, which CrisisSession to fetch.
     */
    where: CrisisSessionWhereUniqueInput
  }

  /**
   * CrisisSession findUniqueOrThrow
   */
  export type CrisisSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisSession
     */
    select?: CrisisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisSession
     */
    omit?: CrisisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisSessionInclude<ExtArgs> | null
    /**
     * Filter, which CrisisSession to fetch.
     */
    where: CrisisSessionWhereUniqueInput
  }

  /**
   * CrisisSession findFirst
   */
  export type CrisisSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisSession
     */
    select?: CrisisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisSession
     */
    omit?: CrisisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisSessionInclude<ExtArgs> | null
    /**
     * Filter, which CrisisSession to fetch.
     */
    where?: CrisisSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisSessions to fetch.
     */
    orderBy?: CrisisSessionOrderByWithRelationInput | CrisisSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrisisSessions.
     */
    cursor?: CrisisSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrisisSessions.
     */
    distinct?: CrisisSessionScalarFieldEnum | CrisisSessionScalarFieldEnum[]
  }

  /**
   * CrisisSession findFirstOrThrow
   */
  export type CrisisSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisSession
     */
    select?: CrisisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisSession
     */
    omit?: CrisisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisSessionInclude<ExtArgs> | null
    /**
     * Filter, which CrisisSession to fetch.
     */
    where?: CrisisSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisSessions to fetch.
     */
    orderBy?: CrisisSessionOrderByWithRelationInput | CrisisSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrisisSessions.
     */
    cursor?: CrisisSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrisisSessions.
     */
    distinct?: CrisisSessionScalarFieldEnum | CrisisSessionScalarFieldEnum[]
  }

  /**
   * CrisisSession findMany
   */
  export type CrisisSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisSession
     */
    select?: CrisisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisSession
     */
    omit?: CrisisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisSessionInclude<ExtArgs> | null
    /**
     * Filter, which CrisisSessions to fetch.
     */
    where?: CrisisSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisSessions to fetch.
     */
    orderBy?: CrisisSessionOrderByWithRelationInput | CrisisSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrisisSessions.
     */
    cursor?: CrisisSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisSessions.
     */
    skip?: number
    distinct?: CrisisSessionScalarFieldEnum | CrisisSessionScalarFieldEnum[]
  }

  /**
   * CrisisSession create
   */
  export type CrisisSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisSession
     */
    select?: CrisisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisSession
     */
    omit?: CrisisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a CrisisSession.
     */
    data: XOR<CrisisSessionCreateInput, CrisisSessionUncheckedCreateInput>
  }

  /**
   * CrisisSession createMany
   */
  export type CrisisSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrisisSessions.
     */
    data: CrisisSessionCreateManyInput | CrisisSessionCreateManyInput[]
  }

  /**
   * CrisisSession createManyAndReturn
   */
  export type CrisisSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisSession
     */
    select?: CrisisSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisSession
     */
    omit?: CrisisSessionOmit<ExtArgs> | null
    /**
     * The data used to create many CrisisSessions.
     */
    data: CrisisSessionCreateManyInput | CrisisSessionCreateManyInput[]
  }

  /**
   * CrisisSession update
   */
  export type CrisisSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisSession
     */
    select?: CrisisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisSession
     */
    omit?: CrisisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a CrisisSession.
     */
    data: XOR<CrisisSessionUpdateInput, CrisisSessionUncheckedUpdateInput>
    /**
     * Choose, which CrisisSession to update.
     */
    where: CrisisSessionWhereUniqueInput
  }

  /**
   * CrisisSession updateMany
   */
  export type CrisisSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrisisSessions.
     */
    data: XOR<CrisisSessionUpdateManyMutationInput, CrisisSessionUncheckedUpdateManyInput>
    /**
     * Filter which CrisisSessions to update
     */
    where?: CrisisSessionWhereInput
    /**
     * Limit how many CrisisSessions to update.
     */
    limit?: number
  }

  /**
   * CrisisSession updateManyAndReturn
   */
  export type CrisisSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisSession
     */
    select?: CrisisSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisSession
     */
    omit?: CrisisSessionOmit<ExtArgs> | null
    /**
     * The data used to update CrisisSessions.
     */
    data: XOR<CrisisSessionUpdateManyMutationInput, CrisisSessionUncheckedUpdateManyInput>
    /**
     * Filter which CrisisSessions to update
     */
    where?: CrisisSessionWhereInput
    /**
     * Limit how many CrisisSessions to update.
     */
    limit?: number
  }

  /**
   * CrisisSession upsert
   */
  export type CrisisSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisSession
     */
    select?: CrisisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisSession
     */
    omit?: CrisisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the CrisisSession to update in case it exists.
     */
    where: CrisisSessionWhereUniqueInput
    /**
     * In case the CrisisSession found by the `where` argument doesn't exist, create a new CrisisSession with this data.
     */
    create: XOR<CrisisSessionCreateInput, CrisisSessionUncheckedCreateInput>
    /**
     * In case the CrisisSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrisisSessionUpdateInput, CrisisSessionUncheckedUpdateInput>
  }

  /**
   * CrisisSession delete
   */
  export type CrisisSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisSession
     */
    select?: CrisisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisSession
     */
    omit?: CrisisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisSessionInclude<ExtArgs> | null
    /**
     * Filter which CrisisSession to delete.
     */
    where: CrisisSessionWhereUniqueInput
  }

  /**
   * CrisisSession deleteMany
   */
  export type CrisisSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrisisSessions to delete
     */
    where?: CrisisSessionWhereInput
    /**
     * Limit how many CrisisSessions to delete.
     */
    limit?: number
  }

  /**
   * CrisisSession.messages
   */
  export type CrisisSession$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisMessage
     */
    select?: CrisisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisMessage
     */
    omit?: CrisisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisMessageInclude<ExtArgs> | null
    where?: CrisisMessageWhereInput
    orderBy?: CrisisMessageOrderByWithRelationInput | CrisisMessageOrderByWithRelationInput[]
    cursor?: CrisisMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrisisMessageScalarFieldEnum | CrisisMessageScalarFieldEnum[]
  }

  /**
   * CrisisSession.escalations
   */
  export type CrisisSession$escalationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisEscalation
     */
    select?: CrisisEscalationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisEscalation
     */
    omit?: CrisisEscalationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisEscalationInclude<ExtArgs> | null
    where?: CrisisEscalationWhereInput
    orderBy?: CrisisEscalationOrderByWithRelationInput | CrisisEscalationOrderByWithRelationInput[]
    cursor?: CrisisEscalationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrisisEscalationScalarFieldEnum | CrisisEscalationScalarFieldEnum[]
  }

  /**
   * CrisisSession.resources
   */
  export type CrisisSession$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResourceUsage
     */
    select?: CrisisResourceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResourceUsage
     */
    omit?: CrisisResourceUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisResourceUsageInclude<ExtArgs> | null
    where?: CrisisResourceUsageWhereInput
    orderBy?: CrisisResourceUsageOrderByWithRelationInput | CrisisResourceUsageOrderByWithRelationInput[]
    cursor?: CrisisResourceUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrisisResourceUsageScalarFieldEnum | CrisisResourceUsageScalarFieldEnum[]
  }

  /**
   * CrisisSession without action
   */
  export type CrisisSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisSession
     */
    select?: CrisisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisSession
     */
    omit?: CrisisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisSessionInclude<ExtArgs> | null
  }


  /**
   * Model CrisisMessage
   */

  export type AggregateCrisisMessage = {
    _count: CrisisMessageCountAggregateOutputType | null
    _avg: CrisisMessageAvgAggregateOutputType | null
    _sum: CrisisMessageSumAggregateOutputType | null
    _min: CrisisMessageMinAggregateOutputType | null
    _max: CrisisMessageMaxAggregateOutputType | null
  }

  export type CrisisMessageAvgAggregateOutputType = {
    sentimentScore: number | null
    riskScore: number | null
  }

  export type CrisisMessageSumAggregateOutputType = {
    sentimentScore: number | null
    riskScore: number | null
  }

  export type CrisisMessageMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    senderType: $Enums.MessageSender | null
    senderId: string | null
    encryptedContent: Uint8Array | null
    messageHash: string | null
    timestamp: Date | null
    messageType: $Enums.MessageType | null
    priority: $Enums.MessagePriority | null
    sentimentScore: number | null
    riskScore: number | null
    riskLevel: string | null
    keywordsDetected: string | null
  }

  export type CrisisMessageMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    senderType: $Enums.MessageSender | null
    senderId: string | null
    encryptedContent: Uint8Array | null
    messageHash: string | null
    timestamp: Date | null
    messageType: $Enums.MessageType | null
    priority: $Enums.MessagePriority | null
    sentimentScore: number | null
    riskScore: number | null
    riskLevel: string | null
    keywordsDetected: string | null
  }

  export type CrisisMessageCountAggregateOutputType = {
    id: number
    sessionId: number
    senderType: number
    senderId: number
    encryptedContent: number
    messageHash: number
    timestamp: number
    messageType: number
    priority: number
    sentimentScore: number
    riskScore: number
    riskLevel: number
    keywordsDetected: number
    _all: number
  }


  export type CrisisMessageAvgAggregateInputType = {
    sentimentScore?: true
    riskScore?: true
  }

  export type CrisisMessageSumAggregateInputType = {
    sentimentScore?: true
    riskScore?: true
  }

  export type CrisisMessageMinAggregateInputType = {
    id?: true
    sessionId?: true
    senderType?: true
    senderId?: true
    encryptedContent?: true
    messageHash?: true
    timestamp?: true
    messageType?: true
    priority?: true
    sentimentScore?: true
    riskScore?: true
    riskLevel?: true
    keywordsDetected?: true
  }

  export type CrisisMessageMaxAggregateInputType = {
    id?: true
    sessionId?: true
    senderType?: true
    senderId?: true
    encryptedContent?: true
    messageHash?: true
    timestamp?: true
    messageType?: true
    priority?: true
    sentimentScore?: true
    riskScore?: true
    riskLevel?: true
    keywordsDetected?: true
  }

  export type CrisisMessageCountAggregateInputType = {
    id?: true
    sessionId?: true
    senderType?: true
    senderId?: true
    encryptedContent?: true
    messageHash?: true
    timestamp?: true
    messageType?: true
    priority?: true
    sentimentScore?: true
    riskScore?: true
    riskLevel?: true
    keywordsDetected?: true
    _all?: true
  }

  export type CrisisMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrisisMessage to aggregate.
     */
    where?: CrisisMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisMessages to fetch.
     */
    orderBy?: CrisisMessageOrderByWithRelationInput | CrisisMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrisisMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrisisMessages
    **/
    _count?: true | CrisisMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrisisMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrisisMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrisisMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrisisMessageMaxAggregateInputType
  }

  export type GetCrisisMessageAggregateType<T extends CrisisMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateCrisisMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrisisMessage[P]>
      : GetScalarType<T[P], AggregateCrisisMessage[P]>
  }




  export type CrisisMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrisisMessageWhereInput
    orderBy?: CrisisMessageOrderByWithAggregationInput | CrisisMessageOrderByWithAggregationInput[]
    by: CrisisMessageScalarFieldEnum[] | CrisisMessageScalarFieldEnum
    having?: CrisisMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrisisMessageCountAggregateInputType | true
    _avg?: CrisisMessageAvgAggregateInputType
    _sum?: CrisisMessageSumAggregateInputType
    _min?: CrisisMessageMinAggregateInputType
    _max?: CrisisMessageMaxAggregateInputType
  }

  export type CrisisMessageGroupByOutputType = {
    id: string
    sessionId: string
    senderType: $Enums.MessageSender
    senderId: string
    encryptedContent: Uint8Array
    messageHash: string
    timestamp: Date
    messageType: $Enums.MessageType
    priority: $Enums.MessagePriority
    sentimentScore: number | null
    riskScore: number | null
    riskLevel: string | null
    keywordsDetected: string | null
    _count: CrisisMessageCountAggregateOutputType | null
    _avg: CrisisMessageAvgAggregateOutputType | null
    _sum: CrisisMessageSumAggregateOutputType | null
    _min: CrisisMessageMinAggregateOutputType | null
    _max: CrisisMessageMaxAggregateOutputType | null
  }

  type GetCrisisMessageGroupByPayload<T extends CrisisMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrisisMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrisisMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrisisMessageGroupByOutputType[P]>
            : GetScalarType<T[P], CrisisMessageGroupByOutputType[P]>
        }
      >
    >


  export type CrisisMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    senderType?: boolean
    senderId?: boolean
    encryptedContent?: boolean
    messageHash?: boolean
    timestamp?: boolean
    messageType?: boolean
    priority?: boolean
    sentimentScore?: boolean
    riskScore?: boolean
    riskLevel?: boolean
    keywordsDetected?: boolean
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crisisMessage"]>

  export type CrisisMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    senderType?: boolean
    senderId?: boolean
    encryptedContent?: boolean
    messageHash?: boolean
    timestamp?: boolean
    messageType?: boolean
    priority?: boolean
    sentimentScore?: boolean
    riskScore?: boolean
    riskLevel?: boolean
    keywordsDetected?: boolean
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crisisMessage"]>

  export type CrisisMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    senderType?: boolean
    senderId?: boolean
    encryptedContent?: boolean
    messageHash?: boolean
    timestamp?: boolean
    messageType?: boolean
    priority?: boolean
    sentimentScore?: boolean
    riskScore?: boolean
    riskLevel?: boolean
    keywordsDetected?: boolean
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crisisMessage"]>

  export type CrisisMessageSelectScalar = {
    id?: boolean
    sessionId?: boolean
    senderType?: boolean
    senderId?: boolean
    encryptedContent?: boolean
    messageHash?: boolean
    timestamp?: boolean
    messageType?: boolean
    priority?: boolean
    sentimentScore?: boolean
    riskScore?: boolean
    riskLevel?: boolean
    keywordsDetected?: boolean
  }

  export type CrisisMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "senderType" | "senderId" | "encryptedContent" | "messageHash" | "timestamp" | "messageType" | "priority" | "sentimentScore" | "riskScore" | "riskLevel" | "keywordsDetected", ExtArgs["result"]["crisisMessage"]>
  export type CrisisMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }
  export type CrisisMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }
  export type CrisisMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }

  export type $CrisisMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrisisMessage"
    objects: {
      session: Prisma.$CrisisSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      senderType: $Enums.MessageSender
      senderId: string
      encryptedContent: Uint8Array
      messageHash: string
      timestamp: Date
      messageType: $Enums.MessageType
      priority: $Enums.MessagePriority
      sentimentScore: number | null
      riskScore: number | null
      riskLevel: string | null
      keywordsDetected: string | null
    }, ExtArgs["result"]["crisisMessage"]>
    composites: {}
  }

  type CrisisMessageGetPayload<S extends boolean | null | undefined | CrisisMessageDefaultArgs> = $Result.GetResult<Prisma.$CrisisMessagePayload, S>

  type CrisisMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CrisisMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: CrisisMessageCountAggregateInputType | true
    }

  export interface CrisisMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrisisMessage'], meta: { name: 'CrisisMessage' } }
    /**
     * Find zero or one CrisisMessage that matches the filter.
     * @param {CrisisMessageFindUniqueArgs} args - Arguments to find a CrisisMessage
     * @example
     * // Get one CrisisMessage
     * const crisisMessage = await prisma.crisisMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrisisMessageFindUniqueArgs>(args: SelectSubset<T, CrisisMessageFindUniqueArgs<ExtArgs>>): Prisma__CrisisMessageClient<$Result.GetResult<Prisma.$CrisisMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CrisisMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CrisisMessageFindUniqueOrThrowArgs} args - Arguments to find a CrisisMessage
     * @example
     * // Get one CrisisMessage
     * const crisisMessage = await prisma.crisisMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrisisMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, CrisisMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrisisMessageClient<$Result.GetResult<Prisma.$CrisisMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrisisMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisMessageFindFirstArgs} args - Arguments to find a CrisisMessage
     * @example
     * // Get one CrisisMessage
     * const crisisMessage = await prisma.crisisMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrisisMessageFindFirstArgs>(args?: SelectSubset<T, CrisisMessageFindFirstArgs<ExtArgs>>): Prisma__CrisisMessageClient<$Result.GetResult<Prisma.$CrisisMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrisisMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisMessageFindFirstOrThrowArgs} args - Arguments to find a CrisisMessage
     * @example
     * // Get one CrisisMessage
     * const crisisMessage = await prisma.crisisMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrisisMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, CrisisMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrisisMessageClient<$Result.GetResult<Prisma.$CrisisMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CrisisMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrisisMessages
     * const crisisMessages = await prisma.crisisMessage.findMany()
     * 
     * // Get first 10 CrisisMessages
     * const crisisMessages = await prisma.crisisMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crisisMessageWithIdOnly = await prisma.crisisMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrisisMessageFindManyArgs>(args?: SelectSubset<T, CrisisMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CrisisMessage.
     * @param {CrisisMessageCreateArgs} args - Arguments to create a CrisisMessage.
     * @example
     * // Create one CrisisMessage
     * const CrisisMessage = await prisma.crisisMessage.create({
     *   data: {
     *     // ... data to create a CrisisMessage
     *   }
     * })
     * 
     */
    create<T extends CrisisMessageCreateArgs>(args: SelectSubset<T, CrisisMessageCreateArgs<ExtArgs>>): Prisma__CrisisMessageClient<$Result.GetResult<Prisma.$CrisisMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CrisisMessages.
     * @param {CrisisMessageCreateManyArgs} args - Arguments to create many CrisisMessages.
     * @example
     * // Create many CrisisMessages
     * const crisisMessage = await prisma.crisisMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrisisMessageCreateManyArgs>(args?: SelectSubset<T, CrisisMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrisisMessages and returns the data saved in the database.
     * @param {CrisisMessageCreateManyAndReturnArgs} args - Arguments to create many CrisisMessages.
     * @example
     * // Create many CrisisMessages
     * const crisisMessage = await prisma.crisisMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrisisMessages and only return the `id`
     * const crisisMessageWithIdOnly = await prisma.crisisMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrisisMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, CrisisMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CrisisMessage.
     * @param {CrisisMessageDeleteArgs} args - Arguments to delete one CrisisMessage.
     * @example
     * // Delete one CrisisMessage
     * const CrisisMessage = await prisma.crisisMessage.delete({
     *   where: {
     *     // ... filter to delete one CrisisMessage
     *   }
     * })
     * 
     */
    delete<T extends CrisisMessageDeleteArgs>(args: SelectSubset<T, CrisisMessageDeleteArgs<ExtArgs>>): Prisma__CrisisMessageClient<$Result.GetResult<Prisma.$CrisisMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CrisisMessage.
     * @param {CrisisMessageUpdateArgs} args - Arguments to update one CrisisMessage.
     * @example
     * // Update one CrisisMessage
     * const crisisMessage = await prisma.crisisMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrisisMessageUpdateArgs>(args: SelectSubset<T, CrisisMessageUpdateArgs<ExtArgs>>): Prisma__CrisisMessageClient<$Result.GetResult<Prisma.$CrisisMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CrisisMessages.
     * @param {CrisisMessageDeleteManyArgs} args - Arguments to filter CrisisMessages to delete.
     * @example
     * // Delete a few CrisisMessages
     * const { count } = await prisma.crisisMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrisisMessageDeleteManyArgs>(args?: SelectSubset<T, CrisisMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrisisMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrisisMessages
     * const crisisMessage = await prisma.crisisMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrisisMessageUpdateManyArgs>(args: SelectSubset<T, CrisisMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrisisMessages and returns the data updated in the database.
     * @param {CrisisMessageUpdateManyAndReturnArgs} args - Arguments to update many CrisisMessages.
     * @example
     * // Update many CrisisMessages
     * const crisisMessage = await prisma.crisisMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CrisisMessages and only return the `id`
     * const crisisMessageWithIdOnly = await prisma.crisisMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CrisisMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, CrisisMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CrisisMessage.
     * @param {CrisisMessageUpsertArgs} args - Arguments to update or create a CrisisMessage.
     * @example
     * // Update or create a CrisisMessage
     * const crisisMessage = await prisma.crisisMessage.upsert({
     *   create: {
     *     // ... data to create a CrisisMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrisisMessage we want to update
     *   }
     * })
     */
    upsert<T extends CrisisMessageUpsertArgs>(args: SelectSubset<T, CrisisMessageUpsertArgs<ExtArgs>>): Prisma__CrisisMessageClient<$Result.GetResult<Prisma.$CrisisMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CrisisMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisMessageCountArgs} args - Arguments to filter CrisisMessages to count.
     * @example
     * // Count the number of CrisisMessages
     * const count = await prisma.crisisMessage.count({
     *   where: {
     *     // ... the filter for the CrisisMessages we want to count
     *   }
     * })
    **/
    count<T extends CrisisMessageCountArgs>(
      args?: Subset<T, CrisisMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrisisMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrisisMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrisisMessageAggregateArgs>(args: Subset<T, CrisisMessageAggregateArgs>): Prisma.PrismaPromise<GetCrisisMessageAggregateType<T>>

    /**
     * Group by CrisisMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrisisMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrisisMessageGroupByArgs['orderBy'] }
        : { orderBy?: CrisisMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrisisMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrisisMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrisisMessage model
   */
  readonly fields: CrisisMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrisisMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrisisMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends CrisisSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CrisisSessionDefaultArgs<ExtArgs>>): Prisma__CrisisSessionClient<$Result.GetResult<Prisma.$CrisisSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrisisMessage model
   */
  interface CrisisMessageFieldRefs {
    readonly id: FieldRef<"CrisisMessage", 'String'>
    readonly sessionId: FieldRef<"CrisisMessage", 'String'>
    readonly senderType: FieldRef<"CrisisMessage", 'MessageSender'>
    readonly senderId: FieldRef<"CrisisMessage", 'String'>
    readonly encryptedContent: FieldRef<"CrisisMessage", 'Bytes'>
    readonly messageHash: FieldRef<"CrisisMessage", 'String'>
    readonly timestamp: FieldRef<"CrisisMessage", 'DateTime'>
    readonly messageType: FieldRef<"CrisisMessage", 'MessageType'>
    readonly priority: FieldRef<"CrisisMessage", 'MessagePriority'>
    readonly sentimentScore: FieldRef<"CrisisMessage", 'Float'>
    readonly riskScore: FieldRef<"CrisisMessage", 'Int'>
    readonly riskLevel: FieldRef<"CrisisMessage", 'String'>
    readonly keywordsDetected: FieldRef<"CrisisMessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CrisisMessage findUnique
   */
  export type CrisisMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisMessage
     */
    select?: CrisisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisMessage
     */
    omit?: CrisisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisMessageInclude<ExtArgs> | null
    /**
     * Filter, which CrisisMessage to fetch.
     */
    where: CrisisMessageWhereUniqueInput
  }

  /**
   * CrisisMessage findUniqueOrThrow
   */
  export type CrisisMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisMessage
     */
    select?: CrisisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisMessage
     */
    omit?: CrisisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisMessageInclude<ExtArgs> | null
    /**
     * Filter, which CrisisMessage to fetch.
     */
    where: CrisisMessageWhereUniqueInput
  }

  /**
   * CrisisMessage findFirst
   */
  export type CrisisMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisMessage
     */
    select?: CrisisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisMessage
     */
    omit?: CrisisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisMessageInclude<ExtArgs> | null
    /**
     * Filter, which CrisisMessage to fetch.
     */
    where?: CrisisMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisMessages to fetch.
     */
    orderBy?: CrisisMessageOrderByWithRelationInput | CrisisMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrisisMessages.
     */
    cursor?: CrisisMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrisisMessages.
     */
    distinct?: CrisisMessageScalarFieldEnum | CrisisMessageScalarFieldEnum[]
  }

  /**
   * CrisisMessage findFirstOrThrow
   */
  export type CrisisMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisMessage
     */
    select?: CrisisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisMessage
     */
    omit?: CrisisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisMessageInclude<ExtArgs> | null
    /**
     * Filter, which CrisisMessage to fetch.
     */
    where?: CrisisMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisMessages to fetch.
     */
    orderBy?: CrisisMessageOrderByWithRelationInput | CrisisMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrisisMessages.
     */
    cursor?: CrisisMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrisisMessages.
     */
    distinct?: CrisisMessageScalarFieldEnum | CrisisMessageScalarFieldEnum[]
  }

  /**
   * CrisisMessage findMany
   */
  export type CrisisMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisMessage
     */
    select?: CrisisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisMessage
     */
    omit?: CrisisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisMessageInclude<ExtArgs> | null
    /**
     * Filter, which CrisisMessages to fetch.
     */
    where?: CrisisMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisMessages to fetch.
     */
    orderBy?: CrisisMessageOrderByWithRelationInput | CrisisMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrisisMessages.
     */
    cursor?: CrisisMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisMessages.
     */
    skip?: number
    distinct?: CrisisMessageScalarFieldEnum | CrisisMessageScalarFieldEnum[]
  }

  /**
   * CrisisMessage create
   */
  export type CrisisMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisMessage
     */
    select?: CrisisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisMessage
     */
    omit?: CrisisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a CrisisMessage.
     */
    data: XOR<CrisisMessageCreateInput, CrisisMessageUncheckedCreateInput>
  }

  /**
   * CrisisMessage createMany
   */
  export type CrisisMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrisisMessages.
     */
    data: CrisisMessageCreateManyInput | CrisisMessageCreateManyInput[]
  }

  /**
   * CrisisMessage createManyAndReturn
   */
  export type CrisisMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisMessage
     */
    select?: CrisisMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisMessage
     */
    omit?: CrisisMessageOmit<ExtArgs> | null
    /**
     * The data used to create many CrisisMessages.
     */
    data: CrisisMessageCreateManyInput | CrisisMessageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrisisMessage update
   */
  export type CrisisMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisMessage
     */
    select?: CrisisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisMessage
     */
    omit?: CrisisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a CrisisMessage.
     */
    data: XOR<CrisisMessageUpdateInput, CrisisMessageUncheckedUpdateInput>
    /**
     * Choose, which CrisisMessage to update.
     */
    where: CrisisMessageWhereUniqueInput
  }

  /**
   * CrisisMessage updateMany
   */
  export type CrisisMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrisisMessages.
     */
    data: XOR<CrisisMessageUpdateManyMutationInput, CrisisMessageUncheckedUpdateManyInput>
    /**
     * Filter which CrisisMessages to update
     */
    where?: CrisisMessageWhereInput
    /**
     * Limit how many CrisisMessages to update.
     */
    limit?: number
  }

  /**
   * CrisisMessage updateManyAndReturn
   */
  export type CrisisMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisMessage
     */
    select?: CrisisMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisMessage
     */
    omit?: CrisisMessageOmit<ExtArgs> | null
    /**
     * The data used to update CrisisMessages.
     */
    data: XOR<CrisisMessageUpdateManyMutationInput, CrisisMessageUncheckedUpdateManyInput>
    /**
     * Filter which CrisisMessages to update
     */
    where?: CrisisMessageWhereInput
    /**
     * Limit how many CrisisMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrisisMessage upsert
   */
  export type CrisisMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisMessage
     */
    select?: CrisisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisMessage
     */
    omit?: CrisisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the CrisisMessage to update in case it exists.
     */
    where: CrisisMessageWhereUniqueInput
    /**
     * In case the CrisisMessage found by the `where` argument doesn't exist, create a new CrisisMessage with this data.
     */
    create: XOR<CrisisMessageCreateInput, CrisisMessageUncheckedCreateInput>
    /**
     * In case the CrisisMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrisisMessageUpdateInput, CrisisMessageUncheckedUpdateInput>
  }

  /**
   * CrisisMessage delete
   */
  export type CrisisMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisMessage
     */
    select?: CrisisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisMessage
     */
    omit?: CrisisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisMessageInclude<ExtArgs> | null
    /**
     * Filter which CrisisMessage to delete.
     */
    where: CrisisMessageWhereUniqueInput
  }

  /**
   * CrisisMessage deleteMany
   */
  export type CrisisMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrisisMessages to delete
     */
    where?: CrisisMessageWhereInput
    /**
     * Limit how many CrisisMessages to delete.
     */
    limit?: number
  }

  /**
   * CrisisMessage without action
   */
  export type CrisisMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisMessage
     */
    select?: CrisisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisMessage
     */
    omit?: CrisisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisMessageInclude<ExtArgs> | null
  }


  /**
   * Model CrisisEscalation
   */

  export type AggregateCrisisEscalation = {
    _count: CrisisEscalationCountAggregateOutputType | null
    _avg: CrisisEscalationAvgAggregateOutputType | null
    _sum: CrisisEscalationSumAggregateOutputType | null
    _min: CrisisEscalationMinAggregateOutputType | null
    _max: CrisisEscalationMaxAggregateOutputType | null
  }

  export type CrisisEscalationAvgAggregateOutputType = {
    responseTime: number | null
  }

  export type CrisisEscalationSumAggregateOutputType = {
    responseTime: number | null
  }

  export type CrisisEscalationMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    triggeredBy: $Enums.EscalationTrigger | null
    severity: $Enums.EscalationSeverity | null
    reason: string | null
    actionsTaken: string | null
    emergencyContacted: boolean | null
    lifeline988Called: boolean | null
    triggeredAt: Date | null
    resolvedAt: Date | null
    responseTime: number | null
    handledBy: string | null
    outcome: $Enums.EscalationOutcome | null
  }

  export type CrisisEscalationMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    triggeredBy: $Enums.EscalationTrigger | null
    severity: $Enums.EscalationSeverity | null
    reason: string | null
    actionsTaken: string | null
    emergencyContacted: boolean | null
    lifeline988Called: boolean | null
    triggeredAt: Date | null
    resolvedAt: Date | null
    responseTime: number | null
    handledBy: string | null
    outcome: $Enums.EscalationOutcome | null
  }

  export type CrisisEscalationCountAggregateOutputType = {
    id: number
    sessionId: number
    triggeredBy: number
    severity: number
    reason: number
    actionsTaken: number
    emergencyContacted: number
    lifeline988Called: number
    triggeredAt: number
    resolvedAt: number
    responseTime: number
    handledBy: number
    outcome: number
    _all: number
  }


  export type CrisisEscalationAvgAggregateInputType = {
    responseTime?: true
  }

  export type CrisisEscalationSumAggregateInputType = {
    responseTime?: true
  }

  export type CrisisEscalationMinAggregateInputType = {
    id?: true
    sessionId?: true
    triggeredBy?: true
    severity?: true
    reason?: true
    actionsTaken?: true
    emergencyContacted?: true
    lifeline988Called?: true
    triggeredAt?: true
    resolvedAt?: true
    responseTime?: true
    handledBy?: true
    outcome?: true
  }

  export type CrisisEscalationMaxAggregateInputType = {
    id?: true
    sessionId?: true
    triggeredBy?: true
    severity?: true
    reason?: true
    actionsTaken?: true
    emergencyContacted?: true
    lifeline988Called?: true
    triggeredAt?: true
    resolvedAt?: true
    responseTime?: true
    handledBy?: true
    outcome?: true
  }

  export type CrisisEscalationCountAggregateInputType = {
    id?: true
    sessionId?: true
    triggeredBy?: true
    severity?: true
    reason?: true
    actionsTaken?: true
    emergencyContacted?: true
    lifeline988Called?: true
    triggeredAt?: true
    resolvedAt?: true
    responseTime?: true
    handledBy?: true
    outcome?: true
    _all?: true
  }

  export type CrisisEscalationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrisisEscalation to aggregate.
     */
    where?: CrisisEscalationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisEscalations to fetch.
     */
    orderBy?: CrisisEscalationOrderByWithRelationInput | CrisisEscalationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrisisEscalationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisEscalations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisEscalations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrisisEscalations
    **/
    _count?: true | CrisisEscalationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrisisEscalationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrisisEscalationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrisisEscalationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrisisEscalationMaxAggregateInputType
  }

  export type GetCrisisEscalationAggregateType<T extends CrisisEscalationAggregateArgs> = {
        [P in keyof T & keyof AggregateCrisisEscalation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrisisEscalation[P]>
      : GetScalarType<T[P], AggregateCrisisEscalation[P]>
  }




  export type CrisisEscalationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrisisEscalationWhereInput
    orderBy?: CrisisEscalationOrderByWithAggregationInput | CrisisEscalationOrderByWithAggregationInput[]
    by: CrisisEscalationScalarFieldEnum[] | CrisisEscalationScalarFieldEnum
    having?: CrisisEscalationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrisisEscalationCountAggregateInputType | true
    _avg?: CrisisEscalationAvgAggregateInputType
    _sum?: CrisisEscalationSumAggregateInputType
    _min?: CrisisEscalationMinAggregateInputType
    _max?: CrisisEscalationMaxAggregateInputType
  }

  export type CrisisEscalationGroupByOutputType = {
    id: string
    sessionId: string
    triggeredBy: $Enums.EscalationTrigger
    severity: $Enums.EscalationSeverity
    reason: string
    actionsTaken: string | null
    emergencyContacted: boolean
    lifeline988Called: boolean
    triggeredAt: Date
    resolvedAt: Date | null
    responseTime: number | null
    handledBy: string | null
    outcome: $Enums.EscalationOutcome | null
    _count: CrisisEscalationCountAggregateOutputType | null
    _avg: CrisisEscalationAvgAggregateOutputType | null
    _sum: CrisisEscalationSumAggregateOutputType | null
    _min: CrisisEscalationMinAggregateOutputType | null
    _max: CrisisEscalationMaxAggregateOutputType | null
  }

  type GetCrisisEscalationGroupByPayload<T extends CrisisEscalationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrisisEscalationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrisisEscalationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrisisEscalationGroupByOutputType[P]>
            : GetScalarType<T[P], CrisisEscalationGroupByOutputType[P]>
        }
      >
    >


  export type CrisisEscalationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    triggeredBy?: boolean
    severity?: boolean
    reason?: boolean
    actionsTaken?: boolean
    emergencyContacted?: boolean
    lifeline988Called?: boolean
    triggeredAt?: boolean
    resolvedAt?: boolean
    responseTime?: boolean
    handledBy?: boolean
    outcome?: boolean
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crisisEscalation"]>

  export type CrisisEscalationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    triggeredBy?: boolean
    severity?: boolean
    reason?: boolean
    actionsTaken?: boolean
    emergencyContacted?: boolean
    lifeline988Called?: boolean
    triggeredAt?: boolean
    resolvedAt?: boolean
    responseTime?: boolean
    handledBy?: boolean
    outcome?: boolean
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crisisEscalation"]>

  export type CrisisEscalationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    triggeredBy?: boolean
    severity?: boolean
    reason?: boolean
    actionsTaken?: boolean
    emergencyContacted?: boolean
    lifeline988Called?: boolean
    triggeredAt?: boolean
    resolvedAt?: boolean
    responseTime?: boolean
    handledBy?: boolean
    outcome?: boolean
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crisisEscalation"]>

  export type CrisisEscalationSelectScalar = {
    id?: boolean
    sessionId?: boolean
    triggeredBy?: boolean
    severity?: boolean
    reason?: boolean
    actionsTaken?: boolean
    emergencyContacted?: boolean
    lifeline988Called?: boolean
    triggeredAt?: boolean
    resolvedAt?: boolean
    responseTime?: boolean
    handledBy?: boolean
    outcome?: boolean
  }

  export type CrisisEscalationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "triggeredBy" | "severity" | "reason" | "actionsTaken" | "emergencyContacted" | "lifeline988Called" | "triggeredAt" | "resolvedAt" | "responseTime" | "handledBy" | "outcome", ExtArgs["result"]["crisisEscalation"]>
  export type CrisisEscalationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }
  export type CrisisEscalationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }
  export type CrisisEscalationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }

  export type $CrisisEscalationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrisisEscalation"
    objects: {
      session: Prisma.$CrisisSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      triggeredBy: $Enums.EscalationTrigger
      severity: $Enums.EscalationSeverity
      reason: string
      actionsTaken: string | null
      emergencyContacted: boolean
      lifeline988Called: boolean
      triggeredAt: Date
      resolvedAt: Date | null
      responseTime: number | null
      handledBy: string | null
      outcome: $Enums.EscalationOutcome | null
    }, ExtArgs["result"]["crisisEscalation"]>
    composites: {}
  }

  type CrisisEscalationGetPayload<S extends boolean | null | undefined | CrisisEscalationDefaultArgs> = $Result.GetResult<Prisma.$CrisisEscalationPayload, S>

  type CrisisEscalationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CrisisEscalationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: CrisisEscalationCountAggregateInputType | true
    }

  export interface CrisisEscalationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrisisEscalation'], meta: { name: 'CrisisEscalation' } }
    /**
     * Find zero or one CrisisEscalation that matches the filter.
     * @param {CrisisEscalationFindUniqueArgs} args - Arguments to find a CrisisEscalation
     * @example
     * // Get one CrisisEscalation
     * const crisisEscalation = await prisma.crisisEscalation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrisisEscalationFindUniqueArgs>(args: SelectSubset<T, CrisisEscalationFindUniqueArgs<ExtArgs>>): Prisma__CrisisEscalationClient<$Result.GetResult<Prisma.$CrisisEscalationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CrisisEscalation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CrisisEscalationFindUniqueOrThrowArgs} args - Arguments to find a CrisisEscalation
     * @example
     * // Get one CrisisEscalation
     * const crisisEscalation = await prisma.crisisEscalation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrisisEscalationFindUniqueOrThrowArgs>(args: SelectSubset<T, CrisisEscalationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrisisEscalationClient<$Result.GetResult<Prisma.$CrisisEscalationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrisisEscalation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisEscalationFindFirstArgs} args - Arguments to find a CrisisEscalation
     * @example
     * // Get one CrisisEscalation
     * const crisisEscalation = await prisma.crisisEscalation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrisisEscalationFindFirstArgs>(args?: SelectSubset<T, CrisisEscalationFindFirstArgs<ExtArgs>>): Prisma__CrisisEscalationClient<$Result.GetResult<Prisma.$CrisisEscalationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrisisEscalation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisEscalationFindFirstOrThrowArgs} args - Arguments to find a CrisisEscalation
     * @example
     * // Get one CrisisEscalation
     * const crisisEscalation = await prisma.crisisEscalation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrisisEscalationFindFirstOrThrowArgs>(args?: SelectSubset<T, CrisisEscalationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrisisEscalationClient<$Result.GetResult<Prisma.$CrisisEscalationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CrisisEscalations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisEscalationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrisisEscalations
     * const crisisEscalations = await prisma.crisisEscalation.findMany()
     * 
     * // Get first 10 CrisisEscalations
     * const crisisEscalations = await prisma.crisisEscalation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crisisEscalationWithIdOnly = await prisma.crisisEscalation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrisisEscalationFindManyArgs>(args?: SelectSubset<T, CrisisEscalationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisEscalationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CrisisEscalation.
     * @param {CrisisEscalationCreateArgs} args - Arguments to create a CrisisEscalation.
     * @example
     * // Create one CrisisEscalation
     * const CrisisEscalation = await prisma.crisisEscalation.create({
     *   data: {
     *     // ... data to create a CrisisEscalation
     *   }
     * })
     * 
     */
    create<T extends CrisisEscalationCreateArgs>(args: SelectSubset<T, CrisisEscalationCreateArgs<ExtArgs>>): Prisma__CrisisEscalationClient<$Result.GetResult<Prisma.$CrisisEscalationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CrisisEscalations.
     * @param {CrisisEscalationCreateManyArgs} args - Arguments to create many CrisisEscalations.
     * @example
     * // Create many CrisisEscalations
     * const crisisEscalation = await prisma.crisisEscalation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrisisEscalationCreateManyArgs>(args?: SelectSubset<T, CrisisEscalationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrisisEscalations and returns the data saved in the database.
     * @param {CrisisEscalationCreateManyAndReturnArgs} args - Arguments to create many CrisisEscalations.
     * @example
     * // Create many CrisisEscalations
     * const crisisEscalation = await prisma.crisisEscalation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrisisEscalations and only return the `id`
     * const crisisEscalationWithIdOnly = await prisma.crisisEscalation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrisisEscalationCreateManyAndReturnArgs>(args?: SelectSubset<T, CrisisEscalationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisEscalationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CrisisEscalation.
     * @param {CrisisEscalationDeleteArgs} args - Arguments to delete one CrisisEscalation.
     * @example
     * // Delete one CrisisEscalation
     * const CrisisEscalation = await prisma.crisisEscalation.delete({
     *   where: {
     *     // ... filter to delete one CrisisEscalation
     *   }
     * })
     * 
     */
    delete<T extends CrisisEscalationDeleteArgs>(args: SelectSubset<T, CrisisEscalationDeleteArgs<ExtArgs>>): Prisma__CrisisEscalationClient<$Result.GetResult<Prisma.$CrisisEscalationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CrisisEscalation.
     * @param {CrisisEscalationUpdateArgs} args - Arguments to update one CrisisEscalation.
     * @example
     * // Update one CrisisEscalation
     * const crisisEscalation = await prisma.crisisEscalation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrisisEscalationUpdateArgs>(args: SelectSubset<T, CrisisEscalationUpdateArgs<ExtArgs>>): Prisma__CrisisEscalationClient<$Result.GetResult<Prisma.$CrisisEscalationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CrisisEscalations.
     * @param {CrisisEscalationDeleteManyArgs} args - Arguments to filter CrisisEscalations to delete.
     * @example
     * // Delete a few CrisisEscalations
     * const { count } = await prisma.crisisEscalation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrisisEscalationDeleteManyArgs>(args?: SelectSubset<T, CrisisEscalationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrisisEscalations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisEscalationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrisisEscalations
     * const crisisEscalation = await prisma.crisisEscalation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrisisEscalationUpdateManyArgs>(args: SelectSubset<T, CrisisEscalationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrisisEscalations and returns the data updated in the database.
     * @param {CrisisEscalationUpdateManyAndReturnArgs} args - Arguments to update many CrisisEscalations.
     * @example
     * // Update many CrisisEscalations
     * const crisisEscalation = await prisma.crisisEscalation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CrisisEscalations and only return the `id`
     * const crisisEscalationWithIdOnly = await prisma.crisisEscalation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CrisisEscalationUpdateManyAndReturnArgs>(args: SelectSubset<T, CrisisEscalationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisEscalationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CrisisEscalation.
     * @param {CrisisEscalationUpsertArgs} args - Arguments to update or create a CrisisEscalation.
     * @example
     * // Update or create a CrisisEscalation
     * const crisisEscalation = await prisma.crisisEscalation.upsert({
     *   create: {
     *     // ... data to create a CrisisEscalation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrisisEscalation we want to update
     *   }
     * })
     */
    upsert<T extends CrisisEscalationUpsertArgs>(args: SelectSubset<T, CrisisEscalationUpsertArgs<ExtArgs>>): Prisma__CrisisEscalationClient<$Result.GetResult<Prisma.$CrisisEscalationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CrisisEscalations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisEscalationCountArgs} args - Arguments to filter CrisisEscalations to count.
     * @example
     * // Count the number of CrisisEscalations
     * const count = await prisma.crisisEscalation.count({
     *   where: {
     *     // ... the filter for the CrisisEscalations we want to count
     *   }
     * })
    **/
    count<T extends CrisisEscalationCountArgs>(
      args?: Subset<T, CrisisEscalationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrisisEscalationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrisisEscalation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisEscalationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrisisEscalationAggregateArgs>(args: Subset<T, CrisisEscalationAggregateArgs>): Prisma.PrismaPromise<GetCrisisEscalationAggregateType<T>>

    /**
     * Group by CrisisEscalation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisEscalationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrisisEscalationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrisisEscalationGroupByArgs['orderBy'] }
        : { orderBy?: CrisisEscalationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrisisEscalationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrisisEscalationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrisisEscalation model
   */
  readonly fields: CrisisEscalationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrisisEscalation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrisisEscalationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends CrisisSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CrisisSessionDefaultArgs<ExtArgs>>): Prisma__CrisisSessionClient<$Result.GetResult<Prisma.$CrisisSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrisisEscalation model
   */
  interface CrisisEscalationFieldRefs {
    readonly id: FieldRef<"CrisisEscalation", 'String'>
    readonly sessionId: FieldRef<"CrisisEscalation", 'String'>
    readonly triggeredBy: FieldRef<"CrisisEscalation", 'EscalationTrigger'>
    readonly severity: FieldRef<"CrisisEscalation", 'EscalationSeverity'>
    readonly reason: FieldRef<"CrisisEscalation", 'String'>
    readonly actionsTaken: FieldRef<"CrisisEscalation", 'String'>
    readonly emergencyContacted: FieldRef<"CrisisEscalation", 'Boolean'>
    readonly lifeline988Called: FieldRef<"CrisisEscalation", 'Boolean'>
    readonly triggeredAt: FieldRef<"CrisisEscalation", 'DateTime'>
    readonly resolvedAt: FieldRef<"CrisisEscalation", 'DateTime'>
    readonly responseTime: FieldRef<"CrisisEscalation", 'Int'>
    readonly handledBy: FieldRef<"CrisisEscalation", 'String'>
    readonly outcome: FieldRef<"CrisisEscalation", 'EscalationOutcome'>
  }
    

  // Custom InputTypes
  /**
   * CrisisEscalation findUnique
   */
  export type CrisisEscalationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisEscalation
     */
    select?: CrisisEscalationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisEscalation
     */
    omit?: CrisisEscalationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisEscalationInclude<ExtArgs> | null
    /**
     * Filter, which CrisisEscalation to fetch.
     */
    where: CrisisEscalationWhereUniqueInput
  }

  /**
   * CrisisEscalation findUniqueOrThrow
   */
  export type CrisisEscalationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisEscalation
     */
    select?: CrisisEscalationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisEscalation
     */
    omit?: CrisisEscalationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisEscalationInclude<ExtArgs> | null
    /**
     * Filter, which CrisisEscalation to fetch.
     */
    where: CrisisEscalationWhereUniqueInput
  }

  /**
   * CrisisEscalation findFirst
   */
  export type CrisisEscalationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisEscalation
     */
    select?: CrisisEscalationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisEscalation
     */
    omit?: CrisisEscalationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisEscalationInclude<ExtArgs> | null
    /**
     * Filter, which CrisisEscalation to fetch.
     */
    where?: CrisisEscalationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisEscalations to fetch.
     */
    orderBy?: CrisisEscalationOrderByWithRelationInput | CrisisEscalationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrisisEscalations.
     */
    cursor?: CrisisEscalationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisEscalations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisEscalations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrisisEscalations.
     */
    distinct?: CrisisEscalationScalarFieldEnum | CrisisEscalationScalarFieldEnum[]
  }

  /**
   * CrisisEscalation findFirstOrThrow
   */
  export type CrisisEscalationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisEscalation
     */
    select?: CrisisEscalationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisEscalation
     */
    omit?: CrisisEscalationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisEscalationInclude<ExtArgs> | null
    /**
     * Filter, which CrisisEscalation to fetch.
     */
    where?: CrisisEscalationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisEscalations to fetch.
     */
    orderBy?: CrisisEscalationOrderByWithRelationInput | CrisisEscalationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrisisEscalations.
     */
    cursor?: CrisisEscalationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisEscalations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisEscalations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrisisEscalations.
     */
    distinct?: CrisisEscalationScalarFieldEnum | CrisisEscalationScalarFieldEnum[]
  }

  /**
   * CrisisEscalation findMany
   */
  export type CrisisEscalationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisEscalation
     */
    select?: CrisisEscalationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisEscalation
     */
    omit?: CrisisEscalationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisEscalationInclude<ExtArgs> | null
    /**
     * Filter, which CrisisEscalations to fetch.
     */
    where?: CrisisEscalationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisEscalations to fetch.
     */
    orderBy?: CrisisEscalationOrderByWithRelationInput | CrisisEscalationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrisisEscalations.
     */
    cursor?: CrisisEscalationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisEscalations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisEscalations.
     */
    skip?: number
    distinct?: CrisisEscalationScalarFieldEnum | CrisisEscalationScalarFieldEnum[]
  }

  /**
   * CrisisEscalation create
   */
  export type CrisisEscalationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisEscalation
     */
    select?: CrisisEscalationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisEscalation
     */
    omit?: CrisisEscalationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisEscalationInclude<ExtArgs> | null
    /**
     * The data needed to create a CrisisEscalation.
     */
    data: XOR<CrisisEscalationCreateInput, CrisisEscalationUncheckedCreateInput>
  }

  /**
   * CrisisEscalation createMany
   */
  export type CrisisEscalationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrisisEscalations.
     */
    data: CrisisEscalationCreateManyInput | CrisisEscalationCreateManyInput[]
  }

  /**
   * CrisisEscalation createManyAndReturn
   */
  export type CrisisEscalationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisEscalation
     */
    select?: CrisisEscalationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisEscalation
     */
    omit?: CrisisEscalationOmit<ExtArgs> | null
    /**
     * The data used to create many CrisisEscalations.
     */
    data: CrisisEscalationCreateManyInput | CrisisEscalationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisEscalationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrisisEscalation update
   */
  export type CrisisEscalationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisEscalation
     */
    select?: CrisisEscalationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisEscalation
     */
    omit?: CrisisEscalationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisEscalationInclude<ExtArgs> | null
    /**
     * The data needed to update a CrisisEscalation.
     */
    data: XOR<CrisisEscalationUpdateInput, CrisisEscalationUncheckedUpdateInput>
    /**
     * Choose, which CrisisEscalation to update.
     */
    where: CrisisEscalationWhereUniqueInput
  }

  /**
   * CrisisEscalation updateMany
   */
  export type CrisisEscalationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrisisEscalations.
     */
    data: XOR<CrisisEscalationUpdateManyMutationInput, CrisisEscalationUncheckedUpdateManyInput>
    /**
     * Filter which CrisisEscalations to update
     */
    where?: CrisisEscalationWhereInput
    /**
     * Limit how many CrisisEscalations to update.
     */
    limit?: number
  }

  /**
   * CrisisEscalation updateManyAndReturn
   */
  export type CrisisEscalationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisEscalation
     */
    select?: CrisisEscalationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisEscalation
     */
    omit?: CrisisEscalationOmit<ExtArgs> | null
    /**
     * The data used to update CrisisEscalations.
     */
    data: XOR<CrisisEscalationUpdateManyMutationInput, CrisisEscalationUncheckedUpdateManyInput>
    /**
     * Filter which CrisisEscalations to update
     */
    where?: CrisisEscalationWhereInput
    /**
     * Limit how many CrisisEscalations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisEscalationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrisisEscalation upsert
   */
  export type CrisisEscalationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisEscalation
     */
    select?: CrisisEscalationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisEscalation
     */
    omit?: CrisisEscalationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisEscalationInclude<ExtArgs> | null
    /**
     * The filter to search for the CrisisEscalation to update in case it exists.
     */
    where: CrisisEscalationWhereUniqueInput
    /**
     * In case the CrisisEscalation found by the `where` argument doesn't exist, create a new CrisisEscalation with this data.
     */
    create: XOR<CrisisEscalationCreateInput, CrisisEscalationUncheckedCreateInput>
    /**
     * In case the CrisisEscalation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrisisEscalationUpdateInput, CrisisEscalationUncheckedUpdateInput>
  }

  /**
   * CrisisEscalation delete
   */
  export type CrisisEscalationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisEscalation
     */
    select?: CrisisEscalationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisEscalation
     */
    omit?: CrisisEscalationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisEscalationInclude<ExtArgs> | null
    /**
     * Filter which CrisisEscalation to delete.
     */
    where: CrisisEscalationWhereUniqueInput
  }

  /**
   * CrisisEscalation deleteMany
   */
  export type CrisisEscalationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrisisEscalations to delete
     */
    where?: CrisisEscalationWhereInput
    /**
     * Limit how many CrisisEscalations to delete.
     */
    limit?: number
  }

  /**
   * CrisisEscalation without action
   */
  export type CrisisEscalationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisEscalation
     */
    select?: CrisisEscalationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisEscalation
     */
    omit?: CrisisEscalationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisEscalationInclude<ExtArgs> | null
  }


  /**
   * Model TetherLink
   */

  export type AggregateTetherLink = {
    _count: TetherLinkCountAggregateOutputType | null
    _avg: TetherLinkAvgAggregateOutputType | null
    _sum: TetherLinkSumAggregateOutputType | null
    _min: TetherLinkMinAggregateOutputType | null
    _max: TetherLinkMaxAggregateOutputType | null
  }

  export type TetherLinkAvgAggregateOutputType = {
    strength: number | null
    trustScore: number | null
    pulseInterval: number | null
    missedPulses: number | null
    matchingScore: number | null
  }

  export type TetherLinkSumAggregateOutputType = {
    strength: number | null
    trustScore: number | null
    pulseInterval: number | null
    missedPulses: number | null
    matchingScore: number | null
  }

  export type TetherLinkMinAggregateOutputType = {
    id: string | null
    seekerId: string | null
    supporterId: string | null
    strength: number | null
    trustScore: number | null
    established: Date | null
    lastActivity: Date | null
    pulseInterval: number | null
    lastPulse: Date | null
    missedPulses: number | null
    emergencyActive: boolean | null
    emergencyType: $Enums.EmergencyType | null
    lastEmergency: Date | null
    matchingScore: number | null
    specialties: string | null
    languages: string | null
    timezone: string | null
    dataSharing: $Enums.TetherDataSharing | null
    locationSharing: boolean | null
    emergencyContact: boolean | null
    encryptedMeta: Uint8Array | null
  }

  export type TetherLinkMaxAggregateOutputType = {
    id: string | null
    seekerId: string | null
    supporterId: string | null
    strength: number | null
    trustScore: number | null
    established: Date | null
    lastActivity: Date | null
    pulseInterval: number | null
    lastPulse: Date | null
    missedPulses: number | null
    emergencyActive: boolean | null
    emergencyType: $Enums.EmergencyType | null
    lastEmergency: Date | null
    matchingScore: number | null
    specialties: string | null
    languages: string | null
    timezone: string | null
    dataSharing: $Enums.TetherDataSharing | null
    locationSharing: boolean | null
    emergencyContact: boolean | null
    encryptedMeta: Uint8Array | null
  }

  export type TetherLinkCountAggregateOutputType = {
    id: number
    seekerId: number
    supporterId: number
    strength: number
    trustScore: number
    established: number
    lastActivity: number
    pulseInterval: number
    lastPulse: number
    missedPulses: number
    emergencyActive: number
    emergencyType: number
    lastEmergency: number
    matchingScore: number
    specialties: number
    languages: number
    timezone: number
    dataSharing: number
    locationSharing: number
    emergencyContact: number
    encryptedMeta: number
    _all: number
  }


  export type TetherLinkAvgAggregateInputType = {
    strength?: true
    trustScore?: true
    pulseInterval?: true
    missedPulses?: true
    matchingScore?: true
  }

  export type TetherLinkSumAggregateInputType = {
    strength?: true
    trustScore?: true
    pulseInterval?: true
    missedPulses?: true
    matchingScore?: true
  }

  export type TetherLinkMinAggregateInputType = {
    id?: true
    seekerId?: true
    supporterId?: true
    strength?: true
    trustScore?: true
    established?: true
    lastActivity?: true
    pulseInterval?: true
    lastPulse?: true
    missedPulses?: true
    emergencyActive?: true
    emergencyType?: true
    lastEmergency?: true
    matchingScore?: true
    specialties?: true
    languages?: true
    timezone?: true
    dataSharing?: true
    locationSharing?: true
    emergencyContact?: true
    encryptedMeta?: true
  }

  export type TetherLinkMaxAggregateInputType = {
    id?: true
    seekerId?: true
    supporterId?: true
    strength?: true
    trustScore?: true
    established?: true
    lastActivity?: true
    pulseInterval?: true
    lastPulse?: true
    missedPulses?: true
    emergencyActive?: true
    emergencyType?: true
    lastEmergency?: true
    matchingScore?: true
    specialties?: true
    languages?: true
    timezone?: true
    dataSharing?: true
    locationSharing?: true
    emergencyContact?: true
    encryptedMeta?: true
  }

  export type TetherLinkCountAggregateInputType = {
    id?: true
    seekerId?: true
    supporterId?: true
    strength?: true
    trustScore?: true
    established?: true
    lastActivity?: true
    pulseInterval?: true
    lastPulse?: true
    missedPulses?: true
    emergencyActive?: true
    emergencyType?: true
    lastEmergency?: true
    matchingScore?: true
    specialties?: true
    languages?: true
    timezone?: true
    dataSharing?: true
    locationSharing?: true
    emergencyContact?: true
    encryptedMeta?: true
    _all?: true
  }

  export type TetherLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TetherLink to aggregate.
     */
    where?: TetherLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TetherLinks to fetch.
     */
    orderBy?: TetherLinkOrderByWithRelationInput | TetherLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TetherLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TetherLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TetherLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TetherLinks
    **/
    _count?: true | TetherLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TetherLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TetherLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TetherLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TetherLinkMaxAggregateInputType
  }

  export type GetTetherLinkAggregateType<T extends TetherLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateTetherLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTetherLink[P]>
      : GetScalarType<T[P], AggregateTetherLink[P]>
  }




  export type TetherLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TetherLinkWhereInput
    orderBy?: TetherLinkOrderByWithAggregationInput | TetherLinkOrderByWithAggregationInput[]
    by: TetherLinkScalarFieldEnum[] | TetherLinkScalarFieldEnum
    having?: TetherLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TetherLinkCountAggregateInputType | true
    _avg?: TetherLinkAvgAggregateInputType
    _sum?: TetherLinkSumAggregateInputType
    _min?: TetherLinkMinAggregateInputType
    _max?: TetherLinkMaxAggregateInputType
  }

  export type TetherLinkGroupByOutputType = {
    id: string
    seekerId: string
    supporterId: string
    strength: number
    trustScore: number
    established: Date
    lastActivity: Date
    pulseInterval: number
    lastPulse: Date
    missedPulses: number
    emergencyActive: boolean
    emergencyType: $Enums.EmergencyType | null
    lastEmergency: Date | null
    matchingScore: number | null
    specialties: string | null
    languages: string | null
    timezone: string | null
    dataSharing: $Enums.TetherDataSharing
    locationSharing: boolean
    emergencyContact: boolean
    encryptedMeta: Uint8Array | null
    _count: TetherLinkCountAggregateOutputType | null
    _avg: TetherLinkAvgAggregateOutputType | null
    _sum: TetherLinkSumAggregateOutputType | null
    _min: TetherLinkMinAggregateOutputType | null
    _max: TetherLinkMaxAggregateOutputType | null
  }

  type GetTetherLinkGroupByPayload<T extends TetherLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TetherLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TetherLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TetherLinkGroupByOutputType[P]>
            : GetScalarType<T[P], TetherLinkGroupByOutputType[P]>
        }
      >
    >


  export type TetherLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seekerId?: boolean
    supporterId?: boolean
    strength?: boolean
    trustScore?: boolean
    established?: boolean
    lastActivity?: boolean
    pulseInterval?: boolean
    lastPulse?: boolean
    missedPulses?: boolean
    emergencyActive?: boolean
    emergencyType?: boolean
    lastEmergency?: boolean
    matchingScore?: boolean
    specialties?: boolean
    languages?: boolean
    timezone?: boolean
    dataSharing?: boolean
    locationSharing?: boolean
    emergencyContact?: boolean
    encryptedMeta?: boolean
    pulses?: boolean | TetherLink$pulsesArgs<ExtArgs>
    emergencies?: boolean | TetherLink$emergenciesArgs<ExtArgs>
    _count?: boolean | TetherLinkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tetherLink"]>

  export type TetherLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seekerId?: boolean
    supporterId?: boolean
    strength?: boolean
    trustScore?: boolean
    established?: boolean
    lastActivity?: boolean
    pulseInterval?: boolean
    lastPulse?: boolean
    missedPulses?: boolean
    emergencyActive?: boolean
    emergencyType?: boolean
    lastEmergency?: boolean
    matchingScore?: boolean
    specialties?: boolean
    languages?: boolean
    timezone?: boolean
    dataSharing?: boolean
    locationSharing?: boolean
    emergencyContact?: boolean
    encryptedMeta?: boolean
  }, ExtArgs["result"]["tetherLink"]>

  export type TetherLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seekerId?: boolean
    supporterId?: boolean
    strength?: boolean
    trustScore?: boolean
    established?: boolean
    lastActivity?: boolean
    pulseInterval?: boolean
    lastPulse?: boolean
    missedPulses?: boolean
    emergencyActive?: boolean
    emergencyType?: boolean
    lastEmergency?: boolean
    matchingScore?: boolean
    specialties?: boolean
    languages?: boolean
    timezone?: boolean
    dataSharing?: boolean
    locationSharing?: boolean
    emergencyContact?: boolean
    encryptedMeta?: boolean
  }, ExtArgs["result"]["tetherLink"]>

  export type TetherLinkSelectScalar = {
    id?: boolean
    seekerId?: boolean
    supporterId?: boolean
    strength?: boolean
    trustScore?: boolean
    established?: boolean
    lastActivity?: boolean
    pulseInterval?: boolean
    lastPulse?: boolean
    missedPulses?: boolean
    emergencyActive?: boolean
    emergencyType?: boolean
    lastEmergency?: boolean
    matchingScore?: boolean
    specialties?: boolean
    languages?: boolean
    timezone?: boolean
    dataSharing?: boolean
    locationSharing?: boolean
    emergencyContact?: boolean
    encryptedMeta?: boolean
  }

  export type TetherLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seekerId" | "supporterId" | "strength" | "trustScore" | "established" | "lastActivity" | "pulseInterval" | "lastPulse" | "missedPulses" | "emergencyActive" | "emergencyType" | "lastEmergency" | "matchingScore" | "specialties" | "languages" | "timezone" | "dataSharing" | "locationSharing" | "emergencyContact" | "encryptedMeta", ExtArgs["result"]["tetherLink"]>
  export type TetherLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pulses?: boolean | TetherLink$pulsesArgs<ExtArgs>
    emergencies?: boolean | TetherLink$emergenciesArgs<ExtArgs>
    _count?: boolean | TetherLinkCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TetherLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TetherLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TetherLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TetherLink"
    objects: {
      pulses: Prisma.$TetherPulsePayload<ExtArgs>[]
      emergencies: Prisma.$TetherEmergencyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seekerId: string
      supporterId: string
      strength: number
      trustScore: number
      established: Date
      lastActivity: Date
      pulseInterval: number
      lastPulse: Date
      missedPulses: number
      emergencyActive: boolean
      emergencyType: $Enums.EmergencyType | null
      lastEmergency: Date | null
      matchingScore: number | null
      specialties: string | null
      languages: string | null
      timezone: string | null
      dataSharing: $Enums.TetherDataSharing
      locationSharing: boolean
      emergencyContact: boolean
      encryptedMeta: Uint8Array | null
    }, ExtArgs["result"]["tetherLink"]>
    composites: {}
  }

  type TetherLinkGetPayload<S extends boolean | null | undefined | TetherLinkDefaultArgs> = $Result.GetResult<Prisma.$TetherLinkPayload, S>

  type TetherLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TetherLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: TetherLinkCountAggregateInputType | true
    }

  export interface TetherLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TetherLink'], meta: { name: 'TetherLink' } }
    /**
     * Find zero or one TetherLink that matches the filter.
     * @param {TetherLinkFindUniqueArgs} args - Arguments to find a TetherLink
     * @example
     * // Get one TetherLink
     * const tetherLink = await prisma.tetherLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TetherLinkFindUniqueArgs>(args: SelectSubset<T, TetherLinkFindUniqueArgs<ExtArgs>>): Prisma__TetherLinkClient<$Result.GetResult<Prisma.$TetherLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TetherLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TetherLinkFindUniqueOrThrowArgs} args - Arguments to find a TetherLink
     * @example
     * // Get one TetherLink
     * const tetherLink = await prisma.tetherLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TetherLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, TetherLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TetherLinkClient<$Result.GetResult<Prisma.$TetherLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TetherLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherLinkFindFirstArgs} args - Arguments to find a TetherLink
     * @example
     * // Get one TetherLink
     * const tetherLink = await prisma.tetherLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TetherLinkFindFirstArgs>(args?: SelectSubset<T, TetherLinkFindFirstArgs<ExtArgs>>): Prisma__TetherLinkClient<$Result.GetResult<Prisma.$TetherLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TetherLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherLinkFindFirstOrThrowArgs} args - Arguments to find a TetherLink
     * @example
     * // Get one TetherLink
     * const tetherLink = await prisma.tetherLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TetherLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, TetherLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__TetherLinkClient<$Result.GetResult<Prisma.$TetherLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TetherLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TetherLinks
     * const tetherLinks = await prisma.tetherLink.findMany()
     * 
     * // Get first 10 TetherLinks
     * const tetherLinks = await prisma.tetherLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tetherLinkWithIdOnly = await prisma.tetherLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TetherLinkFindManyArgs>(args?: SelectSubset<T, TetherLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TetherLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TetherLink.
     * @param {TetherLinkCreateArgs} args - Arguments to create a TetherLink.
     * @example
     * // Create one TetherLink
     * const TetherLink = await prisma.tetherLink.create({
     *   data: {
     *     // ... data to create a TetherLink
     *   }
     * })
     * 
     */
    create<T extends TetherLinkCreateArgs>(args: SelectSubset<T, TetherLinkCreateArgs<ExtArgs>>): Prisma__TetherLinkClient<$Result.GetResult<Prisma.$TetherLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TetherLinks.
     * @param {TetherLinkCreateManyArgs} args - Arguments to create many TetherLinks.
     * @example
     * // Create many TetherLinks
     * const tetherLink = await prisma.tetherLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TetherLinkCreateManyArgs>(args?: SelectSubset<T, TetherLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TetherLinks and returns the data saved in the database.
     * @param {TetherLinkCreateManyAndReturnArgs} args - Arguments to create many TetherLinks.
     * @example
     * // Create many TetherLinks
     * const tetherLink = await prisma.tetherLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TetherLinks and only return the `id`
     * const tetherLinkWithIdOnly = await prisma.tetherLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TetherLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, TetherLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TetherLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TetherLink.
     * @param {TetherLinkDeleteArgs} args - Arguments to delete one TetherLink.
     * @example
     * // Delete one TetherLink
     * const TetherLink = await prisma.tetherLink.delete({
     *   where: {
     *     // ... filter to delete one TetherLink
     *   }
     * })
     * 
     */
    delete<T extends TetherLinkDeleteArgs>(args: SelectSubset<T, TetherLinkDeleteArgs<ExtArgs>>): Prisma__TetherLinkClient<$Result.GetResult<Prisma.$TetherLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TetherLink.
     * @param {TetherLinkUpdateArgs} args - Arguments to update one TetherLink.
     * @example
     * // Update one TetherLink
     * const tetherLink = await prisma.tetherLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TetherLinkUpdateArgs>(args: SelectSubset<T, TetherLinkUpdateArgs<ExtArgs>>): Prisma__TetherLinkClient<$Result.GetResult<Prisma.$TetherLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TetherLinks.
     * @param {TetherLinkDeleteManyArgs} args - Arguments to filter TetherLinks to delete.
     * @example
     * // Delete a few TetherLinks
     * const { count } = await prisma.tetherLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TetherLinkDeleteManyArgs>(args?: SelectSubset<T, TetherLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TetherLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TetherLinks
     * const tetherLink = await prisma.tetherLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TetherLinkUpdateManyArgs>(args: SelectSubset<T, TetherLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TetherLinks and returns the data updated in the database.
     * @param {TetherLinkUpdateManyAndReturnArgs} args - Arguments to update many TetherLinks.
     * @example
     * // Update many TetherLinks
     * const tetherLink = await prisma.tetherLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TetherLinks and only return the `id`
     * const tetherLinkWithIdOnly = await prisma.tetherLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TetherLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, TetherLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TetherLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TetherLink.
     * @param {TetherLinkUpsertArgs} args - Arguments to update or create a TetherLink.
     * @example
     * // Update or create a TetherLink
     * const tetherLink = await prisma.tetherLink.upsert({
     *   create: {
     *     // ... data to create a TetherLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TetherLink we want to update
     *   }
     * })
     */
    upsert<T extends TetherLinkUpsertArgs>(args: SelectSubset<T, TetherLinkUpsertArgs<ExtArgs>>): Prisma__TetherLinkClient<$Result.GetResult<Prisma.$TetherLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TetherLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherLinkCountArgs} args - Arguments to filter TetherLinks to count.
     * @example
     * // Count the number of TetherLinks
     * const count = await prisma.tetherLink.count({
     *   where: {
     *     // ... the filter for the TetherLinks we want to count
     *   }
     * })
    **/
    count<T extends TetherLinkCountArgs>(
      args?: Subset<T, TetherLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TetherLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TetherLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TetherLinkAggregateArgs>(args: Subset<T, TetherLinkAggregateArgs>): Prisma.PrismaPromise<GetTetherLinkAggregateType<T>>

    /**
     * Group by TetherLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TetherLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TetherLinkGroupByArgs['orderBy'] }
        : { orderBy?: TetherLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TetherLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTetherLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TetherLink model
   */
  readonly fields: TetherLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TetherLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TetherLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pulses<T extends TetherLink$pulsesArgs<ExtArgs> = {}>(args?: Subset<T, TetherLink$pulsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TetherPulsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emergencies<T extends TetherLink$emergenciesArgs<ExtArgs> = {}>(args?: Subset<T, TetherLink$emergenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TetherEmergencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TetherLink model
   */
  interface TetherLinkFieldRefs {
    readonly id: FieldRef<"TetherLink", 'String'>
    readonly seekerId: FieldRef<"TetherLink", 'String'>
    readonly supporterId: FieldRef<"TetherLink", 'String'>
    readonly strength: FieldRef<"TetherLink", 'Float'>
    readonly trustScore: FieldRef<"TetherLink", 'Float'>
    readonly established: FieldRef<"TetherLink", 'DateTime'>
    readonly lastActivity: FieldRef<"TetherLink", 'DateTime'>
    readonly pulseInterval: FieldRef<"TetherLink", 'Int'>
    readonly lastPulse: FieldRef<"TetherLink", 'DateTime'>
    readonly missedPulses: FieldRef<"TetherLink", 'Int'>
    readonly emergencyActive: FieldRef<"TetherLink", 'Boolean'>
    readonly emergencyType: FieldRef<"TetherLink", 'EmergencyType'>
    readonly lastEmergency: FieldRef<"TetherLink", 'DateTime'>
    readonly matchingScore: FieldRef<"TetherLink", 'Float'>
    readonly specialties: FieldRef<"TetherLink", 'String'>
    readonly languages: FieldRef<"TetherLink", 'String'>
    readonly timezone: FieldRef<"TetherLink", 'String'>
    readonly dataSharing: FieldRef<"TetherLink", 'TetherDataSharing'>
    readonly locationSharing: FieldRef<"TetherLink", 'Boolean'>
    readonly emergencyContact: FieldRef<"TetherLink", 'Boolean'>
    readonly encryptedMeta: FieldRef<"TetherLink", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * TetherLink findUnique
   */
  export type TetherLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherLink
     */
    select?: TetherLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherLink
     */
    omit?: TetherLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherLinkInclude<ExtArgs> | null
    /**
     * Filter, which TetherLink to fetch.
     */
    where: TetherLinkWhereUniqueInput
  }

  /**
   * TetherLink findUniqueOrThrow
   */
  export type TetherLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherLink
     */
    select?: TetherLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherLink
     */
    omit?: TetherLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherLinkInclude<ExtArgs> | null
    /**
     * Filter, which TetherLink to fetch.
     */
    where: TetherLinkWhereUniqueInput
  }

  /**
   * TetherLink findFirst
   */
  export type TetherLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherLink
     */
    select?: TetherLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherLink
     */
    omit?: TetherLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherLinkInclude<ExtArgs> | null
    /**
     * Filter, which TetherLink to fetch.
     */
    where?: TetherLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TetherLinks to fetch.
     */
    orderBy?: TetherLinkOrderByWithRelationInput | TetherLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TetherLinks.
     */
    cursor?: TetherLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TetherLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TetherLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TetherLinks.
     */
    distinct?: TetherLinkScalarFieldEnum | TetherLinkScalarFieldEnum[]
  }

  /**
   * TetherLink findFirstOrThrow
   */
  export type TetherLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherLink
     */
    select?: TetherLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherLink
     */
    omit?: TetherLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherLinkInclude<ExtArgs> | null
    /**
     * Filter, which TetherLink to fetch.
     */
    where?: TetherLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TetherLinks to fetch.
     */
    orderBy?: TetherLinkOrderByWithRelationInput | TetherLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TetherLinks.
     */
    cursor?: TetherLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TetherLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TetherLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TetherLinks.
     */
    distinct?: TetherLinkScalarFieldEnum | TetherLinkScalarFieldEnum[]
  }

  /**
   * TetherLink findMany
   */
  export type TetherLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherLink
     */
    select?: TetherLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherLink
     */
    omit?: TetherLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherLinkInclude<ExtArgs> | null
    /**
     * Filter, which TetherLinks to fetch.
     */
    where?: TetherLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TetherLinks to fetch.
     */
    orderBy?: TetherLinkOrderByWithRelationInput | TetherLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TetherLinks.
     */
    cursor?: TetherLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TetherLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TetherLinks.
     */
    skip?: number
    distinct?: TetherLinkScalarFieldEnum | TetherLinkScalarFieldEnum[]
  }

  /**
   * TetherLink create
   */
  export type TetherLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherLink
     */
    select?: TetherLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherLink
     */
    omit?: TetherLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a TetherLink.
     */
    data: XOR<TetherLinkCreateInput, TetherLinkUncheckedCreateInput>
  }

  /**
   * TetherLink createMany
   */
  export type TetherLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TetherLinks.
     */
    data: TetherLinkCreateManyInput | TetherLinkCreateManyInput[]
  }

  /**
   * TetherLink createManyAndReturn
   */
  export type TetherLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherLink
     */
    select?: TetherLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TetherLink
     */
    omit?: TetherLinkOmit<ExtArgs> | null
    /**
     * The data used to create many TetherLinks.
     */
    data: TetherLinkCreateManyInput | TetherLinkCreateManyInput[]
  }

  /**
   * TetherLink update
   */
  export type TetherLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherLink
     */
    select?: TetherLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherLink
     */
    omit?: TetherLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a TetherLink.
     */
    data: XOR<TetherLinkUpdateInput, TetherLinkUncheckedUpdateInput>
    /**
     * Choose, which TetherLink to update.
     */
    where: TetherLinkWhereUniqueInput
  }

  /**
   * TetherLink updateMany
   */
  export type TetherLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TetherLinks.
     */
    data: XOR<TetherLinkUpdateManyMutationInput, TetherLinkUncheckedUpdateManyInput>
    /**
     * Filter which TetherLinks to update
     */
    where?: TetherLinkWhereInput
    /**
     * Limit how many TetherLinks to update.
     */
    limit?: number
  }

  /**
   * TetherLink updateManyAndReturn
   */
  export type TetherLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherLink
     */
    select?: TetherLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TetherLink
     */
    omit?: TetherLinkOmit<ExtArgs> | null
    /**
     * The data used to update TetherLinks.
     */
    data: XOR<TetherLinkUpdateManyMutationInput, TetherLinkUncheckedUpdateManyInput>
    /**
     * Filter which TetherLinks to update
     */
    where?: TetherLinkWhereInput
    /**
     * Limit how many TetherLinks to update.
     */
    limit?: number
  }

  /**
   * TetherLink upsert
   */
  export type TetherLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherLink
     */
    select?: TetherLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherLink
     */
    omit?: TetherLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the TetherLink to update in case it exists.
     */
    where: TetherLinkWhereUniqueInput
    /**
     * In case the TetherLink found by the `where` argument doesn't exist, create a new TetherLink with this data.
     */
    create: XOR<TetherLinkCreateInput, TetherLinkUncheckedCreateInput>
    /**
     * In case the TetherLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TetherLinkUpdateInput, TetherLinkUncheckedUpdateInput>
  }

  /**
   * TetherLink delete
   */
  export type TetherLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherLink
     */
    select?: TetherLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherLink
     */
    omit?: TetherLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherLinkInclude<ExtArgs> | null
    /**
     * Filter which TetherLink to delete.
     */
    where: TetherLinkWhereUniqueInput
  }

  /**
   * TetherLink deleteMany
   */
  export type TetherLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TetherLinks to delete
     */
    where?: TetherLinkWhereInput
    /**
     * Limit how many TetherLinks to delete.
     */
    limit?: number
  }

  /**
   * TetherLink.pulses
   */
  export type TetherLink$pulsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherPulse
     */
    select?: TetherPulseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherPulse
     */
    omit?: TetherPulseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherPulseInclude<ExtArgs> | null
    where?: TetherPulseWhereInput
    orderBy?: TetherPulseOrderByWithRelationInput | TetherPulseOrderByWithRelationInput[]
    cursor?: TetherPulseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TetherPulseScalarFieldEnum | TetherPulseScalarFieldEnum[]
  }

  /**
   * TetherLink.emergencies
   */
  export type TetherLink$emergenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherEmergency
     */
    select?: TetherEmergencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherEmergency
     */
    omit?: TetherEmergencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherEmergencyInclude<ExtArgs> | null
    where?: TetherEmergencyWhereInput
    orderBy?: TetherEmergencyOrderByWithRelationInput | TetherEmergencyOrderByWithRelationInput[]
    cursor?: TetherEmergencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TetherEmergencyScalarFieldEnum | TetherEmergencyScalarFieldEnum[]
  }

  /**
   * TetherLink without action
   */
  export type TetherLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherLink
     */
    select?: TetherLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherLink
     */
    omit?: TetherLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherLinkInclude<ExtArgs> | null
  }


  /**
   * Model TetherPulse
   */

  export type AggregateTetherPulse = {
    _count: TetherPulseCountAggregateOutputType | null
    _avg: TetherPulseAvgAggregateOutputType | null
    _sum: TetherPulseSumAggregateOutputType | null
    _min: TetherPulseMinAggregateOutputType | null
    _max: TetherPulseMaxAggregateOutputType | null
  }

  export type TetherPulseAvgAggregateOutputType = {
    strength: number | null
    mood: number | null
  }

  export type TetherPulseSumAggregateOutputType = {
    strength: number | null
    mood: number | null
  }

  export type TetherPulseMinAggregateOutputType = {
    id: string | null
    tetherId: string | null
    pulseType: $Enums.PulseType | null
    strength: number | null
    mood: number | null
    status: $Enums.UserStatus | null
    message: string | null
    emergencySignal: boolean | null
    urgencyLevel: $Enums.UrgencyLevel | null
    timestamp: Date | null
    acknowledged: boolean | null
    acknowledgedAt: Date | null
  }

  export type TetherPulseMaxAggregateOutputType = {
    id: string | null
    tetherId: string | null
    pulseType: $Enums.PulseType | null
    strength: number | null
    mood: number | null
    status: $Enums.UserStatus | null
    message: string | null
    emergencySignal: boolean | null
    urgencyLevel: $Enums.UrgencyLevel | null
    timestamp: Date | null
    acknowledged: boolean | null
    acknowledgedAt: Date | null
  }

  export type TetherPulseCountAggregateOutputType = {
    id: number
    tetherId: number
    pulseType: number
    strength: number
    mood: number
    status: number
    message: number
    emergencySignal: number
    urgencyLevel: number
    timestamp: number
    acknowledged: number
    acknowledgedAt: number
    _all: number
  }


  export type TetherPulseAvgAggregateInputType = {
    strength?: true
    mood?: true
  }

  export type TetherPulseSumAggregateInputType = {
    strength?: true
    mood?: true
  }

  export type TetherPulseMinAggregateInputType = {
    id?: true
    tetherId?: true
    pulseType?: true
    strength?: true
    mood?: true
    status?: true
    message?: true
    emergencySignal?: true
    urgencyLevel?: true
    timestamp?: true
    acknowledged?: true
    acknowledgedAt?: true
  }

  export type TetherPulseMaxAggregateInputType = {
    id?: true
    tetherId?: true
    pulseType?: true
    strength?: true
    mood?: true
    status?: true
    message?: true
    emergencySignal?: true
    urgencyLevel?: true
    timestamp?: true
    acknowledged?: true
    acknowledgedAt?: true
  }

  export type TetherPulseCountAggregateInputType = {
    id?: true
    tetherId?: true
    pulseType?: true
    strength?: true
    mood?: true
    status?: true
    message?: true
    emergencySignal?: true
    urgencyLevel?: true
    timestamp?: true
    acknowledged?: true
    acknowledgedAt?: true
    _all?: true
  }

  export type TetherPulseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TetherPulse to aggregate.
     */
    where?: TetherPulseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TetherPulses to fetch.
     */
    orderBy?: TetherPulseOrderByWithRelationInput | TetherPulseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TetherPulseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TetherPulses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TetherPulses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TetherPulses
    **/
    _count?: true | TetherPulseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TetherPulseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TetherPulseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TetherPulseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TetherPulseMaxAggregateInputType
  }

  export type GetTetherPulseAggregateType<T extends TetherPulseAggregateArgs> = {
        [P in keyof T & keyof AggregateTetherPulse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTetherPulse[P]>
      : GetScalarType<T[P], AggregateTetherPulse[P]>
  }




  export type TetherPulseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TetherPulseWhereInput
    orderBy?: TetherPulseOrderByWithAggregationInput | TetherPulseOrderByWithAggregationInput[]
    by: TetherPulseScalarFieldEnum[] | TetherPulseScalarFieldEnum
    having?: TetherPulseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TetherPulseCountAggregateInputType | true
    _avg?: TetherPulseAvgAggregateInputType
    _sum?: TetherPulseSumAggregateInputType
    _min?: TetherPulseMinAggregateInputType
    _max?: TetherPulseMaxAggregateInputType
  }

  export type TetherPulseGroupByOutputType = {
    id: string
    tetherId: string
    pulseType: $Enums.PulseType
    strength: number
    mood: number | null
    status: $Enums.UserStatus
    message: string | null
    emergencySignal: boolean
    urgencyLevel: $Enums.UrgencyLevel
    timestamp: Date
    acknowledged: boolean
    acknowledgedAt: Date | null
    _count: TetherPulseCountAggregateOutputType | null
    _avg: TetherPulseAvgAggregateOutputType | null
    _sum: TetherPulseSumAggregateOutputType | null
    _min: TetherPulseMinAggregateOutputType | null
    _max: TetherPulseMaxAggregateOutputType | null
  }

  type GetTetherPulseGroupByPayload<T extends TetherPulseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TetherPulseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TetherPulseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TetherPulseGroupByOutputType[P]>
            : GetScalarType<T[P], TetherPulseGroupByOutputType[P]>
        }
      >
    >


  export type TetherPulseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tetherId?: boolean
    pulseType?: boolean
    strength?: boolean
    mood?: boolean
    status?: boolean
    message?: boolean
    emergencySignal?: boolean
    urgencyLevel?: boolean
    timestamp?: boolean
    acknowledged?: boolean
    acknowledgedAt?: boolean
    tether?: boolean | TetherLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tetherPulse"]>

  export type TetherPulseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tetherId?: boolean
    pulseType?: boolean
    strength?: boolean
    mood?: boolean
    status?: boolean
    message?: boolean
    emergencySignal?: boolean
    urgencyLevel?: boolean
    timestamp?: boolean
    acknowledged?: boolean
    acknowledgedAt?: boolean
    tether?: boolean | TetherLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tetherPulse"]>

  export type TetherPulseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tetherId?: boolean
    pulseType?: boolean
    strength?: boolean
    mood?: boolean
    status?: boolean
    message?: boolean
    emergencySignal?: boolean
    urgencyLevel?: boolean
    timestamp?: boolean
    acknowledged?: boolean
    acknowledgedAt?: boolean
    tether?: boolean | TetherLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tetherPulse"]>

  export type TetherPulseSelectScalar = {
    id?: boolean
    tetherId?: boolean
    pulseType?: boolean
    strength?: boolean
    mood?: boolean
    status?: boolean
    message?: boolean
    emergencySignal?: boolean
    urgencyLevel?: boolean
    timestamp?: boolean
    acknowledged?: boolean
    acknowledgedAt?: boolean
  }

  export type TetherPulseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tetherId" | "pulseType" | "strength" | "mood" | "status" | "message" | "emergencySignal" | "urgencyLevel" | "timestamp" | "acknowledged" | "acknowledgedAt", ExtArgs["result"]["tetherPulse"]>
  export type TetherPulseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tether?: boolean | TetherLinkDefaultArgs<ExtArgs>
  }
  export type TetherPulseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tether?: boolean | TetherLinkDefaultArgs<ExtArgs>
  }
  export type TetherPulseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tether?: boolean | TetherLinkDefaultArgs<ExtArgs>
  }

  export type $TetherPulsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TetherPulse"
    objects: {
      tether: Prisma.$TetherLinkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tetherId: string
      pulseType: $Enums.PulseType
      strength: number
      mood: number | null
      status: $Enums.UserStatus
      message: string | null
      emergencySignal: boolean
      urgencyLevel: $Enums.UrgencyLevel
      timestamp: Date
      acknowledged: boolean
      acknowledgedAt: Date | null
    }, ExtArgs["result"]["tetherPulse"]>
    composites: {}
  }

  type TetherPulseGetPayload<S extends boolean | null | undefined | TetherPulseDefaultArgs> = $Result.GetResult<Prisma.$TetherPulsePayload, S>

  type TetherPulseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TetherPulseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: TetherPulseCountAggregateInputType | true
    }

  export interface TetherPulseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TetherPulse'], meta: { name: 'TetherPulse' } }
    /**
     * Find zero or one TetherPulse that matches the filter.
     * @param {TetherPulseFindUniqueArgs} args - Arguments to find a TetherPulse
     * @example
     * // Get one TetherPulse
     * const tetherPulse = await prisma.tetherPulse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TetherPulseFindUniqueArgs>(args: SelectSubset<T, TetherPulseFindUniqueArgs<ExtArgs>>): Prisma__TetherPulseClient<$Result.GetResult<Prisma.$TetherPulsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TetherPulse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TetherPulseFindUniqueOrThrowArgs} args - Arguments to find a TetherPulse
     * @example
     * // Get one TetherPulse
     * const tetherPulse = await prisma.tetherPulse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TetherPulseFindUniqueOrThrowArgs>(args: SelectSubset<T, TetherPulseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TetherPulseClient<$Result.GetResult<Prisma.$TetherPulsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TetherPulse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherPulseFindFirstArgs} args - Arguments to find a TetherPulse
     * @example
     * // Get one TetherPulse
     * const tetherPulse = await prisma.tetherPulse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TetherPulseFindFirstArgs>(args?: SelectSubset<T, TetherPulseFindFirstArgs<ExtArgs>>): Prisma__TetherPulseClient<$Result.GetResult<Prisma.$TetherPulsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TetherPulse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherPulseFindFirstOrThrowArgs} args - Arguments to find a TetherPulse
     * @example
     * // Get one TetherPulse
     * const tetherPulse = await prisma.tetherPulse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TetherPulseFindFirstOrThrowArgs>(args?: SelectSubset<T, TetherPulseFindFirstOrThrowArgs<ExtArgs>>): Prisma__TetherPulseClient<$Result.GetResult<Prisma.$TetherPulsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TetherPulses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherPulseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TetherPulses
     * const tetherPulses = await prisma.tetherPulse.findMany()
     * 
     * // Get first 10 TetherPulses
     * const tetherPulses = await prisma.tetherPulse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tetherPulseWithIdOnly = await prisma.tetherPulse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TetherPulseFindManyArgs>(args?: SelectSubset<T, TetherPulseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TetherPulsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TetherPulse.
     * @param {TetherPulseCreateArgs} args - Arguments to create a TetherPulse.
     * @example
     * // Create one TetherPulse
     * const TetherPulse = await prisma.tetherPulse.create({
     *   data: {
     *     // ... data to create a TetherPulse
     *   }
     * })
     * 
     */
    create<T extends TetherPulseCreateArgs>(args: SelectSubset<T, TetherPulseCreateArgs<ExtArgs>>): Prisma__TetherPulseClient<$Result.GetResult<Prisma.$TetherPulsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TetherPulses.
     * @param {TetherPulseCreateManyArgs} args - Arguments to create many TetherPulses.
     * @example
     * // Create many TetherPulses
     * const tetherPulse = await prisma.tetherPulse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TetherPulseCreateManyArgs>(args?: SelectSubset<T, TetherPulseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TetherPulses and returns the data saved in the database.
     * @param {TetherPulseCreateManyAndReturnArgs} args - Arguments to create many TetherPulses.
     * @example
     * // Create many TetherPulses
     * const tetherPulse = await prisma.tetherPulse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TetherPulses and only return the `id`
     * const tetherPulseWithIdOnly = await prisma.tetherPulse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TetherPulseCreateManyAndReturnArgs>(args?: SelectSubset<T, TetherPulseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TetherPulsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TetherPulse.
     * @param {TetherPulseDeleteArgs} args - Arguments to delete one TetherPulse.
     * @example
     * // Delete one TetherPulse
     * const TetherPulse = await prisma.tetherPulse.delete({
     *   where: {
     *     // ... filter to delete one TetherPulse
     *   }
     * })
     * 
     */
    delete<T extends TetherPulseDeleteArgs>(args: SelectSubset<T, TetherPulseDeleteArgs<ExtArgs>>): Prisma__TetherPulseClient<$Result.GetResult<Prisma.$TetherPulsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TetherPulse.
     * @param {TetherPulseUpdateArgs} args - Arguments to update one TetherPulse.
     * @example
     * // Update one TetherPulse
     * const tetherPulse = await prisma.tetherPulse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TetherPulseUpdateArgs>(args: SelectSubset<T, TetherPulseUpdateArgs<ExtArgs>>): Prisma__TetherPulseClient<$Result.GetResult<Prisma.$TetherPulsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TetherPulses.
     * @param {TetherPulseDeleteManyArgs} args - Arguments to filter TetherPulses to delete.
     * @example
     * // Delete a few TetherPulses
     * const { count } = await prisma.tetherPulse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TetherPulseDeleteManyArgs>(args?: SelectSubset<T, TetherPulseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TetherPulses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherPulseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TetherPulses
     * const tetherPulse = await prisma.tetherPulse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TetherPulseUpdateManyArgs>(args: SelectSubset<T, TetherPulseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TetherPulses and returns the data updated in the database.
     * @param {TetherPulseUpdateManyAndReturnArgs} args - Arguments to update many TetherPulses.
     * @example
     * // Update many TetherPulses
     * const tetherPulse = await prisma.tetherPulse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TetherPulses and only return the `id`
     * const tetherPulseWithIdOnly = await prisma.tetherPulse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TetherPulseUpdateManyAndReturnArgs>(args: SelectSubset<T, TetherPulseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TetherPulsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TetherPulse.
     * @param {TetherPulseUpsertArgs} args - Arguments to update or create a TetherPulse.
     * @example
     * // Update or create a TetherPulse
     * const tetherPulse = await prisma.tetherPulse.upsert({
     *   create: {
     *     // ... data to create a TetherPulse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TetherPulse we want to update
     *   }
     * })
     */
    upsert<T extends TetherPulseUpsertArgs>(args: SelectSubset<T, TetherPulseUpsertArgs<ExtArgs>>): Prisma__TetherPulseClient<$Result.GetResult<Prisma.$TetherPulsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TetherPulses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherPulseCountArgs} args - Arguments to filter TetherPulses to count.
     * @example
     * // Count the number of TetherPulses
     * const count = await prisma.tetherPulse.count({
     *   where: {
     *     // ... the filter for the TetherPulses we want to count
     *   }
     * })
    **/
    count<T extends TetherPulseCountArgs>(
      args?: Subset<T, TetherPulseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TetherPulseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TetherPulse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherPulseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TetherPulseAggregateArgs>(args: Subset<T, TetherPulseAggregateArgs>): Prisma.PrismaPromise<GetTetherPulseAggregateType<T>>

    /**
     * Group by TetherPulse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherPulseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TetherPulseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TetherPulseGroupByArgs['orderBy'] }
        : { orderBy?: TetherPulseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TetherPulseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTetherPulseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TetherPulse model
   */
  readonly fields: TetherPulseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TetherPulse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TetherPulseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tether<T extends TetherLinkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TetherLinkDefaultArgs<ExtArgs>>): Prisma__TetherLinkClient<$Result.GetResult<Prisma.$TetherLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TetherPulse model
   */
  interface TetherPulseFieldRefs {
    readonly id: FieldRef<"TetherPulse", 'String'>
    readonly tetherId: FieldRef<"TetherPulse", 'String'>
    readonly pulseType: FieldRef<"TetherPulse", 'PulseType'>
    readonly strength: FieldRef<"TetherPulse", 'Float'>
    readonly mood: FieldRef<"TetherPulse", 'Int'>
    readonly status: FieldRef<"TetherPulse", 'UserStatus'>
    readonly message: FieldRef<"TetherPulse", 'String'>
    readonly emergencySignal: FieldRef<"TetherPulse", 'Boolean'>
    readonly urgencyLevel: FieldRef<"TetherPulse", 'UrgencyLevel'>
    readonly timestamp: FieldRef<"TetherPulse", 'DateTime'>
    readonly acknowledged: FieldRef<"TetherPulse", 'Boolean'>
    readonly acknowledgedAt: FieldRef<"TetherPulse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TetherPulse findUnique
   */
  export type TetherPulseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherPulse
     */
    select?: TetherPulseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherPulse
     */
    omit?: TetherPulseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherPulseInclude<ExtArgs> | null
    /**
     * Filter, which TetherPulse to fetch.
     */
    where: TetherPulseWhereUniqueInput
  }

  /**
   * TetherPulse findUniqueOrThrow
   */
  export type TetherPulseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherPulse
     */
    select?: TetherPulseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherPulse
     */
    omit?: TetherPulseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherPulseInclude<ExtArgs> | null
    /**
     * Filter, which TetherPulse to fetch.
     */
    where: TetherPulseWhereUniqueInput
  }

  /**
   * TetherPulse findFirst
   */
  export type TetherPulseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherPulse
     */
    select?: TetherPulseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherPulse
     */
    omit?: TetherPulseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherPulseInclude<ExtArgs> | null
    /**
     * Filter, which TetherPulse to fetch.
     */
    where?: TetherPulseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TetherPulses to fetch.
     */
    orderBy?: TetherPulseOrderByWithRelationInput | TetherPulseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TetherPulses.
     */
    cursor?: TetherPulseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TetherPulses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TetherPulses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TetherPulses.
     */
    distinct?: TetherPulseScalarFieldEnum | TetherPulseScalarFieldEnum[]
  }

  /**
   * TetherPulse findFirstOrThrow
   */
  export type TetherPulseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherPulse
     */
    select?: TetherPulseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherPulse
     */
    omit?: TetherPulseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherPulseInclude<ExtArgs> | null
    /**
     * Filter, which TetherPulse to fetch.
     */
    where?: TetherPulseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TetherPulses to fetch.
     */
    orderBy?: TetherPulseOrderByWithRelationInput | TetherPulseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TetherPulses.
     */
    cursor?: TetherPulseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TetherPulses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TetherPulses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TetherPulses.
     */
    distinct?: TetherPulseScalarFieldEnum | TetherPulseScalarFieldEnum[]
  }

  /**
   * TetherPulse findMany
   */
  export type TetherPulseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherPulse
     */
    select?: TetherPulseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherPulse
     */
    omit?: TetherPulseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherPulseInclude<ExtArgs> | null
    /**
     * Filter, which TetherPulses to fetch.
     */
    where?: TetherPulseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TetherPulses to fetch.
     */
    orderBy?: TetherPulseOrderByWithRelationInput | TetherPulseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TetherPulses.
     */
    cursor?: TetherPulseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TetherPulses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TetherPulses.
     */
    skip?: number
    distinct?: TetherPulseScalarFieldEnum | TetherPulseScalarFieldEnum[]
  }

  /**
   * TetherPulse create
   */
  export type TetherPulseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherPulse
     */
    select?: TetherPulseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherPulse
     */
    omit?: TetherPulseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherPulseInclude<ExtArgs> | null
    /**
     * The data needed to create a TetherPulse.
     */
    data: XOR<TetherPulseCreateInput, TetherPulseUncheckedCreateInput>
  }

  /**
   * TetherPulse createMany
   */
  export type TetherPulseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TetherPulses.
     */
    data: TetherPulseCreateManyInput | TetherPulseCreateManyInput[]
  }

  /**
   * TetherPulse createManyAndReturn
   */
  export type TetherPulseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherPulse
     */
    select?: TetherPulseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TetherPulse
     */
    omit?: TetherPulseOmit<ExtArgs> | null
    /**
     * The data used to create many TetherPulses.
     */
    data: TetherPulseCreateManyInput | TetherPulseCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherPulseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TetherPulse update
   */
  export type TetherPulseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherPulse
     */
    select?: TetherPulseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherPulse
     */
    omit?: TetherPulseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherPulseInclude<ExtArgs> | null
    /**
     * The data needed to update a TetherPulse.
     */
    data: XOR<TetherPulseUpdateInput, TetherPulseUncheckedUpdateInput>
    /**
     * Choose, which TetherPulse to update.
     */
    where: TetherPulseWhereUniqueInput
  }

  /**
   * TetherPulse updateMany
   */
  export type TetherPulseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TetherPulses.
     */
    data: XOR<TetherPulseUpdateManyMutationInput, TetherPulseUncheckedUpdateManyInput>
    /**
     * Filter which TetherPulses to update
     */
    where?: TetherPulseWhereInput
    /**
     * Limit how many TetherPulses to update.
     */
    limit?: number
  }

  /**
   * TetherPulse updateManyAndReturn
   */
  export type TetherPulseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherPulse
     */
    select?: TetherPulseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TetherPulse
     */
    omit?: TetherPulseOmit<ExtArgs> | null
    /**
     * The data used to update TetherPulses.
     */
    data: XOR<TetherPulseUpdateManyMutationInput, TetherPulseUncheckedUpdateManyInput>
    /**
     * Filter which TetherPulses to update
     */
    where?: TetherPulseWhereInput
    /**
     * Limit how many TetherPulses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherPulseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TetherPulse upsert
   */
  export type TetherPulseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherPulse
     */
    select?: TetherPulseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherPulse
     */
    omit?: TetherPulseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherPulseInclude<ExtArgs> | null
    /**
     * The filter to search for the TetherPulse to update in case it exists.
     */
    where: TetherPulseWhereUniqueInput
    /**
     * In case the TetherPulse found by the `where` argument doesn't exist, create a new TetherPulse with this data.
     */
    create: XOR<TetherPulseCreateInput, TetherPulseUncheckedCreateInput>
    /**
     * In case the TetherPulse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TetherPulseUpdateInput, TetherPulseUncheckedUpdateInput>
  }

  /**
   * TetherPulse delete
   */
  export type TetherPulseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherPulse
     */
    select?: TetherPulseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherPulse
     */
    omit?: TetherPulseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherPulseInclude<ExtArgs> | null
    /**
     * Filter which TetherPulse to delete.
     */
    where: TetherPulseWhereUniqueInput
  }

  /**
   * TetherPulse deleteMany
   */
  export type TetherPulseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TetherPulses to delete
     */
    where?: TetherPulseWhereInput
    /**
     * Limit how many TetherPulses to delete.
     */
    limit?: number
  }

  /**
   * TetherPulse without action
   */
  export type TetherPulseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherPulse
     */
    select?: TetherPulseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherPulse
     */
    omit?: TetherPulseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherPulseInclude<ExtArgs> | null
  }


  /**
   * Model TetherEmergency
   */

  export type AggregateTetherEmergency = {
    _count: TetherEmergencyCountAggregateOutputType | null
    _avg: TetherEmergencyAvgAggregateOutputType | null
    _sum: TetherEmergencySumAggregateOutputType | null
    _min: TetherEmergencyMinAggregateOutputType | null
    _max: TetherEmergencyMaxAggregateOutputType | null
  }

  export type TetherEmergencyAvgAggregateOutputType = {
    responseTime: number | null
  }

  export type TetherEmergencySumAggregateOutputType = {
    responseTime: number | null
  }

  export type TetherEmergencyMinAggregateOutputType = {
    id: string | null
    tetherId: string | null
    triggerUserId: string | null
    emergencyType: $Enums.EmergencyType | null
    severity: $Enums.EmergencySeverity | null
    description: string | null
    triggeredAt: Date | null
    acknowledgedAt: Date | null
    respondedAt: Date | null
    resolvedAt: Date | null
    responseTime: number | null
    actionsTaken: string | null
    outcome: $Enums.EmergencyOutcome | null
    helpersNotified: string | null
    emergencyContacts: string | null
  }

  export type TetherEmergencyMaxAggregateOutputType = {
    id: string | null
    tetherId: string | null
    triggerUserId: string | null
    emergencyType: $Enums.EmergencyType | null
    severity: $Enums.EmergencySeverity | null
    description: string | null
    triggeredAt: Date | null
    acknowledgedAt: Date | null
    respondedAt: Date | null
    resolvedAt: Date | null
    responseTime: number | null
    actionsTaken: string | null
    outcome: $Enums.EmergencyOutcome | null
    helpersNotified: string | null
    emergencyContacts: string | null
  }

  export type TetherEmergencyCountAggregateOutputType = {
    id: number
    tetherId: number
    triggerUserId: number
    emergencyType: number
    severity: number
    description: number
    location: number
    triggeredAt: number
    acknowledgedAt: number
    respondedAt: number
    resolvedAt: number
    responseTime: number
    actionsTaken: number
    outcome: number
    helpersNotified: number
    emergencyContacts: number
    _all: number
  }


  export type TetherEmergencyAvgAggregateInputType = {
    responseTime?: true
  }

  export type TetherEmergencySumAggregateInputType = {
    responseTime?: true
  }

  export type TetherEmergencyMinAggregateInputType = {
    id?: true
    tetherId?: true
    triggerUserId?: true
    emergencyType?: true
    severity?: true
    description?: true
    triggeredAt?: true
    acknowledgedAt?: true
    respondedAt?: true
    resolvedAt?: true
    responseTime?: true
    actionsTaken?: true
    outcome?: true
    helpersNotified?: true
    emergencyContacts?: true
  }

  export type TetherEmergencyMaxAggregateInputType = {
    id?: true
    tetherId?: true
    triggerUserId?: true
    emergencyType?: true
    severity?: true
    description?: true
    triggeredAt?: true
    acknowledgedAt?: true
    respondedAt?: true
    resolvedAt?: true
    responseTime?: true
    actionsTaken?: true
    outcome?: true
    helpersNotified?: true
    emergencyContacts?: true
  }

  export type TetherEmergencyCountAggregateInputType = {
    id?: true
    tetherId?: true
    triggerUserId?: true
    emergencyType?: true
    severity?: true
    description?: true
    location?: true
    triggeredAt?: true
    acknowledgedAt?: true
    respondedAt?: true
    resolvedAt?: true
    responseTime?: true
    actionsTaken?: true
    outcome?: true
    helpersNotified?: true
    emergencyContacts?: true
    _all?: true
  }

  export type TetherEmergencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TetherEmergency to aggregate.
     */
    where?: TetherEmergencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TetherEmergencies to fetch.
     */
    orderBy?: TetherEmergencyOrderByWithRelationInput | TetherEmergencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TetherEmergencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TetherEmergencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TetherEmergencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TetherEmergencies
    **/
    _count?: true | TetherEmergencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TetherEmergencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TetherEmergencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TetherEmergencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TetherEmergencyMaxAggregateInputType
  }

  export type GetTetherEmergencyAggregateType<T extends TetherEmergencyAggregateArgs> = {
        [P in keyof T & keyof AggregateTetherEmergency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTetherEmergency[P]>
      : GetScalarType<T[P], AggregateTetherEmergency[P]>
  }




  export type TetherEmergencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TetherEmergencyWhereInput
    orderBy?: TetherEmergencyOrderByWithAggregationInput | TetherEmergencyOrderByWithAggregationInput[]
    by: TetherEmergencyScalarFieldEnum[] | TetherEmergencyScalarFieldEnum
    having?: TetherEmergencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TetherEmergencyCountAggregateInputType | true
    _avg?: TetherEmergencyAvgAggregateInputType
    _sum?: TetherEmergencySumAggregateInputType
    _min?: TetherEmergencyMinAggregateInputType
    _max?: TetherEmergencyMaxAggregateInputType
  }

  export type TetherEmergencyGroupByOutputType = {
    id: string
    tetherId: string
    triggerUserId: string
    emergencyType: $Enums.EmergencyType
    severity: $Enums.EmergencySeverity
    description: string
    location: JsonValue | null
    triggeredAt: Date
    acknowledgedAt: Date | null
    respondedAt: Date | null
    resolvedAt: Date | null
    responseTime: number | null
    actionsTaken: string | null
    outcome: $Enums.EmergencyOutcome | null
    helpersNotified: string | null
    emergencyContacts: string | null
    _count: TetherEmergencyCountAggregateOutputType | null
    _avg: TetherEmergencyAvgAggregateOutputType | null
    _sum: TetherEmergencySumAggregateOutputType | null
    _min: TetherEmergencyMinAggregateOutputType | null
    _max: TetherEmergencyMaxAggregateOutputType | null
  }

  type GetTetherEmergencyGroupByPayload<T extends TetherEmergencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TetherEmergencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TetherEmergencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TetherEmergencyGroupByOutputType[P]>
            : GetScalarType<T[P], TetherEmergencyGroupByOutputType[P]>
        }
      >
    >


  export type TetherEmergencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tetherId?: boolean
    triggerUserId?: boolean
    emergencyType?: boolean
    severity?: boolean
    description?: boolean
    location?: boolean
    triggeredAt?: boolean
    acknowledgedAt?: boolean
    respondedAt?: boolean
    resolvedAt?: boolean
    responseTime?: boolean
    actionsTaken?: boolean
    outcome?: boolean
    helpersNotified?: boolean
    emergencyContacts?: boolean
    tether?: boolean | TetherLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tetherEmergency"]>

  export type TetherEmergencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tetherId?: boolean
    triggerUserId?: boolean
    emergencyType?: boolean
    severity?: boolean
    description?: boolean
    location?: boolean
    triggeredAt?: boolean
    acknowledgedAt?: boolean
    respondedAt?: boolean
    resolvedAt?: boolean
    responseTime?: boolean
    actionsTaken?: boolean
    outcome?: boolean
    helpersNotified?: boolean
    emergencyContacts?: boolean
    tether?: boolean | TetherLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tetherEmergency"]>

  export type TetherEmergencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tetherId?: boolean
    triggerUserId?: boolean
    emergencyType?: boolean
    severity?: boolean
    description?: boolean
    location?: boolean
    triggeredAt?: boolean
    acknowledgedAt?: boolean
    respondedAt?: boolean
    resolvedAt?: boolean
    responseTime?: boolean
    actionsTaken?: boolean
    outcome?: boolean
    helpersNotified?: boolean
    emergencyContacts?: boolean
    tether?: boolean | TetherLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tetherEmergency"]>

  export type TetherEmergencySelectScalar = {
    id?: boolean
    tetherId?: boolean
    triggerUserId?: boolean
    emergencyType?: boolean
    severity?: boolean
    description?: boolean
    location?: boolean
    triggeredAt?: boolean
    acknowledgedAt?: boolean
    respondedAt?: boolean
    resolvedAt?: boolean
    responseTime?: boolean
    actionsTaken?: boolean
    outcome?: boolean
    helpersNotified?: boolean
    emergencyContacts?: boolean
  }

  export type TetherEmergencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tetherId" | "triggerUserId" | "emergencyType" | "severity" | "description" | "location" | "triggeredAt" | "acknowledgedAt" | "respondedAt" | "resolvedAt" | "responseTime" | "actionsTaken" | "outcome" | "helpersNotified" | "emergencyContacts", ExtArgs["result"]["tetherEmergency"]>
  export type TetherEmergencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tether?: boolean | TetherLinkDefaultArgs<ExtArgs>
  }
  export type TetherEmergencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tether?: boolean | TetherLinkDefaultArgs<ExtArgs>
  }
  export type TetherEmergencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tether?: boolean | TetherLinkDefaultArgs<ExtArgs>
  }

  export type $TetherEmergencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TetherEmergency"
    objects: {
      tether: Prisma.$TetherLinkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tetherId: string
      triggerUserId: string
      emergencyType: $Enums.EmergencyType
      severity: $Enums.EmergencySeverity
      description: string
      location: Prisma.JsonValue | null
      triggeredAt: Date
      acknowledgedAt: Date | null
      respondedAt: Date | null
      resolvedAt: Date | null
      responseTime: number | null
      actionsTaken: string | null
      outcome: $Enums.EmergencyOutcome | null
      helpersNotified: string | null
      emergencyContacts: string | null
    }, ExtArgs["result"]["tetherEmergency"]>
    composites: {}
  }

  type TetherEmergencyGetPayload<S extends boolean | null | undefined | TetherEmergencyDefaultArgs> = $Result.GetResult<Prisma.$TetherEmergencyPayload, S>

  type TetherEmergencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TetherEmergencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: TetherEmergencyCountAggregateInputType | true
    }

  export interface TetherEmergencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TetherEmergency'], meta: { name: 'TetherEmergency' } }
    /**
     * Find zero or one TetherEmergency that matches the filter.
     * @param {TetherEmergencyFindUniqueArgs} args - Arguments to find a TetherEmergency
     * @example
     * // Get one TetherEmergency
     * const tetherEmergency = await prisma.tetherEmergency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TetherEmergencyFindUniqueArgs>(args: SelectSubset<T, TetherEmergencyFindUniqueArgs<ExtArgs>>): Prisma__TetherEmergencyClient<$Result.GetResult<Prisma.$TetherEmergencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TetherEmergency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TetherEmergencyFindUniqueOrThrowArgs} args - Arguments to find a TetherEmergency
     * @example
     * // Get one TetherEmergency
     * const tetherEmergency = await prisma.tetherEmergency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TetherEmergencyFindUniqueOrThrowArgs>(args: SelectSubset<T, TetherEmergencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TetherEmergencyClient<$Result.GetResult<Prisma.$TetherEmergencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TetherEmergency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherEmergencyFindFirstArgs} args - Arguments to find a TetherEmergency
     * @example
     * // Get one TetherEmergency
     * const tetherEmergency = await prisma.tetherEmergency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TetherEmergencyFindFirstArgs>(args?: SelectSubset<T, TetherEmergencyFindFirstArgs<ExtArgs>>): Prisma__TetherEmergencyClient<$Result.GetResult<Prisma.$TetherEmergencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TetherEmergency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherEmergencyFindFirstOrThrowArgs} args - Arguments to find a TetherEmergency
     * @example
     * // Get one TetherEmergency
     * const tetherEmergency = await prisma.tetherEmergency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TetherEmergencyFindFirstOrThrowArgs>(args?: SelectSubset<T, TetherEmergencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__TetherEmergencyClient<$Result.GetResult<Prisma.$TetherEmergencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TetherEmergencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherEmergencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TetherEmergencies
     * const tetherEmergencies = await prisma.tetherEmergency.findMany()
     * 
     * // Get first 10 TetherEmergencies
     * const tetherEmergencies = await prisma.tetherEmergency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tetherEmergencyWithIdOnly = await prisma.tetherEmergency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TetherEmergencyFindManyArgs>(args?: SelectSubset<T, TetherEmergencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TetherEmergencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TetherEmergency.
     * @param {TetherEmergencyCreateArgs} args - Arguments to create a TetherEmergency.
     * @example
     * // Create one TetherEmergency
     * const TetherEmergency = await prisma.tetherEmergency.create({
     *   data: {
     *     // ... data to create a TetherEmergency
     *   }
     * })
     * 
     */
    create<T extends TetherEmergencyCreateArgs>(args: SelectSubset<T, TetherEmergencyCreateArgs<ExtArgs>>): Prisma__TetherEmergencyClient<$Result.GetResult<Prisma.$TetherEmergencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TetherEmergencies.
     * @param {TetherEmergencyCreateManyArgs} args - Arguments to create many TetherEmergencies.
     * @example
     * // Create many TetherEmergencies
     * const tetherEmergency = await prisma.tetherEmergency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TetherEmergencyCreateManyArgs>(args?: SelectSubset<T, TetherEmergencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TetherEmergencies and returns the data saved in the database.
     * @param {TetherEmergencyCreateManyAndReturnArgs} args - Arguments to create many TetherEmergencies.
     * @example
     * // Create many TetherEmergencies
     * const tetherEmergency = await prisma.tetherEmergency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TetherEmergencies and only return the `id`
     * const tetherEmergencyWithIdOnly = await prisma.tetherEmergency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TetherEmergencyCreateManyAndReturnArgs>(args?: SelectSubset<T, TetherEmergencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TetherEmergencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TetherEmergency.
     * @param {TetherEmergencyDeleteArgs} args - Arguments to delete one TetherEmergency.
     * @example
     * // Delete one TetherEmergency
     * const TetherEmergency = await prisma.tetherEmergency.delete({
     *   where: {
     *     // ... filter to delete one TetherEmergency
     *   }
     * })
     * 
     */
    delete<T extends TetherEmergencyDeleteArgs>(args: SelectSubset<T, TetherEmergencyDeleteArgs<ExtArgs>>): Prisma__TetherEmergencyClient<$Result.GetResult<Prisma.$TetherEmergencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TetherEmergency.
     * @param {TetherEmergencyUpdateArgs} args - Arguments to update one TetherEmergency.
     * @example
     * // Update one TetherEmergency
     * const tetherEmergency = await prisma.tetherEmergency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TetherEmergencyUpdateArgs>(args: SelectSubset<T, TetherEmergencyUpdateArgs<ExtArgs>>): Prisma__TetherEmergencyClient<$Result.GetResult<Prisma.$TetherEmergencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TetherEmergencies.
     * @param {TetherEmergencyDeleteManyArgs} args - Arguments to filter TetherEmergencies to delete.
     * @example
     * // Delete a few TetherEmergencies
     * const { count } = await prisma.tetherEmergency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TetherEmergencyDeleteManyArgs>(args?: SelectSubset<T, TetherEmergencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TetherEmergencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherEmergencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TetherEmergencies
     * const tetherEmergency = await prisma.tetherEmergency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TetherEmergencyUpdateManyArgs>(args: SelectSubset<T, TetherEmergencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TetherEmergencies and returns the data updated in the database.
     * @param {TetherEmergencyUpdateManyAndReturnArgs} args - Arguments to update many TetherEmergencies.
     * @example
     * // Update many TetherEmergencies
     * const tetherEmergency = await prisma.tetherEmergency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TetherEmergencies and only return the `id`
     * const tetherEmergencyWithIdOnly = await prisma.tetherEmergency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TetherEmergencyUpdateManyAndReturnArgs>(args: SelectSubset<T, TetherEmergencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TetherEmergencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TetherEmergency.
     * @param {TetherEmergencyUpsertArgs} args - Arguments to update or create a TetherEmergency.
     * @example
     * // Update or create a TetherEmergency
     * const tetherEmergency = await prisma.tetherEmergency.upsert({
     *   create: {
     *     // ... data to create a TetherEmergency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TetherEmergency we want to update
     *   }
     * })
     */
    upsert<T extends TetherEmergencyUpsertArgs>(args: SelectSubset<T, TetherEmergencyUpsertArgs<ExtArgs>>): Prisma__TetherEmergencyClient<$Result.GetResult<Prisma.$TetherEmergencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TetherEmergencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherEmergencyCountArgs} args - Arguments to filter TetherEmergencies to count.
     * @example
     * // Count the number of TetherEmergencies
     * const count = await prisma.tetherEmergency.count({
     *   where: {
     *     // ... the filter for the TetherEmergencies we want to count
     *   }
     * })
    **/
    count<T extends TetherEmergencyCountArgs>(
      args?: Subset<T, TetherEmergencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TetherEmergencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TetherEmergency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherEmergencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TetherEmergencyAggregateArgs>(args: Subset<T, TetherEmergencyAggregateArgs>): Prisma.PrismaPromise<GetTetherEmergencyAggregateType<T>>

    /**
     * Group by TetherEmergency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TetherEmergencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TetherEmergencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TetherEmergencyGroupByArgs['orderBy'] }
        : { orderBy?: TetherEmergencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TetherEmergencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTetherEmergencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TetherEmergency model
   */
  readonly fields: TetherEmergencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TetherEmergency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TetherEmergencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tether<T extends TetherLinkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TetherLinkDefaultArgs<ExtArgs>>): Prisma__TetherLinkClient<$Result.GetResult<Prisma.$TetherLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TetherEmergency model
   */
  interface TetherEmergencyFieldRefs {
    readonly id: FieldRef<"TetherEmergency", 'String'>
    readonly tetherId: FieldRef<"TetherEmergency", 'String'>
    readonly triggerUserId: FieldRef<"TetherEmergency", 'String'>
    readonly emergencyType: FieldRef<"TetherEmergency", 'EmergencyType'>
    readonly severity: FieldRef<"TetherEmergency", 'EmergencySeverity'>
    readonly description: FieldRef<"TetherEmergency", 'String'>
    readonly location: FieldRef<"TetherEmergency", 'Json'>
    readonly triggeredAt: FieldRef<"TetherEmergency", 'DateTime'>
    readonly acknowledgedAt: FieldRef<"TetherEmergency", 'DateTime'>
    readonly respondedAt: FieldRef<"TetherEmergency", 'DateTime'>
    readonly resolvedAt: FieldRef<"TetherEmergency", 'DateTime'>
    readonly responseTime: FieldRef<"TetherEmergency", 'Int'>
    readonly actionsTaken: FieldRef<"TetherEmergency", 'String'>
    readonly outcome: FieldRef<"TetherEmergency", 'EmergencyOutcome'>
    readonly helpersNotified: FieldRef<"TetherEmergency", 'String'>
    readonly emergencyContacts: FieldRef<"TetherEmergency", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TetherEmergency findUnique
   */
  export type TetherEmergencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherEmergency
     */
    select?: TetherEmergencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherEmergency
     */
    omit?: TetherEmergencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherEmergencyInclude<ExtArgs> | null
    /**
     * Filter, which TetherEmergency to fetch.
     */
    where: TetherEmergencyWhereUniqueInput
  }

  /**
   * TetherEmergency findUniqueOrThrow
   */
  export type TetherEmergencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherEmergency
     */
    select?: TetherEmergencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherEmergency
     */
    omit?: TetherEmergencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherEmergencyInclude<ExtArgs> | null
    /**
     * Filter, which TetherEmergency to fetch.
     */
    where: TetherEmergencyWhereUniqueInput
  }

  /**
   * TetherEmergency findFirst
   */
  export type TetherEmergencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherEmergency
     */
    select?: TetherEmergencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherEmergency
     */
    omit?: TetherEmergencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherEmergencyInclude<ExtArgs> | null
    /**
     * Filter, which TetherEmergency to fetch.
     */
    where?: TetherEmergencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TetherEmergencies to fetch.
     */
    orderBy?: TetherEmergencyOrderByWithRelationInput | TetherEmergencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TetherEmergencies.
     */
    cursor?: TetherEmergencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TetherEmergencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TetherEmergencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TetherEmergencies.
     */
    distinct?: TetherEmergencyScalarFieldEnum | TetherEmergencyScalarFieldEnum[]
  }

  /**
   * TetherEmergency findFirstOrThrow
   */
  export type TetherEmergencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherEmergency
     */
    select?: TetherEmergencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherEmergency
     */
    omit?: TetherEmergencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherEmergencyInclude<ExtArgs> | null
    /**
     * Filter, which TetherEmergency to fetch.
     */
    where?: TetherEmergencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TetherEmergencies to fetch.
     */
    orderBy?: TetherEmergencyOrderByWithRelationInput | TetherEmergencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TetherEmergencies.
     */
    cursor?: TetherEmergencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TetherEmergencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TetherEmergencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TetherEmergencies.
     */
    distinct?: TetherEmergencyScalarFieldEnum | TetherEmergencyScalarFieldEnum[]
  }

  /**
   * TetherEmergency findMany
   */
  export type TetherEmergencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherEmergency
     */
    select?: TetherEmergencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherEmergency
     */
    omit?: TetherEmergencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherEmergencyInclude<ExtArgs> | null
    /**
     * Filter, which TetherEmergencies to fetch.
     */
    where?: TetherEmergencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TetherEmergencies to fetch.
     */
    orderBy?: TetherEmergencyOrderByWithRelationInput | TetherEmergencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TetherEmergencies.
     */
    cursor?: TetherEmergencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TetherEmergencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TetherEmergencies.
     */
    skip?: number
    distinct?: TetherEmergencyScalarFieldEnum | TetherEmergencyScalarFieldEnum[]
  }

  /**
   * TetherEmergency create
   */
  export type TetherEmergencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherEmergency
     */
    select?: TetherEmergencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherEmergency
     */
    omit?: TetherEmergencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherEmergencyInclude<ExtArgs> | null
    /**
     * The data needed to create a TetherEmergency.
     */
    data: XOR<TetherEmergencyCreateInput, TetherEmergencyUncheckedCreateInput>
  }

  /**
   * TetherEmergency createMany
   */
  export type TetherEmergencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TetherEmergencies.
     */
    data: TetherEmergencyCreateManyInput | TetherEmergencyCreateManyInput[]
  }

  /**
   * TetherEmergency createManyAndReturn
   */
  export type TetherEmergencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherEmergency
     */
    select?: TetherEmergencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TetherEmergency
     */
    omit?: TetherEmergencyOmit<ExtArgs> | null
    /**
     * The data used to create many TetherEmergencies.
     */
    data: TetherEmergencyCreateManyInput | TetherEmergencyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherEmergencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TetherEmergency update
   */
  export type TetherEmergencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherEmergency
     */
    select?: TetherEmergencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherEmergency
     */
    omit?: TetherEmergencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherEmergencyInclude<ExtArgs> | null
    /**
     * The data needed to update a TetherEmergency.
     */
    data: XOR<TetherEmergencyUpdateInput, TetherEmergencyUncheckedUpdateInput>
    /**
     * Choose, which TetherEmergency to update.
     */
    where: TetherEmergencyWhereUniqueInput
  }

  /**
   * TetherEmergency updateMany
   */
  export type TetherEmergencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TetherEmergencies.
     */
    data: XOR<TetherEmergencyUpdateManyMutationInput, TetherEmergencyUncheckedUpdateManyInput>
    /**
     * Filter which TetherEmergencies to update
     */
    where?: TetherEmergencyWhereInput
    /**
     * Limit how many TetherEmergencies to update.
     */
    limit?: number
  }

  /**
   * TetherEmergency updateManyAndReturn
   */
  export type TetherEmergencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherEmergency
     */
    select?: TetherEmergencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TetherEmergency
     */
    omit?: TetherEmergencyOmit<ExtArgs> | null
    /**
     * The data used to update TetherEmergencies.
     */
    data: XOR<TetherEmergencyUpdateManyMutationInput, TetherEmergencyUncheckedUpdateManyInput>
    /**
     * Filter which TetherEmergencies to update
     */
    where?: TetherEmergencyWhereInput
    /**
     * Limit how many TetherEmergencies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherEmergencyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TetherEmergency upsert
   */
  export type TetherEmergencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherEmergency
     */
    select?: TetherEmergencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherEmergency
     */
    omit?: TetherEmergencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherEmergencyInclude<ExtArgs> | null
    /**
     * The filter to search for the TetherEmergency to update in case it exists.
     */
    where: TetherEmergencyWhereUniqueInput
    /**
     * In case the TetherEmergency found by the `where` argument doesn't exist, create a new TetherEmergency with this data.
     */
    create: XOR<TetherEmergencyCreateInput, TetherEmergencyUncheckedCreateInput>
    /**
     * In case the TetherEmergency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TetherEmergencyUpdateInput, TetherEmergencyUncheckedUpdateInput>
  }

  /**
   * TetherEmergency delete
   */
  export type TetherEmergencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherEmergency
     */
    select?: TetherEmergencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherEmergency
     */
    omit?: TetherEmergencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherEmergencyInclude<ExtArgs> | null
    /**
     * Filter which TetherEmergency to delete.
     */
    where: TetherEmergencyWhereUniqueInput
  }

  /**
   * TetherEmergency deleteMany
   */
  export type TetherEmergencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TetherEmergencies to delete
     */
    where?: TetherEmergencyWhereInput
    /**
     * Limit how many TetherEmergencies to delete.
     */
    limit?: number
  }

  /**
   * TetherEmergency without action
   */
  export type TetherEmergencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TetherEmergency
     */
    select?: TetherEmergencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TetherEmergency
     */
    omit?: TetherEmergencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TetherEmergencyInclude<ExtArgs> | null
  }


  /**
   * Model Volunteer
   */

  export type AggregateVolunteer = {
    _count: VolunteerCountAggregateOutputType | null
    _avg: VolunteerAvgAggregateOutputType | null
    _sum: VolunteerSumAggregateOutputType | null
    _min: VolunteerMinAggregateOutputType | null
    _max: VolunteerMaxAggregateOutputType | null
  }

  export type VolunteerAvgAggregateOutputType = {
    trainingHours: number | null
    sessionsCount: number | null
    hoursVolunteered: number | null
    averageRating: number | null
    responseRate: number | null
    currentLoad: number | null
    maxConcurrent: number | null
    burnoutScore: number | null
  }

  export type VolunteerSumAggregateOutputType = {
    trainingHours: number | null
    sessionsCount: number | null
    hoursVolunteered: number | null
    averageRating: number | null
    responseRate: number | null
    currentLoad: number | null
    maxConcurrent: number | null
    burnoutScore: number | null
  }

  export type VolunteerMinAggregateOutputType = {
    id: string | null
    anonymousId: string | null
    status: $Enums.VolunteerStatus | null
    trainingHours: number | null
    certifications: string | null
    specializations: string | null
    languages: string | null
    backgroundCheck: $Enums.VerificationStatus | null
    sessionsCount: number | null
    hoursVolunteered: number | null
    averageRating: number | null
    responseRate: number | null
    isActive: boolean | null
    currentLoad: number | null
    maxConcurrent: number | null
    timezone: string | null
    lastActive: Date | null
    burnoutScore: number | null
    needsSupport: boolean | null
    emergencyResponder: boolean | null
    emergencyAvailable: boolean | null
  }

  export type VolunteerMaxAggregateOutputType = {
    id: string | null
    anonymousId: string | null
    status: $Enums.VolunteerStatus | null
    trainingHours: number | null
    certifications: string | null
    specializations: string | null
    languages: string | null
    backgroundCheck: $Enums.VerificationStatus | null
    sessionsCount: number | null
    hoursVolunteered: number | null
    averageRating: number | null
    responseRate: number | null
    isActive: boolean | null
    currentLoad: number | null
    maxConcurrent: number | null
    timezone: string | null
    lastActive: Date | null
    burnoutScore: number | null
    needsSupport: boolean | null
    emergencyResponder: boolean | null
    emergencyAvailable: boolean | null
  }

  export type VolunteerCountAggregateOutputType = {
    id: number
    anonymousId: number
    status: number
    trainingHours: number
    certifications: number
    specializations: number
    languages: number
    backgroundCheck: number
    sessionsCount: number
    hoursVolunteered: number
    averageRating: number
    responseRate: number
    isActive: number
    currentLoad: number
    maxConcurrent: number
    schedule: number
    timezone: number
    lastActive: number
    burnoutScore: number
    needsSupport: number
    emergencyResponder: number
    emergencyAvailable: number
    _all: number
  }


  export type VolunteerAvgAggregateInputType = {
    trainingHours?: true
    sessionsCount?: true
    hoursVolunteered?: true
    averageRating?: true
    responseRate?: true
    currentLoad?: true
    maxConcurrent?: true
    burnoutScore?: true
  }

  export type VolunteerSumAggregateInputType = {
    trainingHours?: true
    sessionsCount?: true
    hoursVolunteered?: true
    averageRating?: true
    responseRate?: true
    currentLoad?: true
    maxConcurrent?: true
    burnoutScore?: true
  }

  export type VolunteerMinAggregateInputType = {
    id?: true
    anonymousId?: true
    status?: true
    trainingHours?: true
    certifications?: true
    specializations?: true
    languages?: true
    backgroundCheck?: true
    sessionsCount?: true
    hoursVolunteered?: true
    averageRating?: true
    responseRate?: true
    isActive?: true
    currentLoad?: true
    maxConcurrent?: true
    timezone?: true
    lastActive?: true
    burnoutScore?: true
    needsSupport?: true
    emergencyResponder?: true
    emergencyAvailable?: true
  }

  export type VolunteerMaxAggregateInputType = {
    id?: true
    anonymousId?: true
    status?: true
    trainingHours?: true
    certifications?: true
    specializations?: true
    languages?: true
    backgroundCheck?: true
    sessionsCount?: true
    hoursVolunteered?: true
    averageRating?: true
    responseRate?: true
    isActive?: true
    currentLoad?: true
    maxConcurrent?: true
    timezone?: true
    lastActive?: true
    burnoutScore?: true
    needsSupport?: true
    emergencyResponder?: true
    emergencyAvailable?: true
  }

  export type VolunteerCountAggregateInputType = {
    id?: true
    anonymousId?: true
    status?: true
    trainingHours?: true
    certifications?: true
    specializations?: true
    languages?: true
    backgroundCheck?: true
    sessionsCount?: true
    hoursVolunteered?: true
    averageRating?: true
    responseRate?: true
    isActive?: true
    currentLoad?: true
    maxConcurrent?: true
    schedule?: true
    timezone?: true
    lastActive?: true
    burnoutScore?: true
    needsSupport?: true
    emergencyResponder?: true
    emergencyAvailable?: true
    _all?: true
  }

  export type VolunteerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Volunteer to aggregate.
     */
    where?: VolunteerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Volunteers to fetch.
     */
    orderBy?: VolunteerOrderByWithRelationInput | VolunteerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VolunteerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Volunteers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Volunteers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Volunteers
    **/
    _count?: true | VolunteerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VolunteerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VolunteerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VolunteerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VolunteerMaxAggregateInputType
  }

  export type GetVolunteerAggregateType<T extends VolunteerAggregateArgs> = {
        [P in keyof T & keyof AggregateVolunteer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVolunteer[P]>
      : GetScalarType<T[P], AggregateVolunteer[P]>
  }




  export type VolunteerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolunteerWhereInput
    orderBy?: VolunteerOrderByWithAggregationInput | VolunteerOrderByWithAggregationInput[]
    by: VolunteerScalarFieldEnum[] | VolunteerScalarFieldEnum
    having?: VolunteerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VolunteerCountAggregateInputType | true
    _avg?: VolunteerAvgAggregateInputType
    _sum?: VolunteerSumAggregateInputType
    _min?: VolunteerMinAggregateInputType
    _max?: VolunteerMaxAggregateInputType
  }

  export type VolunteerGroupByOutputType = {
    id: string
    anonymousId: string
    status: $Enums.VolunteerStatus
    trainingHours: number
    certifications: string | null
    specializations: string | null
    languages: string | null
    backgroundCheck: $Enums.VerificationStatus
    sessionsCount: number
    hoursVolunteered: number
    averageRating: number | null
    responseRate: number
    isActive: boolean
    currentLoad: number
    maxConcurrent: number
    schedule: JsonValue | null
    timezone: string | null
    lastActive: Date
    burnoutScore: number
    needsSupport: boolean
    emergencyResponder: boolean
    emergencyAvailable: boolean
    _count: VolunteerCountAggregateOutputType | null
    _avg: VolunteerAvgAggregateOutputType | null
    _sum: VolunteerSumAggregateOutputType | null
    _min: VolunteerMinAggregateOutputType | null
    _max: VolunteerMaxAggregateOutputType | null
  }

  type GetVolunteerGroupByPayload<T extends VolunteerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VolunteerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VolunteerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VolunteerGroupByOutputType[P]>
            : GetScalarType<T[P], VolunteerGroupByOutputType[P]>
        }
      >
    >


  export type VolunteerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    anonymousId?: boolean
    status?: boolean
    trainingHours?: boolean
    certifications?: boolean
    specializations?: boolean
    languages?: boolean
    backgroundCheck?: boolean
    sessionsCount?: boolean
    hoursVolunteered?: boolean
    averageRating?: boolean
    responseRate?: boolean
    isActive?: boolean
    currentLoad?: boolean
    maxConcurrent?: boolean
    schedule?: boolean
    timezone?: boolean
    lastActive?: boolean
    burnoutScore?: boolean
    needsSupport?: boolean
    emergencyResponder?: boolean
    emergencyAvailable?: boolean
    training?: boolean | Volunteer$trainingArgs<ExtArgs>
    sessions?: boolean | Volunteer$sessionsArgs<ExtArgs>
    feedback?: boolean | Volunteer$feedbackArgs<ExtArgs>
    _count?: boolean | VolunteerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volunteer"]>

  export type VolunteerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    anonymousId?: boolean
    status?: boolean
    trainingHours?: boolean
    certifications?: boolean
    specializations?: boolean
    languages?: boolean
    backgroundCheck?: boolean
    sessionsCount?: boolean
    hoursVolunteered?: boolean
    averageRating?: boolean
    responseRate?: boolean
    isActive?: boolean
    currentLoad?: boolean
    maxConcurrent?: boolean
    schedule?: boolean
    timezone?: boolean
    lastActive?: boolean
    burnoutScore?: boolean
    needsSupport?: boolean
    emergencyResponder?: boolean
    emergencyAvailable?: boolean
  }, ExtArgs["result"]["volunteer"]>

  export type VolunteerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    anonymousId?: boolean
    status?: boolean
    trainingHours?: boolean
    certifications?: boolean
    specializations?: boolean
    languages?: boolean
    backgroundCheck?: boolean
    sessionsCount?: boolean
    hoursVolunteered?: boolean
    averageRating?: boolean
    responseRate?: boolean
    isActive?: boolean
    currentLoad?: boolean
    maxConcurrent?: boolean
    schedule?: boolean
    timezone?: boolean
    lastActive?: boolean
    burnoutScore?: boolean
    needsSupport?: boolean
    emergencyResponder?: boolean
    emergencyAvailable?: boolean
  }, ExtArgs["result"]["volunteer"]>

  export type VolunteerSelectScalar = {
    id?: boolean
    anonymousId?: boolean
    status?: boolean
    trainingHours?: boolean
    certifications?: boolean
    specializations?: boolean
    languages?: boolean
    backgroundCheck?: boolean
    sessionsCount?: boolean
    hoursVolunteered?: boolean
    averageRating?: boolean
    responseRate?: boolean
    isActive?: boolean
    currentLoad?: boolean
    maxConcurrent?: boolean
    schedule?: boolean
    timezone?: boolean
    lastActive?: boolean
    burnoutScore?: boolean
    needsSupport?: boolean
    emergencyResponder?: boolean
    emergencyAvailable?: boolean
  }

  export type VolunteerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "anonymousId" | "status" | "trainingHours" | "certifications" | "specializations" | "languages" | "backgroundCheck" | "sessionsCount" | "hoursVolunteered" | "averageRating" | "responseRate" | "isActive" | "currentLoad" | "maxConcurrent" | "schedule" | "timezone" | "lastActive" | "burnoutScore" | "needsSupport" | "emergencyResponder" | "emergencyAvailable", ExtArgs["result"]["volunteer"]>
  export type VolunteerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | Volunteer$trainingArgs<ExtArgs>
    sessions?: boolean | Volunteer$sessionsArgs<ExtArgs>
    feedback?: boolean | Volunteer$feedbackArgs<ExtArgs>
    _count?: boolean | VolunteerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VolunteerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VolunteerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VolunteerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Volunteer"
    objects: {
      training: Prisma.$VolunteerTrainingPayload<ExtArgs>[]
      sessions: Prisma.$VolunteerSessionPayload<ExtArgs>[]
      feedback: Prisma.$VolunteerFeedbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      anonymousId: string
      status: $Enums.VolunteerStatus
      trainingHours: number
      certifications: string | null
      specializations: string | null
      languages: string | null
      backgroundCheck: $Enums.VerificationStatus
      sessionsCount: number
      hoursVolunteered: number
      averageRating: number | null
      responseRate: number
      isActive: boolean
      currentLoad: number
      maxConcurrent: number
      schedule: Prisma.JsonValue | null
      timezone: string | null
      lastActive: Date
      burnoutScore: number
      needsSupport: boolean
      emergencyResponder: boolean
      emergencyAvailable: boolean
    }, ExtArgs["result"]["volunteer"]>
    composites: {}
  }

  type VolunteerGetPayload<S extends boolean | null | undefined | VolunteerDefaultArgs> = $Result.GetResult<Prisma.$VolunteerPayload, S>

  type VolunteerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VolunteerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: VolunteerCountAggregateInputType | true
    }

  export interface VolunteerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Volunteer'], meta: { name: 'Volunteer' } }
    /**
     * Find zero or one Volunteer that matches the filter.
     * @param {VolunteerFindUniqueArgs} args - Arguments to find a Volunteer
     * @example
     * // Get one Volunteer
     * const volunteer = await prisma.volunteer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VolunteerFindUniqueArgs>(args: SelectSubset<T, VolunteerFindUniqueArgs<ExtArgs>>): Prisma__VolunteerClient<$Result.GetResult<Prisma.$VolunteerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Volunteer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VolunteerFindUniqueOrThrowArgs} args - Arguments to find a Volunteer
     * @example
     * // Get one Volunteer
     * const volunteer = await prisma.volunteer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VolunteerFindUniqueOrThrowArgs>(args: SelectSubset<T, VolunteerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VolunteerClient<$Result.GetResult<Prisma.$VolunteerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Volunteer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerFindFirstArgs} args - Arguments to find a Volunteer
     * @example
     * // Get one Volunteer
     * const volunteer = await prisma.volunteer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VolunteerFindFirstArgs>(args?: SelectSubset<T, VolunteerFindFirstArgs<ExtArgs>>): Prisma__VolunteerClient<$Result.GetResult<Prisma.$VolunteerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Volunteer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerFindFirstOrThrowArgs} args - Arguments to find a Volunteer
     * @example
     * // Get one Volunteer
     * const volunteer = await prisma.volunteer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VolunteerFindFirstOrThrowArgs>(args?: SelectSubset<T, VolunteerFindFirstOrThrowArgs<ExtArgs>>): Prisma__VolunteerClient<$Result.GetResult<Prisma.$VolunteerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Volunteers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Volunteers
     * const volunteers = await prisma.volunteer.findMany()
     * 
     * // Get first 10 Volunteers
     * const volunteers = await prisma.volunteer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const volunteerWithIdOnly = await prisma.volunteer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VolunteerFindManyArgs>(args?: SelectSubset<T, VolunteerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Volunteer.
     * @param {VolunteerCreateArgs} args - Arguments to create a Volunteer.
     * @example
     * // Create one Volunteer
     * const Volunteer = await prisma.volunteer.create({
     *   data: {
     *     // ... data to create a Volunteer
     *   }
     * })
     * 
     */
    create<T extends VolunteerCreateArgs>(args: SelectSubset<T, VolunteerCreateArgs<ExtArgs>>): Prisma__VolunteerClient<$Result.GetResult<Prisma.$VolunteerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Volunteers.
     * @param {VolunteerCreateManyArgs} args - Arguments to create many Volunteers.
     * @example
     * // Create many Volunteers
     * const volunteer = await prisma.volunteer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VolunteerCreateManyArgs>(args?: SelectSubset<T, VolunteerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Volunteers and returns the data saved in the database.
     * @param {VolunteerCreateManyAndReturnArgs} args - Arguments to create many Volunteers.
     * @example
     * // Create many Volunteers
     * const volunteer = await prisma.volunteer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Volunteers and only return the `id`
     * const volunteerWithIdOnly = await prisma.volunteer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VolunteerCreateManyAndReturnArgs>(args?: SelectSubset<T, VolunteerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Volunteer.
     * @param {VolunteerDeleteArgs} args - Arguments to delete one Volunteer.
     * @example
     * // Delete one Volunteer
     * const Volunteer = await prisma.volunteer.delete({
     *   where: {
     *     // ... filter to delete one Volunteer
     *   }
     * })
     * 
     */
    delete<T extends VolunteerDeleteArgs>(args: SelectSubset<T, VolunteerDeleteArgs<ExtArgs>>): Prisma__VolunteerClient<$Result.GetResult<Prisma.$VolunteerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Volunteer.
     * @param {VolunteerUpdateArgs} args - Arguments to update one Volunteer.
     * @example
     * // Update one Volunteer
     * const volunteer = await prisma.volunteer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VolunteerUpdateArgs>(args: SelectSubset<T, VolunteerUpdateArgs<ExtArgs>>): Prisma__VolunteerClient<$Result.GetResult<Prisma.$VolunteerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Volunteers.
     * @param {VolunteerDeleteManyArgs} args - Arguments to filter Volunteers to delete.
     * @example
     * // Delete a few Volunteers
     * const { count } = await prisma.volunteer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VolunteerDeleteManyArgs>(args?: SelectSubset<T, VolunteerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Volunteers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Volunteers
     * const volunteer = await prisma.volunteer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VolunteerUpdateManyArgs>(args: SelectSubset<T, VolunteerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Volunteers and returns the data updated in the database.
     * @param {VolunteerUpdateManyAndReturnArgs} args - Arguments to update many Volunteers.
     * @example
     * // Update many Volunteers
     * const volunteer = await prisma.volunteer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Volunteers and only return the `id`
     * const volunteerWithIdOnly = await prisma.volunteer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VolunteerUpdateManyAndReturnArgs>(args: SelectSubset<T, VolunteerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Volunteer.
     * @param {VolunteerUpsertArgs} args - Arguments to update or create a Volunteer.
     * @example
     * // Update or create a Volunteer
     * const volunteer = await prisma.volunteer.upsert({
     *   create: {
     *     // ... data to create a Volunteer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Volunteer we want to update
     *   }
     * })
     */
    upsert<T extends VolunteerUpsertArgs>(args: SelectSubset<T, VolunteerUpsertArgs<ExtArgs>>): Prisma__VolunteerClient<$Result.GetResult<Prisma.$VolunteerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Volunteers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerCountArgs} args - Arguments to filter Volunteers to count.
     * @example
     * // Count the number of Volunteers
     * const count = await prisma.volunteer.count({
     *   where: {
     *     // ... the filter for the Volunteers we want to count
     *   }
     * })
    **/
    count<T extends VolunteerCountArgs>(
      args?: Subset<T, VolunteerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VolunteerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Volunteer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VolunteerAggregateArgs>(args: Subset<T, VolunteerAggregateArgs>): Prisma.PrismaPromise<GetVolunteerAggregateType<T>>

    /**
     * Group by Volunteer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VolunteerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VolunteerGroupByArgs['orderBy'] }
        : { orderBy?: VolunteerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VolunteerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVolunteerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Volunteer model
   */
  readonly fields: VolunteerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Volunteer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VolunteerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends Volunteer$trainingArgs<ExtArgs> = {}>(args?: Subset<T, Volunteer$trainingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteerTrainingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends Volunteer$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Volunteer$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteerSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedback<T extends Volunteer$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, Volunteer$feedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteerFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Volunteer model
   */
  interface VolunteerFieldRefs {
    readonly id: FieldRef<"Volunteer", 'String'>
    readonly anonymousId: FieldRef<"Volunteer", 'String'>
    readonly status: FieldRef<"Volunteer", 'VolunteerStatus'>
    readonly trainingHours: FieldRef<"Volunteer", 'Float'>
    readonly certifications: FieldRef<"Volunteer", 'String'>
    readonly specializations: FieldRef<"Volunteer", 'String'>
    readonly languages: FieldRef<"Volunteer", 'String'>
    readonly backgroundCheck: FieldRef<"Volunteer", 'VerificationStatus'>
    readonly sessionsCount: FieldRef<"Volunteer", 'Int'>
    readonly hoursVolunteered: FieldRef<"Volunteer", 'Float'>
    readonly averageRating: FieldRef<"Volunteer", 'Float'>
    readonly responseRate: FieldRef<"Volunteer", 'Float'>
    readonly isActive: FieldRef<"Volunteer", 'Boolean'>
    readonly currentLoad: FieldRef<"Volunteer", 'Int'>
    readonly maxConcurrent: FieldRef<"Volunteer", 'Int'>
    readonly schedule: FieldRef<"Volunteer", 'Json'>
    readonly timezone: FieldRef<"Volunteer", 'String'>
    readonly lastActive: FieldRef<"Volunteer", 'DateTime'>
    readonly burnoutScore: FieldRef<"Volunteer", 'Float'>
    readonly needsSupport: FieldRef<"Volunteer", 'Boolean'>
    readonly emergencyResponder: FieldRef<"Volunteer", 'Boolean'>
    readonly emergencyAvailable: FieldRef<"Volunteer", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Volunteer findUnique
   */
  export type VolunteerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteer
     */
    select?: VolunteerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteer
     */
    omit?: VolunteerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerInclude<ExtArgs> | null
    /**
     * Filter, which Volunteer to fetch.
     */
    where: VolunteerWhereUniqueInput
  }

  /**
   * Volunteer findUniqueOrThrow
   */
  export type VolunteerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteer
     */
    select?: VolunteerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteer
     */
    omit?: VolunteerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerInclude<ExtArgs> | null
    /**
     * Filter, which Volunteer to fetch.
     */
    where: VolunteerWhereUniqueInput
  }

  /**
   * Volunteer findFirst
   */
  export type VolunteerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteer
     */
    select?: VolunteerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteer
     */
    omit?: VolunteerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerInclude<ExtArgs> | null
    /**
     * Filter, which Volunteer to fetch.
     */
    where?: VolunteerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Volunteers to fetch.
     */
    orderBy?: VolunteerOrderByWithRelationInput | VolunteerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Volunteers.
     */
    cursor?: VolunteerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Volunteers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Volunteers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Volunteers.
     */
    distinct?: VolunteerScalarFieldEnum | VolunteerScalarFieldEnum[]
  }

  /**
   * Volunteer findFirstOrThrow
   */
  export type VolunteerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteer
     */
    select?: VolunteerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteer
     */
    omit?: VolunteerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerInclude<ExtArgs> | null
    /**
     * Filter, which Volunteer to fetch.
     */
    where?: VolunteerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Volunteers to fetch.
     */
    orderBy?: VolunteerOrderByWithRelationInput | VolunteerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Volunteers.
     */
    cursor?: VolunteerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Volunteers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Volunteers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Volunteers.
     */
    distinct?: VolunteerScalarFieldEnum | VolunteerScalarFieldEnum[]
  }

  /**
   * Volunteer findMany
   */
  export type VolunteerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteer
     */
    select?: VolunteerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteer
     */
    omit?: VolunteerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerInclude<ExtArgs> | null
    /**
     * Filter, which Volunteers to fetch.
     */
    where?: VolunteerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Volunteers to fetch.
     */
    orderBy?: VolunteerOrderByWithRelationInput | VolunteerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Volunteers.
     */
    cursor?: VolunteerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Volunteers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Volunteers.
     */
    skip?: number
    distinct?: VolunteerScalarFieldEnum | VolunteerScalarFieldEnum[]
  }

  /**
   * Volunteer create
   */
  export type VolunteerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteer
     */
    select?: VolunteerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteer
     */
    omit?: VolunteerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerInclude<ExtArgs> | null
    /**
     * The data needed to create a Volunteer.
     */
    data: XOR<VolunteerCreateInput, VolunteerUncheckedCreateInput>
  }

  /**
   * Volunteer createMany
   */
  export type VolunteerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Volunteers.
     */
    data: VolunteerCreateManyInput | VolunteerCreateManyInput[]
  }

  /**
   * Volunteer createManyAndReturn
   */
  export type VolunteerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteer
     */
    select?: VolunteerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteer
     */
    omit?: VolunteerOmit<ExtArgs> | null
    /**
     * The data used to create many Volunteers.
     */
    data: VolunteerCreateManyInput | VolunteerCreateManyInput[]
  }

  /**
   * Volunteer update
   */
  export type VolunteerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteer
     */
    select?: VolunteerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteer
     */
    omit?: VolunteerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerInclude<ExtArgs> | null
    /**
     * The data needed to update a Volunteer.
     */
    data: XOR<VolunteerUpdateInput, VolunteerUncheckedUpdateInput>
    /**
     * Choose, which Volunteer to update.
     */
    where: VolunteerWhereUniqueInput
  }

  /**
   * Volunteer updateMany
   */
  export type VolunteerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Volunteers.
     */
    data: XOR<VolunteerUpdateManyMutationInput, VolunteerUncheckedUpdateManyInput>
    /**
     * Filter which Volunteers to update
     */
    where?: VolunteerWhereInput
    /**
     * Limit how many Volunteers to update.
     */
    limit?: number
  }

  /**
   * Volunteer updateManyAndReturn
   */
  export type VolunteerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteer
     */
    select?: VolunteerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteer
     */
    omit?: VolunteerOmit<ExtArgs> | null
    /**
     * The data used to update Volunteers.
     */
    data: XOR<VolunteerUpdateManyMutationInput, VolunteerUncheckedUpdateManyInput>
    /**
     * Filter which Volunteers to update
     */
    where?: VolunteerWhereInput
    /**
     * Limit how many Volunteers to update.
     */
    limit?: number
  }

  /**
   * Volunteer upsert
   */
  export type VolunteerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteer
     */
    select?: VolunteerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteer
     */
    omit?: VolunteerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerInclude<ExtArgs> | null
    /**
     * The filter to search for the Volunteer to update in case it exists.
     */
    where: VolunteerWhereUniqueInput
    /**
     * In case the Volunteer found by the `where` argument doesn't exist, create a new Volunteer with this data.
     */
    create: XOR<VolunteerCreateInput, VolunteerUncheckedCreateInput>
    /**
     * In case the Volunteer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VolunteerUpdateInput, VolunteerUncheckedUpdateInput>
  }

  /**
   * Volunteer delete
   */
  export type VolunteerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteer
     */
    select?: VolunteerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteer
     */
    omit?: VolunteerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerInclude<ExtArgs> | null
    /**
     * Filter which Volunteer to delete.
     */
    where: VolunteerWhereUniqueInput
  }

  /**
   * Volunteer deleteMany
   */
  export type VolunteerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Volunteers to delete
     */
    where?: VolunteerWhereInput
    /**
     * Limit how many Volunteers to delete.
     */
    limit?: number
  }

  /**
   * Volunteer.training
   */
  export type Volunteer$trainingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerTraining
     */
    select?: VolunteerTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerTraining
     */
    omit?: VolunteerTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerTrainingInclude<ExtArgs> | null
    where?: VolunteerTrainingWhereInput
    orderBy?: VolunteerTrainingOrderByWithRelationInput | VolunteerTrainingOrderByWithRelationInput[]
    cursor?: VolunteerTrainingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VolunteerTrainingScalarFieldEnum | VolunteerTrainingScalarFieldEnum[]
  }

  /**
   * Volunteer.sessions
   */
  export type Volunteer$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerSession
     */
    select?: VolunteerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerSession
     */
    omit?: VolunteerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerSessionInclude<ExtArgs> | null
    where?: VolunteerSessionWhereInput
    orderBy?: VolunteerSessionOrderByWithRelationInput | VolunteerSessionOrderByWithRelationInput[]
    cursor?: VolunteerSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VolunteerSessionScalarFieldEnum | VolunteerSessionScalarFieldEnum[]
  }

  /**
   * Volunteer.feedback
   */
  export type Volunteer$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerFeedback
     */
    select?: VolunteerFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerFeedback
     */
    omit?: VolunteerFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerFeedbackInclude<ExtArgs> | null
    where?: VolunteerFeedbackWhereInput
    orderBy?: VolunteerFeedbackOrderByWithRelationInput | VolunteerFeedbackOrderByWithRelationInput[]
    cursor?: VolunteerFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VolunteerFeedbackScalarFieldEnum | VolunteerFeedbackScalarFieldEnum[]
  }

  /**
   * Volunteer without action
   */
  export type VolunteerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteer
     */
    select?: VolunteerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteer
     */
    omit?: VolunteerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerInclude<ExtArgs> | null
  }


  /**
   * Model VolunteerTraining
   */

  export type AggregateVolunteerTraining = {
    _count: VolunteerTrainingCountAggregateOutputType | null
    _avg: VolunteerTrainingAvgAggregateOutputType | null
    _sum: VolunteerTrainingSumAggregateOutputType | null
    _min: VolunteerTrainingMinAggregateOutputType | null
    _max: VolunteerTrainingMaxAggregateOutputType | null
  }

  export type VolunteerTrainingAvgAggregateOutputType = {
    score: number | null
    passingScore: number | null
    attempts: number | null
    duration: number | null
  }

  export type VolunteerTrainingSumAggregateOutputType = {
    score: number | null
    passingScore: number | null
    attempts: number | null
    duration: number | null
  }

  export type VolunteerTrainingMinAggregateOutputType = {
    id: string | null
    volunteerId: string | null
    moduleId: string | null
    status: $Enums.TrainingStatus | null
    startedAt: Date | null
    completedAt: Date | null
    score: number | null
    passingScore: number | null
    attempts: number | null
    moduleTitle: string | null
    moduleType: $Enums.TrainingType | null
    duration: number | null
  }

  export type VolunteerTrainingMaxAggregateOutputType = {
    id: string | null
    volunteerId: string | null
    moduleId: string | null
    status: $Enums.TrainingStatus | null
    startedAt: Date | null
    completedAt: Date | null
    score: number | null
    passingScore: number | null
    attempts: number | null
    moduleTitle: string | null
    moduleType: $Enums.TrainingType | null
    duration: number | null
  }

  export type VolunteerTrainingCountAggregateOutputType = {
    id: number
    volunteerId: number
    moduleId: number
    status: number
    startedAt: number
    completedAt: number
    score: number
    passingScore: number
    attempts: number
    moduleTitle: number
    moduleType: number
    duration: number
    content: number
    _all: number
  }


  export type VolunteerTrainingAvgAggregateInputType = {
    score?: true
    passingScore?: true
    attempts?: true
    duration?: true
  }

  export type VolunteerTrainingSumAggregateInputType = {
    score?: true
    passingScore?: true
    attempts?: true
    duration?: true
  }

  export type VolunteerTrainingMinAggregateInputType = {
    id?: true
    volunteerId?: true
    moduleId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    score?: true
    passingScore?: true
    attempts?: true
    moduleTitle?: true
    moduleType?: true
    duration?: true
  }

  export type VolunteerTrainingMaxAggregateInputType = {
    id?: true
    volunteerId?: true
    moduleId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    score?: true
    passingScore?: true
    attempts?: true
    moduleTitle?: true
    moduleType?: true
    duration?: true
  }

  export type VolunteerTrainingCountAggregateInputType = {
    id?: true
    volunteerId?: true
    moduleId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    score?: true
    passingScore?: true
    attempts?: true
    moduleTitle?: true
    moduleType?: true
    duration?: true
    content?: true
    _all?: true
  }

  export type VolunteerTrainingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VolunteerTraining to aggregate.
     */
    where?: VolunteerTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolunteerTrainings to fetch.
     */
    orderBy?: VolunteerTrainingOrderByWithRelationInput | VolunteerTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VolunteerTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolunteerTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolunteerTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VolunteerTrainings
    **/
    _count?: true | VolunteerTrainingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VolunteerTrainingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VolunteerTrainingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VolunteerTrainingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VolunteerTrainingMaxAggregateInputType
  }

  export type GetVolunteerTrainingAggregateType<T extends VolunteerTrainingAggregateArgs> = {
        [P in keyof T & keyof AggregateVolunteerTraining]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVolunteerTraining[P]>
      : GetScalarType<T[P], AggregateVolunteerTraining[P]>
  }




  export type VolunteerTrainingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolunteerTrainingWhereInput
    orderBy?: VolunteerTrainingOrderByWithAggregationInput | VolunteerTrainingOrderByWithAggregationInput[]
    by: VolunteerTrainingScalarFieldEnum[] | VolunteerTrainingScalarFieldEnum
    having?: VolunteerTrainingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VolunteerTrainingCountAggregateInputType | true
    _avg?: VolunteerTrainingAvgAggregateInputType
    _sum?: VolunteerTrainingSumAggregateInputType
    _min?: VolunteerTrainingMinAggregateInputType
    _max?: VolunteerTrainingMaxAggregateInputType
  }

  export type VolunteerTrainingGroupByOutputType = {
    id: string
    volunteerId: string
    moduleId: string
    status: $Enums.TrainingStatus
    startedAt: Date | null
    completedAt: Date | null
    score: number | null
    passingScore: number
    attempts: number
    moduleTitle: string
    moduleType: $Enums.TrainingType
    duration: number
    content: JsonValue
    _count: VolunteerTrainingCountAggregateOutputType | null
    _avg: VolunteerTrainingAvgAggregateOutputType | null
    _sum: VolunteerTrainingSumAggregateOutputType | null
    _min: VolunteerTrainingMinAggregateOutputType | null
    _max: VolunteerTrainingMaxAggregateOutputType | null
  }

  type GetVolunteerTrainingGroupByPayload<T extends VolunteerTrainingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VolunteerTrainingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VolunteerTrainingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VolunteerTrainingGroupByOutputType[P]>
            : GetScalarType<T[P], VolunteerTrainingGroupByOutputType[P]>
        }
      >
    >


  export type VolunteerTrainingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volunteerId?: boolean
    moduleId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    score?: boolean
    passingScore?: boolean
    attempts?: boolean
    moduleTitle?: boolean
    moduleType?: boolean
    duration?: boolean
    content?: boolean
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volunteerTraining"]>

  export type VolunteerTrainingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volunteerId?: boolean
    moduleId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    score?: boolean
    passingScore?: boolean
    attempts?: boolean
    moduleTitle?: boolean
    moduleType?: boolean
    duration?: boolean
    content?: boolean
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volunteerTraining"]>

  export type VolunteerTrainingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volunteerId?: boolean
    moduleId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    score?: boolean
    passingScore?: boolean
    attempts?: boolean
    moduleTitle?: boolean
    moduleType?: boolean
    duration?: boolean
    content?: boolean
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volunteerTraining"]>

  export type VolunteerTrainingSelectScalar = {
    id?: boolean
    volunteerId?: boolean
    moduleId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    score?: boolean
    passingScore?: boolean
    attempts?: boolean
    moduleTitle?: boolean
    moduleType?: boolean
    duration?: boolean
    content?: boolean
  }

  export type VolunteerTrainingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "volunteerId" | "moduleId" | "status" | "startedAt" | "completedAt" | "score" | "passingScore" | "attempts" | "moduleTitle" | "moduleType" | "duration" | "content", ExtArgs["result"]["volunteerTraining"]>
  export type VolunteerTrainingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }
  export type VolunteerTrainingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }
  export type VolunteerTrainingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }

  export type $VolunteerTrainingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VolunteerTraining"
    objects: {
      volunteer: Prisma.$VolunteerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      volunteerId: string
      moduleId: string
      status: $Enums.TrainingStatus
      startedAt: Date | null
      completedAt: Date | null
      score: number | null
      passingScore: number
      attempts: number
      moduleTitle: string
      moduleType: $Enums.TrainingType
      duration: number
      content: Prisma.JsonValue
    }, ExtArgs["result"]["volunteerTraining"]>
    composites: {}
  }

  type VolunteerTrainingGetPayload<S extends boolean | null | undefined | VolunteerTrainingDefaultArgs> = $Result.GetResult<Prisma.$VolunteerTrainingPayload, S>

  type VolunteerTrainingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VolunteerTrainingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: VolunteerTrainingCountAggregateInputType | true
    }

  export interface VolunteerTrainingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VolunteerTraining'], meta: { name: 'VolunteerTraining' } }
    /**
     * Find zero or one VolunteerTraining that matches the filter.
     * @param {VolunteerTrainingFindUniqueArgs} args - Arguments to find a VolunteerTraining
     * @example
     * // Get one VolunteerTraining
     * const volunteerTraining = await prisma.volunteerTraining.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VolunteerTrainingFindUniqueArgs>(args: SelectSubset<T, VolunteerTrainingFindUniqueArgs<ExtArgs>>): Prisma__VolunteerTrainingClient<$Result.GetResult<Prisma.$VolunteerTrainingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VolunteerTraining that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VolunteerTrainingFindUniqueOrThrowArgs} args - Arguments to find a VolunteerTraining
     * @example
     * // Get one VolunteerTraining
     * const volunteerTraining = await prisma.volunteerTraining.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VolunteerTrainingFindUniqueOrThrowArgs>(args: SelectSubset<T, VolunteerTrainingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VolunteerTrainingClient<$Result.GetResult<Prisma.$VolunteerTrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VolunteerTraining that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerTrainingFindFirstArgs} args - Arguments to find a VolunteerTraining
     * @example
     * // Get one VolunteerTraining
     * const volunteerTraining = await prisma.volunteerTraining.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VolunteerTrainingFindFirstArgs>(args?: SelectSubset<T, VolunteerTrainingFindFirstArgs<ExtArgs>>): Prisma__VolunteerTrainingClient<$Result.GetResult<Prisma.$VolunteerTrainingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VolunteerTraining that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerTrainingFindFirstOrThrowArgs} args - Arguments to find a VolunteerTraining
     * @example
     * // Get one VolunteerTraining
     * const volunteerTraining = await prisma.volunteerTraining.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VolunteerTrainingFindFirstOrThrowArgs>(args?: SelectSubset<T, VolunteerTrainingFindFirstOrThrowArgs<ExtArgs>>): Prisma__VolunteerTrainingClient<$Result.GetResult<Prisma.$VolunteerTrainingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VolunteerTrainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerTrainingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VolunteerTrainings
     * const volunteerTrainings = await prisma.volunteerTraining.findMany()
     * 
     * // Get first 10 VolunteerTrainings
     * const volunteerTrainings = await prisma.volunteerTraining.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const volunteerTrainingWithIdOnly = await prisma.volunteerTraining.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VolunteerTrainingFindManyArgs>(args?: SelectSubset<T, VolunteerTrainingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteerTrainingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VolunteerTraining.
     * @param {VolunteerTrainingCreateArgs} args - Arguments to create a VolunteerTraining.
     * @example
     * // Create one VolunteerTraining
     * const VolunteerTraining = await prisma.volunteerTraining.create({
     *   data: {
     *     // ... data to create a VolunteerTraining
     *   }
     * })
     * 
     */
    create<T extends VolunteerTrainingCreateArgs>(args: SelectSubset<T, VolunteerTrainingCreateArgs<ExtArgs>>): Prisma__VolunteerTrainingClient<$Result.GetResult<Prisma.$VolunteerTrainingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VolunteerTrainings.
     * @param {VolunteerTrainingCreateManyArgs} args - Arguments to create many VolunteerTrainings.
     * @example
     * // Create many VolunteerTrainings
     * const volunteerTraining = await prisma.volunteerTraining.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VolunteerTrainingCreateManyArgs>(args?: SelectSubset<T, VolunteerTrainingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VolunteerTrainings and returns the data saved in the database.
     * @param {VolunteerTrainingCreateManyAndReturnArgs} args - Arguments to create many VolunteerTrainings.
     * @example
     * // Create many VolunteerTrainings
     * const volunteerTraining = await prisma.volunteerTraining.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VolunteerTrainings and only return the `id`
     * const volunteerTrainingWithIdOnly = await prisma.volunteerTraining.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VolunteerTrainingCreateManyAndReturnArgs>(args?: SelectSubset<T, VolunteerTrainingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteerTrainingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VolunteerTraining.
     * @param {VolunteerTrainingDeleteArgs} args - Arguments to delete one VolunteerTraining.
     * @example
     * // Delete one VolunteerTraining
     * const VolunteerTraining = await prisma.volunteerTraining.delete({
     *   where: {
     *     // ... filter to delete one VolunteerTraining
     *   }
     * })
     * 
     */
    delete<T extends VolunteerTrainingDeleteArgs>(args: SelectSubset<T, VolunteerTrainingDeleteArgs<ExtArgs>>): Prisma__VolunteerTrainingClient<$Result.GetResult<Prisma.$VolunteerTrainingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VolunteerTraining.
     * @param {VolunteerTrainingUpdateArgs} args - Arguments to update one VolunteerTraining.
     * @example
     * // Update one VolunteerTraining
     * const volunteerTraining = await prisma.volunteerTraining.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VolunteerTrainingUpdateArgs>(args: SelectSubset<T, VolunteerTrainingUpdateArgs<ExtArgs>>): Prisma__VolunteerTrainingClient<$Result.GetResult<Prisma.$VolunteerTrainingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VolunteerTrainings.
     * @param {VolunteerTrainingDeleteManyArgs} args - Arguments to filter VolunteerTrainings to delete.
     * @example
     * // Delete a few VolunteerTrainings
     * const { count } = await prisma.volunteerTraining.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VolunteerTrainingDeleteManyArgs>(args?: SelectSubset<T, VolunteerTrainingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VolunteerTrainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerTrainingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VolunteerTrainings
     * const volunteerTraining = await prisma.volunteerTraining.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VolunteerTrainingUpdateManyArgs>(args: SelectSubset<T, VolunteerTrainingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VolunteerTrainings and returns the data updated in the database.
     * @param {VolunteerTrainingUpdateManyAndReturnArgs} args - Arguments to update many VolunteerTrainings.
     * @example
     * // Update many VolunteerTrainings
     * const volunteerTraining = await prisma.volunteerTraining.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VolunteerTrainings and only return the `id`
     * const volunteerTrainingWithIdOnly = await prisma.volunteerTraining.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VolunteerTrainingUpdateManyAndReturnArgs>(args: SelectSubset<T, VolunteerTrainingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteerTrainingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VolunteerTraining.
     * @param {VolunteerTrainingUpsertArgs} args - Arguments to update or create a VolunteerTraining.
     * @example
     * // Update or create a VolunteerTraining
     * const volunteerTraining = await prisma.volunteerTraining.upsert({
     *   create: {
     *     // ... data to create a VolunteerTraining
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VolunteerTraining we want to update
     *   }
     * })
     */
    upsert<T extends VolunteerTrainingUpsertArgs>(args: SelectSubset<T, VolunteerTrainingUpsertArgs<ExtArgs>>): Prisma__VolunteerTrainingClient<$Result.GetResult<Prisma.$VolunteerTrainingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VolunteerTrainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerTrainingCountArgs} args - Arguments to filter VolunteerTrainings to count.
     * @example
     * // Count the number of VolunteerTrainings
     * const count = await prisma.volunteerTraining.count({
     *   where: {
     *     // ... the filter for the VolunteerTrainings we want to count
     *   }
     * })
    **/
    count<T extends VolunteerTrainingCountArgs>(
      args?: Subset<T, VolunteerTrainingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VolunteerTrainingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VolunteerTraining.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerTrainingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VolunteerTrainingAggregateArgs>(args: Subset<T, VolunteerTrainingAggregateArgs>): Prisma.PrismaPromise<GetVolunteerTrainingAggregateType<T>>

    /**
     * Group by VolunteerTraining.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerTrainingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VolunteerTrainingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VolunteerTrainingGroupByArgs['orderBy'] }
        : { orderBy?: VolunteerTrainingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VolunteerTrainingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVolunteerTrainingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VolunteerTraining model
   */
  readonly fields: VolunteerTrainingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VolunteerTraining.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VolunteerTrainingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    volunteer<T extends VolunteerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VolunteerDefaultArgs<ExtArgs>>): Prisma__VolunteerClient<$Result.GetResult<Prisma.$VolunteerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VolunteerTraining model
   */
  interface VolunteerTrainingFieldRefs {
    readonly id: FieldRef<"VolunteerTraining", 'String'>
    readonly volunteerId: FieldRef<"VolunteerTraining", 'String'>
    readonly moduleId: FieldRef<"VolunteerTraining", 'String'>
    readonly status: FieldRef<"VolunteerTraining", 'TrainingStatus'>
    readonly startedAt: FieldRef<"VolunteerTraining", 'DateTime'>
    readonly completedAt: FieldRef<"VolunteerTraining", 'DateTime'>
    readonly score: FieldRef<"VolunteerTraining", 'Float'>
    readonly passingScore: FieldRef<"VolunteerTraining", 'Float'>
    readonly attempts: FieldRef<"VolunteerTraining", 'Int'>
    readonly moduleTitle: FieldRef<"VolunteerTraining", 'String'>
    readonly moduleType: FieldRef<"VolunteerTraining", 'TrainingType'>
    readonly duration: FieldRef<"VolunteerTraining", 'Int'>
    readonly content: FieldRef<"VolunteerTraining", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * VolunteerTraining findUnique
   */
  export type VolunteerTrainingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerTraining
     */
    select?: VolunteerTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerTraining
     */
    omit?: VolunteerTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerTrainingInclude<ExtArgs> | null
    /**
     * Filter, which VolunteerTraining to fetch.
     */
    where: VolunteerTrainingWhereUniqueInput
  }

  /**
   * VolunteerTraining findUniqueOrThrow
   */
  export type VolunteerTrainingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerTraining
     */
    select?: VolunteerTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerTraining
     */
    omit?: VolunteerTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerTrainingInclude<ExtArgs> | null
    /**
     * Filter, which VolunteerTraining to fetch.
     */
    where: VolunteerTrainingWhereUniqueInput
  }

  /**
   * VolunteerTraining findFirst
   */
  export type VolunteerTrainingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerTraining
     */
    select?: VolunteerTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerTraining
     */
    omit?: VolunteerTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerTrainingInclude<ExtArgs> | null
    /**
     * Filter, which VolunteerTraining to fetch.
     */
    where?: VolunteerTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolunteerTrainings to fetch.
     */
    orderBy?: VolunteerTrainingOrderByWithRelationInput | VolunteerTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VolunteerTrainings.
     */
    cursor?: VolunteerTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolunteerTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolunteerTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VolunteerTrainings.
     */
    distinct?: VolunteerTrainingScalarFieldEnum | VolunteerTrainingScalarFieldEnum[]
  }

  /**
   * VolunteerTraining findFirstOrThrow
   */
  export type VolunteerTrainingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerTraining
     */
    select?: VolunteerTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerTraining
     */
    omit?: VolunteerTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerTrainingInclude<ExtArgs> | null
    /**
     * Filter, which VolunteerTraining to fetch.
     */
    where?: VolunteerTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolunteerTrainings to fetch.
     */
    orderBy?: VolunteerTrainingOrderByWithRelationInput | VolunteerTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VolunteerTrainings.
     */
    cursor?: VolunteerTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolunteerTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolunteerTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VolunteerTrainings.
     */
    distinct?: VolunteerTrainingScalarFieldEnum | VolunteerTrainingScalarFieldEnum[]
  }

  /**
   * VolunteerTraining findMany
   */
  export type VolunteerTrainingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerTraining
     */
    select?: VolunteerTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerTraining
     */
    omit?: VolunteerTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerTrainingInclude<ExtArgs> | null
    /**
     * Filter, which VolunteerTrainings to fetch.
     */
    where?: VolunteerTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolunteerTrainings to fetch.
     */
    orderBy?: VolunteerTrainingOrderByWithRelationInput | VolunteerTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VolunteerTrainings.
     */
    cursor?: VolunteerTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolunteerTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolunteerTrainings.
     */
    skip?: number
    distinct?: VolunteerTrainingScalarFieldEnum | VolunteerTrainingScalarFieldEnum[]
  }

  /**
   * VolunteerTraining create
   */
  export type VolunteerTrainingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerTraining
     */
    select?: VolunteerTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerTraining
     */
    omit?: VolunteerTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerTrainingInclude<ExtArgs> | null
    /**
     * The data needed to create a VolunteerTraining.
     */
    data: XOR<VolunteerTrainingCreateInput, VolunteerTrainingUncheckedCreateInput>
  }

  /**
   * VolunteerTraining createMany
   */
  export type VolunteerTrainingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VolunteerTrainings.
     */
    data: VolunteerTrainingCreateManyInput | VolunteerTrainingCreateManyInput[]
  }

  /**
   * VolunteerTraining createManyAndReturn
   */
  export type VolunteerTrainingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerTraining
     */
    select?: VolunteerTrainingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerTraining
     */
    omit?: VolunteerTrainingOmit<ExtArgs> | null
    /**
     * The data used to create many VolunteerTrainings.
     */
    data: VolunteerTrainingCreateManyInput | VolunteerTrainingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerTrainingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VolunteerTraining update
   */
  export type VolunteerTrainingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerTraining
     */
    select?: VolunteerTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerTraining
     */
    omit?: VolunteerTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerTrainingInclude<ExtArgs> | null
    /**
     * The data needed to update a VolunteerTraining.
     */
    data: XOR<VolunteerTrainingUpdateInput, VolunteerTrainingUncheckedUpdateInput>
    /**
     * Choose, which VolunteerTraining to update.
     */
    where: VolunteerTrainingWhereUniqueInput
  }

  /**
   * VolunteerTraining updateMany
   */
  export type VolunteerTrainingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VolunteerTrainings.
     */
    data: XOR<VolunteerTrainingUpdateManyMutationInput, VolunteerTrainingUncheckedUpdateManyInput>
    /**
     * Filter which VolunteerTrainings to update
     */
    where?: VolunteerTrainingWhereInput
    /**
     * Limit how many VolunteerTrainings to update.
     */
    limit?: number
  }

  /**
   * VolunteerTraining updateManyAndReturn
   */
  export type VolunteerTrainingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerTraining
     */
    select?: VolunteerTrainingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerTraining
     */
    omit?: VolunteerTrainingOmit<ExtArgs> | null
    /**
     * The data used to update VolunteerTrainings.
     */
    data: XOR<VolunteerTrainingUpdateManyMutationInput, VolunteerTrainingUncheckedUpdateManyInput>
    /**
     * Filter which VolunteerTrainings to update
     */
    where?: VolunteerTrainingWhereInput
    /**
     * Limit how many VolunteerTrainings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerTrainingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VolunteerTraining upsert
   */
  export type VolunteerTrainingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerTraining
     */
    select?: VolunteerTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerTraining
     */
    omit?: VolunteerTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerTrainingInclude<ExtArgs> | null
    /**
     * The filter to search for the VolunteerTraining to update in case it exists.
     */
    where: VolunteerTrainingWhereUniqueInput
    /**
     * In case the VolunteerTraining found by the `where` argument doesn't exist, create a new VolunteerTraining with this data.
     */
    create: XOR<VolunteerTrainingCreateInput, VolunteerTrainingUncheckedCreateInput>
    /**
     * In case the VolunteerTraining was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VolunteerTrainingUpdateInput, VolunteerTrainingUncheckedUpdateInput>
  }

  /**
   * VolunteerTraining delete
   */
  export type VolunteerTrainingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerTraining
     */
    select?: VolunteerTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerTraining
     */
    omit?: VolunteerTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerTrainingInclude<ExtArgs> | null
    /**
     * Filter which VolunteerTraining to delete.
     */
    where: VolunteerTrainingWhereUniqueInput
  }

  /**
   * VolunteerTraining deleteMany
   */
  export type VolunteerTrainingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VolunteerTrainings to delete
     */
    where?: VolunteerTrainingWhereInput
    /**
     * Limit how many VolunteerTrainings to delete.
     */
    limit?: number
  }

  /**
   * VolunteerTraining without action
   */
  export type VolunteerTrainingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerTraining
     */
    select?: VolunteerTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerTraining
     */
    omit?: VolunteerTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerTrainingInclude<ExtArgs> | null
  }


  /**
   * Model VolunteerSession
   */

  export type AggregateVolunteerSession = {
    _count: VolunteerSessionCountAggregateOutputType | null
    _avg: VolunteerSessionAvgAggregateOutputType | null
    _sum: VolunteerSessionSumAggregateOutputType | null
    _min: VolunteerSessionMinAggregateOutputType | null
    _max: VolunteerSessionMaxAggregateOutputType | null
  }

  export type VolunteerSessionAvgAggregateOutputType = {
    duration: number | null
    responseTime: number | null
    userSatisfaction: number | null
  }

  export type VolunteerSessionSumAggregateOutputType = {
    duration: number | null
    responseTime: number | null
    userSatisfaction: number | null
  }

  export type VolunteerSessionMinAggregateOutputType = {
    id: string | null
    volunteerId: string | null
    sessionType: $Enums.VolunteerSessionType | null
    startedAt: Date | null
    endedAt: Date | null
    duration: number | null
    crisisSessionId: string | null
    responseTime: number | null
    userSatisfaction: number | null
    outcome: $Enums.SessionOutcome | null
  }

  export type VolunteerSessionMaxAggregateOutputType = {
    id: string | null
    volunteerId: string | null
    sessionType: $Enums.VolunteerSessionType | null
    startedAt: Date | null
    endedAt: Date | null
    duration: number | null
    crisisSessionId: string | null
    responseTime: number | null
    userSatisfaction: number | null
    outcome: $Enums.SessionOutcome | null
  }

  export type VolunteerSessionCountAggregateOutputType = {
    id: number
    volunteerId: number
    sessionType: number
    startedAt: number
    endedAt: number
    duration: number
    crisisSessionId: number
    responseTime: number
    userSatisfaction: number
    outcome: number
    _all: number
  }


  export type VolunteerSessionAvgAggregateInputType = {
    duration?: true
    responseTime?: true
    userSatisfaction?: true
  }

  export type VolunteerSessionSumAggregateInputType = {
    duration?: true
    responseTime?: true
    userSatisfaction?: true
  }

  export type VolunteerSessionMinAggregateInputType = {
    id?: true
    volunteerId?: true
    sessionType?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    crisisSessionId?: true
    responseTime?: true
    userSatisfaction?: true
    outcome?: true
  }

  export type VolunteerSessionMaxAggregateInputType = {
    id?: true
    volunteerId?: true
    sessionType?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    crisisSessionId?: true
    responseTime?: true
    userSatisfaction?: true
    outcome?: true
  }

  export type VolunteerSessionCountAggregateInputType = {
    id?: true
    volunteerId?: true
    sessionType?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    crisisSessionId?: true
    responseTime?: true
    userSatisfaction?: true
    outcome?: true
    _all?: true
  }

  export type VolunteerSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VolunteerSession to aggregate.
     */
    where?: VolunteerSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolunteerSessions to fetch.
     */
    orderBy?: VolunteerSessionOrderByWithRelationInput | VolunteerSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VolunteerSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolunteerSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolunteerSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VolunteerSessions
    **/
    _count?: true | VolunteerSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VolunteerSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VolunteerSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VolunteerSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VolunteerSessionMaxAggregateInputType
  }

  export type GetVolunteerSessionAggregateType<T extends VolunteerSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateVolunteerSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVolunteerSession[P]>
      : GetScalarType<T[P], AggregateVolunteerSession[P]>
  }




  export type VolunteerSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolunteerSessionWhereInput
    orderBy?: VolunteerSessionOrderByWithAggregationInput | VolunteerSessionOrderByWithAggregationInput[]
    by: VolunteerSessionScalarFieldEnum[] | VolunteerSessionScalarFieldEnum
    having?: VolunteerSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VolunteerSessionCountAggregateInputType | true
    _avg?: VolunteerSessionAvgAggregateInputType
    _sum?: VolunteerSessionSumAggregateInputType
    _min?: VolunteerSessionMinAggregateInputType
    _max?: VolunteerSessionMaxAggregateInputType
  }

  export type VolunteerSessionGroupByOutputType = {
    id: string
    volunteerId: string
    sessionType: $Enums.VolunteerSessionType
    startedAt: Date
    endedAt: Date | null
    duration: number | null
    crisisSessionId: string | null
    responseTime: number | null
    userSatisfaction: number | null
    outcome: $Enums.SessionOutcome | null
    _count: VolunteerSessionCountAggregateOutputType | null
    _avg: VolunteerSessionAvgAggregateOutputType | null
    _sum: VolunteerSessionSumAggregateOutputType | null
    _min: VolunteerSessionMinAggregateOutputType | null
    _max: VolunteerSessionMaxAggregateOutputType | null
  }

  type GetVolunteerSessionGroupByPayload<T extends VolunteerSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VolunteerSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VolunteerSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VolunteerSessionGroupByOutputType[P]>
            : GetScalarType<T[P], VolunteerSessionGroupByOutputType[P]>
        }
      >
    >


  export type VolunteerSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volunteerId?: boolean
    sessionType?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    crisisSessionId?: boolean
    responseTime?: boolean
    userSatisfaction?: boolean
    outcome?: boolean
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volunteerSession"]>

  export type VolunteerSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volunteerId?: boolean
    sessionType?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    crisisSessionId?: boolean
    responseTime?: boolean
    userSatisfaction?: boolean
    outcome?: boolean
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volunteerSession"]>

  export type VolunteerSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volunteerId?: boolean
    sessionType?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    crisisSessionId?: boolean
    responseTime?: boolean
    userSatisfaction?: boolean
    outcome?: boolean
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volunteerSession"]>

  export type VolunteerSessionSelectScalar = {
    id?: boolean
    volunteerId?: boolean
    sessionType?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    crisisSessionId?: boolean
    responseTime?: boolean
    userSatisfaction?: boolean
    outcome?: boolean
  }

  export type VolunteerSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "volunteerId" | "sessionType" | "startedAt" | "endedAt" | "duration" | "crisisSessionId" | "responseTime" | "userSatisfaction" | "outcome", ExtArgs["result"]["volunteerSession"]>
  export type VolunteerSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }
  export type VolunteerSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }
  export type VolunteerSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }

  export type $VolunteerSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VolunteerSession"
    objects: {
      volunteer: Prisma.$VolunteerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      volunteerId: string
      sessionType: $Enums.VolunteerSessionType
      startedAt: Date
      endedAt: Date | null
      duration: number | null
      crisisSessionId: string | null
      responseTime: number | null
      userSatisfaction: number | null
      outcome: $Enums.SessionOutcome | null
    }, ExtArgs["result"]["volunteerSession"]>
    composites: {}
  }

  type VolunteerSessionGetPayload<S extends boolean | null | undefined | VolunteerSessionDefaultArgs> = $Result.GetResult<Prisma.$VolunteerSessionPayload, S>

  type VolunteerSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VolunteerSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: VolunteerSessionCountAggregateInputType | true
    }

  export interface VolunteerSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VolunteerSession'], meta: { name: 'VolunteerSession' } }
    /**
     * Find zero or one VolunteerSession that matches the filter.
     * @param {VolunteerSessionFindUniqueArgs} args - Arguments to find a VolunteerSession
     * @example
     * // Get one VolunteerSession
     * const volunteerSession = await prisma.volunteerSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VolunteerSessionFindUniqueArgs>(args: SelectSubset<T, VolunteerSessionFindUniqueArgs<ExtArgs>>): Prisma__VolunteerSessionClient<$Result.GetResult<Prisma.$VolunteerSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VolunteerSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VolunteerSessionFindUniqueOrThrowArgs} args - Arguments to find a VolunteerSession
     * @example
     * // Get one VolunteerSession
     * const volunteerSession = await prisma.volunteerSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VolunteerSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, VolunteerSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VolunteerSessionClient<$Result.GetResult<Prisma.$VolunteerSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VolunteerSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerSessionFindFirstArgs} args - Arguments to find a VolunteerSession
     * @example
     * // Get one VolunteerSession
     * const volunteerSession = await prisma.volunteerSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VolunteerSessionFindFirstArgs>(args?: SelectSubset<T, VolunteerSessionFindFirstArgs<ExtArgs>>): Prisma__VolunteerSessionClient<$Result.GetResult<Prisma.$VolunteerSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VolunteerSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerSessionFindFirstOrThrowArgs} args - Arguments to find a VolunteerSession
     * @example
     * // Get one VolunteerSession
     * const volunteerSession = await prisma.volunteerSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VolunteerSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, VolunteerSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__VolunteerSessionClient<$Result.GetResult<Prisma.$VolunteerSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VolunteerSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VolunteerSessions
     * const volunteerSessions = await prisma.volunteerSession.findMany()
     * 
     * // Get first 10 VolunteerSessions
     * const volunteerSessions = await prisma.volunteerSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const volunteerSessionWithIdOnly = await prisma.volunteerSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VolunteerSessionFindManyArgs>(args?: SelectSubset<T, VolunteerSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteerSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VolunteerSession.
     * @param {VolunteerSessionCreateArgs} args - Arguments to create a VolunteerSession.
     * @example
     * // Create one VolunteerSession
     * const VolunteerSession = await prisma.volunteerSession.create({
     *   data: {
     *     // ... data to create a VolunteerSession
     *   }
     * })
     * 
     */
    create<T extends VolunteerSessionCreateArgs>(args: SelectSubset<T, VolunteerSessionCreateArgs<ExtArgs>>): Prisma__VolunteerSessionClient<$Result.GetResult<Prisma.$VolunteerSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VolunteerSessions.
     * @param {VolunteerSessionCreateManyArgs} args - Arguments to create many VolunteerSessions.
     * @example
     * // Create many VolunteerSessions
     * const volunteerSession = await prisma.volunteerSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VolunteerSessionCreateManyArgs>(args?: SelectSubset<T, VolunteerSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VolunteerSessions and returns the data saved in the database.
     * @param {VolunteerSessionCreateManyAndReturnArgs} args - Arguments to create many VolunteerSessions.
     * @example
     * // Create many VolunteerSessions
     * const volunteerSession = await prisma.volunteerSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VolunteerSessions and only return the `id`
     * const volunteerSessionWithIdOnly = await prisma.volunteerSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VolunteerSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, VolunteerSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteerSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VolunteerSession.
     * @param {VolunteerSessionDeleteArgs} args - Arguments to delete one VolunteerSession.
     * @example
     * // Delete one VolunteerSession
     * const VolunteerSession = await prisma.volunteerSession.delete({
     *   where: {
     *     // ... filter to delete one VolunteerSession
     *   }
     * })
     * 
     */
    delete<T extends VolunteerSessionDeleteArgs>(args: SelectSubset<T, VolunteerSessionDeleteArgs<ExtArgs>>): Prisma__VolunteerSessionClient<$Result.GetResult<Prisma.$VolunteerSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VolunteerSession.
     * @param {VolunteerSessionUpdateArgs} args - Arguments to update one VolunteerSession.
     * @example
     * // Update one VolunteerSession
     * const volunteerSession = await prisma.volunteerSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VolunteerSessionUpdateArgs>(args: SelectSubset<T, VolunteerSessionUpdateArgs<ExtArgs>>): Prisma__VolunteerSessionClient<$Result.GetResult<Prisma.$VolunteerSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VolunteerSessions.
     * @param {VolunteerSessionDeleteManyArgs} args - Arguments to filter VolunteerSessions to delete.
     * @example
     * // Delete a few VolunteerSessions
     * const { count } = await prisma.volunteerSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VolunteerSessionDeleteManyArgs>(args?: SelectSubset<T, VolunteerSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VolunteerSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VolunteerSessions
     * const volunteerSession = await prisma.volunteerSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VolunteerSessionUpdateManyArgs>(args: SelectSubset<T, VolunteerSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VolunteerSessions and returns the data updated in the database.
     * @param {VolunteerSessionUpdateManyAndReturnArgs} args - Arguments to update many VolunteerSessions.
     * @example
     * // Update many VolunteerSessions
     * const volunteerSession = await prisma.volunteerSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VolunteerSessions and only return the `id`
     * const volunteerSessionWithIdOnly = await prisma.volunteerSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VolunteerSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, VolunteerSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteerSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VolunteerSession.
     * @param {VolunteerSessionUpsertArgs} args - Arguments to update or create a VolunteerSession.
     * @example
     * // Update or create a VolunteerSession
     * const volunteerSession = await prisma.volunteerSession.upsert({
     *   create: {
     *     // ... data to create a VolunteerSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VolunteerSession we want to update
     *   }
     * })
     */
    upsert<T extends VolunteerSessionUpsertArgs>(args: SelectSubset<T, VolunteerSessionUpsertArgs<ExtArgs>>): Prisma__VolunteerSessionClient<$Result.GetResult<Prisma.$VolunteerSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VolunteerSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerSessionCountArgs} args - Arguments to filter VolunteerSessions to count.
     * @example
     * // Count the number of VolunteerSessions
     * const count = await prisma.volunteerSession.count({
     *   where: {
     *     // ... the filter for the VolunteerSessions we want to count
     *   }
     * })
    **/
    count<T extends VolunteerSessionCountArgs>(
      args?: Subset<T, VolunteerSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VolunteerSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VolunteerSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VolunteerSessionAggregateArgs>(args: Subset<T, VolunteerSessionAggregateArgs>): Prisma.PrismaPromise<GetVolunteerSessionAggregateType<T>>

    /**
     * Group by VolunteerSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VolunteerSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VolunteerSessionGroupByArgs['orderBy'] }
        : { orderBy?: VolunteerSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VolunteerSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVolunteerSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VolunteerSession model
   */
  readonly fields: VolunteerSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VolunteerSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VolunteerSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    volunteer<T extends VolunteerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VolunteerDefaultArgs<ExtArgs>>): Prisma__VolunteerClient<$Result.GetResult<Prisma.$VolunteerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VolunteerSession model
   */
  interface VolunteerSessionFieldRefs {
    readonly id: FieldRef<"VolunteerSession", 'String'>
    readonly volunteerId: FieldRef<"VolunteerSession", 'String'>
    readonly sessionType: FieldRef<"VolunteerSession", 'VolunteerSessionType'>
    readonly startedAt: FieldRef<"VolunteerSession", 'DateTime'>
    readonly endedAt: FieldRef<"VolunteerSession", 'DateTime'>
    readonly duration: FieldRef<"VolunteerSession", 'Int'>
    readonly crisisSessionId: FieldRef<"VolunteerSession", 'String'>
    readonly responseTime: FieldRef<"VolunteerSession", 'Int'>
    readonly userSatisfaction: FieldRef<"VolunteerSession", 'Float'>
    readonly outcome: FieldRef<"VolunteerSession", 'SessionOutcome'>
  }
    

  // Custom InputTypes
  /**
   * VolunteerSession findUnique
   */
  export type VolunteerSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerSession
     */
    select?: VolunteerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerSession
     */
    omit?: VolunteerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerSessionInclude<ExtArgs> | null
    /**
     * Filter, which VolunteerSession to fetch.
     */
    where: VolunteerSessionWhereUniqueInput
  }

  /**
   * VolunteerSession findUniqueOrThrow
   */
  export type VolunteerSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerSession
     */
    select?: VolunteerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerSession
     */
    omit?: VolunteerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerSessionInclude<ExtArgs> | null
    /**
     * Filter, which VolunteerSession to fetch.
     */
    where: VolunteerSessionWhereUniqueInput
  }

  /**
   * VolunteerSession findFirst
   */
  export type VolunteerSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerSession
     */
    select?: VolunteerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerSession
     */
    omit?: VolunteerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerSessionInclude<ExtArgs> | null
    /**
     * Filter, which VolunteerSession to fetch.
     */
    where?: VolunteerSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolunteerSessions to fetch.
     */
    orderBy?: VolunteerSessionOrderByWithRelationInput | VolunteerSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VolunteerSessions.
     */
    cursor?: VolunteerSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolunteerSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolunteerSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VolunteerSessions.
     */
    distinct?: VolunteerSessionScalarFieldEnum | VolunteerSessionScalarFieldEnum[]
  }

  /**
   * VolunteerSession findFirstOrThrow
   */
  export type VolunteerSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerSession
     */
    select?: VolunteerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerSession
     */
    omit?: VolunteerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerSessionInclude<ExtArgs> | null
    /**
     * Filter, which VolunteerSession to fetch.
     */
    where?: VolunteerSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolunteerSessions to fetch.
     */
    orderBy?: VolunteerSessionOrderByWithRelationInput | VolunteerSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VolunteerSessions.
     */
    cursor?: VolunteerSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolunteerSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolunteerSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VolunteerSessions.
     */
    distinct?: VolunteerSessionScalarFieldEnum | VolunteerSessionScalarFieldEnum[]
  }

  /**
   * VolunteerSession findMany
   */
  export type VolunteerSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerSession
     */
    select?: VolunteerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerSession
     */
    omit?: VolunteerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerSessionInclude<ExtArgs> | null
    /**
     * Filter, which VolunteerSessions to fetch.
     */
    where?: VolunteerSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolunteerSessions to fetch.
     */
    orderBy?: VolunteerSessionOrderByWithRelationInput | VolunteerSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VolunteerSessions.
     */
    cursor?: VolunteerSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolunteerSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolunteerSessions.
     */
    skip?: number
    distinct?: VolunteerSessionScalarFieldEnum | VolunteerSessionScalarFieldEnum[]
  }

  /**
   * VolunteerSession create
   */
  export type VolunteerSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerSession
     */
    select?: VolunteerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerSession
     */
    omit?: VolunteerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a VolunteerSession.
     */
    data: XOR<VolunteerSessionCreateInput, VolunteerSessionUncheckedCreateInput>
  }

  /**
   * VolunteerSession createMany
   */
  export type VolunteerSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VolunteerSessions.
     */
    data: VolunteerSessionCreateManyInput | VolunteerSessionCreateManyInput[]
  }

  /**
   * VolunteerSession createManyAndReturn
   */
  export type VolunteerSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerSession
     */
    select?: VolunteerSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerSession
     */
    omit?: VolunteerSessionOmit<ExtArgs> | null
    /**
     * The data used to create many VolunteerSessions.
     */
    data: VolunteerSessionCreateManyInput | VolunteerSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VolunteerSession update
   */
  export type VolunteerSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerSession
     */
    select?: VolunteerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerSession
     */
    omit?: VolunteerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a VolunteerSession.
     */
    data: XOR<VolunteerSessionUpdateInput, VolunteerSessionUncheckedUpdateInput>
    /**
     * Choose, which VolunteerSession to update.
     */
    where: VolunteerSessionWhereUniqueInput
  }

  /**
   * VolunteerSession updateMany
   */
  export type VolunteerSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VolunteerSessions.
     */
    data: XOR<VolunteerSessionUpdateManyMutationInput, VolunteerSessionUncheckedUpdateManyInput>
    /**
     * Filter which VolunteerSessions to update
     */
    where?: VolunteerSessionWhereInput
    /**
     * Limit how many VolunteerSessions to update.
     */
    limit?: number
  }

  /**
   * VolunteerSession updateManyAndReturn
   */
  export type VolunteerSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerSession
     */
    select?: VolunteerSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerSession
     */
    omit?: VolunteerSessionOmit<ExtArgs> | null
    /**
     * The data used to update VolunteerSessions.
     */
    data: XOR<VolunteerSessionUpdateManyMutationInput, VolunteerSessionUncheckedUpdateManyInput>
    /**
     * Filter which VolunteerSessions to update
     */
    where?: VolunteerSessionWhereInput
    /**
     * Limit how many VolunteerSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VolunteerSession upsert
   */
  export type VolunteerSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerSession
     */
    select?: VolunteerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerSession
     */
    omit?: VolunteerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the VolunteerSession to update in case it exists.
     */
    where: VolunteerSessionWhereUniqueInput
    /**
     * In case the VolunteerSession found by the `where` argument doesn't exist, create a new VolunteerSession with this data.
     */
    create: XOR<VolunteerSessionCreateInput, VolunteerSessionUncheckedCreateInput>
    /**
     * In case the VolunteerSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VolunteerSessionUpdateInput, VolunteerSessionUncheckedUpdateInput>
  }

  /**
   * VolunteerSession delete
   */
  export type VolunteerSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerSession
     */
    select?: VolunteerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerSession
     */
    omit?: VolunteerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerSessionInclude<ExtArgs> | null
    /**
     * Filter which VolunteerSession to delete.
     */
    where: VolunteerSessionWhereUniqueInput
  }

  /**
   * VolunteerSession deleteMany
   */
  export type VolunteerSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VolunteerSessions to delete
     */
    where?: VolunteerSessionWhereInput
    /**
     * Limit how many VolunteerSessions to delete.
     */
    limit?: number
  }

  /**
   * VolunteerSession without action
   */
  export type VolunteerSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerSession
     */
    select?: VolunteerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerSession
     */
    omit?: VolunteerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerSessionInclude<ExtArgs> | null
  }


  /**
   * Model VolunteerFeedback
   */

  export type AggregateVolunteerFeedback = {
    _count: VolunteerFeedbackCountAggregateOutputType | null
    _avg: VolunteerFeedbackAvgAggregateOutputType | null
    _sum: VolunteerFeedbackSumAggregateOutputType | null
    _min: VolunteerFeedbackMinAggregateOutputType | null
    _max: VolunteerFeedbackMaxAggregateOutputType | null
  }

  export type VolunteerFeedbackAvgAggregateOutputType = {
    rating: number | null
  }

  export type VolunteerFeedbackSumAggregateOutputType = {
    rating: number | null
  }

  export type VolunteerFeedbackMinAggregateOutputType = {
    id: string | null
    volunteerId: string | null
    sessionId: string | null
    feedbackType: $Enums.FeedbackType | null
    rating: number | null
    comment: string | null
    submittedBy: string | null
    sourceType: $Enums.FeedbackSource | null
    submittedAt: Date | null
    isAnonymous: boolean | null
    isApproved: boolean | null
    moderatedAt: Date | null
    moderatedBy: string | null
  }

  export type VolunteerFeedbackMaxAggregateOutputType = {
    id: string | null
    volunteerId: string | null
    sessionId: string | null
    feedbackType: $Enums.FeedbackType | null
    rating: number | null
    comment: string | null
    submittedBy: string | null
    sourceType: $Enums.FeedbackSource | null
    submittedAt: Date | null
    isAnonymous: boolean | null
    isApproved: boolean | null
    moderatedAt: Date | null
    moderatedBy: string | null
  }

  export type VolunteerFeedbackCountAggregateOutputType = {
    id: number
    volunteerId: number
    sessionId: number
    feedbackType: number
    rating: number
    comment: number
    submittedBy: number
    sourceType: number
    submittedAt: number
    isAnonymous: number
    isApproved: number
    moderatedAt: number
    moderatedBy: number
    _all: number
  }


  export type VolunteerFeedbackAvgAggregateInputType = {
    rating?: true
  }

  export type VolunteerFeedbackSumAggregateInputType = {
    rating?: true
  }

  export type VolunteerFeedbackMinAggregateInputType = {
    id?: true
    volunteerId?: true
    sessionId?: true
    feedbackType?: true
    rating?: true
    comment?: true
    submittedBy?: true
    sourceType?: true
    submittedAt?: true
    isAnonymous?: true
    isApproved?: true
    moderatedAt?: true
    moderatedBy?: true
  }

  export type VolunteerFeedbackMaxAggregateInputType = {
    id?: true
    volunteerId?: true
    sessionId?: true
    feedbackType?: true
    rating?: true
    comment?: true
    submittedBy?: true
    sourceType?: true
    submittedAt?: true
    isAnonymous?: true
    isApproved?: true
    moderatedAt?: true
    moderatedBy?: true
  }

  export type VolunteerFeedbackCountAggregateInputType = {
    id?: true
    volunteerId?: true
    sessionId?: true
    feedbackType?: true
    rating?: true
    comment?: true
    submittedBy?: true
    sourceType?: true
    submittedAt?: true
    isAnonymous?: true
    isApproved?: true
    moderatedAt?: true
    moderatedBy?: true
    _all?: true
  }

  export type VolunteerFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VolunteerFeedback to aggregate.
     */
    where?: VolunteerFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolunteerFeedbacks to fetch.
     */
    orderBy?: VolunteerFeedbackOrderByWithRelationInput | VolunteerFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VolunteerFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolunteerFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolunteerFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VolunteerFeedbacks
    **/
    _count?: true | VolunteerFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VolunteerFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VolunteerFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VolunteerFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VolunteerFeedbackMaxAggregateInputType
  }

  export type GetVolunteerFeedbackAggregateType<T extends VolunteerFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateVolunteerFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVolunteerFeedback[P]>
      : GetScalarType<T[P], AggregateVolunteerFeedback[P]>
  }




  export type VolunteerFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolunteerFeedbackWhereInput
    orderBy?: VolunteerFeedbackOrderByWithAggregationInput | VolunteerFeedbackOrderByWithAggregationInput[]
    by: VolunteerFeedbackScalarFieldEnum[] | VolunteerFeedbackScalarFieldEnum
    having?: VolunteerFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VolunteerFeedbackCountAggregateInputType | true
    _avg?: VolunteerFeedbackAvgAggregateInputType
    _sum?: VolunteerFeedbackSumAggregateInputType
    _min?: VolunteerFeedbackMinAggregateInputType
    _max?: VolunteerFeedbackMaxAggregateInputType
  }

  export type VolunteerFeedbackGroupByOutputType = {
    id: string
    volunteerId: string
    sessionId: string | null
    feedbackType: $Enums.FeedbackType
    rating: number
    comment: string | null
    submittedBy: string | null
    sourceType: $Enums.FeedbackSource
    submittedAt: Date
    isAnonymous: boolean
    isApproved: boolean
    moderatedAt: Date | null
    moderatedBy: string | null
    _count: VolunteerFeedbackCountAggregateOutputType | null
    _avg: VolunteerFeedbackAvgAggregateOutputType | null
    _sum: VolunteerFeedbackSumAggregateOutputType | null
    _min: VolunteerFeedbackMinAggregateOutputType | null
    _max: VolunteerFeedbackMaxAggregateOutputType | null
  }

  type GetVolunteerFeedbackGroupByPayload<T extends VolunteerFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VolunteerFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VolunteerFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VolunteerFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], VolunteerFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type VolunteerFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volunteerId?: boolean
    sessionId?: boolean
    feedbackType?: boolean
    rating?: boolean
    comment?: boolean
    submittedBy?: boolean
    sourceType?: boolean
    submittedAt?: boolean
    isAnonymous?: boolean
    isApproved?: boolean
    moderatedAt?: boolean
    moderatedBy?: boolean
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volunteerFeedback"]>

  export type VolunteerFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volunteerId?: boolean
    sessionId?: boolean
    feedbackType?: boolean
    rating?: boolean
    comment?: boolean
    submittedBy?: boolean
    sourceType?: boolean
    submittedAt?: boolean
    isAnonymous?: boolean
    isApproved?: boolean
    moderatedAt?: boolean
    moderatedBy?: boolean
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volunteerFeedback"]>

  export type VolunteerFeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volunteerId?: boolean
    sessionId?: boolean
    feedbackType?: boolean
    rating?: boolean
    comment?: boolean
    submittedBy?: boolean
    sourceType?: boolean
    submittedAt?: boolean
    isAnonymous?: boolean
    isApproved?: boolean
    moderatedAt?: boolean
    moderatedBy?: boolean
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volunteerFeedback"]>

  export type VolunteerFeedbackSelectScalar = {
    id?: boolean
    volunteerId?: boolean
    sessionId?: boolean
    feedbackType?: boolean
    rating?: boolean
    comment?: boolean
    submittedBy?: boolean
    sourceType?: boolean
    submittedAt?: boolean
    isAnonymous?: boolean
    isApproved?: boolean
    moderatedAt?: boolean
    moderatedBy?: boolean
  }

  export type VolunteerFeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "volunteerId" | "sessionId" | "feedbackType" | "rating" | "comment" | "submittedBy" | "sourceType" | "submittedAt" | "isAnonymous" | "isApproved" | "moderatedAt" | "moderatedBy", ExtArgs["result"]["volunteerFeedback"]>
  export type VolunteerFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }
  export type VolunteerFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }
  export type VolunteerFeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    volunteer?: boolean | VolunteerDefaultArgs<ExtArgs>
  }

  export type $VolunteerFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VolunteerFeedback"
    objects: {
      volunteer: Prisma.$VolunteerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      volunteerId: string
      sessionId: string | null
      feedbackType: $Enums.FeedbackType
      rating: number
      comment: string | null
      submittedBy: string | null
      sourceType: $Enums.FeedbackSource
      submittedAt: Date
      isAnonymous: boolean
      isApproved: boolean
      moderatedAt: Date | null
      moderatedBy: string | null
    }, ExtArgs["result"]["volunteerFeedback"]>
    composites: {}
  }

  type VolunteerFeedbackGetPayload<S extends boolean | null | undefined | VolunteerFeedbackDefaultArgs> = $Result.GetResult<Prisma.$VolunteerFeedbackPayload, S>

  type VolunteerFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VolunteerFeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: VolunteerFeedbackCountAggregateInputType | true
    }

  export interface VolunteerFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VolunteerFeedback'], meta: { name: 'VolunteerFeedback' } }
    /**
     * Find zero or one VolunteerFeedback that matches the filter.
     * @param {VolunteerFeedbackFindUniqueArgs} args - Arguments to find a VolunteerFeedback
     * @example
     * // Get one VolunteerFeedback
     * const volunteerFeedback = await prisma.volunteerFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VolunteerFeedbackFindUniqueArgs>(args: SelectSubset<T, VolunteerFeedbackFindUniqueArgs<ExtArgs>>): Prisma__VolunteerFeedbackClient<$Result.GetResult<Prisma.$VolunteerFeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VolunteerFeedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VolunteerFeedbackFindUniqueOrThrowArgs} args - Arguments to find a VolunteerFeedback
     * @example
     * // Get one VolunteerFeedback
     * const volunteerFeedback = await prisma.volunteerFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VolunteerFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, VolunteerFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VolunteerFeedbackClient<$Result.GetResult<Prisma.$VolunteerFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VolunteerFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerFeedbackFindFirstArgs} args - Arguments to find a VolunteerFeedback
     * @example
     * // Get one VolunteerFeedback
     * const volunteerFeedback = await prisma.volunteerFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VolunteerFeedbackFindFirstArgs>(args?: SelectSubset<T, VolunteerFeedbackFindFirstArgs<ExtArgs>>): Prisma__VolunteerFeedbackClient<$Result.GetResult<Prisma.$VolunteerFeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VolunteerFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerFeedbackFindFirstOrThrowArgs} args - Arguments to find a VolunteerFeedback
     * @example
     * // Get one VolunteerFeedback
     * const volunteerFeedback = await prisma.volunteerFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VolunteerFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, VolunteerFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__VolunteerFeedbackClient<$Result.GetResult<Prisma.$VolunteerFeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VolunteerFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VolunteerFeedbacks
     * const volunteerFeedbacks = await prisma.volunteerFeedback.findMany()
     * 
     * // Get first 10 VolunteerFeedbacks
     * const volunteerFeedbacks = await prisma.volunteerFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const volunteerFeedbackWithIdOnly = await prisma.volunteerFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VolunteerFeedbackFindManyArgs>(args?: SelectSubset<T, VolunteerFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteerFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VolunteerFeedback.
     * @param {VolunteerFeedbackCreateArgs} args - Arguments to create a VolunteerFeedback.
     * @example
     * // Create one VolunteerFeedback
     * const VolunteerFeedback = await prisma.volunteerFeedback.create({
     *   data: {
     *     // ... data to create a VolunteerFeedback
     *   }
     * })
     * 
     */
    create<T extends VolunteerFeedbackCreateArgs>(args: SelectSubset<T, VolunteerFeedbackCreateArgs<ExtArgs>>): Prisma__VolunteerFeedbackClient<$Result.GetResult<Prisma.$VolunteerFeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VolunteerFeedbacks.
     * @param {VolunteerFeedbackCreateManyArgs} args - Arguments to create many VolunteerFeedbacks.
     * @example
     * // Create many VolunteerFeedbacks
     * const volunteerFeedback = await prisma.volunteerFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VolunteerFeedbackCreateManyArgs>(args?: SelectSubset<T, VolunteerFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VolunteerFeedbacks and returns the data saved in the database.
     * @param {VolunteerFeedbackCreateManyAndReturnArgs} args - Arguments to create many VolunteerFeedbacks.
     * @example
     * // Create many VolunteerFeedbacks
     * const volunteerFeedback = await prisma.volunteerFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VolunteerFeedbacks and only return the `id`
     * const volunteerFeedbackWithIdOnly = await prisma.volunteerFeedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VolunteerFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, VolunteerFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteerFeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VolunteerFeedback.
     * @param {VolunteerFeedbackDeleteArgs} args - Arguments to delete one VolunteerFeedback.
     * @example
     * // Delete one VolunteerFeedback
     * const VolunteerFeedback = await prisma.volunteerFeedback.delete({
     *   where: {
     *     // ... filter to delete one VolunteerFeedback
     *   }
     * })
     * 
     */
    delete<T extends VolunteerFeedbackDeleteArgs>(args: SelectSubset<T, VolunteerFeedbackDeleteArgs<ExtArgs>>): Prisma__VolunteerFeedbackClient<$Result.GetResult<Prisma.$VolunteerFeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VolunteerFeedback.
     * @param {VolunteerFeedbackUpdateArgs} args - Arguments to update one VolunteerFeedback.
     * @example
     * // Update one VolunteerFeedback
     * const volunteerFeedback = await prisma.volunteerFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VolunteerFeedbackUpdateArgs>(args: SelectSubset<T, VolunteerFeedbackUpdateArgs<ExtArgs>>): Prisma__VolunteerFeedbackClient<$Result.GetResult<Prisma.$VolunteerFeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VolunteerFeedbacks.
     * @param {VolunteerFeedbackDeleteManyArgs} args - Arguments to filter VolunteerFeedbacks to delete.
     * @example
     * // Delete a few VolunteerFeedbacks
     * const { count } = await prisma.volunteerFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VolunteerFeedbackDeleteManyArgs>(args?: SelectSubset<T, VolunteerFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VolunteerFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VolunteerFeedbacks
     * const volunteerFeedback = await prisma.volunteerFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VolunteerFeedbackUpdateManyArgs>(args: SelectSubset<T, VolunteerFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VolunteerFeedbacks and returns the data updated in the database.
     * @param {VolunteerFeedbackUpdateManyAndReturnArgs} args - Arguments to update many VolunteerFeedbacks.
     * @example
     * // Update many VolunteerFeedbacks
     * const volunteerFeedback = await prisma.volunteerFeedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VolunteerFeedbacks and only return the `id`
     * const volunteerFeedbackWithIdOnly = await prisma.volunteerFeedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VolunteerFeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, VolunteerFeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteerFeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VolunteerFeedback.
     * @param {VolunteerFeedbackUpsertArgs} args - Arguments to update or create a VolunteerFeedback.
     * @example
     * // Update or create a VolunteerFeedback
     * const volunteerFeedback = await prisma.volunteerFeedback.upsert({
     *   create: {
     *     // ... data to create a VolunteerFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VolunteerFeedback we want to update
     *   }
     * })
     */
    upsert<T extends VolunteerFeedbackUpsertArgs>(args: SelectSubset<T, VolunteerFeedbackUpsertArgs<ExtArgs>>): Prisma__VolunteerFeedbackClient<$Result.GetResult<Prisma.$VolunteerFeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VolunteerFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerFeedbackCountArgs} args - Arguments to filter VolunteerFeedbacks to count.
     * @example
     * // Count the number of VolunteerFeedbacks
     * const count = await prisma.volunteerFeedback.count({
     *   where: {
     *     // ... the filter for the VolunteerFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends VolunteerFeedbackCountArgs>(
      args?: Subset<T, VolunteerFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VolunteerFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VolunteerFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VolunteerFeedbackAggregateArgs>(args: Subset<T, VolunteerFeedbackAggregateArgs>): Prisma.PrismaPromise<GetVolunteerFeedbackAggregateType<T>>

    /**
     * Group by VolunteerFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteerFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VolunteerFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VolunteerFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: VolunteerFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VolunteerFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVolunteerFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VolunteerFeedback model
   */
  readonly fields: VolunteerFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VolunteerFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VolunteerFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    volunteer<T extends VolunteerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VolunteerDefaultArgs<ExtArgs>>): Prisma__VolunteerClient<$Result.GetResult<Prisma.$VolunteerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VolunteerFeedback model
   */
  interface VolunteerFeedbackFieldRefs {
    readonly id: FieldRef<"VolunteerFeedback", 'String'>
    readonly volunteerId: FieldRef<"VolunteerFeedback", 'String'>
    readonly sessionId: FieldRef<"VolunteerFeedback", 'String'>
    readonly feedbackType: FieldRef<"VolunteerFeedback", 'FeedbackType'>
    readonly rating: FieldRef<"VolunteerFeedback", 'Int'>
    readonly comment: FieldRef<"VolunteerFeedback", 'String'>
    readonly submittedBy: FieldRef<"VolunteerFeedback", 'String'>
    readonly sourceType: FieldRef<"VolunteerFeedback", 'FeedbackSource'>
    readonly submittedAt: FieldRef<"VolunteerFeedback", 'DateTime'>
    readonly isAnonymous: FieldRef<"VolunteerFeedback", 'Boolean'>
    readonly isApproved: FieldRef<"VolunteerFeedback", 'Boolean'>
    readonly moderatedAt: FieldRef<"VolunteerFeedback", 'DateTime'>
    readonly moderatedBy: FieldRef<"VolunteerFeedback", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VolunteerFeedback findUnique
   */
  export type VolunteerFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerFeedback
     */
    select?: VolunteerFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerFeedback
     */
    omit?: VolunteerFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which VolunteerFeedback to fetch.
     */
    where: VolunteerFeedbackWhereUniqueInput
  }

  /**
   * VolunteerFeedback findUniqueOrThrow
   */
  export type VolunteerFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerFeedback
     */
    select?: VolunteerFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerFeedback
     */
    omit?: VolunteerFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which VolunteerFeedback to fetch.
     */
    where: VolunteerFeedbackWhereUniqueInput
  }

  /**
   * VolunteerFeedback findFirst
   */
  export type VolunteerFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerFeedback
     */
    select?: VolunteerFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerFeedback
     */
    omit?: VolunteerFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which VolunteerFeedback to fetch.
     */
    where?: VolunteerFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolunteerFeedbacks to fetch.
     */
    orderBy?: VolunteerFeedbackOrderByWithRelationInput | VolunteerFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VolunteerFeedbacks.
     */
    cursor?: VolunteerFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolunteerFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolunteerFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VolunteerFeedbacks.
     */
    distinct?: VolunteerFeedbackScalarFieldEnum | VolunteerFeedbackScalarFieldEnum[]
  }

  /**
   * VolunteerFeedback findFirstOrThrow
   */
  export type VolunteerFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerFeedback
     */
    select?: VolunteerFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerFeedback
     */
    omit?: VolunteerFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which VolunteerFeedback to fetch.
     */
    where?: VolunteerFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolunteerFeedbacks to fetch.
     */
    orderBy?: VolunteerFeedbackOrderByWithRelationInput | VolunteerFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VolunteerFeedbacks.
     */
    cursor?: VolunteerFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolunteerFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolunteerFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VolunteerFeedbacks.
     */
    distinct?: VolunteerFeedbackScalarFieldEnum | VolunteerFeedbackScalarFieldEnum[]
  }

  /**
   * VolunteerFeedback findMany
   */
  export type VolunteerFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerFeedback
     */
    select?: VolunteerFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerFeedback
     */
    omit?: VolunteerFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which VolunteerFeedbacks to fetch.
     */
    where?: VolunteerFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolunteerFeedbacks to fetch.
     */
    orderBy?: VolunteerFeedbackOrderByWithRelationInput | VolunteerFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VolunteerFeedbacks.
     */
    cursor?: VolunteerFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolunteerFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolunteerFeedbacks.
     */
    skip?: number
    distinct?: VolunteerFeedbackScalarFieldEnum | VolunteerFeedbackScalarFieldEnum[]
  }

  /**
   * VolunteerFeedback create
   */
  export type VolunteerFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerFeedback
     */
    select?: VolunteerFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerFeedback
     */
    omit?: VolunteerFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a VolunteerFeedback.
     */
    data: XOR<VolunteerFeedbackCreateInput, VolunteerFeedbackUncheckedCreateInput>
  }

  /**
   * VolunteerFeedback createMany
   */
  export type VolunteerFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VolunteerFeedbacks.
     */
    data: VolunteerFeedbackCreateManyInput | VolunteerFeedbackCreateManyInput[]
  }

  /**
   * VolunteerFeedback createManyAndReturn
   */
  export type VolunteerFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerFeedback
     */
    select?: VolunteerFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerFeedback
     */
    omit?: VolunteerFeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many VolunteerFeedbacks.
     */
    data: VolunteerFeedbackCreateManyInput | VolunteerFeedbackCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VolunteerFeedback update
   */
  export type VolunteerFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerFeedback
     */
    select?: VolunteerFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerFeedback
     */
    omit?: VolunteerFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a VolunteerFeedback.
     */
    data: XOR<VolunteerFeedbackUpdateInput, VolunteerFeedbackUncheckedUpdateInput>
    /**
     * Choose, which VolunteerFeedback to update.
     */
    where: VolunteerFeedbackWhereUniqueInput
  }

  /**
   * VolunteerFeedback updateMany
   */
  export type VolunteerFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VolunteerFeedbacks.
     */
    data: XOR<VolunteerFeedbackUpdateManyMutationInput, VolunteerFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which VolunteerFeedbacks to update
     */
    where?: VolunteerFeedbackWhereInput
    /**
     * Limit how many VolunteerFeedbacks to update.
     */
    limit?: number
  }

  /**
   * VolunteerFeedback updateManyAndReturn
   */
  export type VolunteerFeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerFeedback
     */
    select?: VolunteerFeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerFeedback
     */
    omit?: VolunteerFeedbackOmit<ExtArgs> | null
    /**
     * The data used to update VolunteerFeedbacks.
     */
    data: XOR<VolunteerFeedbackUpdateManyMutationInput, VolunteerFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which VolunteerFeedbacks to update
     */
    where?: VolunteerFeedbackWhereInput
    /**
     * Limit how many VolunteerFeedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerFeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VolunteerFeedback upsert
   */
  export type VolunteerFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerFeedback
     */
    select?: VolunteerFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerFeedback
     */
    omit?: VolunteerFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the VolunteerFeedback to update in case it exists.
     */
    where: VolunteerFeedbackWhereUniqueInput
    /**
     * In case the VolunteerFeedback found by the `where` argument doesn't exist, create a new VolunteerFeedback with this data.
     */
    create: XOR<VolunteerFeedbackCreateInput, VolunteerFeedbackUncheckedCreateInput>
    /**
     * In case the VolunteerFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VolunteerFeedbackUpdateInput, VolunteerFeedbackUncheckedUpdateInput>
  }

  /**
   * VolunteerFeedback delete
   */
  export type VolunteerFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerFeedback
     */
    select?: VolunteerFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerFeedback
     */
    omit?: VolunteerFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerFeedbackInclude<ExtArgs> | null
    /**
     * Filter which VolunteerFeedback to delete.
     */
    where: VolunteerFeedbackWhereUniqueInput
  }

  /**
   * VolunteerFeedback deleteMany
   */
  export type VolunteerFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VolunteerFeedbacks to delete
     */
    where?: VolunteerFeedbackWhereInput
    /**
     * Limit how many VolunteerFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * VolunteerFeedback without action
   */
  export type VolunteerFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteerFeedback
     */
    select?: VolunteerFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolunteerFeedback
     */
    omit?: VolunteerFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteerFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model CrisisResourceUsage
   */

  export type AggregateCrisisResourceUsage = {
    _count: CrisisResourceUsageCountAggregateOutputType | null
    _avg: CrisisResourceUsageAvgAggregateOutputType | null
    _sum: CrisisResourceUsageSumAggregateOutputType | null
    _min: CrisisResourceUsageMinAggregateOutputType | null
    _max: CrisisResourceUsageMaxAggregateOutputType | null
  }

  export type CrisisResourceUsageAvgAggregateOutputType = {
    timeSpent: number | null
    helpfulRating: number | null
  }

  export type CrisisResourceUsageSumAggregateOutputType = {
    timeSpent: number | null
    helpfulRating: number | null
  }

  export type CrisisResourceUsageMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    resourceId: string | null
    accessedAt: Date | null
    timeSpent: number | null
    wasHelpful: boolean | null
    helpfulRating: number | null
    resourceTitle: string | null
    resourceType: $Enums.ResourceCategory | null
  }

  export type CrisisResourceUsageMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    resourceId: string | null
    accessedAt: Date | null
    timeSpent: number | null
    wasHelpful: boolean | null
    helpfulRating: number | null
    resourceTitle: string | null
    resourceType: $Enums.ResourceCategory | null
  }

  export type CrisisResourceUsageCountAggregateOutputType = {
    id: number
    sessionId: number
    resourceId: number
    accessedAt: number
    timeSpent: number
    wasHelpful: number
    helpfulRating: number
    resourceTitle: number
    resourceType: number
    _all: number
  }


  export type CrisisResourceUsageAvgAggregateInputType = {
    timeSpent?: true
    helpfulRating?: true
  }

  export type CrisisResourceUsageSumAggregateInputType = {
    timeSpent?: true
    helpfulRating?: true
  }

  export type CrisisResourceUsageMinAggregateInputType = {
    id?: true
    sessionId?: true
    resourceId?: true
    accessedAt?: true
    timeSpent?: true
    wasHelpful?: true
    helpfulRating?: true
    resourceTitle?: true
    resourceType?: true
  }

  export type CrisisResourceUsageMaxAggregateInputType = {
    id?: true
    sessionId?: true
    resourceId?: true
    accessedAt?: true
    timeSpent?: true
    wasHelpful?: true
    helpfulRating?: true
    resourceTitle?: true
    resourceType?: true
  }

  export type CrisisResourceUsageCountAggregateInputType = {
    id?: true
    sessionId?: true
    resourceId?: true
    accessedAt?: true
    timeSpent?: true
    wasHelpful?: true
    helpfulRating?: true
    resourceTitle?: true
    resourceType?: true
    _all?: true
  }

  export type CrisisResourceUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrisisResourceUsage to aggregate.
     */
    where?: CrisisResourceUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisResourceUsages to fetch.
     */
    orderBy?: CrisisResourceUsageOrderByWithRelationInput | CrisisResourceUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrisisResourceUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisResourceUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisResourceUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrisisResourceUsages
    **/
    _count?: true | CrisisResourceUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrisisResourceUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrisisResourceUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrisisResourceUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrisisResourceUsageMaxAggregateInputType
  }

  export type GetCrisisResourceUsageAggregateType<T extends CrisisResourceUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateCrisisResourceUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrisisResourceUsage[P]>
      : GetScalarType<T[P], AggregateCrisisResourceUsage[P]>
  }




  export type CrisisResourceUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrisisResourceUsageWhereInput
    orderBy?: CrisisResourceUsageOrderByWithAggregationInput | CrisisResourceUsageOrderByWithAggregationInput[]
    by: CrisisResourceUsageScalarFieldEnum[] | CrisisResourceUsageScalarFieldEnum
    having?: CrisisResourceUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrisisResourceUsageCountAggregateInputType | true
    _avg?: CrisisResourceUsageAvgAggregateInputType
    _sum?: CrisisResourceUsageSumAggregateInputType
    _min?: CrisisResourceUsageMinAggregateInputType
    _max?: CrisisResourceUsageMaxAggregateInputType
  }

  export type CrisisResourceUsageGroupByOutputType = {
    id: string
    sessionId: string
    resourceId: string
    accessedAt: Date
    timeSpent: number | null
    wasHelpful: boolean | null
    helpfulRating: number | null
    resourceTitle: string
    resourceType: $Enums.ResourceCategory
    _count: CrisisResourceUsageCountAggregateOutputType | null
    _avg: CrisisResourceUsageAvgAggregateOutputType | null
    _sum: CrisisResourceUsageSumAggregateOutputType | null
    _min: CrisisResourceUsageMinAggregateOutputType | null
    _max: CrisisResourceUsageMaxAggregateOutputType | null
  }

  type GetCrisisResourceUsageGroupByPayload<T extends CrisisResourceUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrisisResourceUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrisisResourceUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrisisResourceUsageGroupByOutputType[P]>
            : GetScalarType<T[P], CrisisResourceUsageGroupByOutputType[P]>
        }
      >
    >


  export type CrisisResourceUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    resourceId?: boolean
    accessedAt?: boolean
    timeSpent?: boolean
    wasHelpful?: boolean
    helpfulRating?: boolean
    resourceTitle?: boolean
    resourceType?: boolean
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crisisResourceUsage"]>

  export type CrisisResourceUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    resourceId?: boolean
    accessedAt?: boolean
    timeSpent?: boolean
    wasHelpful?: boolean
    helpfulRating?: boolean
    resourceTitle?: boolean
    resourceType?: boolean
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crisisResourceUsage"]>

  export type CrisisResourceUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    resourceId?: boolean
    accessedAt?: boolean
    timeSpent?: boolean
    wasHelpful?: boolean
    helpfulRating?: boolean
    resourceTitle?: boolean
    resourceType?: boolean
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crisisResourceUsage"]>

  export type CrisisResourceUsageSelectScalar = {
    id?: boolean
    sessionId?: boolean
    resourceId?: boolean
    accessedAt?: boolean
    timeSpent?: boolean
    wasHelpful?: boolean
    helpfulRating?: boolean
    resourceTitle?: boolean
    resourceType?: boolean
  }

  export type CrisisResourceUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "resourceId" | "accessedAt" | "timeSpent" | "wasHelpful" | "helpfulRating" | "resourceTitle" | "resourceType", ExtArgs["result"]["crisisResourceUsage"]>
  export type CrisisResourceUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }
  export type CrisisResourceUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }
  export type CrisisResourceUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | CrisisSessionDefaultArgs<ExtArgs>
  }

  export type $CrisisResourceUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrisisResourceUsage"
    objects: {
      session: Prisma.$CrisisSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      resourceId: string
      accessedAt: Date
      timeSpent: number | null
      wasHelpful: boolean | null
      helpfulRating: number | null
      resourceTitle: string
      resourceType: $Enums.ResourceCategory
    }, ExtArgs["result"]["crisisResourceUsage"]>
    composites: {}
  }

  type CrisisResourceUsageGetPayload<S extends boolean | null | undefined | CrisisResourceUsageDefaultArgs> = $Result.GetResult<Prisma.$CrisisResourceUsagePayload, S>

  type CrisisResourceUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CrisisResourceUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: CrisisResourceUsageCountAggregateInputType | true
    }

  export interface CrisisResourceUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrisisResourceUsage'], meta: { name: 'CrisisResourceUsage' } }
    /**
     * Find zero or one CrisisResourceUsage that matches the filter.
     * @param {CrisisResourceUsageFindUniqueArgs} args - Arguments to find a CrisisResourceUsage
     * @example
     * // Get one CrisisResourceUsage
     * const crisisResourceUsage = await prisma.crisisResourceUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrisisResourceUsageFindUniqueArgs>(args: SelectSubset<T, CrisisResourceUsageFindUniqueArgs<ExtArgs>>): Prisma__CrisisResourceUsageClient<$Result.GetResult<Prisma.$CrisisResourceUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CrisisResourceUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CrisisResourceUsageFindUniqueOrThrowArgs} args - Arguments to find a CrisisResourceUsage
     * @example
     * // Get one CrisisResourceUsage
     * const crisisResourceUsage = await prisma.crisisResourceUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrisisResourceUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, CrisisResourceUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrisisResourceUsageClient<$Result.GetResult<Prisma.$CrisisResourceUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrisisResourceUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisResourceUsageFindFirstArgs} args - Arguments to find a CrisisResourceUsage
     * @example
     * // Get one CrisisResourceUsage
     * const crisisResourceUsage = await prisma.crisisResourceUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrisisResourceUsageFindFirstArgs>(args?: SelectSubset<T, CrisisResourceUsageFindFirstArgs<ExtArgs>>): Prisma__CrisisResourceUsageClient<$Result.GetResult<Prisma.$CrisisResourceUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrisisResourceUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisResourceUsageFindFirstOrThrowArgs} args - Arguments to find a CrisisResourceUsage
     * @example
     * // Get one CrisisResourceUsage
     * const crisisResourceUsage = await prisma.crisisResourceUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrisisResourceUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, CrisisResourceUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrisisResourceUsageClient<$Result.GetResult<Prisma.$CrisisResourceUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CrisisResourceUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisResourceUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrisisResourceUsages
     * const crisisResourceUsages = await prisma.crisisResourceUsage.findMany()
     * 
     * // Get first 10 CrisisResourceUsages
     * const crisisResourceUsages = await prisma.crisisResourceUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crisisResourceUsageWithIdOnly = await prisma.crisisResourceUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrisisResourceUsageFindManyArgs>(args?: SelectSubset<T, CrisisResourceUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisResourceUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CrisisResourceUsage.
     * @param {CrisisResourceUsageCreateArgs} args - Arguments to create a CrisisResourceUsage.
     * @example
     * // Create one CrisisResourceUsage
     * const CrisisResourceUsage = await prisma.crisisResourceUsage.create({
     *   data: {
     *     // ... data to create a CrisisResourceUsage
     *   }
     * })
     * 
     */
    create<T extends CrisisResourceUsageCreateArgs>(args: SelectSubset<T, CrisisResourceUsageCreateArgs<ExtArgs>>): Prisma__CrisisResourceUsageClient<$Result.GetResult<Prisma.$CrisisResourceUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CrisisResourceUsages.
     * @param {CrisisResourceUsageCreateManyArgs} args - Arguments to create many CrisisResourceUsages.
     * @example
     * // Create many CrisisResourceUsages
     * const crisisResourceUsage = await prisma.crisisResourceUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrisisResourceUsageCreateManyArgs>(args?: SelectSubset<T, CrisisResourceUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrisisResourceUsages and returns the data saved in the database.
     * @param {CrisisResourceUsageCreateManyAndReturnArgs} args - Arguments to create many CrisisResourceUsages.
     * @example
     * // Create many CrisisResourceUsages
     * const crisisResourceUsage = await prisma.crisisResourceUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrisisResourceUsages and only return the `id`
     * const crisisResourceUsageWithIdOnly = await prisma.crisisResourceUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrisisResourceUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, CrisisResourceUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisResourceUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CrisisResourceUsage.
     * @param {CrisisResourceUsageDeleteArgs} args - Arguments to delete one CrisisResourceUsage.
     * @example
     * // Delete one CrisisResourceUsage
     * const CrisisResourceUsage = await prisma.crisisResourceUsage.delete({
     *   where: {
     *     // ... filter to delete one CrisisResourceUsage
     *   }
     * })
     * 
     */
    delete<T extends CrisisResourceUsageDeleteArgs>(args: SelectSubset<T, CrisisResourceUsageDeleteArgs<ExtArgs>>): Prisma__CrisisResourceUsageClient<$Result.GetResult<Prisma.$CrisisResourceUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CrisisResourceUsage.
     * @param {CrisisResourceUsageUpdateArgs} args - Arguments to update one CrisisResourceUsage.
     * @example
     * // Update one CrisisResourceUsage
     * const crisisResourceUsage = await prisma.crisisResourceUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrisisResourceUsageUpdateArgs>(args: SelectSubset<T, CrisisResourceUsageUpdateArgs<ExtArgs>>): Prisma__CrisisResourceUsageClient<$Result.GetResult<Prisma.$CrisisResourceUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CrisisResourceUsages.
     * @param {CrisisResourceUsageDeleteManyArgs} args - Arguments to filter CrisisResourceUsages to delete.
     * @example
     * // Delete a few CrisisResourceUsages
     * const { count } = await prisma.crisisResourceUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrisisResourceUsageDeleteManyArgs>(args?: SelectSubset<T, CrisisResourceUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrisisResourceUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisResourceUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrisisResourceUsages
     * const crisisResourceUsage = await prisma.crisisResourceUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrisisResourceUsageUpdateManyArgs>(args: SelectSubset<T, CrisisResourceUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrisisResourceUsages and returns the data updated in the database.
     * @param {CrisisResourceUsageUpdateManyAndReturnArgs} args - Arguments to update many CrisisResourceUsages.
     * @example
     * // Update many CrisisResourceUsages
     * const crisisResourceUsage = await prisma.crisisResourceUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CrisisResourceUsages and only return the `id`
     * const crisisResourceUsageWithIdOnly = await prisma.crisisResourceUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CrisisResourceUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, CrisisResourceUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisResourceUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CrisisResourceUsage.
     * @param {CrisisResourceUsageUpsertArgs} args - Arguments to update or create a CrisisResourceUsage.
     * @example
     * // Update or create a CrisisResourceUsage
     * const crisisResourceUsage = await prisma.crisisResourceUsage.upsert({
     *   create: {
     *     // ... data to create a CrisisResourceUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrisisResourceUsage we want to update
     *   }
     * })
     */
    upsert<T extends CrisisResourceUsageUpsertArgs>(args: SelectSubset<T, CrisisResourceUsageUpsertArgs<ExtArgs>>): Prisma__CrisisResourceUsageClient<$Result.GetResult<Prisma.$CrisisResourceUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CrisisResourceUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisResourceUsageCountArgs} args - Arguments to filter CrisisResourceUsages to count.
     * @example
     * // Count the number of CrisisResourceUsages
     * const count = await prisma.crisisResourceUsage.count({
     *   where: {
     *     // ... the filter for the CrisisResourceUsages we want to count
     *   }
     * })
    **/
    count<T extends CrisisResourceUsageCountArgs>(
      args?: Subset<T, CrisisResourceUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrisisResourceUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrisisResourceUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisResourceUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrisisResourceUsageAggregateArgs>(args: Subset<T, CrisisResourceUsageAggregateArgs>): Prisma.PrismaPromise<GetCrisisResourceUsageAggregateType<T>>

    /**
     * Group by CrisisResourceUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisResourceUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrisisResourceUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrisisResourceUsageGroupByArgs['orderBy'] }
        : { orderBy?: CrisisResourceUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrisisResourceUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrisisResourceUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrisisResourceUsage model
   */
  readonly fields: CrisisResourceUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrisisResourceUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrisisResourceUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends CrisisSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CrisisSessionDefaultArgs<ExtArgs>>): Prisma__CrisisSessionClient<$Result.GetResult<Prisma.$CrisisSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrisisResourceUsage model
   */
  interface CrisisResourceUsageFieldRefs {
    readonly id: FieldRef<"CrisisResourceUsage", 'String'>
    readonly sessionId: FieldRef<"CrisisResourceUsage", 'String'>
    readonly resourceId: FieldRef<"CrisisResourceUsage", 'String'>
    readonly accessedAt: FieldRef<"CrisisResourceUsage", 'DateTime'>
    readonly timeSpent: FieldRef<"CrisisResourceUsage", 'Int'>
    readonly wasHelpful: FieldRef<"CrisisResourceUsage", 'Boolean'>
    readonly helpfulRating: FieldRef<"CrisisResourceUsage", 'Int'>
    readonly resourceTitle: FieldRef<"CrisisResourceUsage", 'String'>
    readonly resourceType: FieldRef<"CrisisResourceUsage", 'ResourceCategory'>
  }
    

  // Custom InputTypes
  /**
   * CrisisResourceUsage findUnique
   */
  export type CrisisResourceUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResourceUsage
     */
    select?: CrisisResourceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResourceUsage
     */
    omit?: CrisisResourceUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisResourceUsageInclude<ExtArgs> | null
    /**
     * Filter, which CrisisResourceUsage to fetch.
     */
    where: CrisisResourceUsageWhereUniqueInput
  }

  /**
   * CrisisResourceUsage findUniqueOrThrow
   */
  export type CrisisResourceUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResourceUsage
     */
    select?: CrisisResourceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResourceUsage
     */
    omit?: CrisisResourceUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisResourceUsageInclude<ExtArgs> | null
    /**
     * Filter, which CrisisResourceUsage to fetch.
     */
    where: CrisisResourceUsageWhereUniqueInput
  }

  /**
   * CrisisResourceUsage findFirst
   */
  export type CrisisResourceUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResourceUsage
     */
    select?: CrisisResourceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResourceUsage
     */
    omit?: CrisisResourceUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisResourceUsageInclude<ExtArgs> | null
    /**
     * Filter, which CrisisResourceUsage to fetch.
     */
    where?: CrisisResourceUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisResourceUsages to fetch.
     */
    orderBy?: CrisisResourceUsageOrderByWithRelationInput | CrisisResourceUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrisisResourceUsages.
     */
    cursor?: CrisisResourceUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisResourceUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisResourceUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrisisResourceUsages.
     */
    distinct?: CrisisResourceUsageScalarFieldEnum | CrisisResourceUsageScalarFieldEnum[]
  }

  /**
   * CrisisResourceUsage findFirstOrThrow
   */
  export type CrisisResourceUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResourceUsage
     */
    select?: CrisisResourceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResourceUsage
     */
    omit?: CrisisResourceUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisResourceUsageInclude<ExtArgs> | null
    /**
     * Filter, which CrisisResourceUsage to fetch.
     */
    where?: CrisisResourceUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisResourceUsages to fetch.
     */
    orderBy?: CrisisResourceUsageOrderByWithRelationInput | CrisisResourceUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrisisResourceUsages.
     */
    cursor?: CrisisResourceUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisResourceUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisResourceUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrisisResourceUsages.
     */
    distinct?: CrisisResourceUsageScalarFieldEnum | CrisisResourceUsageScalarFieldEnum[]
  }

  /**
   * CrisisResourceUsage findMany
   */
  export type CrisisResourceUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResourceUsage
     */
    select?: CrisisResourceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResourceUsage
     */
    omit?: CrisisResourceUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisResourceUsageInclude<ExtArgs> | null
    /**
     * Filter, which CrisisResourceUsages to fetch.
     */
    where?: CrisisResourceUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisResourceUsages to fetch.
     */
    orderBy?: CrisisResourceUsageOrderByWithRelationInput | CrisisResourceUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrisisResourceUsages.
     */
    cursor?: CrisisResourceUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisResourceUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisResourceUsages.
     */
    skip?: number
    distinct?: CrisisResourceUsageScalarFieldEnum | CrisisResourceUsageScalarFieldEnum[]
  }

  /**
   * CrisisResourceUsage create
   */
  export type CrisisResourceUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResourceUsage
     */
    select?: CrisisResourceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResourceUsage
     */
    omit?: CrisisResourceUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisResourceUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a CrisisResourceUsage.
     */
    data: XOR<CrisisResourceUsageCreateInput, CrisisResourceUsageUncheckedCreateInput>
  }

  /**
   * CrisisResourceUsage createMany
   */
  export type CrisisResourceUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrisisResourceUsages.
     */
    data: CrisisResourceUsageCreateManyInput | CrisisResourceUsageCreateManyInput[]
  }

  /**
   * CrisisResourceUsage createManyAndReturn
   */
  export type CrisisResourceUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResourceUsage
     */
    select?: CrisisResourceUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResourceUsage
     */
    omit?: CrisisResourceUsageOmit<ExtArgs> | null
    /**
     * The data used to create many CrisisResourceUsages.
     */
    data: CrisisResourceUsageCreateManyInput | CrisisResourceUsageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisResourceUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrisisResourceUsage update
   */
  export type CrisisResourceUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResourceUsage
     */
    select?: CrisisResourceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResourceUsage
     */
    omit?: CrisisResourceUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisResourceUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a CrisisResourceUsage.
     */
    data: XOR<CrisisResourceUsageUpdateInput, CrisisResourceUsageUncheckedUpdateInput>
    /**
     * Choose, which CrisisResourceUsage to update.
     */
    where: CrisisResourceUsageWhereUniqueInput
  }

  /**
   * CrisisResourceUsage updateMany
   */
  export type CrisisResourceUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrisisResourceUsages.
     */
    data: XOR<CrisisResourceUsageUpdateManyMutationInput, CrisisResourceUsageUncheckedUpdateManyInput>
    /**
     * Filter which CrisisResourceUsages to update
     */
    where?: CrisisResourceUsageWhereInput
    /**
     * Limit how many CrisisResourceUsages to update.
     */
    limit?: number
  }

  /**
   * CrisisResourceUsage updateManyAndReturn
   */
  export type CrisisResourceUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResourceUsage
     */
    select?: CrisisResourceUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResourceUsage
     */
    omit?: CrisisResourceUsageOmit<ExtArgs> | null
    /**
     * The data used to update CrisisResourceUsages.
     */
    data: XOR<CrisisResourceUsageUpdateManyMutationInput, CrisisResourceUsageUncheckedUpdateManyInput>
    /**
     * Filter which CrisisResourceUsages to update
     */
    where?: CrisisResourceUsageWhereInput
    /**
     * Limit how many CrisisResourceUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisResourceUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrisisResourceUsage upsert
   */
  export type CrisisResourceUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResourceUsage
     */
    select?: CrisisResourceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResourceUsage
     */
    omit?: CrisisResourceUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisResourceUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the CrisisResourceUsage to update in case it exists.
     */
    where: CrisisResourceUsageWhereUniqueInput
    /**
     * In case the CrisisResourceUsage found by the `where` argument doesn't exist, create a new CrisisResourceUsage with this data.
     */
    create: XOR<CrisisResourceUsageCreateInput, CrisisResourceUsageUncheckedCreateInput>
    /**
     * In case the CrisisResourceUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrisisResourceUsageUpdateInput, CrisisResourceUsageUncheckedUpdateInput>
  }

  /**
   * CrisisResourceUsage delete
   */
  export type CrisisResourceUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResourceUsage
     */
    select?: CrisisResourceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResourceUsage
     */
    omit?: CrisisResourceUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisResourceUsageInclude<ExtArgs> | null
    /**
     * Filter which CrisisResourceUsage to delete.
     */
    where: CrisisResourceUsageWhereUniqueInput
  }

  /**
   * CrisisResourceUsage deleteMany
   */
  export type CrisisResourceUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrisisResourceUsages to delete
     */
    where?: CrisisResourceUsageWhereInput
    /**
     * Limit how many CrisisResourceUsages to delete.
     */
    limit?: number
  }

  /**
   * CrisisResourceUsage without action
   */
  export type CrisisResourceUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResourceUsage
     */
    select?: CrisisResourceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResourceUsage
     */
    omit?: CrisisResourceUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrisisResourceUsageInclude<ExtArgs> | null
  }


  /**
   * Model SafetyReport
   */

  export type AggregateSafetyReport = {
    _count: SafetyReportCountAggregateOutputType | null
    _avg: SafetyReportAvgAggregateOutputType | null
    _sum: SafetyReportSumAggregateOutputType | null
    _min: SafetyReportMinAggregateOutputType | null
    _max: SafetyReportMaxAggregateOutputType | null
  }

  export type SafetyReportAvgAggregateOutputType = {
    confidence: number | null
    riskScore: number | null
  }

  export type SafetyReportSumAggregateOutputType = {
    confidence: number | null
    riskScore: number | null
  }

  export type SafetyReportMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    messageId: string | null
    reportType: $Enums.ReportType | null
    severity: $Enums.ReportSeverity | null
    status: $Enums.ReportStatus | null
    content: string | null
    reason: string | null
    confidence: number | null
    keywordsMatched: string | null
    riskScore: number | null
    reviewedBy: string | null
    reviewedAt: Date | null
    reviewNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SafetyReportMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    messageId: string | null
    reportType: $Enums.ReportType | null
    severity: $Enums.ReportSeverity | null
    status: $Enums.ReportStatus | null
    content: string | null
    reason: string | null
    confidence: number | null
    keywordsMatched: string | null
    riskScore: number | null
    reviewedBy: string | null
    reviewedAt: Date | null
    reviewNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SafetyReportCountAggregateOutputType = {
    id: number
    sessionId: number
    messageId: number
    reportType: number
    severity: number
    status: number
    content: number
    reason: number
    confidence: number
    aiAnalysis: number
    keywordsMatched: number
    riskScore: number
    reviewedBy: number
    reviewedAt: number
    reviewNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SafetyReportAvgAggregateInputType = {
    confidence?: true
    riskScore?: true
  }

  export type SafetyReportSumAggregateInputType = {
    confidence?: true
    riskScore?: true
  }

  export type SafetyReportMinAggregateInputType = {
    id?: true
    sessionId?: true
    messageId?: true
    reportType?: true
    severity?: true
    status?: true
    content?: true
    reason?: true
    confidence?: true
    keywordsMatched?: true
    riskScore?: true
    reviewedBy?: true
    reviewedAt?: true
    reviewNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SafetyReportMaxAggregateInputType = {
    id?: true
    sessionId?: true
    messageId?: true
    reportType?: true
    severity?: true
    status?: true
    content?: true
    reason?: true
    confidence?: true
    keywordsMatched?: true
    riskScore?: true
    reviewedBy?: true
    reviewedAt?: true
    reviewNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SafetyReportCountAggregateInputType = {
    id?: true
    sessionId?: true
    messageId?: true
    reportType?: true
    severity?: true
    status?: true
    content?: true
    reason?: true
    confidence?: true
    aiAnalysis?: true
    keywordsMatched?: true
    riskScore?: true
    reviewedBy?: true
    reviewedAt?: true
    reviewNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SafetyReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SafetyReport to aggregate.
     */
    where?: SafetyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyReports to fetch.
     */
    orderBy?: SafetyReportOrderByWithRelationInput | SafetyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SafetyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SafetyReports
    **/
    _count?: true | SafetyReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SafetyReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SafetyReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SafetyReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SafetyReportMaxAggregateInputType
  }

  export type GetSafetyReportAggregateType<T extends SafetyReportAggregateArgs> = {
        [P in keyof T & keyof AggregateSafetyReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSafetyReport[P]>
      : GetScalarType<T[P], AggregateSafetyReport[P]>
  }




  export type SafetyReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SafetyReportWhereInput
    orderBy?: SafetyReportOrderByWithAggregationInput | SafetyReportOrderByWithAggregationInput[]
    by: SafetyReportScalarFieldEnum[] | SafetyReportScalarFieldEnum
    having?: SafetyReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SafetyReportCountAggregateInputType | true
    _avg?: SafetyReportAvgAggregateInputType
    _sum?: SafetyReportSumAggregateInputType
    _min?: SafetyReportMinAggregateInputType
    _max?: SafetyReportMaxAggregateInputType
  }

  export type SafetyReportGroupByOutputType = {
    id: string
    sessionId: string | null
    messageId: string | null
    reportType: $Enums.ReportType
    severity: $Enums.ReportSeverity
    status: $Enums.ReportStatus
    content: string | null
    reason: string
    confidence: number
    aiAnalysis: JsonValue | null
    keywordsMatched: string | null
    riskScore: number
    reviewedBy: string | null
    reviewedAt: Date | null
    reviewNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: SafetyReportCountAggregateOutputType | null
    _avg: SafetyReportAvgAggregateOutputType | null
    _sum: SafetyReportSumAggregateOutputType | null
    _min: SafetyReportMinAggregateOutputType | null
    _max: SafetyReportMaxAggregateOutputType | null
  }

  type GetSafetyReportGroupByPayload<T extends SafetyReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SafetyReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SafetyReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SafetyReportGroupByOutputType[P]>
            : GetScalarType<T[P], SafetyReportGroupByOutputType[P]>
        }
      >
    >


  export type SafetyReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    messageId?: boolean
    reportType?: boolean
    severity?: boolean
    status?: boolean
    content?: boolean
    reason?: boolean
    confidence?: boolean
    aiAnalysis?: boolean
    keywordsMatched?: boolean
    riskScore?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reviewNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["safetyReport"]>

  export type SafetyReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    messageId?: boolean
    reportType?: boolean
    severity?: boolean
    status?: boolean
    content?: boolean
    reason?: boolean
    confidence?: boolean
    aiAnalysis?: boolean
    keywordsMatched?: boolean
    riskScore?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reviewNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["safetyReport"]>

  export type SafetyReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    messageId?: boolean
    reportType?: boolean
    severity?: boolean
    status?: boolean
    content?: boolean
    reason?: boolean
    confidence?: boolean
    aiAnalysis?: boolean
    keywordsMatched?: boolean
    riskScore?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reviewNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["safetyReport"]>

  export type SafetyReportSelectScalar = {
    id?: boolean
    sessionId?: boolean
    messageId?: boolean
    reportType?: boolean
    severity?: boolean
    status?: boolean
    content?: boolean
    reason?: boolean
    confidence?: boolean
    aiAnalysis?: boolean
    keywordsMatched?: boolean
    riskScore?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reviewNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SafetyReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "messageId" | "reportType" | "severity" | "status" | "content" | "reason" | "confidence" | "aiAnalysis" | "keywordsMatched" | "riskScore" | "reviewedBy" | "reviewedAt" | "reviewNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["safetyReport"]>

  export type $SafetyReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SafetyReport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string | null
      messageId: string | null
      reportType: $Enums.ReportType
      severity: $Enums.ReportSeverity
      status: $Enums.ReportStatus
      content: string | null
      reason: string
      confidence: number
      aiAnalysis: Prisma.JsonValue | null
      keywordsMatched: string | null
      riskScore: number
      reviewedBy: string | null
      reviewedAt: Date | null
      reviewNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["safetyReport"]>
    composites: {}
  }

  type SafetyReportGetPayload<S extends boolean | null | undefined | SafetyReportDefaultArgs> = $Result.GetResult<Prisma.$SafetyReportPayload, S>

  type SafetyReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SafetyReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SafetyReportCountAggregateInputType | true
    }

  export interface SafetyReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SafetyReport'], meta: { name: 'SafetyReport' } }
    /**
     * Find zero or one SafetyReport that matches the filter.
     * @param {SafetyReportFindUniqueArgs} args - Arguments to find a SafetyReport
     * @example
     * // Get one SafetyReport
     * const safetyReport = await prisma.safetyReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SafetyReportFindUniqueArgs>(args: SelectSubset<T, SafetyReportFindUniqueArgs<ExtArgs>>): Prisma__SafetyReportClient<$Result.GetResult<Prisma.$SafetyReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SafetyReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SafetyReportFindUniqueOrThrowArgs} args - Arguments to find a SafetyReport
     * @example
     * // Get one SafetyReport
     * const safetyReport = await prisma.safetyReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SafetyReportFindUniqueOrThrowArgs>(args: SelectSubset<T, SafetyReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SafetyReportClient<$Result.GetResult<Prisma.$SafetyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SafetyReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyReportFindFirstArgs} args - Arguments to find a SafetyReport
     * @example
     * // Get one SafetyReport
     * const safetyReport = await prisma.safetyReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SafetyReportFindFirstArgs>(args?: SelectSubset<T, SafetyReportFindFirstArgs<ExtArgs>>): Prisma__SafetyReportClient<$Result.GetResult<Prisma.$SafetyReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SafetyReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyReportFindFirstOrThrowArgs} args - Arguments to find a SafetyReport
     * @example
     * // Get one SafetyReport
     * const safetyReport = await prisma.safetyReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SafetyReportFindFirstOrThrowArgs>(args?: SelectSubset<T, SafetyReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__SafetyReportClient<$Result.GetResult<Prisma.$SafetyReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SafetyReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SafetyReports
     * const safetyReports = await prisma.safetyReport.findMany()
     * 
     * // Get first 10 SafetyReports
     * const safetyReports = await prisma.safetyReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const safetyReportWithIdOnly = await prisma.safetyReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SafetyReportFindManyArgs>(args?: SelectSubset<T, SafetyReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SafetyReport.
     * @param {SafetyReportCreateArgs} args - Arguments to create a SafetyReport.
     * @example
     * // Create one SafetyReport
     * const SafetyReport = await prisma.safetyReport.create({
     *   data: {
     *     // ... data to create a SafetyReport
     *   }
     * })
     * 
     */
    create<T extends SafetyReportCreateArgs>(args: SelectSubset<T, SafetyReportCreateArgs<ExtArgs>>): Prisma__SafetyReportClient<$Result.GetResult<Prisma.$SafetyReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SafetyReports.
     * @param {SafetyReportCreateManyArgs} args - Arguments to create many SafetyReports.
     * @example
     * // Create many SafetyReports
     * const safetyReport = await prisma.safetyReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SafetyReportCreateManyArgs>(args?: SelectSubset<T, SafetyReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SafetyReports and returns the data saved in the database.
     * @param {SafetyReportCreateManyAndReturnArgs} args - Arguments to create many SafetyReports.
     * @example
     * // Create many SafetyReports
     * const safetyReport = await prisma.safetyReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SafetyReports and only return the `id`
     * const safetyReportWithIdOnly = await prisma.safetyReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SafetyReportCreateManyAndReturnArgs>(args?: SelectSubset<T, SafetyReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetyReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SafetyReport.
     * @param {SafetyReportDeleteArgs} args - Arguments to delete one SafetyReport.
     * @example
     * // Delete one SafetyReport
     * const SafetyReport = await prisma.safetyReport.delete({
     *   where: {
     *     // ... filter to delete one SafetyReport
     *   }
     * })
     * 
     */
    delete<T extends SafetyReportDeleteArgs>(args: SelectSubset<T, SafetyReportDeleteArgs<ExtArgs>>): Prisma__SafetyReportClient<$Result.GetResult<Prisma.$SafetyReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SafetyReport.
     * @param {SafetyReportUpdateArgs} args - Arguments to update one SafetyReport.
     * @example
     * // Update one SafetyReport
     * const safetyReport = await prisma.safetyReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SafetyReportUpdateArgs>(args: SelectSubset<T, SafetyReportUpdateArgs<ExtArgs>>): Prisma__SafetyReportClient<$Result.GetResult<Prisma.$SafetyReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SafetyReports.
     * @param {SafetyReportDeleteManyArgs} args - Arguments to filter SafetyReports to delete.
     * @example
     * // Delete a few SafetyReports
     * const { count } = await prisma.safetyReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SafetyReportDeleteManyArgs>(args?: SelectSubset<T, SafetyReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SafetyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SafetyReports
     * const safetyReport = await prisma.safetyReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SafetyReportUpdateManyArgs>(args: SelectSubset<T, SafetyReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SafetyReports and returns the data updated in the database.
     * @param {SafetyReportUpdateManyAndReturnArgs} args - Arguments to update many SafetyReports.
     * @example
     * // Update many SafetyReports
     * const safetyReport = await prisma.safetyReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SafetyReports and only return the `id`
     * const safetyReportWithIdOnly = await prisma.safetyReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SafetyReportUpdateManyAndReturnArgs>(args: SelectSubset<T, SafetyReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetyReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SafetyReport.
     * @param {SafetyReportUpsertArgs} args - Arguments to update or create a SafetyReport.
     * @example
     * // Update or create a SafetyReport
     * const safetyReport = await prisma.safetyReport.upsert({
     *   create: {
     *     // ... data to create a SafetyReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SafetyReport we want to update
     *   }
     * })
     */
    upsert<T extends SafetyReportUpsertArgs>(args: SelectSubset<T, SafetyReportUpsertArgs<ExtArgs>>): Prisma__SafetyReportClient<$Result.GetResult<Prisma.$SafetyReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SafetyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyReportCountArgs} args - Arguments to filter SafetyReports to count.
     * @example
     * // Count the number of SafetyReports
     * const count = await prisma.safetyReport.count({
     *   where: {
     *     // ... the filter for the SafetyReports we want to count
     *   }
     * })
    **/
    count<T extends SafetyReportCountArgs>(
      args?: Subset<T, SafetyReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SafetyReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SafetyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SafetyReportAggregateArgs>(args: Subset<T, SafetyReportAggregateArgs>): Prisma.PrismaPromise<GetSafetyReportAggregateType<T>>

    /**
     * Group by SafetyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SafetyReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SafetyReportGroupByArgs['orderBy'] }
        : { orderBy?: SafetyReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SafetyReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSafetyReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SafetyReport model
   */
  readonly fields: SafetyReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SafetyReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SafetyReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SafetyReport model
   */
  interface SafetyReportFieldRefs {
    readonly id: FieldRef<"SafetyReport", 'String'>
    readonly sessionId: FieldRef<"SafetyReport", 'String'>
    readonly messageId: FieldRef<"SafetyReport", 'String'>
    readonly reportType: FieldRef<"SafetyReport", 'ReportType'>
    readonly severity: FieldRef<"SafetyReport", 'ReportSeverity'>
    readonly status: FieldRef<"SafetyReport", 'ReportStatus'>
    readonly content: FieldRef<"SafetyReport", 'String'>
    readonly reason: FieldRef<"SafetyReport", 'String'>
    readonly confidence: FieldRef<"SafetyReport", 'Float'>
    readonly aiAnalysis: FieldRef<"SafetyReport", 'Json'>
    readonly keywordsMatched: FieldRef<"SafetyReport", 'String'>
    readonly riskScore: FieldRef<"SafetyReport", 'Int'>
    readonly reviewedBy: FieldRef<"SafetyReport", 'String'>
    readonly reviewedAt: FieldRef<"SafetyReport", 'DateTime'>
    readonly reviewNotes: FieldRef<"SafetyReport", 'String'>
    readonly createdAt: FieldRef<"SafetyReport", 'DateTime'>
    readonly updatedAt: FieldRef<"SafetyReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SafetyReport findUnique
   */
  export type SafetyReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyReport
     */
    select?: SafetyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyReport
     */
    omit?: SafetyReportOmit<ExtArgs> | null
    /**
     * Filter, which SafetyReport to fetch.
     */
    where: SafetyReportWhereUniqueInput
  }

  /**
   * SafetyReport findUniqueOrThrow
   */
  export type SafetyReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyReport
     */
    select?: SafetyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyReport
     */
    omit?: SafetyReportOmit<ExtArgs> | null
    /**
     * Filter, which SafetyReport to fetch.
     */
    where: SafetyReportWhereUniqueInput
  }

  /**
   * SafetyReport findFirst
   */
  export type SafetyReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyReport
     */
    select?: SafetyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyReport
     */
    omit?: SafetyReportOmit<ExtArgs> | null
    /**
     * Filter, which SafetyReport to fetch.
     */
    where?: SafetyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyReports to fetch.
     */
    orderBy?: SafetyReportOrderByWithRelationInput | SafetyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SafetyReports.
     */
    cursor?: SafetyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SafetyReports.
     */
    distinct?: SafetyReportScalarFieldEnum | SafetyReportScalarFieldEnum[]
  }

  /**
   * SafetyReport findFirstOrThrow
   */
  export type SafetyReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyReport
     */
    select?: SafetyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyReport
     */
    omit?: SafetyReportOmit<ExtArgs> | null
    /**
     * Filter, which SafetyReport to fetch.
     */
    where?: SafetyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyReports to fetch.
     */
    orderBy?: SafetyReportOrderByWithRelationInput | SafetyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SafetyReports.
     */
    cursor?: SafetyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SafetyReports.
     */
    distinct?: SafetyReportScalarFieldEnum | SafetyReportScalarFieldEnum[]
  }

  /**
   * SafetyReport findMany
   */
  export type SafetyReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyReport
     */
    select?: SafetyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyReport
     */
    omit?: SafetyReportOmit<ExtArgs> | null
    /**
     * Filter, which SafetyReports to fetch.
     */
    where?: SafetyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyReports to fetch.
     */
    orderBy?: SafetyReportOrderByWithRelationInput | SafetyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SafetyReports.
     */
    cursor?: SafetyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyReports.
     */
    skip?: number
    distinct?: SafetyReportScalarFieldEnum | SafetyReportScalarFieldEnum[]
  }

  /**
   * SafetyReport create
   */
  export type SafetyReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyReport
     */
    select?: SafetyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyReport
     */
    omit?: SafetyReportOmit<ExtArgs> | null
    /**
     * The data needed to create a SafetyReport.
     */
    data: XOR<SafetyReportCreateInput, SafetyReportUncheckedCreateInput>
  }

  /**
   * SafetyReport createMany
   */
  export type SafetyReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SafetyReports.
     */
    data: SafetyReportCreateManyInput | SafetyReportCreateManyInput[]
  }

  /**
   * SafetyReport createManyAndReturn
   */
  export type SafetyReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyReport
     */
    select?: SafetyReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyReport
     */
    omit?: SafetyReportOmit<ExtArgs> | null
    /**
     * The data used to create many SafetyReports.
     */
    data: SafetyReportCreateManyInput | SafetyReportCreateManyInput[]
  }

  /**
   * SafetyReport update
   */
  export type SafetyReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyReport
     */
    select?: SafetyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyReport
     */
    omit?: SafetyReportOmit<ExtArgs> | null
    /**
     * The data needed to update a SafetyReport.
     */
    data: XOR<SafetyReportUpdateInput, SafetyReportUncheckedUpdateInput>
    /**
     * Choose, which SafetyReport to update.
     */
    where: SafetyReportWhereUniqueInput
  }

  /**
   * SafetyReport updateMany
   */
  export type SafetyReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SafetyReports.
     */
    data: XOR<SafetyReportUpdateManyMutationInput, SafetyReportUncheckedUpdateManyInput>
    /**
     * Filter which SafetyReports to update
     */
    where?: SafetyReportWhereInput
    /**
     * Limit how many SafetyReports to update.
     */
    limit?: number
  }

  /**
   * SafetyReport updateManyAndReturn
   */
  export type SafetyReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyReport
     */
    select?: SafetyReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyReport
     */
    omit?: SafetyReportOmit<ExtArgs> | null
    /**
     * The data used to update SafetyReports.
     */
    data: XOR<SafetyReportUpdateManyMutationInput, SafetyReportUncheckedUpdateManyInput>
    /**
     * Filter which SafetyReports to update
     */
    where?: SafetyReportWhereInput
    /**
     * Limit how many SafetyReports to update.
     */
    limit?: number
  }

  /**
   * SafetyReport upsert
   */
  export type SafetyReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyReport
     */
    select?: SafetyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyReport
     */
    omit?: SafetyReportOmit<ExtArgs> | null
    /**
     * The filter to search for the SafetyReport to update in case it exists.
     */
    where: SafetyReportWhereUniqueInput
    /**
     * In case the SafetyReport found by the `where` argument doesn't exist, create a new SafetyReport with this data.
     */
    create: XOR<SafetyReportCreateInput, SafetyReportUncheckedCreateInput>
    /**
     * In case the SafetyReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SafetyReportUpdateInput, SafetyReportUncheckedUpdateInput>
  }

  /**
   * SafetyReport delete
   */
  export type SafetyReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyReport
     */
    select?: SafetyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyReport
     */
    omit?: SafetyReportOmit<ExtArgs> | null
    /**
     * Filter which SafetyReport to delete.
     */
    where: SafetyReportWhereUniqueInput
  }

  /**
   * SafetyReport deleteMany
   */
  export type SafetyReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SafetyReports to delete
     */
    where?: SafetyReportWhereInput
    /**
     * Limit how many SafetyReports to delete.
     */
    limit?: number
  }

  /**
   * SafetyReport without action
   */
  export type SafetyReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyReport
     */
    select?: SafetyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyReport
     */
    omit?: SafetyReportOmit<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    errorMessage: string | null
    timestamp: Date | null
    sessionId: string | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    errorMessage: string | null
    timestamp: Date | null
    sessionId: string | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    resourceId: number
    details: number
    ipAddress: number
    userAgent: number
    success: number
    errorMessage: number
    timestamp: number
    sessionId: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    timestamp?: true
    sessionId?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    timestamp?: true
    sessionId?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    timestamp?: true
    sessionId?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    resource: string
    resourceId: string | null
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean
    errorMessage: string | null
    timestamp: Date
    sessionId: string | null
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    timestamp?: boolean
    sessionId?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    timestamp?: boolean
    sessionId?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    timestamp?: boolean
    sessionId?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    timestamp?: boolean
    sessionId?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "resource" | "resourceId" | "details" | "ipAddress" | "userAgent" | "success" | "errorMessage" | "timestamp" | "sessionId", ExtArgs["result"]["auditLog"]>

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      resource: string
      resourceId: string | null
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      success: boolean
      errorMessage: string | null
      timestamp: Date
      sessionId: string | null
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly success: FieldRef<"AuditLog", 'Boolean'>
    readonly errorMessage: FieldRef<"AuditLog", 'String'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
    readonly sessionId: FieldRef<"AuditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
  }


  /**
   * Model AnalyticsEvent
   */

  export type AggregateAnalyticsEvent = {
    _count: AnalyticsEventCountAggregateOutputType | null
    _avg: AnalyticsEventAvgAggregateOutputType | null
    _sum: AnalyticsEventSumAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  export type AnalyticsEventAvgAggregateOutputType = {
    responseTime: number | null
  }

  export type AnalyticsEventSumAggregateOutputType = {
    responseTime: number | null
  }

  export type AnalyticsEventMinAggregateOutputType = {
    id: string | null
    eventType: string | null
    eventName: string | null
    userHash: string | null
    sessionId: string | null
    timestamp: Date | null
    responseTime: number | null
    success: boolean | null
    errorCode: string | null
  }

  export type AnalyticsEventMaxAggregateOutputType = {
    id: string | null
    eventType: string | null
    eventName: string | null
    userHash: string | null
    sessionId: string | null
    timestamp: Date | null
    responseTime: number | null
    success: boolean | null
    errorCode: string | null
  }

  export type AnalyticsEventCountAggregateOutputType = {
    id: number
    eventType: number
    eventName: number
    userHash: number
    sessionId: number
    properties: number
    timestamp: number
    responseTime: number
    success: number
    errorCode: number
    _all: number
  }


  export type AnalyticsEventAvgAggregateInputType = {
    responseTime?: true
  }

  export type AnalyticsEventSumAggregateInputType = {
    responseTime?: true
  }

  export type AnalyticsEventMinAggregateInputType = {
    id?: true
    eventType?: true
    eventName?: true
    userHash?: true
    sessionId?: true
    timestamp?: true
    responseTime?: true
    success?: true
    errorCode?: true
  }

  export type AnalyticsEventMaxAggregateInputType = {
    id?: true
    eventType?: true
    eventName?: true
    userHash?: true
    sessionId?: true
    timestamp?: true
    responseTime?: true
    success?: true
    errorCode?: true
  }

  export type AnalyticsEventCountAggregateInputType = {
    id?: true
    eventType?: true
    eventName?: true
    userHash?: true
    sessionId?: true
    properties?: true
    timestamp?: true
    responseTime?: true
    success?: true
    errorCode?: true
    _all?: true
  }

  export type AnalyticsEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvent to aggregate.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsEvents
    **/
    _count?: true | AnalyticsEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalyticsEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalyticsEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsEventMaxAggregateInputType
  }

  export type GetAnalyticsEventAggregateType<T extends AnalyticsEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
      : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
  }




  export type AnalyticsEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsEventWhereInput
    orderBy?: AnalyticsEventOrderByWithAggregationInput | AnalyticsEventOrderByWithAggregationInput[]
    by: AnalyticsEventScalarFieldEnum[] | AnalyticsEventScalarFieldEnum
    having?: AnalyticsEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsEventCountAggregateInputType | true
    _avg?: AnalyticsEventAvgAggregateInputType
    _sum?: AnalyticsEventSumAggregateInputType
    _min?: AnalyticsEventMinAggregateInputType
    _max?: AnalyticsEventMaxAggregateInputType
  }

  export type AnalyticsEventGroupByOutputType = {
    id: string
    eventType: string
    eventName: string
    userHash: string | null
    sessionId: string | null
    properties: JsonValue | null
    timestamp: Date
    responseTime: number | null
    success: boolean
    errorCode: string | null
    _count: AnalyticsEventCountAggregateOutputType | null
    _avg: AnalyticsEventAvgAggregateOutputType | null
    _sum: AnalyticsEventSumAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  type GetAnalyticsEventGroupByPayload<T extends AnalyticsEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    eventName?: boolean
    userHash?: boolean
    sessionId?: boolean
    properties?: boolean
    timestamp?: boolean
    responseTime?: boolean
    success?: boolean
    errorCode?: boolean
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    eventName?: boolean
    userHash?: boolean
    sessionId?: boolean
    properties?: boolean
    timestamp?: boolean
    responseTime?: boolean
    success?: boolean
    errorCode?: boolean
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    eventName?: boolean
    userHash?: boolean
    sessionId?: boolean
    properties?: boolean
    timestamp?: boolean
    responseTime?: boolean
    success?: boolean
    errorCode?: boolean
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectScalar = {
    id?: boolean
    eventType?: boolean
    eventName?: boolean
    userHash?: boolean
    sessionId?: boolean
    properties?: boolean
    timestamp?: boolean
    responseTime?: boolean
    success?: boolean
    errorCode?: boolean
  }

  export type AnalyticsEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventType" | "eventName" | "userHash" | "sessionId" | "properties" | "timestamp" | "responseTime" | "success" | "errorCode", ExtArgs["result"]["analyticsEvent"]>

  export type $AnalyticsEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventType: string
      eventName: string
      userHash: string | null
      sessionId: string | null
      properties: Prisma.JsonValue | null
      timestamp: Date
      responseTime: number | null
      success: boolean
      errorCode: string | null
    }, ExtArgs["result"]["analyticsEvent"]>
    composites: {}
  }

  type AnalyticsEventGetPayload<S extends boolean | null | undefined | AnalyticsEventDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsEventPayload, S>

  type AnalyticsEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AnalyticsEventCountAggregateInputType | true
    }

  export interface AnalyticsEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsEvent'], meta: { name: 'AnalyticsEvent' } }
    /**
     * Find zero or one AnalyticsEvent that matches the filter.
     * @param {AnalyticsEventFindUniqueArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsEventFindUniqueArgs>(args: SelectSubset<T, AnalyticsEventFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticsEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsEventFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsEventFindFirstArgs>(args?: SelectSubset<T, AnalyticsEventFindFirstArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany()
     * 
     * // Get first 10 AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsEventFindManyArgs>(args?: SelectSubset<T, AnalyticsEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticsEvent.
     * @param {AnalyticsEventCreateArgs} args - Arguments to create a AnalyticsEvent.
     * @example
     * // Create one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.create({
     *   data: {
     *     // ... data to create a AnalyticsEvent
     *   }
     * })
     * 
     */
    create<T extends AnalyticsEventCreateArgs>(args: SelectSubset<T, AnalyticsEventCreateArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticsEvents.
     * @param {AnalyticsEventCreateManyArgs} args - Arguments to create many AnalyticsEvents.
     * @example
     * // Create many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsEventCreateManyArgs>(args?: SelectSubset<T, AnalyticsEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsEvents and returns the data saved in the database.
     * @param {AnalyticsEventCreateManyAndReturnArgs} args - Arguments to create many AnalyticsEvents.
     * @example
     * // Create many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsEvents and only return the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalyticsEvent.
     * @param {AnalyticsEventDeleteArgs} args - Arguments to delete one AnalyticsEvent.
     * @example
     * // Delete one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsEvent
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsEventDeleteArgs>(args: SelectSubset<T, AnalyticsEventDeleteArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticsEvent.
     * @param {AnalyticsEventUpdateArgs} args - Arguments to update one AnalyticsEvent.
     * @example
     * // Update one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsEventUpdateArgs>(args: SelectSubset<T, AnalyticsEventUpdateArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticsEvents.
     * @param {AnalyticsEventDeleteManyArgs} args - Arguments to filter AnalyticsEvents to delete.
     * @example
     * // Delete a few AnalyticsEvents
     * const { count } = await prisma.analyticsEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsEventDeleteManyArgs>(args?: SelectSubset<T, AnalyticsEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsEventUpdateManyArgs>(args: SelectSubset<T, AnalyticsEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsEvents and returns the data updated in the database.
     * @param {AnalyticsEventUpdateManyAndReturnArgs} args - Arguments to update many AnalyticsEvents.
     * @example
     * // Update many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalyticsEvents and only return the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalyticsEvent.
     * @param {AnalyticsEventUpsertArgs} args - Arguments to update or create a AnalyticsEvent.
     * @example
     * // Update or create a AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.upsert({
     *   create: {
     *     // ... data to create a AnalyticsEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsEvent we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsEventUpsertArgs>(args: SelectSubset<T, AnalyticsEventUpsertArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventCountArgs} args - Arguments to filter AnalyticsEvents to count.
     * @example
     * // Count the number of AnalyticsEvents
     * const count = await prisma.analyticsEvent.count({
     *   where: {
     *     // ... the filter for the AnalyticsEvents we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsEventCountArgs>(
      args?: Subset<T, AnalyticsEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsEventAggregateArgs>(args: Subset<T, AnalyticsEventAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsEventAggregateType<T>>

    /**
     * Group by AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsEventGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsEvent model
   */
  readonly fields: AnalyticsEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsEvent model
   */
  interface AnalyticsEventFieldRefs {
    readonly id: FieldRef<"AnalyticsEvent", 'String'>
    readonly eventType: FieldRef<"AnalyticsEvent", 'String'>
    readonly eventName: FieldRef<"AnalyticsEvent", 'String'>
    readonly userHash: FieldRef<"AnalyticsEvent", 'String'>
    readonly sessionId: FieldRef<"AnalyticsEvent", 'String'>
    readonly properties: FieldRef<"AnalyticsEvent", 'Json'>
    readonly timestamp: FieldRef<"AnalyticsEvent", 'DateTime'>
    readonly responseTime: FieldRef<"AnalyticsEvent", 'Int'>
    readonly success: FieldRef<"AnalyticsEvent", 'Boolean'>
    readonly errorCode: FieldRef<"AnalyticsEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsEvent findUnique
   */
  export type AnalyticsEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent findUniqueOrThrow
   */
  export type AnalyticsEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent findFirst
   */
  export type AnalyticsEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent findFirstOrThrow
   */
  export type AnalyticsEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent findMany
   */
  export type AnalyticsEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvents to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent create
   */
  export type AnalyticsEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
  }

  /**
   * AnalyticsEvent createMany
   */
  export type AnalyticsEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsEvents.
     */
    data: AnalyticsEventCreateManyInput | AnalyticsEventCreateManyInput[]
  }

  /**
   * AnalyticsEvent createManyAndReturn
   */
  export type AnalyticsEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data used to create many AnalyticsEvents.
     */
    data: AnalyticsEventCreateManyInput | AnalyticsEventCreateManyInput[]
  }

  /**
   * AnalyticsEvent update
   */
  export type AnalyticsEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsEvent to update.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent updateMany
   */
  export type AnalyticsEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsEvents.
     */
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsEvents to update
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to update.
     */
    limit?: number
  }

  /**
   * AnalyticsEvent updateManyAndReturn
   */
  export type AnalyticsEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data used to update AnalyticsEvents.
     */
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsEvents to update
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to update.
     */
    limit?: number
  }

  /**
   * AnalyticsEvent upsert
   */
  export type AnalyticsEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsEvent to update in case it exists.
     */
    where: AnalyticsEventWhereUniqueInput
    /**
     * In case the AnalyticsEvent found by the `where` argument doesn't exist, create a new AnalyticsEvent with this data.
     */
    create: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
    /**
     * In case the AnalyticsEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
  }

  /**
   * AnalyticsEvent delete
   */
  export type AnalyticsEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter which AnalyticsEvent to delete.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent deleteMany
   */
  export type AnalyticsEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvents to delete
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to delete.
     */
    limit?: number
  }

  /**
   * AnalyticsEvent without action
   */
  export type AnalyticsEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
  }


  /**
   * Model PerformanceMetric
   */

  export type AggregatePerformanceMetric = {
    _count: PerformanceMetricCountAggregateOutputType | null
    _avg: PerformanceMetricAvgAggregateOutputType | null
    _sum: PerformanceMetricSumAggregateOutputType | null
    _min: PerformanceMetricMinAggregateOutputType | null
    _max: PerformanceMetricMaxAggregateOutputType | null
  }

  export type PerformanceMetricAvgAggregateOutputType = {
    value: number | null
    target: number | null
    threshold: number | null
  }

  export type PerformanceMetricSumAggregateOutputType = {
    value: number | null
    target: number | null
    threshold: number | null
  }

  export type PerformanceMetricMinAggregateOutputType = {
    id: string | null
    metricType: string | null
    value: number | null
    unit: string | null
    endpoint: string | null
    region: string | null
    timestamp: Date | null
    target: number | null
    threshold: number | null
    status: $Enums.MetricStatus | null
  }

  export type PerformanceMetricMaxAggregateOutputType = {
    id: string | null
    metricType: string | null
    value: number | null
    unit: string | null
    endpoint: string | null
    region: string | null
    timestamp: Date | null
    target: number | null
    threshold: number | null
    status: $Enums.MetricStatus | null
  }

  export type PerformanceMetricCountAggregateOutputType = {
    id: number
    metricType: number
    value: number
    unit: number
    endpoint: number
    region: number
    timestamp: number
    target: number
    threshold: number
    status: number
    _all: number
  }


  export type PerformanceMetricAvgAggregateInputType = {
    value?: true
    target?: true
    threshold?: true
  }

  export type PerformanceMetricSumAggregateInputType = {
    value?: true
    target?: true
    threshold?: true
  }

  export type PerformanceMetricMinAggregateInputType = {
    id?: true
    metricType?: true
    value?: true
    unit?: true
    endpoint?: true
    region?: true
    timestamp?: true
    target?: true
    threshold?: true
    status?: true
  }

  export type PerformanceMetricMaxAggregateInputType = {
    id?: true
    metricType?: true
    value?: true
    unit?: true
    endpoint?: true
    region?: true
    timestamp?: true
    target?: true
    threshold?: true
    status?: true
  }

  export type PerformanceMetricCountAggregateInputType = {
    id?: true
    metricType?: true
    value?: true
    unit?: true
    endpoint?: true
    region?: true
    timestamp?: true
    target?: true
    threshold?: true
    status?: true
    _all?: true
  }

  export type PerformanceMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceMetric to aggregate.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceMetrics
    **/
    _count?: true | PerformanceMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceMetricMaxAggregateInputType
  }

  export type GetPerformanceMetricAggregateType<T extends PerformanceMetricAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceMetric[P]>
      : GetScalarType<T[P], AggregatePerformanceMetric[P]>
  }




  export type PerformanceMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceMetricWhereInput
    orderBy?: PerformanceMetricOrderByWithAggregationInput | PerformanceMetricOrderByWithAggregationInput[]
    by: PerformanceMetricScalarFieldEnum[] | PerformanceMetricScalarFieldEnum
    having?: PerformanceMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceMetricCountAggregateInputType | true
    _avg?: PerformanceMetricAvgAggregateInputType
    _sum?: PerformanceMetricSumAggregateInputType
    _min?: PerformanceMetricMinAggregateInputType
    _max?: PerformanceMetricMaxAggregateInputType
  }

  export type PerformanceMetricGroupByOutputType = {
    id: string
    metricType: string
    value: number
    unit: string
    endpoint: string | null
    region: string | null
    timestamp: Date
    target: number | null
    threshold: number | null
    status: $Enums.MetricStatus
    _count: PerformanceMetricCountAggregateOutputType | null
    _avg: PerformanceMetricAvgAggregateOutputType | null
    _sum: PerformanceMetricSumAggregateOutputType | null
    _min: PerformanceMetricMinAggregateOutputType | null
    _max: PerformanceMetricMaxAggregateOutputType | null
  }

  type GetPerformanceMetricGroupByPayload<T extends PerformanceMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceMetricGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceMetricGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricType?: boolean
    value?: boolean
    unit?: boolean
    endpoint?: boolean
    region?: boolean
    timestamp?: boolean
    target?: boolean
    threshold?: boolean
    status?: boolean
  }, ExtArgs["result"]["performanceMetric"]>

  export type PerformanceMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricType?: boolean
    value?: boolean
    unit?: boolean
    endpoint?: boolean
    region?: boolean
    timestamp?: boolean
    target?: boolean
    threshold?: boolean
    status?: boolean
  }, ExtArgs["result"]["performanceMetric"]>

  export type PerformanceMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricType?: boolean
    value?: boolean
    unit?: boolean
    endpoint?: boolean
    region?: boolean
    timestamp?: boolean
    target?: boolean
    threshold?: boolean
    status?: boolean
  }, ExtArgs["result"]["performanceMetric"]>

  export type PerformanceMetricSelectScalar = {
    id?: boolean
    metricType?: boolean
    value?: boolean
    unit?: boolean
    endpoint?: boolean
    region?: boolean
    timestamp?: boolean
    target?: boolean
    threshold?: boolean
    status?: boolean
  }

  export type PerformanceMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "metricType" | "value" | "unit" | "endpoint" | "region" | "timestamp" | "target" | "threshold" | "status", ExtArgs["result"]["performanceMetric"]>

  export type $PerformanceMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceMetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      metricType: string
      value: number
      unit: string
      endpoint: string | null
      region: string | null
      timestamp: Date
      target: number | null
      threshold: number | null
      status: $Enums.MetricStatus
    }, ExtArgs["result"]["performanceMetric"]>
    composites: {}
  }

  type PerformanceMetricGetPayload<S extends boolean | null | undefined | PerformanceMetricDefaultArgs> = $Result.GetResult<Prisma.$PerformanceMetricPayload, S>

  type PerformanceMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: PerformanceMetricCountAggregateInputType | true
    }

  export interface PerformanceMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceMetric'], meta: { name: 'PerformanceMetric' } }
    /**
     * Find zero or one PerformanceMetric that matches the filter.
     * @param {PerformanceMetricFindUniqueArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceMetricFindUniqueArgs>(args: SelectSubset<T, PerformanceMetricFindUniqueArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PerformanceMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceMetricFindUniqueOrThrowArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindFirstArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceMetricFindFirstArgs>(args?: SelectSubset<T, PerformanceMetricFindFirstArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindFirstOrThrowArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PerformanceMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceMetrics
     * const performanceMetrics = await prisma.performanceMetric.findMany()
     * 
     * // Get first 10 PerformanceMetrics
     * const performanceMetrics = await prisma.performanceMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceMetricWithIdOnly = await prisma.performanceMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceMetricFindManyArgs>(args?: SelectSubset<T, PerformanceMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PerformanceMetric.
     * @param {PerformanceMetricCreateArgs} args - Arguments to create a PerformanceMetric.
     * @example
     * // Create one PerformanceMetric
     * const PerformanceMetric = await prisma.performanceMetric.create({
     *   data: {
     *     // ... data to create a PerformanceMetric
     *   }
     * })
     * 
     */
    create<T extends PerformanceMetricCreateArgs>(args: SelectSubset<T, PerformanceMetricCreateArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PerformanceMetrics.
     * @param {PerformanceMetricCreateManyArgs} args - Arguments to create many PerformanceMetrics.
     * @example
     * // Create many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceMetricCreateManyArgs>(args?: SelectSubset<T, PerformanceMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerformanceMetrics and returns the data saved in the database.
     * @param {PerformanceMetricCreateManyAndReturnArgs} args - Arguments to create many PerformanceMetrics.
     * @example
     * // Create many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerformanceMetrics and only return the `id`
     * const performanceMetricWithIdOnly = await prisma.performanceMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerformanceMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, PerformanceMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PerformanceMetric.
     * @param {PerformanceMetricDeleteArgs} args - Arguments to delete one PerformanceMetric.
     * @example
     * // Delete one PerformanceMetric
     * const PerformanceMetric = await prisma.performanceMetric.delete({
     *   where: {
     *     // ... filter to delete one PerformanceMetric
     *   }
     * })
     * 
     */
    delete<T extends PerformanceMetricDeleteArgs>(args: SelectSubset<T, PerformanceMetricDeleteArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PerformanceMetric.
     * @param {PerformanceMetricUpdateArgs} args - Arguments to update one PerformanceMetric.
     * @example
     * // Update one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceMetricUpdateArgs>(args: SelectSubset<T, PerformanceMetricUpdateArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PerformanceMetrics.
     * @param {PerformanceMetricDeleteManyArgs} args - Arguments to filter PerformanceMetrics to delete.
     * @example
     * // Delete a few PerformanceMetrics
     * const { count } = await prisma.performanceMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceMetricDeleteManyArgs>(args?: SelectSubset<T, PerformanceMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceMetricUpdateManyArgs>(args: SelectSubset<T, PerformanceMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceMetrics and returns the data updated in the database.
     * @param {PerformanceMetricUpdateManyAndReturnArgs} args - Arguments to update many PerformanceMetrics.
     * @example
     * // Update many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PerformanceMetrics and only return the `id`
     * const performanceMetricWithIdOnly = await prisma.performanceMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PerformanceMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, PerformanceMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PerformanceMetric.
     * @param {PerformanceMetricUpsertArgs} args - Arguments to update or create a PerformanceMetric.
     * @example
     * // Update or create a PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.upsert({
     *   create: {
     *     // ... data to create a PerformanceMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceMetric we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceMetricUpsertArgs>(args: SelectSubset<T, PerformanceMetricUpsertArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PerformanceMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricCountArgs} args - Arguments to filter PerformanceMetrics to count.
     * @example
     * // Count the number of PerformanceMetrics
     * const count = await prisma.performanceMetric.count({
     *   where: {
     *     // ... the filter for the PerformanceMetrics we want to count
     *   }
     * })
    **/
    count<T extends PerformanceMetricCountArgs>(
      args?: Subset<T, PerformanceMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceMetricAggregateArgs>(args: Subset<T, PerformanceMetricAggregateArgs>): Prisma.PrismaPromise<GetPerformanceMetricAggregateType<T>>

    /**
     * Group by PerformanceMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceMetricGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceMetric model
   */
  readonly fields: PerformanceMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceMetric model
   */
  interface PerformanceMetricFieldRefs {
    readonly id: FieldRef<"PerformanceMetric", 'String'>
    readonly metricType: FieldRef<"PerformanceMetric", 'String'>
    readonly value: FieldRef<"PerformanceMetric", 'Float'>
    readonly unit: FieldRef<"PerformanceMetric", 'String'>
    readonly endpoint: FieldRef<"PerformanceMetric", 'String'>
    readonly region: FieldRef<"PerformanceMetric", 'String'>
    readonly timestamp: FieldRef<"PerformanceMetric", 'DateTime'>
    readonly target: FieldRef<"PerformanceMetric", 'Float'>
    readonly threshold: FieldRef<"PerformanceMetric", 'Float'>
    readonly status: FieldRef<"PerformanceMetric", 'MetricStatus'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceMetric findUnique
   */
  export type PerformanceMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric findUniqueOrThrow
   */
  export type PerformanceMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric findFirst
   */
  export type PerformanceMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceMetrics.
     */
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }

  /**
   * PerformanceMetric findFirstOrThrow
   */
  export type PerformanceMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceMetrics.
     */
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }

  /**
   * PerformanceMetric findMany
   */
  export type PerformanceMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Filter, which PerformanceMetrics to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }

  /**
   * PerformanceMetric create
   */
  export type PerformanceMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * The data needed to create a PerformanceMetric.
     */
    data: XOR<PerformanceMetricCreateInput, PerformanceMetricUncheckedCreateInput>
  }

  /**
   * PerformanceMetric createMany
   */
  export type PerformanceMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceMetrics.
     */
    data: PerformanceMetricCreateManyInput | PerformanceMetricCreateManyInput[]
  }

  /**
   * PerformanceMetric createManyAndReturn
   */
  export type PerformanceMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * The data used to create many PerformanceMetrics.
     */
    data: PerformanceMetricCreateManyInput | PerformanceMetricCreateManyInput[]
  }

  /**
   * PerformanceMetric update
   */
  export type PerformanceMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * The data needed to update a PerformanceMetric.
     */
    data: XOR<PerformanceMetricUpdateInput, PerformanceMetricUncheckedUpdateInput>
    /**
     * Choose, which PerformanceMetric to update.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric updateMany
   */
  export type PerformanceMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceMetrics.
     */
    data: XOR<PerformanceMetricUpdateManyMutationInput, PerformanceMetricUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceMetrics to update
     */
    where?: PerformanceMetricWhereInput
    /**
     * Limit how many PerformanceMetrics to update.
     */
    limit?: number
  }

  /**
   * PerformanceMetric updateManyAndReturn
   */
  export type PerformanceMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * The data used to update PerformanceMetrics.
     */
    data: XOR<PerformanceMetricUpdateManyMutationInput, PerformanceMetricUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceMetrics to update
     */
    where?: PerformanceMetricWhereInput
    /**
     * Limit how many PerformanceMetrics to update.
     */
    limit?: number
  }

  /**
   * PerformanceMetric upsert
   */
  export type PerformanceMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * The filter to search for the PerformanceMetric to update in case it exists.
     */
    where: PerformanceMetricWhereUniqueInput
    /**
     * In case the PerformanceMetric found by the `where` argument doesn't exist, create a new PerformanceMetric with this data.
     */
    create: XOR<PerformanceMetricCreateInput, PerformanceMetricUncheckedCreateInput>
    /**
     * In case the PerformanceMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceMetricUpdateInput, PerformanceMetricUncheckedUpdateInput>
  }

  /**
   * PerformanceMetric delete
   */
  export type PerformanceMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Filter which PerformanceMetric to delete.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric deleteMany
   */
  export type PerformanceMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceMetrics to delete
     */
    where?: PerformanceMetricWhereInput
    /**
     * Limit how many PerformanceMetrics to delete.
     */
    limit?: number
  }

  /**
   * PerformanceMetric without action
   */
  export type PerformanceMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
  }


  /**
   * Model SystemHealth
   */

  export type AggregateSystemHealth = {
    _count: SystemHealthCountAggregateOutputType | null
    _avg: SystemHealthAvgAggregateOutputType | null
    _sum: SystemHealthSumAggregateOutputType | null
    _min: SystemHealthMinAggregateOutputType | null
    _max: SystemHealthMaxAggregateOutputType | null
  }

  export type SystemHealthAvgAggregateOutputType = {
    responseTime: number | null
    uptime: number | null
    errorRate: number | null
    cpuUsage: number | null
    memoryUsage: number | null
    diskUsage: number | null
  }

  export type SystemHealthSumAggregateOutputType = {
    responseTime: number | null
    uptime: number | null
    errorRate: number | null
    cpuUsage: number | null
    memoryUsage: number | null
    diskUsage: number | null
  }

  export type SystemHealthMinAggregateOutputType = {
    id: string | null
    component: string | null
    status: $Enums.HealthStatus | null
    responseTime: number | null
    uptime: number | null
    errorRate: number | null
    lastError: Date | null
    errorMessage: string | null
    cpuUsage: number | null
    memoryUsage: number | null
    diskUsage: number | null
    timestamp: Date | null
  }

  export type SystemHealthMaxAggregateOutputType = {
    id: string | null
    component: string | null
    status: $Enums.HealthStatus | null
    responseTime: number | null
    uptime: number | null
    errorRate: number | null
    lastError: Date | null
    errorMessage: string | null
    cpuUsage: number | null
    memoryUsage: number | null
    diskUsage: number | null
    timestamp: Date | null
  }

  export type SystemHealthCountAggregateOutputType = {
    id: number
    component: number
    status: number
    responseTime: number
    uptime: number
    errorRate: number
    lastError: number
    errorMessage: number
    cpuUsage: number
    memoryUsage: number
    diskUsage: number
    timestamp: number
    _all: number
  }


  export type SystemHealthAvgAggregateInputType = {
    responseTime?: true
    uptime?: true
    errorRate?: true
    cpuUsage?: true
    memoryUsage?: true
    diskUsage?: true
  }

  export type SystemHealthSumAggregateInputType = {
    responseTime?: true
    uptime?: true
    errorRate?: true
    cpuUsage?: true
    memoryUsage?: true
    diskUsage?: true
  }

  export type SystemHealthMinAggregateInputType = {
    id?: true
    component?: true
    status?: true
    responseTime?: true
    uptime?: true
    errorRate?: true
    lastError?: true
    errorMessage?: true
    cpuUsage?: true
    memoryUsage?: true
    diskUsage?: true
    timestamp?: true
  }

  export type SystemHealthMaxAggregateInputType = {
    id?: true
    component?: true
    status?: true
    responseTime?: true
    uptime?: true
    errorRate?: true
    lastError?: true
    errorMessage?: true
    cpuUsage?: true
    memoryUsage?: true
    diskUsage?: true
    timestamp?: true
  }

  export type SystemHealthCountAggregateInputType = {
    id?: true
    component?: true
    status?: true
    responseTime?: true
    uptime?: true
    errorRate?: true
    lastError?: true
    errorMessage?: true
    cpuUsage?: true
    memoryUsage?: true
    diskUsage?: true
    timestamp?: true
    _all?: true
  }

  export type SystemHealthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemHealth to aggregate.
     */
    where?: SystemHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemHealths to fetch.
     */
    orderBy?: SystemHealthOrderByWithRelationInput | SystemHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemHealths
    **/
    _count?: true | SystemHealthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemHealthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemHealthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemHealthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemHealthMaxAggregateInputType
  }

  export type GetSystemHealthAggregateType<T extends SystemHealthAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemHealth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemHealth[P]>
      : GetScalarType<T[P], AggregateSystemHealth[P]>
  }




  export type SystemHealthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemHealthWhereInput
    orderBy?: SystemHealthOrderByWithAggregationInput | SystemHealthOrderByWithAggregationInput[]
    by: SystemHealthScalarFieldEnum[] | SystemHealthScalarFieldEnum
    having?: SystemHealthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemHealthCountAggregateInputType | true
    _avg?: SystemHealthAvgAggregateInputType
    _sum?: SystemHealthSumAggregateInputType
    _min?: SystemHealthMinAggregateInputType
    _max?: SystemHealthMaxAggregateInputType
  }

  export type SystemHealthGroupByOutputType = {
    id: string
    component: string
    status: $Enums.HealthStatus
    responseTime: number | null
    uptime: number | null
    errorRate: number | null
    lastError: Date | null
    errorMessage: string | null
    cpuUsage: number | null
    memoryUsage: number | null
    diskUsage: number | null
    timestamp: Date
    _count: SystemHealthCountAggregateOutputType | null
    _avg: SystemHealthAvgAggregateOutputType | null
    _sum: SystemHealthSumAggregateOutputType | null
    _min: SystemHealthMinAggregateOutputType | null
    _max: SystemHealthMaxAggregateOutputType | null
  }

  type GetSystemHealthGroupByPayload<T extends SystemHealthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemHealthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemHealthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemHealthGroupByOutputType[P]>
            : GetScalarType<T[P], SystemHealthGroupByOutputType[P]>
        }
      >
    >


  export type SystemHealthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    component?: boolean
    status?: boolean
    responseTime?: boolean
    uptime?: boolean
    errorRate?: boolean
    lastError?: boolean
    errorMessage?: boolean
    cpuUsage?: boolean
    memoryUsage?: boolean
    diskUsage?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["systemHealth"]>

  export type SystemHealthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    component?: boolean
    status?: boolean
    responseTime?: boolean
    uptime?: boolean
    errorRate?: boolean
    lastError?: boolean
    errorMessage?: boolean
    cpuUsage?: boolean
    memoryUsage?: boolean
    diskUsage?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["systemHealth"]>

  export type SystemHealthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    component?: boolean
    status?: boolean
    responseTime?: boolean
    uptime?: boolean
    errorRate?: boolean
    lastError?: boolean
    errorMessage?: boolean
    cpuUsage?: boolean
    memoryUsage?: boolean
    diskUsage?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["systemHealth"]>

  export type SystemHealthSelectScalar = {
    id?: boolean
    component?: boolean
    status?: boolean
    responseTime?: boolean
    uptime?: boolean
    errorRate?: boolean
    lastError?: boolean
    errorMessage?: boolean
    cpuUsage?: boolean
    memoryUsage?: boolean
    diskUsage?: boolean
    timestamp?: boolean
  }

  export type SystemHealthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "component" | "status" | "responseTime" | "uptime" | "errorRate" | "lastError" | "errorMessage" | "cpuUsage" | "memoryUsage" | "diskUsage" | "timestamp", ExtArgs["result"]["systemHealth"]>

  export type $SystemHealthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemHealth"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      component: string
      status: $Enums.HealthStatus
      responseTime: number | null
      uptime: number | null
      errorRate: number | null
      lastError: Date | null
      errorMessage: string | null
      cpuUsage: number | null
      memoryUsage: number | null
      diskUsage: number | null
      timestamp: Date
    }, ExtArgs["result"]["systemHealth"]>
    composites: {}
  }

  type SystemHealthGetPayload<S extends boolean | null | undefined | SystemHealthDefaultArgs> = $Result.GetResult<Prisma.$SystemHealthPayload, S>

  type SystemHealthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemHealthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SystemHealthCountAggregateInputType | true
    }

  export interface SystemHealthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemHealth'], meta: { name: 'SystemHealth' } }
    /**
     * Find zero or one SystemHealth that matches the filter.
     * @param {SystemHealthFindUniqueArgs} args - Arguments to find a SystemHealth
     * @example
     * // Get one SystemHealth
     * const systemHealth = await prisma.systemHealth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemHealthFindUniqueArgs>(args: SelectSubset<T, SystemHealthFindUniqueArgs<ExtArgs>>): Prisma__SystemHealthClient<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemHealth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemHealthFindUniqueOrThrowArgs} args - Arguments to find a SystemHealth
     * @example
     * // Get one SystemHealth
     * const systemHealth = await prisma.systemHealth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemHealthFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemHealthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemHealthClient<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemHealth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthFindFirstArgs} args - Arguments to find a SystemHealth
     * @example
     * // Get one SystemHealth
     * const systemHealth = await prisma.systemHealth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemHealthFindFirstArgs>(args?: SelectSubset<T, SystemHealthFindFirstArgs<ExtArgs>>): Prisma__SystemHealthClient<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemHealth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthFindFirstOrThrowArgs} args - Arguments to find a SystemHealth
     * @example
     * // Get one SystemHealth
     * const systemHealth = await prisma.systemHealth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemHealthFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemHealthFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemHealthClient<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemHealths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemHealths
     * const systemHealths = await prisma.systemHealth.findMany()
     * 
     * // Get first 10 SystemHealths
     * const systemHealths = await prisma.systemHealth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemHealthWithIdOnly = await prisma.systemHealth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemHealthFindManyArgs>(args?: SelectSubset<T, SystemHealthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemHealth.
     * @param {SystemHealthCreateArgs} args - Arguments to create a SystemHealth.
     * @example
     * // Create one SystemHealth
     * const SystemHealth = await prisma.systemHealth.create({
     *   data: {
     *     // ... data to create a SystemHealth
     *   }
     * })
     * 
     */
    create<T extends SystemHealthCreateArgs>(args: SelectSubset<T, SystemHealthCreateArgs<ExtArgs>>): Prisma__SystemHealthClient<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemHealths.
     * @param {SystemHealthCreateManyArgs} args - Arguments to create many SystemHealths.
     * @example
     * // Create many SystemHealths
     * const systemHealth = await prisma.systemHealth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemHealthCreateManyArgs>(args?: SelectSubset<T, SystemHealthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemHealths and returns the data saved in the database.
     * @param {SystemHealthCreateManyAndReturnArgs} args - Arguments to create many SystemHealths.
     * @example
     * // Create many SystemHealths
     * const systemHealth = await prisma.systemHealth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemHealths and only return the `id`
     * const systemHealthWithIdOnly = await prisma.systemHealth.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemHealthCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemHealthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemHealth.
     * @param {SystemHealthDeleteArgs} args - Arguments to delete one SystemHealth.
     * @example
     * // Delete one SystemHealth
     * const SystemHealth = await prisma.systemHealth.delete({
     *   where: {
     *     // ... filter to delete one SystemHealth
     *   }
     * })
     * 
     */
    delete<T extends SystemHealthDeleteArgs>(args: SelectSubset<T, SystemHealthDeleteArgs<ExtArgs>>): Prisma__SystemHealthClient<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemHealth.
     * @param {SystemHealthUpdateArgs} args - Arguments to update one SystemHealth.
     * @example
     * // Update one SystemHealth
     * const systemHealth = await prisma.systemHealth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemHealthUpdateArgs>(args: SelectSubset<T, SystemHealthUpdateArgs<ExtArgs>>): Prisma__SystemHealthClient<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemHealths.
     * @param {SystemHealthDeleteManyArgs} args - Arguments to filter SystemHealths to delete.
     * @example
     * // Delete a few SystemHealths
     * const { count } = await prisma.systemHealth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemHealthDeleteManyArgs>(args?: SelectSubset<T, SystemHealthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemHealths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemHealths
     * const systemHealth = await prisma.systemHealth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemHealthUpdateManyArgs>(args: SelectSubset<T, SystemHealthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemHealths and returns the data updated in the database.
     * @param {SystemHealthUpdateManyAndReturnArgs} args - Arguments to update many SystemHealths.
     * @example
     * // Update many SystemHealths
     * const systemHealth = await prisma.systemHealth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemHealths and only return the `id`
     * const systemHealthWithIdOnly = await prisma.systemHealth.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemHealthUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemHealthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemHealth.
     * @param {SystemHealthUpsertArgs} args - Arguments to update or create a SystemHealth.
     * @example
     * // Update or create a SystemHealth
     * const systemHealth = await prisma.systemHealth.upsert({
     *   create: {
     *     // ... data to create a SystemHealth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemHealth we want to update
     *   }
     * })
     */
    upsert<T extends SystemHealthUpsertArgs>(args: SelectSubset<T, SystemHealthUpsertArgs<ExtArgs>>): Prisma__SystemHealthClient<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemHealths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthCountArgs} args - Arguments to filter SystemHealths to count.
     * @example
     * // Count the number of SystemHealths
     * const count = await prisma.systemHealth.count({
     *   where: {
     *     // ... the filter for the SystemHealths we want to count
     *   }
     * })
    **/
    count<T extends SystemHealthCountArgs>(
      args?: Subset<T, SystemHealthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemHealthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemHealth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemHealthAggregateArgs>(args: Subset<T, SystemHealthAggregateArgs>): Prisma.PrismaPromise<GetSystemHealthAggregateType<T>>

    /**
     * Group by SystemHealth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemHealthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemHealthGroupByArgs['orderBy'] }
        : { orderBy?: SystemHealthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemHealthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemHealthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemHealth model
   */
  readonly fields: SystemHealthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemHealth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemHealthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemHealth model
   */
  interface SystemHealthFieldRefs {
    readonly id: FieldRef<"SystemHealth", 'String'>
    readonly component: FieldRef<"SystemHealth", 'String'>
    readonly status: FieldRef<"SystemHealth", 'HealthStatus'>
    readonly responseTime: FieldRef<"SystemHealth", 'Float'>
    readonly uptime: FieldRef<"SystemHealth", 'Float'>
    readonly errorRate: FieldRef<"SystemHealth", 'Float'>
    readonly lastError: FieldRef<"SystemHealth", 'DateTime'>
    readonly errorMessage: FieldRef<"SystemHealth", 'String'>
    readonly cpuUsage: FieldRef<"SystemHealth", 'Float'>
    readonly memoryUsage: FieldRef<"SystemHealth", 'Float'>
    readonly diskUsage: FieldRef<"SystemHealth", 'Float'>
    readonly timestamp: FieldRef<"SystemHealth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemHealth findUnique
   */
  export type SystemHealthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * Filter, which SystemHealth to fetch.
     */
    where: SystemHealthWhereUniqueInput
  }

  /**
   * SystemHealth findUniqueOrThrow
   */
  export type SystemHealthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * Filter, which SystemHealth to fetch.
     */
    where: SystemHealthWhereUniqueInput
  }

  /**
   * SystemHealth findFirst
   */
  export type SystemHealthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * Filter, which SystemHealth to fetch.
     */
    where?: SystemHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemHealths to fetch.
     */
    orderBy?: SystemHealthOrderByWithRelationInput | SystemHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemHealths.
     */
    cursor?: SystemHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemHealths.
     */
    distinct?: SystemHealthScalarFieldEnum | SystemHealthScalarFieldEnum[]
  }

  /**
   * SystemHealth findFirstOrThrow
   */
  export type SystemHealthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * Filter, which SystemHealth to fetch.
     */
    where?: SystemHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemHealths to fetch.
     */
    orderBy?: SystemHealthOrderByWithRelationInput | SystemHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemHealths.
     */
    cursor?: SystemHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemHealths.
     */
    distinct?: SystemHealthScalarFieldEnum | SystemHealthScalarFieldEnum[]
  }

  /**
   * SystemHealth findMany
   */
  export type SystemHealthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * Filter, which SystemHealths to fetch.
     */
    where?: SystemHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemHealths to fetch.
     */
    orderBy?: SystemHealthOrderByWithRelationInput | SystemHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemHealths.
     */
    cursor?: SystemHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemHealths.
     */
    skip?: number
    distinct?: SystemHealthScalarFieldEnum | SystemHealthScalarFieldEnum[]
  }

  /**
   * SystemHealth create
   */
  export type SystemHealthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemHealth.
     */
    data: XOR<SystemHealthCreateInput, SystemHealthUncheckedCreateInput>
  }

  /**
   * SystemHealth createMany
   */
  export type SystemHealthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemHealths.
     */
    data: SystemHealthCreateManyInput | SystemHealthCreateManyInput[]
  }

  /**
   * SystemHealth createManyAndReturn
   */
  export type SystemHealthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * The data used to create many SystemHealths.
     */
    data: SystemHealthCreateManyInput | SystemHealthCreateManyInput[]
  }

  /**
   * SystemHealth update
   */
  export type SystemHealthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemHealth.
     */
    data: XOR<SystemHealthUpdateInput, SystemHealthUncheckedUpdateInput>
    /**
     * Choose, which SystemHealth to update.
     */
    where: SystemHealthWhereUniqueInput
  }

  /**
   * SystemHealth updateMany
   */
  export type SystemHealthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemHealths.
     */
    data: XOR<SystemHealthUpdateManyMutationInput, SystemHealthUncheckedUpdateManyInput>
    /**
     * Filter which SystemHealths to update
     */
    where?: SystemHealthWhereInput
    /**
     * Limit how many SystemHealths to update.
     */
    limit?: number
  }

  /**
   * SystemHealth updateManyAndReturn
   */
  export type SystemHealthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * The data used to update SystemHealths.
     */
    data: XOR<SystemHealthUpdateManyMutationInput, SystemHealthUncheckedUpdateManyInput>
    /**
     * Filter which SystemHealths to update
     */
    where?: SystemHealthWhereInput
    /**
     * Limit how many SystemHealths to update.
     */
    limit?: number
  }

  /**
   * SystemHealth upsert
   */
  export type SystemHealthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemHealth to update in case it exists.
     */
    where: SystemHealthWhereUniqueInput
    /**
     * In case the SystemHealth found by the `where` argument doesn't exist, create a new SystemHealth with this data.
     */
    create: XOR<SystemHealthCreateInput, SystemHealthUncheckedCreateInput>
    /**
     * In case the SystemHealth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemHealthUpdateInput, SystemHealthUncheckedUpdateInput>
  }

  /**
   * SystemHealth delete
   */
  export type SystemHealthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * Filter which SystemHealth to delete.
     */
    where: SystemHealthWhereUniqueInput
  }

  /**
   * SystemHealth deleteMany
   */
  export type SystemHealthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemHealths to delete
     */
    where?: SystemHealthWhereInput
    /**
     * Limit how many SystemHealths to delete.
     */
    limit?: number
  }

  /**
   * SystemHealth without action
   */
  export type SystemHealthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
  }


  /**
   * Model CrisisResource
   */

  export type AggregateCrisisResource = {
    _count: CrisisResourceCountAggregateOutputType | null
    _avg: CrisisResourceAvgAggregateOutputType | null
    _sum: CrisisResourceSumAggregateOutputType | null
    _min: CrisisResourceMinAggregateOutputType | null
    _max: CrisisResourceMaxAggregateOutputType | null
  }

  export type CrisisResourceAvgAggregateOutputType = {
    priority: number | null
    severityMin: number | null
  }

  export type CrisisResourceSumAggregateOutputType = {
    priority: number | null
    severityMin: number | null
  }

  export type CrisisResourceMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: $Enums.ResourceCategory | null
    phoneNumber: string | null
    url: string | null
    email: string | null
    textNumber: string | null
    content: string | null
    instructions: string | null
    available24_7: boolean | null
    languages: string | null
    countries: string | null
    regions: string | null
    priority: number | null
    isEmergency: boolean | null
    severityMin: number | null
    tags: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrisisResourceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: $Enums.ResourceCategory | null
    phoneNumber: string | null
    url: string | null
    email: string | null
    textNumber: string | null
    content: string | null
    instructions: string | null
    available24_7: boolean | null
    languages: string | null
    countries: string | null
    regions: string | null
    priority: number | null
    isEmergency: boolean | null
    severityMin: number | null
    tags: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrisisResourceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    phoneNumber: number
    url: number
    email: number
    textNumber: number
    content: number
    instructions: number
    available24_7: number
    languages: number
    countries: number
    regions: number
    priority: number
    isEmergency: number
    severityMin: number
    tags: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CrisisResourceAvgAggregateInputType = {
    priority?: true
    severityMin?: true
  }

  export type CrisisResourceSumAggregateInputType = {
    priority?: true
    severityMin?: true
  }

  export type CrisisResourceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    phoneNumber?: true
    url?: true
    email?: true
    textNumber?: true
    content?: true
    instructions?: true
    available24_7?: true
    languages?: true
    countries?: true
    regions?: true
    priority?: true
    isEmergency?: true
    severityMin?: true
    tags?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrisisResourceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    phoneNumber?: true
    url?: true
    email?: true
    textNumber?: true
    content?: true
    instructions?: true
    available24_7?: true
    languages?: true
    countries?: true
    regions?: true
    priority?: true
    isEmergency?: true
    severityMin?: true
    tags?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrisisResourceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    phoneNumber?: true
    url?: true
    email?: true
    textNumber?: true
    content?: true
    instructions?: true
    available24_7?: true
    languages?: true
    countries?: true
    regions?: true
    priority?: true
    isEmergency?: true
    severityMin?: true
    tags?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CrisisResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrisisResource to aggregate.
     */
    where?: CrisisResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisResources to fetch.
     */
    orderBy?: CrisisResourceOrderByWithRelationInput | CrisisResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrisisResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrisisResources
    **/
    _count?: true | CrisisResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrisisResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrisisResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrisisResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrisisResourceMaxAggregateInputType
  }

  export type GetCrisisResourceAggregateType<T extends CrisisResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateCrisisResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrisisResource[P]>
      : GetScalarType<T[P], AggregateCrisisResource[P]>
  }




  export type CrisisResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrisisResourceWhereInput
    orderBy?: CrisisResourceOrderByWithAggregationInput | CrisisResourceOrderByWithAggregationInput[]
    by: CrisisResourceScalarFieldEnum[] | CrisisResourceScalarFieldEnum
    having?: CrisisResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrisisResourceCountAggregateInputType | true
    _avg?: CrisisResourceAvgAggregateInputType
    _sum?: CrisisResourceSumAggregateInputType
    _min?: CrisisResourceMinAggregateInputType
    _max?: CrisisResourceMaxAggregateInputType
  }

  export type CrisisResourceGroupByOutputType = {
    id: string
    title: string
    description: string
    category: $Enums.ResourceCategory
    phoneNumber: string | null
    url: string | null
    email: string | null
    textNumber: string | null
    content: string | null
    instructions: string | null
    available24_7: boolean
    languages: string | null
    countries: string | null
    regions: string | null
    priority: number
    isEmergency: boolean
    severityMin: number
    tags: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CrisisResourceCountAggregateOutputType | null
    _avg: CrisisResourceAvgAggregateOutputType | null
    _sum: CrisisResourceSumAggregateOutputType | null
    _min: CrisisResourceMinAggregateOutputType | null
    _max: CrisisResourceMaxAggregateOutputType | null
  }

  type GetCrisisResourceGroupByPayload<T extends CrisisResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrisisResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrisisResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrisisResourceGroupByOutputType[P]>
            : GetScalarType<T[P], CrisisResourceGroupByOutputType[P]>
        }
      >
    >


  export type CrisisResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    phoneNumber?: boolean
    url?: boolean
    email?: boolean
    textNumber?: boolean
    content?: boolean
    instructions?: boolean
    available24_7?: boolean
    languages?: boolean
    countries?: boolean
    regions?: boolean
    priority?: boolean
    isEmergency?: boolean
    severityMin?: boolean
    tags?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["crisisResource"]>

  export type CrisisResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    phoneNumber?: boolean
    url?: boolean
    email?: boolean
    textNumber?: boolean
    content?: boolean
    instructions?: boolean
    available24_7?: boolean
    languages?: boolean
    countries?: boolean
    regions?: boolean
    priority?: boolean
    isEmergency?: boolean
    severityMin?: boolean
    tags?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["crisisResource"]>

  export type CrisisResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    phoneNumber?: boolean
    url?: boolean
    email?: boolean
    textNumber?: boolean
    content?: boolean
    instructions?: boolean
    available24_7?: boolean
    languages?: boolean
    countries?: boolean
    regions?: boolean
    priority?: boolean
    isEmergency?: boolean
    severityMin?: boolean
    tags?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["crisisResource"]>

  export type CrisisResourceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    phoneNumber?: boolean
    url?: boolean
    email?: boolean
    textNumber?: boolean
    content?: boolean
    instructions?: boolean
    available24_7?: boolean
    languages?: boolean
    countries?: boolean
    regions?: boolean
    priority?: boolean
    isEmergency?: boolean
    severityMin?: boolean
    tags?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CrisisResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "category" | "phoneNumber" | "url" | "email" | "textNumber" | "content" | "instructions" | "available24_7" | "languages" | "countries" | "regions" | "priority" | "isEmergency" | "severityMin" | "tags" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["crisisResource"]>

  export type $CrisisResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrisisResource"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      category: $Enums.ResourceCategory
      phoneNumber: string | null
      url: string | null
      email: string | null
      textNumber: string | null
      content: string | null
      instructions: string | null
      available24_7: boolean
      languages: string | null
      countries: string | null
      regions: string | null
      priority: number
      isEmergency: boolean
      severityMin: number
      tags: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["crisisResource"]>
    composites: {}
  }

  type CrisisResourceGetPayload<S extends boolean | null | undefined | CrisisResourceDefaultArgs> = $Result.GetResult<Prisma.$CrisisResourcePayload, S>

  type CrisisResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CrisisResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: CrisisResourceCountAggregateInputType | true
    }

  export interface CrisisResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrisisResource'], meta: { name: 'CrisisResource' } }
    /**
     * Find zero or one CrisisResource that matches the filter.
     * @param {CrisisResourceFindUniqueArgs} args - Arguments to find a CrisisResource
     * @example
     * // Get one CrisisResource
     * const crisisResource = await prisma.crisisResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrisisResourceFindUniqueArgs>(args: SelectSubset<T, CrisisResourceFindUniqueArgs<ExtArgs>>): Prisma__CrisisResourceClient<$Result.GetResult<Prisma.$CrisisResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CrisisResource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CrisisResourceFindUniqueOrThrowArgs} args - Arguments to find a CrisisResource
     * @example
     * // Get one CrisisResource
     * const crisisResource = await prisma.crisisResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrisisResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, CrisisResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrisisResourceClient<$Result.GetResult<Prisma.$CrisisResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrisisResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisResourceFindFirstArgs} args - Arguments to find a CrisisResource
     * @example
     * // Get one CrisisResource
     * const crisisResource = await prisma.crisisResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrisisResourceFindFirstArgs>(args?: SelectSubset<T, CrisisResourceFindFirstArgs<ExtArgs>>): Prisma__CrisisResourceClient<$Result.GetResult<Prisma.$CrisisResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrisisResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisResourceFindFirstOrThrowArgs} args - Arguments to find a CrisisResource
     * @example
     * // Get one CrisisResource
     * const crisisResource = await prisma.crisisResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrisisResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, CrisisResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrisisResourceClient<$Result.GetResult<Prisma.$CrisisResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CrisisResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrisisResources
     * const crisisResources = await prisma.crisisResource.findMany()
     * 
     * // Get first 10 CrisisResources
     * const crisisResources = await prisma.crisisResource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crisisResourceWithIdOnly = await prisma.crisisResource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrisisResourceFindManyArgs>(args?: SelectSubset<T, CrisisResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CrisisResource.
     * @param {CrisisResourceCreateArgs} args - Arguments to create a CrisisResource.
     * @example
     * // Create one CrisisResource
     * const CrisisResource = await prisma.crisisResource.create({
     *   data: {
     *     // ... data to create a CrisisResource
     *   }
     * })
     * 
     */
    create<T extends CrisisResourceCreateArgs>(args: SelectSubset<T, CrisisResourceCreateArgs<ExtArgs>>): Prisma__CrisisResourceClient<$Result.GetResult<Prisma.$CrisisResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CrisisResources.
     * @param {CrisisResourceCreateManyArgs} args - Arguments to create many CrisisResources.
     * @example
     * // Create many CrisisResources
     * const crisisResource = await prisma.crisisResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrisisResourceCreateManyArgs>(args?: SelectSubset<T, CrisisResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrisisResources and returns the data saved in the database.
     * @param {CrisisResourceCreateManyAndReturnArgs} args - Arguments to create many CrisisResources.
     * @example
     * // Create many CrisisResources
     * const crisisResource = await prisma.crisisResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrisisResources and only return the `id`
     * const crisisResourceWithIdOnly = await prisma.crisisResource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrisisResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, CrisisResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CrisisResource.
     * @param {CrisisResourceDeleteArgs} args - Arguments to delete one CrisisResource.
     * @example
     * // Delete one CrisisResource
     * const CrisisResource = await prisma.crisisResource.delete({
     *   where: {
     *     // ... filter to delete one CrisisResource
     *   }
     * })
     * 
     */
    delete<T extends CrisisResourceDeleteArgs>(args: SelectSubset<T, CrisisResourceDeleteArgs<ExtArgs>>): Prisma__CrisisResourceClient<$Result.GetResult<Prisma.$CrisisResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CrisisResource.
     * @param {CrisisResourceUpdateArgs} args - Arguments to update one CrisisResource.
     * @example
     * // Update one CrisisResource
     * const crisisResource = await prisma.crisisResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrisisResourceUpdateArgs>(args: SelectSubset<T, CrisisResourceUpdateArgs<ExtArgs>>): Prisma__CrisisResourceClient<$Result.GetResult<Prisma.$CrisisResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CrisisResources.
     * @param {CrisisResourceDeleteManyArgs} args - Arguments to filter CrisisResources to delete.
     * @example
     * // Delete a few CrisisResources
     * const { count } = await prisma.crisisResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrisisResourceDeleteManyArgs>(args?: SelectSubset<T, CrisisResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrisisResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrisisResources
     * const crisisResource = await prisma.crisisResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrisisResourceUpdateManyArgs>(args: SelectSubset<T, CrisisResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrisisResources and returns the data updated in the database.
     * @param {CrisisResourceUpdateManyAndReturnArgs} args - Arguments to update many CrisisResources.
     * @example
     * // Update many CrisisResources
     * const crisisResource = await prisma.crisisResource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CrisisResources and only return the `id`
     * const crisisResourceWithIdOnly = await prisma.crisisResource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CrisisResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, CrisisResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrisisResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CrisisResource.
     * @param {CrisisResourceUpsertArgs} args - Arguments to update or create a CrisisResource.
     * @example
     * // Update or create a CrisisResource
     * const crisisResource = await prisma.crisisResource.upsert({
     *   create: {
     *     // ... data to create a CrisisResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrisisResource we want to update
     *   }
     * })
     */
    upsert<T extends CrisisResourceUpsertArgs>(args: SelectSubset<T, CrisisResourceUpsertArgs<ExtArgs>>): Prisma__CrisisResourceClient<$Result.GetResult<Prisma.$CrisisResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CrisisResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisResourceCountArgs} args - Arguments to filter CrisisResources to count.
     * @example
     * // Count the number of CrisisResources
     * const count = await prisma.crisisResource.count({
     *   where: {
     *     // ... the filter for the CrisisResources we want to count
     *   }
     * })
    **/
    count<T extends CrisisResourceCountArgs>(
      args?: Subset<T, CrisisResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrisisResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrisisResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrisisResourceAggregateArgs>(args: Subset<T, CrisisResourceAggregateArgs>): Prisma.PrismaPromise<GetCrisisResourceAggregateType<T>>

    /**
     * Group by CrisisResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrisisResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrisisResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrisisResourceGroupByArgs['orderBy'] }
        : { orderBy?: CrisisResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrisisResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrisisResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrisisResource model
   */
  readonly fields: CrisisResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrisisResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrisisResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrisisResource model
   */
  interface CrisisResourceFieldRefs {
    readonly id: FieldRef<"CrisisResource", 'String'>
    readonly title: FieldRef<"CrisisResource", 'String'>
    readonly description: FieldRef<"CrisisResource", 'String'>
    readonly category: FieldRef<"CrisisResource", 'ResourceCategory'>
    readonly phoneNumber: FieldRef<"CrisisResource", 'String'>
    readonly url: FieldRef<"CrisisResource", 'String'>
    readonly email: FieldRef<"CrisisResource", 'String'>
    readonly textNumber: FieldRef<"CrisisResource", 'String'>
    readonly content: FieldRef<"CrisisResource", 'String'>
    readonly instructions: FieldRef<"CrisisResource", 'String'>
    readonly available24_7: FieldRef<"CrisisResource", 'Boolean'>
    readonly languages: FieldRef<"CrisisResource", 'String'>
    readonly countries: FieldRef<"CrisisResource", 'String'>
    readonly regions: FieldRef<"CrisisResource", 'String'>
    readonly priority: FieldRef<"CrisisResource", 'Int'>
    readonly isEmergency: FieldRef<"CrisisResource", 'Boolean'>
    readonly severityMin: FieldRef<"CrisisResource", 'Int'>
    readonly tags: FieldRef<"CrisisResource", 'String'>
    readonly isActive: FieldRef<"CrisisResource", 'Boolean'>
    readonly createdAt: FieldRef<"CrisisResource", 'DateTime'>
    readonly updatedAt: FieldRef<"CrisisResource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CrisisResource findUnique
   */
  export type CrisisResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResource
     */
    select?: CrisisResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResource
     */
    omit?: CrisisResourceOmit<ExtArgs> | null
    /**
     * Filter, which CrisisResource to fetch.
     */
    where: CrisisResourceWhereUniqueInput
  }

  /**
   * CrisisResource findUniqueOrThrow
   */
  export type CrisisResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResource
     */
    select?: CrisisResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResource
     */
    omit?: CrisisResourceOmit<ExtArgs> | null
    /**
     * Filter, which CrisisResource to fetch.
     */
    where: CrisisResourceWhereUniqueInput
  }

  /**
   * CrisisResource findFirst
   */
  export type CrisisResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResource
     */
    select?: CrisisResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResource
     */
    omit?: CrisisResourceOmit<ExtArgs> | null
    /**
     * Filter, which CrisisResource to fetch.
     */
    where?: CrisisResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisResources to fetch.
     */
    orderBy?: CrisisResourceOrderByWithRelationInput | CrisisResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrisisResources.
     */
    cursor?: CrisisResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrisisResources.
     */
    distinct?: CrisisResourceScalarFieldEnum | CrisisResourceScalarFieldEnum[]
  }

  /**
   * CrisisResource findFirstOrThrow
   */
  export type CrisisResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResource
     */
    select?: CrisisResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResource
     */
    omit?: CrisisResourceOmit<ExtArgs> | null
    /**
     * Filter, which CrisisResource to fetch.
     */
    where?: CrisisResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisResources to fetch.
     */
    orderBy?: CrisisResourceOrderByWithRelationInput | CrisisResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrisisResources.
     */
    cursor?: CrisisResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrisisResources.
     */
    distinct?: CrisisResourceScalarFieldEnum | CrisisResourceScalarFieldEnum[]
  }

  /**
   * CrisisResource findMany
   */
  export type CrisisResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResource
     */
    select?: CrisisResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResource
     */
    omit?: CrisisResourceOmit<ExtArgs> | null
    /**
     * Filter, which CrisisResources to fetch.
     */
    where?: CrisisResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrisisResources to fetch.
     */
    orderBy?: CrisisResourceOrderByWithRelationInput | CrisisResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrisisResources.
     */
    cursor?: CrisisResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrisisResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrisisResources.
     */
    skip?: number
    distinct?: CrisisResourceScalarFieldEnum | CrisisResourceScalarFieldEnum[]
  }

  /**
   * CrisisResource create
   */
  export type CrisisResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResource
     */
    select?: CrisisResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResource
     */
    omit?: CrisisResourceOmit<ExtArgs> | null
    /**
     * The data needed to create a CrisisResource.
     */
    data: XOR<CrisisResourceCreateInput, CrisisResourceUncheckedCreateInput>
  }

  /**
   * CrisisResource createMany
   */
  export type CrisisResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrisisResources.
     */
    data: CrisisResourceCreateManyInput | CrisisResourceCreateManyInput[]
  }

  /**
   * CrisisResource createManyAndReturn
   */
  export type CrisisResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResource
     */
    select?: CrisisResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResource
     */
    omit?: CrisisResourceOmit<ExtArgs> | null
    /**
     * The data used to create many CrisisResources.
     */
    data: CrisisResourceCreateManyInput | CrisisResourceCreateManyInput[]
  }

  /**
   * CrisisResource update
   */
  export type CrisisResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResource
     */
    select?: CrisisResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResource
     */
    omit?: CrisisResourceOmit<ExtArgs> | null
    /**
     * The data needed to update a CrisisResource.
     */
    data: XOR<CrisisResourceUpdateInput, CrisisResourceUncheckedUpdateInput>
    /**
     * Choose, which CrisisResource to update.
     */
    where: CrisisResourceWhereUniqueInput
  }

  /**
   * CrisisResource updateMany
   */
  export type CrisisResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrisisResources.
     */
    data: XOR<CrisisResourceUpdateManyMutationInput, CrisisResourceUncheckedUpdateManyInput>
    /**
     * Filter which CrisisResources to update
     */
    where?: CrisisResourceWhereInput
    /**
     * Limit how many CrisisResources to update.
     */
    limit?: number
  }

  /**
   * CrisisResource updateManyAndReturn
   */
  export type CrisisResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResource
     */
    select?: CrisisResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResource
     */
    omit?: CrisisResourceOmit<ExtArgs> | null
    /**
     * The data used to update CrisisResources.
     */
    data: XOR<CrisisResourceUpdateManyMutationInput, CrisisResourceUncheckedUpdateManyInput>
    /**
     * Filter which CrisisResources to update
     */
    where?: CrisisResourceWhereInput
    /**
     * Limit how many CrisisResources to update.
     */
    limit?: number
  }

  /**
   * CrisisResource upsert
   */
  export type CrisisResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResource
     */
    select?: CrisisResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResource
     */
    omit?: CrisisResourceOmit<ExtArgs> | null
    /**
     * The filter to search for the CrisisResource to update in case it exists.
     */
    where: CrisisResourceWhereUniqueInput
    /**
     * In case the CrisisResource found by the `where` argument doesn't exist, create a new CrisisResource with this data.
     */
    create: XOR<CrisisResourceCreateInput, CrisisResourceUncheckedCreateInput>
    /**
     * In case the CrisisResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrisisResourceUpdateInput, CrisisResourceUncheckedUpdateInput>
  }

  /**
   * CrisisResource delete
   */
  export type CrisisResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResource
     */
    select?: CrisisResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResource
     */
    omit?: CrisisResourceOmit<ExtArgs> | null
    /**
     * Filter which CrisisResource to delete.
     */
    where: CrisisResourceWhereUniqueInput
  }

  /**
   * CrisisResource deleteMany
   */
  export type CrisisResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrisisResources to delete
     */
    where?: CrisisResourceWhereInput
    /**
     * Limit how many CrisisResources to delete.
     */
    limit?: number
  }

  /**
   * CrisisResource without action
   */
  export type CrisisResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrisisResource
     */
    select?: CrisisResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrisisResource
     */
    omit?: CrisisResourceOmit<ExtArgs> | null
  }


  /**
   * Model PublicMetrics
   */

  export type AggregatePublicMetrics = {
    _count: PublicMetricsCountAggregateOutputType | null
    _avg: PublicMetricsAvgAggregateOutputType | null
    _sum: PublicMetricsSumAggregateOutputType | null
    _min: PublicMetricsMinAggregateOutputType | null
    _max: PublicMetricsMaxAggregateOutputType | null
  }

  export type PublicMetricsAvgAggregateOutputType = {
    value: number | null
    displayOrder: number | null
  }

  export type PublicMetricsSumAggregateOutputType = {
    value: number | null
    displayOrder: number | null
  }

  export type PublicMetricsMinAggregateOutputType = {
    id: string | null
    metricName: string | null
    value: number | null
    displayValue: string | null
    description: string | null
    isPublic: boolean | null
    displayOrder: number | null
    icon: string | null
    color: string | null
    lastUpdated: Date | null
    updateFrequency: string | null
  }

  export type PublicMetricsMaxAggregateOutputType = {
    id: string | null
    metricName: string | null
    value: number | null
    displayValue: string | null
    description: string | null
    isPublic: boolean | null
    displayOrder: number | null
    icon: string | null
    color: string | null
    lastUpdated: Date | null
    updateFrequency: string | null
  }

  export type PublicMetricsCountAggregateOutputType = {
    id: number
    metricName: number
    value: number
    displayValue: number
    description: number
    isPublic: number
    displayOrder: number
    icon: number
    color: number
    lastUpdated: number
    updateFrequency: number
    _all: number
  }


  export type PublicMetricsAvgAggregateInputType = {
    value?: true
    displayOrder?: true
  }

  export type PublicMetricsSumAggregateInputType = {
    value?: true
    displayOrder?: true
  }

  export type PublicMetricsMinAggregateInputType = {
    id?: true
    metricName?: true
    value?: true
    displayValue?: true
    description?: true
    isPublic?: true
    displayOrder?: true
    icon?: true
    color?: true
    lastUpdated?: true
    updateFrequency?: true
  }

  export type PublicMetricsMaxAggregateInputType = {
    id?: true
    metricName?: true
    value?: true
    displayValue?: true
    description?: true
    isPublic?: true
    displayOrder?: true
    icon?: true
    color?: true
    lastUpdated?: true
    updateFrequency?: true
  }

  export type PublicMetricsCountAggregateInputType = {
    id?: true
    metricName?: true
    value?: true
    displayValue?: true
    description?: true
    isPublic?: true
    displayOrder?: true
    icon?: true
    color?: true
    lastUpdated?: true
    updateFrequency?: true
    _all?: true
  }

  export type PublicMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublicMetrics to aggregate.
     */
    where?: PublicMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicMetrics to fetch.
     */
    orderBy?: PublicMetricsOrderByWithRelationInput | PublicMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PublicMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PublicMetrics
    **/
    _count?: true | PublicMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PublicMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PublicMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicMetricsMaxAggregateInputType
  }

  export type GetPublicMetricsAggregateType<T extends PublicMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregatePublicMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublicMetrics[P]>
      : GetScalarType<T[P], AggregatePublicMetrics[P]>
  }




  export type PublicMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicMetricsWhereInput
    orderBy?: PublicMetricsOrderByWithAggregationInput | PublicMetricsOrderByWithAggregationInput[]
    by: PublicMetricsScalarFieldEnum[] | PublicMetricsScalarFieldEnum
    having?: PublicMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicMetricsCountAggregateInputType | true
    _avg?: PublicMetricsAvgAggregateInputType
    _sum?: PublicMetricsSumAggregateInputType
    _min?: PublicMetricsMinAggregateInputType
    _max?: PublicMetricsMaxAggregateInputType
  }

  export type PublicMetricsGroupByOutputType = {
    id: string
    metricName: string
    value: number
    displayValue: string
    description: string
    isPublic: boolean
    displayOrder: number
    icon: string | null
    color: string | null
    lastUpdated: Date
    updateFrequency: string
    _count: PublicMetricsCountAggregateOutputType | null
    _avg: PublicMetricsAvgAggregateOutputType | null
    _sum: PublicMetricsSumAggregateOutputType | null
    _min: PublicMetricsMinAggregateOutputType | null
    _max: PublicMetricsMaxAggregateOutputType | null
  }

  type GetPublicMetricsGroupByPayload<T extends PublicMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublicMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], PublicMetricsGroupByOutputType[P]>
        }
      >
    >


  export type PublicMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricName?: boolean
    value?: boolean
    displayValue?: boolean
    description?: boolean
    isPublic?: boolean
    displayOrder?: boolean
    icon?: boolean
    color?: boolean
    lastUpdated?: boolean
    updateFrequency?: boolean
  }, ExtArgs["result"]["publicMetrics"]>

  export type PublicMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricName?: boolean
    value?: boolean
    displayValue?: boolean
    description?: boolean
    isPublic?: boolean
    displayOrder?: boolean
    icon?: boolean
    color?: boolean
    lastUpdated?: boolean
    updateFrequency?: boolean
  }, ExtArgs["result"]["publicMetrics"]>

  export type PublicMetricsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricName?: boolean
    value?: boolean
    displayValue?: boolean
    description?: boolean
    isPublic?: boolean
    displayOrder?: boolean
    icon?: boolean
    color?: boolean
    lastUpdated?: boolean
    updateFrequency?: boolean
  }, ExtArgs["result"]["publicMetrics"]>

  export type PublicMetricsSelectScalar = {
    id?: boolean
    metricName?: boolean
    value?: boolean
    displayValue?: boolean
    description?: boolean
    isPublic?: boolean
    displayOrder?: boolean
    icon?: boolean
    color?: boolean
    lastUpdated?: boolean
    updateFrequency?: boolean
  }

  export type PublicMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "metricName" | "value" | "displayValue" | "description" | "isPublic" | "displayOrder" | "icon" | "color" | "lastUpdated" | "updateFrequency", ExtArgs["result"]["publicMetrics"]>

  export type $PublicMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PublicMetrics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      metricName: string
      value: number
      displayValue: string
      description: string
      isPublic: boolean
      displayOrder: number
      icon: string | null
      color: string | null
      lastUpdated: Date
      updateFrequency: string
    }, ExtArgs["result"]["publicMetrics"]>
    composites: {}
  }

  type PublicMetricsGetPayload<S extends boolean | null | undefined | PublicMetricsDefaultArgs> = $Result.GetResult<Prisma.$PublicMetricsPayload, S>

  type PublicMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PublicMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: PublicMetricsCountAggregateInputType | true
    }

  export interface PublicMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PublicMetrics'], meta: { name: 'PublicMetrics' } }
    /**
     * Find zero or one PublicMetrics that matches the filter.
     * @param {PublicMetricsFindUniqueArgs} args - Arguments to find a PublicMetrics
     * @example
     * // Get one PublicMetrics
     * const publicMetrics = await prisma.publicMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PublicMetricsFindUniqueArgs>(args: SelectSubset<T, PublicMetricsFindUniqueArgs<ExtArgs>>): Prisma__PublicMetricsClient<$Result.GetResult<Prisma.$PublicMetricsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PublicMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PublicMetricsFindUniqueOrThrowArgs} args - Arguments to find a PublicMetrics
     * @example
     * // Get one PublicMetrics
     * const publicMetrics = await prisma.publicMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PublicMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, PublicMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PublicMetricsClient<$Result.GetResult<Prisma.$PublicMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PublicMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicMetricsFindFirstArgs} args - Arguments to find a PublicMetrics
     * @example
     * // Get one PublicMetrics
     * const publicMetrics = await prisma.publicMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PublicMetricsFindFirstArgs>(args?: SelectSubset<T, PublicMetricsFindFirstArgs<ExtArgs>>): Prisma__PublicMetricsClient<$Result.GetResult<Prisma.$PublicMetricsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PublicMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicMetricsFindFirstOrThrowArgs} args - Arguments to find a PublicMetrics
     * @example
     * // Get one PublicMetrics
     * const publicMetrics = await prisma.publicMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PublicMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, PublicMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PublicMetricsClient<$Result.GetResult<Prisma.$PublicMetricsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PublicMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PublicMetrics
     * const publicMetrics = await prisma.publicMetrics.findMany()
     * 
     * // Get first 10 PublicMetrics
     * const publicMetrics = await prisma.publicMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publicMetricsWithIdOnly = await prisma.publicMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PublicMetricsFindManyArgs>(args?: SelectSubset<T, PublicMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PublicMetrics.
     * @param {PublicMetricsCreateArgs} args - Arguments to create a PublicMetrics.
     * @example
     * // Create one PublicMetrics
     * const PublicMetrics = await prisma.publicMetrics.create({
     *   data: {
     *     // ... data to create a PublicMetrics
     *   }
     * })
     * 
     */
    create<T extends PublicMetricsCreateArgs>(args: SelectSubset<T, PublicMetricsCreateArgs<ExtArgs>>): Prisma__PublicMetricsClient<$Result.GetResult<Prisma.$PublicMetricsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PublicMetrics.
     * @param {PublicMetricsCreateManyArgs} args - Arguments to create many PublicMetrics.
     * @example
     * // Create many PublicMetrics
     * const publicMetrics = await prisma.publicMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PublicMetricsCreateManyArgs>(args?: SelectSubset<T, PublicMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PublicMetrics and returns the data saved in the database.
     * @param {PublicMetricsCreateManyAndReturnArgs} args - Arguments to create many PublicMetrics.
     * @example
     * // Create many PublicMetrics
     * const publicMetrics = await prisma.publicMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PublicMetrics and only return the `id`
     * const publicMetricsWithIdOnly = await prisma.publicMetrics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PublicMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, PublicMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicMetricsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PublicMetrics.
     * @param {PublicMetricsDeleteArgs} args - Arguments to delete one PublicMetrics.
     * @example
     * // Delete one PublicMetrics
     * const PublicMetrics = await prisma.publicMetrics.delete({
     *   where: {
     *     // ... filter to delete one PublicMetrics
     *   }
     * })
     * 
     */
    delete<T extends PublicMetricsDeleteArgs>(args: SelectSubset<T, PublicMetricsDeleteArgs<ExtArgs>>): Prisma__PublicMetricsClient<$Result.GetResult<Prisma.$PublicMetricsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PublicMetrics.
     * @param {PublicMetricsUpdateArgs} args - Arguments to update one PublicMetrics.
     * @example
     * // Update one PublicMetrics
     * const publicMetrics = await prisma.publicMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PublicMetricsUpdateArgs>(args: SelectSubset<T, PublicMetricsUpdateArgs<ExtArgs>>): Prisma__PublicMetricsClient<$Result.GetResult<Prisma.$PublicMetricsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PublicMetrics.
     * @param {PublicMetricsDeleteManyArgs} args - Arguments to filter PublicMetrics to delete.
     * @example
     * // Delete a few PublicMetrics
     * const { count } = await prisma.publicMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PublicMetricsDeleteManyArgs>(args?: SelectSubset<T, PublicMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PublicMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PublicMetrics
     * const publicMetrics = await prisma.publicMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PublicMetricsUpdateManyArgs>(args: SelectSubset<T, PublicMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PublicMetrics and returns the data updated in the database.
     * @param {PublicMetricsUpdateManyAndReturnArgs} args - Arguments to update many PublicMetrics.
     * @example
     * // Update many PublicMetrics
     * const publicMetrics = await prisma.publicMetrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PublicMetrics and only return the `id`
     * const publicMetricsWithIdOnly = await prisma.publicMetrics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PublicMetricsUpdateManyAndReturnArgs>(args: SelectSubset<T, PublicMetricsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicMetricsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PublicMetrics.
     * @param {PublicMetricsUpsertArgs} args - Arguments to update or create a PublicMetrics.
     * @example
     * // Update or create a PublicMetrics
     * const publicMetrics = await prisma.publicMetrics.upsert({
     *   create: {
     *     // ... data to create a PublicMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PublicMetrics we want to update
     *   }
     * })
     */
    upsert<T extends PublicMetricsUpsertArgs>(args: SelectSubset<T, PublicMetricsUpsertArgs<ExtArgs>>): Prisma__PublicMetricsClient<$Result.GetResult<Prisma.$PublicMetricsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PublicMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicMetricsCountArgs} args - Arguments to filter PublicMetrics to count.
     * @example
     * // Count the number of PublicMetrics
     * const count = await prisma.publicMetrics.count({
     *   where: {
     *     // ... the filter for the PublicMetrics we want to count
     *   }
     * })
    **/
    count<T extends PublicMetricsCountArgs>(
      args?: Subset<T, PublicMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PublicMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicMetricsAggregateArgs>(args: Subset<T, PublicMetricsAggregateArgs>): Prisma.PrismaPromise<GetPublicMetricsAggregateType<T>>

    /**
     * Group by PublicMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublicMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublicMetricsGroupByArgs['orderBy'] }
        : { orderBy?: PublicMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublicMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PublicMetrics model
   */
  readonly fields: PublicMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PublicMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PublicMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PublicMetrics model
   */
  interface PublicMetricsFieldRefs {
    readonly id: FieldRef<"PublicMetrics", 'String'>
    readonly metricName: FieldRef<"PublicMetrics", 'String'>
    readonly value: FieldRef<"PublicMetrics", 'Float'>
    readonly displayValue: FieldRef<"PublicMetrics", 'String'>
    readonly description: FieldRef<"PublicMetrics", 'String'>
    readonly isPublic: FieldRef<"PublicMetrics", 'Boolean'>
    readonly displayOrder: FieldRef<"PublicMetrics", 'Int'>
    readonly icon: FieldRef<"PublicMetrics", 'String'>
    readonly color: FieldRef<"PublicMetrics", 'String'>
    readonly lastUpdated: FieldRef<"PublicMetrics", 'DateTime'>
    readonly updateFrequency: FieldRef<"PublicMetrics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PublicMetrics findUnique
   */
  export type PublicMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicMetrics
     */
    select?: PublicMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicMetrics
     */
    omit?: PublicMetricsOmit<ExtArgs> | null
    /**
     * Filter, which PublicMetrics to fetch.
     */
    where: PublicMetricsWhereUniqueInput
  }

  /**
   * PublicMetrics findUniqueOrThrow
   */
  export type PublicMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicMetrics
     */
    select?: PublicMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicMetrics
     */
    omit?: PublicMetricsOmit<ExtArgs> | null
    /**
     * Filter, which PublicMetrics to fetch.
     */
    where: PublicMetricsWhereUniqueInput
  }

  /**
   * PublicMetrics findFirst
   */
  export type PublicMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicMetrics
     */
    select?: PublicMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicMetrics
     */
    omit?: PublicMetricsOmit<ExtArgs> | null
    /**
     * Filter, which PublicMetrics to fetch.
     */
    where?: PublicMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicMetrics to fetch.
     */
    orderBy?: PublicMetricsOrderByWithRelationInput | PublicMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PublicMetrics.
     */
    cursor?: PublicMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PublicMetrics.
     */
    distinct?: PublicMetricsScalarFieldEnum | PublicMetricsScalarFieldEnum[]
  }

  /**
   * PublicMetrics findFirstOrThrow
   */
  export type PublicMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicMetrics
     */
    select?: PublicMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicMetrics
     */
    omit?: PublicMetricsOmit<ExtArgs> | null
    /**
     * Filter, which PublicMetrics to fetch.
     */
    where?: PublicMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicMetrics to fetch.
     */
    orderBy?: PublicMetricsOrderByWithRelationInput | PublicMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PublicMetrics.
     */
    cursor?: PublicMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PublicMetrics.
     */
    distinct?: PublicMetricsScalarFieldEnum | PublicMetricsScalarFieldEnum[]
  }

  /**
   * PublicMetrics findMany
   */
  export type PublicMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicMetrics
     */
    select?: PublicMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicMetrics
     */
    omit?: PublicMetricsOmit<ExtArgs> | null
    /**
     * Filter, which PublicMetrics to fetch.
     */
    where?: PublicMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicMetrics to fetch.
     */
    orderBy?: PublicMetricsOrderByWithRelationInput | PublicMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PublicMetrics.
     */
    cursor?: PublicMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicMetrics.
     */
    skip?: number
    distinct?: PublicMetricsScalarFieldEnum | PublicMetricsScalarFieldEnum[]
  }

  /**
   * PublicMetrics create
   */
  export type PublicMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicMetrics
     */
    select?: PublicMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicMetrics
     */
    omit?: PublicMetricsOmit<ExtArgs> | null
    /**
     * The data needed to create a PublicMetrics.
     */
    data: XOR<PublicMetricsCreateInput, PublicMetricsUncheckedCreateInput>
  }

  /**
   * PublicMetrics createMany
   */
  export type PublicMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PublicMetrics.
     */
    data: PublicMetricsCreateManyInput | PublicMetricsCreateManyInput[]
  }

  /**
   * PublicMetrics createManyAndReturn
   */
  export type PublicMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicMetrics
     */
    select?: PublicMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PublicMetrics
     */
    omit?: PublicMetricsOmit<ExtArgs> | null
    /**
     * The data used to create many PublicMetrics.
     */
    data: PublicMetricsCreateManyInput | PublicMetricsCreateManyInput[]
  }

  /**
   * PublicMetrics update
   */
  export type PublicMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicMetrics
     */
    select?: PublicMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicMetrics
     */
    omit?: PublicMetricsOmit<ExtArgs> | null
    /**
     * The data needed to update a PublicMetrics.
     */
    data: XOR<PublicMetricsUpdateInput, PublicMetricsUncheckedUpdateInput>
    /**
     * Choose, which PublicMetrics to update.
     */
    where: PublicMetricsWhereUniqueInput
  }

  /**
   * PublicMetrics updateMany
   */
  export type PublicMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PublicMetrics.
     */
    data: XOR<PublicMetricsUpdateManyMutationInput, PublicMetricsUncheckedUpdateManyInput>
    /**
     * Filter which PublicMetrics to update
     */
    where?: PublicMetricsWhereInput
    /**
     * Limit how many PublicMetrics to update.
     */
    limit?: number
  }

  /**
   * PublicMetrics updateManyAndReturn
   */
  export type PublicMetricsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicMetrics
     */
    select?: PublicMetricsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PublicMetrics
     */
    omit?: PublicMetricsOmit<ExtArgs> | null
    /**
     * The data used to update PublicMetrics.
     */
    data: XOR<PublicMetricsUpdateManyMutationInput, PublicMetricsUncheckedUpdateManyInput>
    /**
     * Filter which PublicMetrics to update
     */
    where?: PublicMetricsWhereInput
    /**
     * Limit how many PublicMetrics to update.
     */
    limit?: number
  }

  /**
   * PublicMetrics upsert
   */
  export type PublicMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicMetrics
     */
    select?: PublicMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicMetrics
     */
    omit?: PublicMetricsOmit<ExtArgs> | null
    /**
     * The filter to search for the PublicMetrics to update in case it exists.
     */
    where: PublicMetricsWhereUniqueInput
    /**
     * In case the PublicMetrics found by the `where` argument doesn't exist, create a new PublicMetrics with this data.
     */
    create: XOR<PublicMetricsCreateInput, PublicMetricsUncheckedCreateInput>
    /**
     * In case the PublicMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PublicMetricsUpdateInput, PublicMetricsUncheckedUpdateInput>
  }

  /**
   * PublicMetrics delete
   */
  export type PublicMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicMetrics
     */
    select?: PublicMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicMetrics
     */
    omit?: PublicMetricsOmit<ExtArgs> | null
    /**
     * Filter which PublicMetrics to delete.
     */
    where: PublicMetricsWhereUniqueInput
  }

  /**
   * PublicMetrics deleteMany
   */
  export type PublicMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublicMetrics to delete
     */
    where?: PublicMetricsWhereInput
    /**
     * Limit how many PublicMetrics to delete.
     */
    limit?: number
  }

  /**
   * PublicMetrics without action
   */
  export type PublicMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicMetrics
     */
    select?: PublicMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicMetrics
     */
    omit?: PublicMetricsOmit<ExtArgs> | null
  }


  /**
   * Model EmergencyContact
   */

  export type AggregateEmergencyContact = {
    _count: EmergencyContactCountAggregateOutputType | null
    _avg: EmergencyContactAvgAggregateOutputType | null
    _sum: EmergencyContactSumAggregateOutputType | null
    _min: EmergencyContactMinAggregateOutputType | null
    _max: EmergencyContactMaxAggregateOutputType | null
  }

  export type EmergencyContactAvgAggregateOutputType = {
    priority: number | null
  }

  export type EmergencyContactSumAggregateOutputType = {
    priority: number | null
  }

  export type EmergencyContactMinAggregateOutputType = {
    id: string | null
    userId: string | null
    encryptedName: Uint8Array | null
    encryptedPhone: Uint8Array | null
    encryptedEmail: Uint8Array | null
    relationship: string | null
    priority: number | null
    contactMethod: string | null
    timezone: string | null
    preferredMethod: string | null
    autoNotify: boolean | null
    crisisOnly: boolean | null
    hasConsent: boolean | null
    consentDate: Date | null
    keyDerivationSalt: Uint8Array | null
    isVerified: boolean | null
    verifiedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastContacted: Date | null
  }

  export type EmergencyContactMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    encryptedName: Uint8Array | null
    encryptedPhone: Uint8Array | null
    encryptedEmail: Uint8Array | null
    relationship: string | null
    priority: number | null
    contactMethod: string | null
    timezone: string | null
    preferredMethod: string | null
    autoNotify: boolean | null
    crisisOnly: boolean | null
    hasConsent: boolean | null
    consentDate: Date | null
    keyDerivationSalt: Uint8Array | null
    isVerified: boolean | null
    verifiedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastContacted: Date | null
  }

  export type EmergencyContactCountAggregateOutputType = {
    id: number
    userId: number
    encryptedName: number
    encryptedPhone: number
    encryptedEmail: number
    relationship: number
    priority: number
    contactMethod: number
    timezone: number
    availableHours: number
    preferredMethod: number
    autoNotify: number
    crisisOnly: number
    hasConsent: number
    consentDate: number
    keyDerivationSalt: number
    isVerified: number
    verifiedAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    lastContacted: number
    _all: number
  }


  export type EmergencyContactAvgAggregateInputType = {
    priority?: true
  }

  export type EmergencyContactSumAggregateInputType = {
    priority?: true
  }

  export type EmergencyContactMinAggregateInputType = {
    id?: true
    userId?: true
    encryptedName?: true
    encryptedPhone?: true
    encryptedEmail?: true
    relationship?: true
    priority?: true
    contactMethod?: true
    timezone?: true
    preferredMethod?: true
    autoNotify?: true
    crisisOnly?: true
    hasConsent?: true
    consentDate?: true
    keyDerivationSalt?: true
    isVerified?: true
    verifiedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastContacted?: true
  }

  export type EmergencyContactMaxAggregateInputType = {
    id?: true
    userId?: true
    encryptedName?: true
    encryptedPhone?: true
    encryptedEmail?: true
    relationship?: true
    priority?: true
    contactMethod?: true
    timezone?: true
    preferredMethod?: true
    autoNotify?: true
    crisisOnly?: true
    hasConsent?: true
    consentDate?: true
    keyDerivationSalt?: true
    isVerified?: true
    verifiedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastContacted?: true
  }

  export type EmergencyContactCountAggregateInputType = {
    id?: true
    userId?: true
    encryptedName?: true
    encryptedPhone?: true
    encryptedEmail?: true
    relationship?: true
    priority?: true
    contactMethod?: true
    timezone?: true
    availableHours?: true
    preferredMethod?: true
    autoNotify?: true
    crisisOnly?: true
    hasConsent?: true
    consentDate?: true
    keyDerivationSalt?: true
    isVerified?: true
    verifiedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastContacted?: true
    _all?: true
  }

  export type EmergencyContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyContact to aggregate.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmergencyContacts
    **/
    _count?: true | EmergencyContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmergencyContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmergencyContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmergencyContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmergencyContactMaxAggregateInputType
  }

  export type GetEmergencyContactAggregateType<T extends EmergencyContactAggregateArgs> = {
        [P in keyof T & keyof AggregateEmergencyContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmergencyContact[P]>
      : GetScalarType<T[P], AggregateEmergencyContact[P]>
  }




  export type EmergencyContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyContactWhereInput
    orderBy?: EmergencyContactOrderByWithAggregationInput | EmergencyContactOrderByWithAggregationInput[]
    by: EmergencyContactScalarFieldEnum[] | EmergencyContactScalarFieldEnum
    having?: EmergencyContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmergencyContactCountAggregateInputType | true
    _avg?: EmergencyContactAvgAggregateInputType
    _sum?: EmergencyContactSumAggregateInputType
    _min?: EmergencyContactMinAggregateInputType
    _max?: EmergencyContactMaxAggregateInputType
  }

  export type EmergencyContactGroupByOutputType = {
    id: string
    userId: string
    encryptedName: Uint8Array
    encryptedPhone: Uint8Array
    encryptedEmail: Uint8Array | null
    relationship: string
    priority: number
    contactMethod: string
    timezone: string | null
    availableHours: JsonValue | null
    preferredMethod: string | null
    autoNotify: boolean
    crisisOnly: boolean
    hasConsent: boolean
    consentDate: Date | null
    keyDerivationSalt: Uint8Array
    isVerified: boolean
    verifiedAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    lastContacted: Date | null
    _count: EmergencyContactCountAggregateOutputType | null
    _avg: EmergencyContactAvgAggregateOutputType | null
    _sum: EmergencyContactSumAggregateOutputType | null
    _min: EmergencyContactMinAggregateOutputType | null
    _max: EmergencyContactMaxAggregateOutputType | null
  }

  type GetEmergencyContactGroupByPayload<T extends EmergencyContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmergencyContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmergencyContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmergencyContactGroupByOutputType[P]>
            : GetScalarType<T[P], EmergencyContactGroupByOutputType[P]>
        }
      >
    >


  export type EmergencyContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    encryptedName?: boolean
    encryptedPhone?: boolean
    encryptedEmail?: boolean
    relationship?: boolean
    priority?: boolean
    contactMethod?: boolean
    timezone?: boolean
    availableHours?: boolean
    preferredMethod?: boolean
    autoNotify?: boolean
    crisisOnly?: boolean
    hasConsent?: boolean
    consentDate?: boolean
    keyDerivationSalt?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastContacted?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    notifications?: boolean | EmergencyContact$notificationsArgs<ExtArgs>
    _count?: boolean | EmergencyContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyContact"]>

  export type EmergencyContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    encryptedName?: boolean
    encryptedPhone?: boolean
    encryptedEmail?: boolean
    relationship?: boolean
    priority?: boolean
    contactMethod?: boolean
    timezone?: boolean
    availableHours?: boolean
    preferredMethod?: boolean
    autoNotify?: boolean
    crisisOnly?: boolean
    hasConsent?: boolean
    consentDate?: boolean
    keyDerivationSalt?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastContacted?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyContact"]>

  export type EmergencyContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    encryptedName?: boolean
    encryptedPhone?: boolean
    encryptedEmail?: boolean
    relationship?: boolean
    priority?: boolean
    contactMethod?: boolean
    timezone?: boolean
    availableHours?: boolean
    preferredMethod?: boolean
    autoNotify?: boolean
    crisisOnly?: boolean
    hasConsent?: boolean
    consentDate?: boolean
    keyDerivationSalt?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastContacted?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyContact"]>

  export type EmergencyContactSelectScalar = {
    id?: boolean
    userId?: boolean
    encryptedName?: boolean
    encryptedPhone?: boolean
    encryptedEmail?: boolean
    relationship?: boolean
    priority?: boolean
    contactMethod?: boolean
    timezone?: boolean
    availableHours?: boolean
    preferredMethod?: boolean
    autoNotify?: boolean
    crisisOnly?: boolean
    hasConsent?: boolean
    consentDate?: boolean
    keyDerivationSalt?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastContacted?: boolean
  }

  export type EmergencyContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "encryptedName" | "encryptedPhone" | "encryptedEmail" | "relationship" | "priority" | "contactMethod" | "timezone" | "availableHours" | "preferredMethod" | "autoNotify" | "crisisOnly" | "hasConsent" | "consentDate" | "keyDerivationSalt" | "isVerified" | "verifiedAt" | "isActive" | "createdAt" | "updatedAt" | "lastContacted", ExtArgs["result"]["emergencyContact"]>
  export type EmergencyContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    notifications?: boolean | EmergencyContact$notificationsArgs<ExtArgs>
    _count?: boolean | EmergencyContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmergencyContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmergencyContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmergencyContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmergencyContact"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      notifications: Prisma.$EmergencyNotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      encryptedName: Uint8Array
      encryptedPhone: Uint8Array
      encryptedEmail: Uint8Array | null
      relationship: string
      priority: number
      contactMethod: string
      timezone: string | null
      availableHours: Prisma.JsonValue | null
      preferredMethod: string | null
      autoNotify: boolean
      crisisOnly: boolean
      hasConsent: boolean
      consentDate: Date | null
      keyDerivationSalt: Uint8Array
      isVerified: boolean
      verifiedAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      lastContacted: Date | null
    }, ExtArgs["result"]["emergencyContact"]>
    composites: {}
  }

  type EmergencyContactGetPayload<S extends boolean | null | undefined | EmergencyContactDefaultArgs> = $Result.GetResult<Prisma.$EmergencyContactPayload, S>

  type EmergencyContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmergencyContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: EmergencyContactCountAggregateInputType | true
    }

  export interface EmergencyContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmergencyContact'], meta: { name: 'EmergencyContact' } }
    /**
     * Find zero or one EmergencyContact that matches the filter.
     * @param {EmergencyContactFindUniqueArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmergencyContactFindUniqueArgs>(args: SelectSubset<T, EmergencyContactFindUniqueArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmergencyContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmergencyContactFindUniqueOrThrowArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmergencyContactFindUniqueOrThrowArgs>(args: SelectSubset<T, EmergencyContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindFirstArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmergencyContactFindFirstArgs>(args?: SelectSubset<T, EmergencyContactFindFirstArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindFirstOrThrowArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmergencyContactFindFirstOrThrowArgs>(args?: SelectSubset<T, EmergencyContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmergencyContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmergencyContacts
     * const emergencyContacts = await prisma.emergencyContact.findMany()
     * 
     * // Get first 10 EmergencyContacts
     * const emergencyContacts = await prisma.emergencyContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emergencyContactWithIdOnly = await prisma.emergencyContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmergencyContactFindManyArgs>(args?: SelectSubset<T, EmergencyContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmergencyContact.
     * @param {EmergencyContactCreateArgs} args - Arguments to create a EmergencyContact.
     * @example
     * // Create one EmergencyContact
     * const EmergencyContact = await prisma.emergencyContact.create({
     *   data: {
     *     // ... data to create a EmergencyContact
     *   }
     * })
     * 
     */
    create<T extends EmergencyContactCreateArgs>(args: SelectSubset<T, EmergencyContactCreateArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmergencyContacts.
     * @param {EmergencyContactCreateManyArgs} args - Arguments to create many EmergencyContacts.
     * @example
     * // Create many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmergencyContactCreateManyArgs>(args?: SelectSubset<T, EmergencyContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmergencyContacts and returns the data saved in the database.
     * @param {EmergencyContactCreateManyAndReturnArgs} args - Arguments to create many EmergencyContacts.
     * @example
     * // Create many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmergencyContacts and only return the `id`
     * const emergencyContactWithIdOnly = await prisma.emergencyContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmergencyContactCreateManyAndReturnArgs>(args?: SelectSubset<T, EmergencyContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmergencyContact.
     * @param {EmergencyContactDeleteArgs} args - Arguments to delete one EmergencyContact.
     * @example
     * // Delete one EmergencyContact
     * const EmergencyContact = await prisma.emergencyContact.delete({
     *   where: {
     *     // ... filter to delete one EmergencyContact
     *   }
     * })
     * 
     */
    delete<T extends EmergencyContactDeleteArgs>(args: SelectSubset<T, EmergencyContactDeleteArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmergencyContact.
     * @param {EmergencyContactUpdateArgs} args - Arguments to update one EmergencyContact.
     * @example
     * // Update one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmergencyContactUpdateArgs>(args: SelectSubset<T, EmergencyContactUpdateArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmergencyContacts.
     * @param {EmergencyContactDeleteManyArgs} args - Arguments to filter EmergencyContacts to delete.
     * @example
     * // Delete a few EmergencyContacts
     * const { count } = await prisma.emergencyContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmergencyContactDeleteManyArgs>(args?: SelectSubset<T, EmergencyContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmergencyContactUpdateManyArgs>(args: SelectSubset<T, EmergencyContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyContacts and returns the data updated in the database.
     * @param {EmergencyContactUpdateManyAndReturnArgs} args - Arguments to update many EmergencyContacts.
     * @example
     * // Update many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmergencyContacts and only return the `id`
     * const emergencyContactWithIdOnly = await prisma.emergencyContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmergencyContactUpdateManyAndReturnArgs>(args: SelectSubset<T, EmergencyContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmergencyContact.
     * @param {EmergencyContactUpsertArgs} args - Arguments to update or create a EmergencyContact.
     * @example
     * // Update or create a EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.upsert({
     *   create: {
     *     // ... data to create a EmergencyContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmergencyContact we want to update
     *   }
     * })
     */
    upsert<T extends EmergencyContactUpsertArgs>(args: SelectSubset<T, EmergencyContactUpsertArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactCountArgs} args - Arguments to filter EmergencyContacts to count.
     * @example
     * // Count the number of EmergencyContacts
     * const count = await prisma.emergencyContact.count({
     *   where: {
     *     // ... the filter for the EmergencyContacts we want to count
     *   }
     * })
    **/
    count<T extends EmergencyContactCountArgs>(
      args?: Subset<T, EmergencyContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmergencyContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmergencyContactAggregateArgs>(args: Subset<T, EmergencyContactAggregateArgs>): Prisma.PrismaPromise<GetEmergencyContactAggregateType<T>>

    /**
     * Group by EmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmergencyContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmergencyContactGroupByArgs['orderBy'] }
        : { orderBy?: EmergencyContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmergencyContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmergencyContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmergencyContact model
   */
  readonly fields: EmergencyContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmergencyContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmergencyContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notifications<T extends EmergencyContact$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, EmergencyContact$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmergencyContact model
   */
  interface EmergencyContactFieldRefs {
    readonly id: FieldRef<"EmergencyContact", 'String'>
    readonly userId: FieldRef<"EmergencyContact", 'String'>
    readonly encryptedName: FieldRef<"EmergencyContact", 'Bytes'>
    readonly encryptedPhone: FieldRef<"EmergencyContact", 'Bytes'>
    readonly encryptedEmail: FieldRef<"EmergencyContact", 'Bytes'>
    readonly relationship: FieldRef<"EmergencyContact", 'String'>
    readonly priority: FieldRef<"EmergencyContact", 'Int'>
    readonly contactMethod: FieldRef<"EmergencyContact", 'String'>
    readonly timezone: FieldRef<"EmergencyContact", 'String'>
    readonly availableHours: FieldRef<"EmergencyContact", 'Json'>
    readonly preferredMethod: FieldRef<"EmergencyContact", 'String'>
    readonly autoNotify: FieldRef<"EmergencyContact", 'Boolean'>
    readonly crisisOnly: FieldRef<"EmergencyContact", 'Boolean'>
    readonly hasConsent: FieldRef<"EmergencyContact", 'Boolean'>
    readonly consentDate: FieldRef<"EmergencyContact", 'DateTime'>
    readonly keyDerivationSalt: FieldRef<"EmergencyContact", 'Bytes'>
    readonly isVerified: FieldRef<"EmergencyContact", 'Boolean'>
    readonly verifiedAt: FieldRef<"EmergencyContact", 'DateTime'>
    readonly isActive: FieldRef<"EmergencyContact", 'Boolean'>
    readonly createdAt: FieldRef<"EmergencyContact", 'DateTime'>
    readonly updatedAt: FieldRef<"EmergencyContact", 'DateTime'>
    readonly lastContacted: FieldRef<"EmergencyContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmergencyContact findUnique
   */
  export type EmergencyContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact findUniqueOrThrow
   */
  export type EmergencyContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact findFirst
   */
  export type EmergencyContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyContacts.
     */
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact findFirstOrThrow
   */
  export type EmergencyContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyContacts.
     */
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact findMany
   */
  export type EmergencyContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContacts to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact create
   */
  export type EmergencyContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to create a EmergencyContact.
     */
    data: XOR<EmergencyContactCreateInput, EmergencyContactUncheckedCreateInput>
  }

  /**
   * EmergencyContact createMany
   */
  export type EmergencyContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmergencyContacts.
     */
    data: EmergencyContactCreateManyInput | EmergencyContactCreateManyInput[]
  }

  /**
   * EmergencyContact createManyAndReturn
   */
  export type EmergencyContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * The data used to create many EmergencyContacts.
     */
    data: EmergencyContactCreateManyInput | EmergencyContactCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmergencyContact update
   */
  export type EmergencyContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to update a EmergencyContact.
     */
    data: XOR<EmergencyContactUpdateInput, EmergencyContactUncheckedUpdateInput>
    /**
     * Choose, which EmergencyContact to update.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact updateMany
   */
  export type EmergencyContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmergencyContacts.
     */
    data: XOR<EmergencyContactUpdateManyMutationInput, EmergencyContactUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyContacts to update
     */
    where?: EmergencyContactWhereInput
    /**
     * Limit how many EmergencyContacts to update.
     */
    limit?: number
  }

  /**
   * EmergencyContact updateManyAndReturn
   */
  export type EmergencyContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * The data used to update EmergencyContacts.
     */
    data: XOR<EmergencyContactUpdateManyMutationInput, EmergencyContactUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyContacts to update
     */
    where?: EmergencyContactWhereInput
    /**
     * Limit how many EmergencyContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmergencyContact upsert
   */
  export type EmergencyContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The filter to search for the EmergencyContact to update in case it exists.
     */
    where: EmergencyContactWhereUniqueInput
    /**
     * In case the EmergencyContact found by the `where` argument doesn't exist, create a new EmergencyContact with this data.
     */
    create: XOR<EmergencyContactCreateInput, EmergencyContactUncheckedCreateInput>
    /**
     * In case the EmergencyContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmergencyContactUpdateInput, EmergencyContactUncheckedUpdateInput>
  }

  /**
   * EmergencyContact delete
   */
  export type EmergencyContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter which EmergencyContact to delete.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact deleteMany
   */
  export type EmergencyContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyContacts to delete
     */
    where?: EmergencyContactWhereInput
    /**
     * Limit how many EmergencyContacts to delete.
     */
    limit?: number
  }

  /**
   * EmergencyContact.notifications
   */
  export type EmergencyContact$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyNotification
     */
    select?: EmergencyNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyNotification
     */
    omit?: EmergencyNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyNotificationInclude<ExtArgs> | null
    where?: EmergencyNotificationWhereInput
    orderBy?: EmergencyNotificationOrderByWithRelationInput | EmergencyNotificationOrderByWithRelationInput[]
    cursor?: EmergencyNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmergencyNotificationScalarFieldEnum | EmergencyNotificationScalarFieldEnum[]
  }

  /**
   * EmergencyContact without action
   */
  export type EmergencyContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
  }


  /**
   * Model EmergencyNotification
   */

  export type AggregateEmergencyNotification = {
    _count: EmergencyNotificationCountAggregateOutputType | null
    _avg: EmergencyNotificationAvgAggregateOutputType | null
    _sum: EmergencyNotificationSumAggregateOutputType | null
    _min: EmergencyNotificationMinAggregateOutputType | null
    _max: EmergencyNotificationMaxAggregateOutputType | null
  }

  export type EmergencyNotificationAvgAggregateOutputType = {
    responseTime: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type EmergencyNotificationSumAggregateOutputType = {
    responseTime: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type EmergencyNotificationMinAggregateOutputType = {
    id: string | null
    emergencyContactId: string | null
    sessionId: string | null
    tetherEmergencyId: string | null
    notificationType: $Enums.EmergencyNotificationType | null
    severity: $Enums.EmergencySeverity | null
    message: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    acknowledgedAt: Date | null
    responseReceived: boolean | null
    responseTime: number | null
    method: string | null
    status: $Enums.NotificationStatus | null
    attempts: number | null
    maxAttempts: number | null
    errorMessage: string | null
    nextRetryAt: Date | null
  }

  export type EmergencyNotificationMaxAggregateOutputType = {
    id: string | null
    emergencyContactId: string | null
    sessionId: string | null
    tetherEmergencyId: string | null
    notificationType: $Enums.EmergencyNotificationType | null
    severity: $Enums.EmergencySeverity | null
    message: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    acknowledgedAt: Date | null
    responseReceived: boolean | null
    responseTime: number | null
    method: string | null
    status: $Enums.NotificationStatus | null
    attempts: number | null
    maxAttempts: number | null
    errorMessage: string | null
    nextRetryAt: Date | null
  }

  export type EmergencyNotificationCountAggregateOutputType = {
    id: number
    emergencyContactId: number
    sessionId: number
    tetherEmergencyId: number
    notificationType: number
    severity: number
    message: number
    sentAt: number
    deliveredAt: number
    acknowledgedAt: number
    responseReceived: number
    responseTime: number
    method: number
    status: number
    attempts: number
    maxAttempts: number
    errorMessage: number
    nextRetryAt: number
    _all: number
  }


  export type EmergencyNotificationAvgAggregateInputType = {
    responseTime?: true
    attempts?: true
    maxAttempts?: true
  }

  export type EmergencyNotificationSumAggregateInputType = {
    responseTime?: true
    attempts?: true
    maxAttempts?: true
  }

  export type EmergencyNotificationMinAggregateInputType = {
    id?: true
    emergencyContactId?: true
    sessionId?: true
    tetherEmergencyId?: true
    notificationType?: true
    severity?: true
    message?: true
    sentAt?: true
    deliveredAt?: true
    acknowledgedAt?: true
    responseReceived?: true
    responseTime?: true
    method?: true
    status?: true
    attempts?: true
    maxAttempts?: true
    errorMessage?: true
    nextRetryAt?: true
  }

  export type EmergencyNotificationMaxAggregateInputType = {
    id?: true
    emergencyContactId?: true
    sessionId?: true
    tetherEmergencyId?: true
    notificationType?: true
    severity?: true
    message?: true
    sentAt?: true
    deliveredAt?: true
    acknowledgedAt?: true
    responseReceived?: true
    responseTime?: true
    method?: true
    status?: true
    attempts?: true
    maxAttempts?: true
    errorMessage?: true
    nextRetryAt?: true
  }

  export type EmergencyNotificationCountAggregateInputType = {
    id?: true
    emergencyContactId?: true
    sessionId?: true
    tetherEmergencyId?: true
    notificationType?: true
    severity?: true
    message?: true
    sentAt?: true
    deliveredAt?: true
    acknowledgedAt?: true
    responseReceived?: true
    responseTime?: true
    method?: true
    status?: true
    attempts?: true
    maxAttempts?: true
    errorMessage?: true
    nextRetryAt?: true
    _all?: true
  }

  export type EmergencyNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyNotification to aggregate.
     */
    where?: EmergencyNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyNotifications to fetch.
     */
    orderBy?: EmergencyNotificationOrderByWithRelationInput | EmergencyNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmergencyNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmergencyNotifications
    **/
    _count?: true | EmergencyNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmergencyNotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmergencyNotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmergencyNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmergencyNotificationMaxAggregateInputType
  }

  export type GetEmergencyNotificationAggregateType<T extends EmergencyNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateEmergencyNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmergencyNotification[P]>
      : GetScalarType<T[P], AggregateEmergencyNotification[P]>
  }




  export type EmergencyNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyNotificationWhereInput
    orderBy?: EmergencyNotificationOrderByWithAggregationInput | EmergencyNotificationOrderByWithAggregationInput[]
    by: EmergencyNotificationScalarFieldEnum[] | EmergencyNotificationScalarFieldEnum
    having?: EmergencyNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmergencyNotificationCountAggregateInputType | true
    _avg?: EmergencyNotificationAvgAggregateInputType
    _sum?: EmergencyNotificationSumAggregateInputType
    _min?: EmergencyNotificationMinAggregateInputType
    _max?: EmergencyNotificationMaxAggregateInputType
  }

  export type EmergencyNotificationGroupByOutputType = {
    id: string
    emergencyContactId: string
    sessionId: string | null
    tetherEmergencyId: string | null
    notificationType: $Enums.EmergencyNotificationType
    severity: $Enums.EmergencySeverity
    message: string
    sentAt: Date
    deliveredAt: Date | null
    acknowledgedAt: Date | null
    responseReceived: boolean
    responseTime: number | null
    method: string
    status: $Enums.NotificationStatus
    attempts: number
    maxAttempts: number
    errorMessage: string | null
    nextRetryAt: Date | null
    _count: EmergencyNotificationCountAggregateOutputType | null
    _avg: EmergencyNotificationAvgAggregateOutputType | null
    _sum: EmergencyNotificationSumAggregateOutputType | null
    _min: EmergencyNotificationMinAggregateOutputType | null
    _max: EmergencyNotificationMaxAggregateOutputType | null
  }

  type GetEmergencyNotificationGroupByPayload<T extends EmergencyNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmergencyNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmergencyNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmergencyNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], EmergencyNotificationGroupByOutputType[P]>
        }
      >
    >


  export type EmergencyNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emergencyContactId?: boolean
    sessionId?: boolean
    tetherEmergencyId?: boolean
    notificationType?: boolean
    severity?: boolean
    message?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    acknowledgedAt?: boolean
    responseReceived?: boolean
    responseTime?: boolean
    method?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    errorMessage?: boolean
    nextRetryAt?: boolean
    emergencyContact?: boolean | EmergencyContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyNotification"]>

  export type EmergencyNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emergencyContactId?: boolean
    sessionId?: boolean
    tetherEmergencyId?: boolean
    notificationType?: boolean
    severity?: boolean
    message?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    acknowledgedAt?: boolean
    responseReceived?: boolean
    responseTime?: boolean
    method?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    errorMessage?: boolean
    nextRetryAt?: boolean
    emergencyContact?: boolean | EmergencyContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyNotification"]>

  export type EmergencyNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emergencyContactId?: boolean
    sessionId?: boolean
    tetherEmergencyId?: boolean
    notificationType?: boolean
    severity?: boolean
    message?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    acknowledgedAt?: boolean
    responseReceived?: boolean
    responseTime?: boolean
    method?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    errorMessage?: boolean
    nextRetryAt?: boolean
    emergencyContact?: boolean | EmergencyContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyNotification"]>

  export type EmergencyNotificationSelectScalar = {
    id?: boolean
    emergencyContactId?: boolean
    sessionId?: boolean
    tetherEmergencyId?: boolean
    notificationType?: boolean
    severity?: boolean
    message?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    acknowledgedAt?: boolean
    responseReceived?: boolean
    responseTime?: boolean
    method?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    errorMessage?: boolean
    nextRetryAt?: boolean
  }

  export type EmergencyNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "emergencyContactId" | "sessionId" | "tetherEmergencyId" | "notificationType" | "severity" | "message" | "sentAt" | "deliveredAt" | "acknowledgedAt" | "responseReceived" | "responseTime" | "method" | "status" | "attempts" | "maxAttempts" | "errorMessage" | "nextRetryAt", ExtArgs["result"]["emergencyNotification"]>
  export type EmergencyNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emergencyContact?: boolean | EmergencyContactDefaultArgs<ExtArgs>
  }
  export type EmergencyNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emergencyContact?: boolean | EmergencyContactDefaultArgs<ExtArgs>
  }
  export type EmergencyNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emergencyContact?: boolean | EmergencyContactDefaultArgs<ExtArgs>
  }

  export type $EmergencyNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmergencyNotification"
    objects: {
      emergencyContact: Prisma.$EmergencyContactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      emergencyContactId: string
      sessionId: string | null
      tetherEmergencyId: string | null
      notificationType: $Enums.EmergencyNotificationType
      severity: $Enums.EmergencySeverity
      message: string
      sentAt: Date
      deliveredAt: Date | null
      acknowledgedAt: Date | null
      responseReceived: boolean
      responseTime: number | null
      method: string
      status: $Enums.NotificationStatus
      attempts: number
      maxAttempts: number
      errorMessage: string | null
      nextRetryAt: Date | null
    }, ExtArgs["result"]["emergencyNotification"]>
    composites: {}
  }

  type EmergencyNotificationGetPayload<S extends boolean | null | undefined | EmergencyNotificationDefaultArgs> = $Result.GetResult<Prisma.$EmergencyNotificationPayload, S>

  type EmergencyNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmergencyNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: EmergencyNotificationCountAggregateInputType | true
    }

  export interface EmergencyNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmergencyNotification'], meta: { name: 'EmergencyNotification' } }
    /**
     * Find zero or one EmergencyNotification that matches the filter.
     * @param {EmergencyNotificationFindUniqueArgs} args - Arguments to find a EmergencyNotification
     * @example
     * // Get one EmergencyNotification
     * const emergencyNotification = await prisma.emergencyNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmergencyNotificationFindUniqueArgs>(args: SelectSubset<T, EmergencyNotificationFindUniqueArgs<ExtArgs>>): Prisma__EmergencyNotificationClient<$Result.GetResult<Prisma.$EmergencyNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmergencyNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmergencyNotificationFindUniqueOrThrowArgs} args - Arguments to find a EmergencyNotification
     * @example
     * // Get one EmergencyNotification
     * const emergencyNotification = await prisma.emergencyNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmergencyNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, EmergencyNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmergencyNotificationClient<$Result.GetResult<Prisma.$EmergencyNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyNotificationFindFirstArgs} args - Arguments to find a EmergencyNotification
     * @example
     * // Get one EmergencyNotification
     * const emergencyNotification = await prisma.emergencyNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmergencyNotificationFindFirstArgs>(args?: SelectSubset<T, EmergencyNotificationFindFirstArgs<ExtArgs>>): Prisma__EmergencyNotificationClient<$Result.GetResult<Prisma.$EmergencyNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyNotificationFindFirstOrThrowArgs} args - Arguments to find a EmergencyNotification
     * @example
     * // Get one EmergencyNotification
     * const emergencyNotification = await prisma.emergencyNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmergencyNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, EmergencyNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmergencyNotificationClient<$Result.GetResult<Prisma.$EmergencyNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmergencyNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmergencyNotifications
     * const emergencyNotifications = await prisma.emergencyNotification.findMany()
     * 
     * // Get first 10 EmergencyNotifications
     * const emergencyNotifications = await prisma.emergencyNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emergencyNotificationWithIdOnly = await prisma.emergencyNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmergencyNotificationFindManyArgs>(args?: SelectSubset<T, EmergencyNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmergencyNotification.
     * @param {EmergencyNotificationCreateArgs} args - Arguments to create a EmergencyNotification.
     * @example
     * // Create one EmergencyNotification
     * const EmergencyNotification = await prisma.emergencyNotification.create({
     *   data: {
     *     // ... data to create a EmergencyNotification
     *   }
     * })
     * 
     */
    create<T extends EmergencyNotificationCreateArgs>(args: SelectSubset<T, EmergencyNotificationCreateArgs<ExtArgs>>): Prisma__EmergencyNotificationClient<$Result.GetResult<Prisma.$EmergencyNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmergencyNotifications.
     * @param {EmergencyNotificationCreateManyArgs} args - Arguments to create many EmergencyNotifications.
     * @example
     * // Create many EmergencyNotifications
     * const emergencyNotification = await prisma.emergencyNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmergencyNotificationCreateManyArgs>(args?: SelectSubset<T, EmergencyNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmergencyNotifications and returns the data saved in the database.
     * @param {EmergencyNotificationCreateManyAndReturnArgs} args - Arguments to create many EmergencyNotifications.
     * @example
     * // Create many EmergencyNotifications
     * const emergencyNotification = await prisma.emergencyNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmergencyNotifications and only return the `id`
     * const emergencyNotificationWithIdOnly = await prisma.emergencyNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmergencyNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, EmergencyNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmergencyNotification.
     * @param {EmergencyNotificationDeleteArgs} args - Arguments to delete one EmergencyNotification.
     * @example
     * // Delete one EmergencyNotification
     * const EmergencyNotification = await prisma.emergencyNotification.delete({
     *   where: {
     *     // ... filter to delete one EmergencyNotification
     *   }
     * })
     * 
     */
    delete<T extends EmergencyNotificationDeleteArgs>(args: SelectSubset<T, EmergencyNotificationDeleteArgs<ExtArgs>>): Prisma__EmergencyNotificationClient<$Result.GetResult<Prisma.$EmergencyNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmergencyNotification.
     * @param {EmergencyNotificationUpdateArgs} args - Arguments to update one EmergencyNotification.
     * @example
     * // Update one EmergencyNotification
     * const emergencyNotification = await prisma.emergencyNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmergencyNotificationUpdateArgs>(args: SelectSubset<T, EmergencyNotificationUpdateArgs<ExtArgs>>): Prisma__EmergencyNotificationClient<$Result.GetResult<Prisma.$EmergencyNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmergencyNotifications.
     * @param {EmergencyNotificationDeleteManyArgs} args - Arguments to filter EmergencyNotifications to delete.
     * @example
     * // Delete a few EmergencyNotifications
     * const { count } = await prisma.emergencyNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmergencyNotificationDeleteManyArgs>(args?: SelectSubset<T, EmergencyNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmergencyNotifications
     * const emergencyNotification = await prisma.emergencyNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmergencyNotificationUpdateManyArgs>(args: SelectSubset<T, EmergencyNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyNotifications and returns the data updated in the database.
     * @param {EmergencyNotificationUpdateManyAndReturnArgs} args - Arguments to update many EmergencyNotifications.
     * @example
     * // Update many EmergencyNotifications
     * const emergencyNotification = await prisma.emergencyNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmergencyNotifications and only return the `id`
     * const emergencyNotificationWithIdOnly = await prisma.emergencyNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmergencyNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, EmergencyNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmergencyNotification.
     * @param {EmergencyNotificationUpsertArgs} args - Arguments to update or create a EmergencyNotification.
     * @example
     * // Update or create a EmergencyNotification
     * const emergencyNotification = await prisma.emergencyNotification.upsert({
     *   create: {
     *     // ... data to create a EmergencyNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmergencyNotification we want to update
     *   }
     * })
     */
    upsert<T extends EmergencyNotificationUpsertArgs>(args: SelectSubset<T, EmergencyNotificationUpsertArgs<ExtArgs>>): Prisma__EmergencyNotificationClient<$Result.GetResult<Prisma.$EmergencyNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmergencyNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyNotificationCountArgs} args - Arguments to filter EmergencyNotifications to count.
     * @example
     * // Count the number of EmergencyNotifications
     * const count = await prisma.emergencyNotification.count({
     *   where: {
     *     // ... the filter for the EmergencyNotifications we want to count
     *   }
     * })
    **/
    count<T extends EmergencyNotificationCountArgs>(
      args?: Subset<T, EmergencyNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmergencyNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmergencyNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmergencyNotificationAggregateArgs>(args: Subset<T, EmergencyNotificationAggregateArgs>): Prisma.PrismaPromise<GetEmergencyNotificationAggregateType<T>>

    /**
     * Group by EmergencyNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmergencyNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmergencyNotificationGroupByArgs['orderBy'] }
        : { orderBy?: EmergencyNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmergencyNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmergencyNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmergencyNotification model
   */
  readonly fields: EmergencyNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmergencyNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmergencyNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emergencyContact<T extends EmergencyContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmergencyContactDefaultArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmergencyNotification model
   */
  interface EmergencyNotificationFieldRefs {
    readonly id: FieldRef<"EmergencyNotification", 'String'>
    readonly emergencyContactId: FieldRef<"EmergencyNotification", 'String'>
    readonly sessionId: FieldRef<"EmergencyNotification", 'String'>
    readonly tetherEmergencyId: FieldRef<"EmergencyNotification", 'String'>
    readonly notificationType: FieldRef<"EmergencyNotification", 'EmergencyNotificationType'>
    readonly severity: FieldRef<"EmergencyNotification", 'EmergencySeverity'>
    readonly message: FieldRef<"EmergencyNotification", 'String'>
    readonly sentAt: FieldRef<"EmergencyNotification", 'DateTime'>
    readonly deliveredAt: FieldRef<"EmergencyNotification", 'DateTime'>
    readonly acknowledgedAt: FieldRef<"EmergencyNotification", 'DateTime'>
    readonly responseReceived: FieldRef<"EmergencyNotification", 'Boolean'>
    readonly responseTime: FieldRef<"EmergencyNotification", 'Int'>
    readonly method: FieldRef<"EmergencyNotification", 'String'>
    readonly status: FieldRef<"EmergencyNotification", 'NotificationStatus'>
    readonly attempts: FieldRef<"EmergencyNotification", 'Int'>
    readonly maxAttempts: FieldRef<"EmergencyNotification", 'Int'>
    readonly errorMessage: FieldRef<"EmergencyNotification", 'String'>
    readonly nextRetryAt: FieldRef<"EmergencyNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmergencyNotification findUnique
   */
  export type EmergencyNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyNotification
     */
    select?: EmergencyNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyNotification
     */
    omit?: EmergencyNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyNotificationInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyNotification to fetch.
     */
    where: EmergencyNotificationWhereUniqueInput
  }

  /**
   * EmergencyNotification findUniqueOrThrow
   */
  export type EmergencyNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyNotification
     */
    select?: EmergencyNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyNotification
     */
    omit?: EmergencyNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyNotificationInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyNotification to fetch.
     */
    where: EmergencyNotificationWhereUniqueInput
  }

  /**
   * EmergencyNotification findFirst
   */
  export type EmergencyNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyNotification
     */
    select?: EmergencyNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyNotification
     */
    omit?: EmergencyNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyNotificationInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyNotification to fetch.
     */
    where?: EmergencyNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyNotifications to fetch.
     */
    orderBy?: EmergencyNotificationOrderByWithRelationInput | EmergencyNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyNotifications.
     */
    cursor?: EmergencyNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyNotifications.
     */
    distinct?: EmergencyNotificationScalarFieldEnum | EmergencyNotificationScalarFieldEnum[]
  }

  /**
   * EmergencyNotification findFirstOrThrow
   */
  export type EmergencyNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyNotification
     */
    select?: EmergencyNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyNotification
     */
    omit?: EmergencyNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyNotificationInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyNotification to fetch.
     */
    where?: EmergencyNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyNotifications to fetch.
     */
    orderBy?: EmergencyNotificationOrderByWithRelationInput | EmergencyNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyNotifications.
     */
    cursor?: EmergencyNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyNotifications.
     */
    distinct?: EmergencyNotificationScalarFieldEnum | EmergencyNotificationScalarFieldEnum[]
  }

  /**
   * EmergencyNotification findMany
   */
  export type EmergencyNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyNotification
     */
    select?: EmergencyNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyNotification
     */
    omit?: EmergencyNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyNotificationInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyNotifications to fetch.
     */
    where?: EmergencyNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyNotifications to fetch.
     */
    orderBy?: EmergencyNotificationOrderByWithRelationInput | EmergencyNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmergencyNotifications.
     */
    cursor?: EmergencyNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyNotifications.
     */
    skip?: number
    distinct?: EmergencyNotificationScalarFieldEnum | EmergencyNotificationScalarFieldEnum[]
  }

  /**
   * EmergencyNotification create
   */
  export type EmergencyNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyNotification
     */
    select?: EmergencyNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyNotification
     */
    omit?: EmergencyNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a EmergencyNotification.
     */
    data: XOR<EmergencyNotificationCreateInput, EmergencyNotificationUncheckedCreateInput>
  }

  /**
   * EmergencyNotification createMany
   */
  export type EmergencyNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmergencyNotifications.
     */
    data: EmergencyNotificationCreateManyInput | EmergencyNotificationCreateManyInput[]
  }

  /**
   * EmergencyNotification createManyAndReturn
   */
  export type EmergencyNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyNotification
     */
    select?: EmergencyNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyNotification
     */
    omit?: EmergencyNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many EmergencyNotifications.
     */
    data: EmergencyNotificationCreateManyInput | EmergencyNotificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmergencyNotification update
   */
  export type EmergencyNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyNotification
     */
    select?: EmergencyNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyNotification
     */
    omit?: EmergencyNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a EmergencyNotification.
     */
    data: XOR<EmergencyNotificationUpdateInput, EmergencyNotificationUncheckedUpdateInput>
    /**
     * Choose, which EmergencyNotification to update.
     */
    where: EmergencyNotificationWhereUniqueInput
  }

  /**
   * EmergencyNotification updateMany
   */
  export type EmergencyNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmergencyNotifications.
     */
    data: XOR<EmergencyNotificationUpdateManyMutationInput, EmergencyNotificationUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyNotifications to update
     */
    where?: EmergencyNotificationWhereInput
    /**
     * Limit how many EmergencyNotifications to update.
     */
    limit?: number
  }

  /**
   * EmergencyNotification updateManyAndReturn
   */
  export type EmergencyNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyNotification
     */
    select?: EmergencyNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyNotification
     */
    omit?: EmergencyNotificationOmit<ExtArgs> | null
    /**
     * The data used to update EmergencyNotifications.
     */
    data: XOR<EmergencyNotificationUpdateManyMutationInput, EmergencyNotificationUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyNotifications to update
     */
    where?: EmergencyNotificationWhereInput
    /**
     * Limit how many EmergencyNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmergencyNotification upsert
   */
  export type EmergencyNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyNotification
     */
    select?: EmergencyNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyNotification
     */
    omit?: EmergencyNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the EmergencyNotification to update in case it exists.
     */
    where: EmergencyNotificationWhereUniqueInput
    /**
     * In case the EmergencyNotification found by the `where` argument doesn't exist, create a new EmergencyNotification with this data.
     */
    create: XOR<EmergencyNotificationCreateInput, EmergencyNotificationUncheckedCreateInput>
    /**
     * In case the EmergencyNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmergencyNotificationUpdateInput, EmergencyNotificationUncheckedUpdateInput>
  }

  /**
   * EmergencyNotification delete
   */
  export type EmergencyNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyNotification
     */
    select?: EmergencyNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyNotification
     */
    omit?: EmergencyNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyNotificationInclude<ExtArgs> | null
    /**
     * Filter which EmergencyNotification to delete.
     */
    where: EmergencyNotificationWhereUniqueInput
  }

  /**
   * EmergencyNotification deleteMany
   */
  export type EmergencyNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyNotifications to delete
     */
    where?: EmergencyNotificationWhereInput
    /**
     * Limit how many EmergencyNotifications to delete.
     */
    limit?: number
  }

  /**
   * EmergencyNotification without action
   */
  export type EmergencyNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyNotification
     */
    select?: EmergencyNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyNotification
     */
    omit?: EmergencyNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyNotificationInclude<ExtArgs> | null
  }


  /**
   * Model WebSocketConnection
   */

  export type AggregateWebSocketConnection = {
    _count: WebSocketConnectionCountAggregateOutputType | null
    _min: WebSocketConnectionMinAggregateOutputType | null
    _max: WebSocketConnectionMaxAggregateOutputType | null
  }

  export type WebSocketConnectionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userType: string | null
    userId: string | null
    isActive: boolean | null
    createdAt: Date | null
    lastActivity: Date | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type WebSocketConnectionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userType: string | null
    userId: string | null
    isActive: boolean | null
    createdAt: Date | null
    lastActivity: Date | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type WebSocketConnectionCountAggregateOutputType = {
    id: number
    sessionId: number
    userType: number
    userId: number
    isActive: number
    createdAt: number
    lastActivity: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    _all: number
  }


  export type WebSocketConnectionMinAggregateInputType = {
    id?: true
    sessionId?: true
    userType?: true
    userId?: true
    isActive?: true
    createdAt?: true
    lastActivity?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
  }

  export type WebSocketConnectionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userType?: true
    userId?: true
    isActive?: true
    createdAt?: true
    lastActivity?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
  }

  export type WebSocketConnectionCountAggregateInputType = {
    id?: true
    sessionId?: true
    userType?: true
    userId?: true
    isActive?: true
    createdAt?: true
    lastActivity?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    _all?: true
  }

  export type WebSocketConnectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebSocketConnection to aggregate.
     */
    where?: WebSocketConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebSocketConnections to fetch.
     */
    orderBy?: WebSocketConnectionOrderByWithRelationInput | WebSocketConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebSocketConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebSocketConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebSocketConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebSocketConnections
    **/
    _count?: true | WebSocketConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebSocketConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebSocketConnectionMaxAggregateInputType
  }

  export type GetWebSocketConnectionAggregateType<T extends WebSocketConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateWebSocketConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebSocketConnection[P]>
      : GetScalarType<T[P], AggregateWebSocketConnection[P]>
  }




  export type WebSocketConnectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebSocketConnectionWhereInput
    orderBy?: WebSocketConnectionOrderByWithAggregationInput | WebSocketConnectionOrderByWithAggregationInput[]
    by: WebSocketConnectionScalarFieldEnum[] | WebSocketConnectionScalarFieldEnum
    having?: WebSocketConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebSocketConnectionCountAggregateInputType | true
    _min?: WebSocketConnectionMinAggregateInputType
    _max?: WebSocketConnectionMaxAggregateInputType
  }

  export type WebSocketConnectionGroupByOutputType = {
    id: string
    sessionId: string
    userType: string
    userId: string | null
    isActive: boolean
    createdAt: Date
    lastActivity: Date
    expiresAt: Date
    ipAddress: string | null
    userAgent: string | null
    _count: WebSocketConnectionCountAggregateOutputType | null
    _min: WebSocketConnectionMinAggregateOutputType | null
    _max: WebSocketConnectionMaxAggregateOutputType | null
  }

  type GetWebSocketConnectionGroupByPayload<T extends WebSocketConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebSocketConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebSocketConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebSocketConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], WebSocketConnectionGroupByOutputType[P]>
        }
      >
    >


  export type WebSocketConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userType?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    lastActivity?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }, ExtArgs["result"]["webSocketConnection"]>

  export type WebSocketConnectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userType?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    lastActivity?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }, ExtArgs["result"]["webSocketConnection"]>

  export type WebSocketConnectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userType?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    lastActivity?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }, ExtArgs["result"]["webSocketConnection"]>

  export type WebSocketConnectionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userType?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    lastActivity?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }

  export type WebSocketConnectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "userType" | "userId" | "isActive" | "createdAt" | "lastActivity" | "expiresAt" | "ipAddress" | "userAgent", ExtArgs["result"]["webSocketConnection"]>

  export type $WebSocketConnectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebSocketConnection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      userType: string
      userId: string | null
      isActive: boolean
      createdAt: Date
      lastActivity: Date
      expiresAt: Date
      ipAddress: string | null
      userAgent: string | null
    }, ExtArgs["result"]["webSocketConnection"]>
    composites: {}
  }

  type WebSocketConnectionGetPayload<S extends boolean | null | undefined | WebSocketConnectionDefaultArgs> = $Result.GetResult<Prisma.$WebSocketConnectionPayload, S>

  type WebSocketConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebSocketConnectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: WebSocketConnectionCountAggregateInputType | true
    }

  export interface WebSocketConnectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebSocketConnection'], meta: { name: 'WebSocketConnection' } }
    /**
     * Find zero or one WebSocketConnection that matches the filter.
     * @param {WebSocketConnectionFindUniqueArgs} args - Arguments to find a WebSocketConnection
     * @example
     * // Get one WebSocketConnection
     * const webSocketConnection = await prisma.webSocketConnection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebSocketConnectionFindUniqueArgs>(args: SelectSubset<T, WebSocketConnectionFindUniqueArgs<ExtArgs>>): Prisma__WebSocketConnectionClient<$Result.GetResult<Prisma.$WebSocketConnectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebSocketConnection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebSocketConnectionFindUniqueOrThrowArgs} args - Arguments to find a WebSocketConnection
     * @example
     * // Get one WebSocketConnection
     * const webSocketConnection = await prisma.webSocketConnection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebSocketConnectionFindUniqueOrThrowArgs>(args: SelectSubset<T, WebSocketConnectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebSocketConnectionClient<$Result.GetResult<Prisma.$WebSocketConnectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebSocketConnection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebSocketConnectionFindFirstArgs} args - Arguments to find a WebSocketConnection
     * @example
     * // Get one WebSocketConnection
     * const webSocketConnection = await prisma.webSocketConnection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebSocketConnectionFindFirstArgs>(args?: SelectSubset<T, WebSocketConnectionFindFirstArgs<ExtArgs>>): Prisma__WebSocketConnectionClient<$Result.GetResult<Prisma.$WebSocketConnectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebSocketConnection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebSocketConnectionFindFirstOrThrowArgs} args - Arguments to find a WebSocketConnection
     * @example
     * // Get one WebSocketConnection
     * const webSocketConnection = await prisma.webSocketConnection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebSocketConnectionFindFirstOrThrowArgs>(args?: SelectSubset<T, WebSocketConnectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebSocketConnectionClient<$Result.GetResult<Prisma.$WebSocketConnectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebSocketConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebSocketConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebSocketConnections
     * const webSocketConnections = await prisma.webSocketConnection.findMany()
     * 
     * // Get first 10 WebSocketConnections
     * const webSocketConnections = await prisma.webSocketConnection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webSocketConnectionWithIdOnly = await prisma.webSocketConnection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebSocketConnectionFindManyArgs>(args?: SelectSubset<T, WebSocketConnectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebSocketConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebSocketConnection.
     * @param {WebSocketConnectionCreateArgs} args - Arguments to create a WebSocketConnection.
     * @example
     * // Create one WebSocketConnection
     * const WebSocketConnection = await prisma.webSocketConnection.create({
     *   data: {
     *     // ... data to create a WebSocketConnection
     *   }
     * })
     * 
     */
    create<T extends WebSocketConnectionCreateArgs>(args: SelectSubset<T, WebSocketConnectionCreateArgs<ExtArgs>>): Prisma__WebSocketConnectionClient<$Result.GetResult<Prisma.$WebSocketConnectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebSocketConnections.
     * @param {WebSocketConnectionCreateManyArgs} args - Arguments to create many WebSocketConnections.
     * @example
     * // Create many WebSocketConnections
     * const webSocketConnection = await prisma.webSocketConnection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebSocketConnectionCreateManyArgs>(args?: SelectSubset<T, WebSocketConnectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebSocketConnections and returns the data saved in the database.
     * @param {WebSocketConnectionCreateManyAndReturnArgs} args - Arguments to create many WebSocketConnections.
     * @example
     * // Create many WebSocketConnections
     * const webSocketConnection = await prisma.webSocketConnection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebSocketConnections and only return the `id`
     * const webSocketConnectionWithIdOnly = await prisma.webSocketConnection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebSocketConnectionCreateManyAndReturnArgs>(args?: SelectSubset<T, WebSocketConnectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebSocketConnectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebSocketConnection.
     * @param {WebSocketConnectionDeleteArgs} args - Arguments to delete one WebSocketConnection.
     * @example
     * // Delete one WebSocketConnection
     * const WebSocketConnection = await prisma.webSocketConnection.delete({
     *   where: {
     *     // ... filter to delete one WebSocketConnection
     *   }
     * })
     * 
     */
    delete<T extends WebSocketConnectionDeleteArgs>(args: SelectSubset<T, WebSocketConnectionDeleteArgs<ExtArgs>>): Prisma__WebSocketConnectionClient<$Result.GetResult<Prisma.$WebSocketConnectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebSocketConnection.
     * @param {WebSocketConnectionUpdateArgs} args - Arguments to update one WebSocketConnection.
     * @example
     * // Update one WebSocketConnection
     * const webSocketConnection = await prisma.webSocketConnection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebSocketConnectionUpdateArgs>(args: SelectSubset<T, WebSocketConnectionUpdateArgs<ExtArgs>>): Prisma__WebSocketConnectionClient<$Result.GetResult<Prisma.$WebSocketConnectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebSocketConnections.
     * @param {WebSocketConnectionDeleteManyArgs} args - Arguments to filter WebSocketConnections to delete.
     * @example
     * // Delete a few WebSocketConnections
     * const { count } = await prisma.webSocketConnection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebSocketConnectionDeleteManyArgs>(args?: SelectSubset<T, WebSocketConnectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebSocketConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebSocketConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebSocketConnections
     * const webSocketConnection = await prisma.webSocketConnection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebSocketConnectionUpdateManyArgs>(args: SelectSubset<T, WebSocketConnectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebSocketConnections and returns the data updated in the database.
     * @param {WebSocketConnectionUpdateManyAndReturnArgs} args - Arguments to update many WebSocketConnections.
     * @example
     * // Update many WebSocketConnections
     * const webSocketConnection = await prisma.webSocketConnection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebSocketConnections and only return the `id`
     * const webSocketConnectionWithIdOnly = await prisma.webSocketConnection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebSocketConnectionUpdateManyAndReturnArgs>(args: SelectSubset<T, WebSocketConnectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebSocketConnectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebSocketConnection.
     * @param {WebSocketConnectionUpsertArgs} args - Arguments to update or create a WebSocketConnection.
     * @example
     * // Update or create a WebSocketConnection
     * const webSocketConnection = await prisma.webSocketConnection.upsert({
     *   create: {
     *     // ... data to create a WebSocketConnection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebSocketConnection we want to update
     *   }
     * })
     */
    upsert<T extends WebSocketConnectionUpsertArgs>(args: SelectSubset<T, WebSocketConnectionUpsertArgs<ExtArgs>>): Prisma__WebSocketConnectionClient<$Result.GetResult<Prisma.$WebSocketConnectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebSocketConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebSocketConnectionCountArgs} args - Arguments to filter WebSocketConnections to count.
     * @example
     * // Count the number of WebSocketConnections
     * const count = await prisma.webSocketConnection.count({
     *   where: {
     *     // ... the filter for the WebSocketConnections we want to count
     *   }
     * })
    **/
    count<T extends WebSocketConnectionCountArgs>(
      args?: Subset<T, WebSocketConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebSocketConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebSocketConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebSocketConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebSocketConnectionAggregateArgs>(args: Subset<T, WebSocketConnectionAggregateArgs>): Prisma.PrismaPromise<GetWebSocketConnectionAggregateType<T>>

    /**
     * Group by WebSocketConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebSocketConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebSocketConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebSocketConnectionGroupByArgs['orderBy'] }
        : { orderBy?: WebSocketConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebSocketConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebSocketConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebSocketConnection model
   */
  readonly fields: WebSocketConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebSocketConnection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebSocketConnectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebSocketConnection model
   */
  interface WebSocketConnectionFieldRefs {
    readonly id: FieldRef<"WebSocketConnection", 'String'>
    readonly sessionId: FieldRef<"WebSocketConnection", 'String'>
    readonly userType: FieldRef<"WebSocketConnection", 'String'>
    readonly userId: FieldRef<"WebSocketConnection", 'String'>
    readonly isActive: FieldRef<"WebSocketConnection", 'Boolean'>
    readonly createdAt: FieldRef<"WebSocketConnection", 'DateTime'>
    readonly lastActivity: FieldRef<"WebSocketConnection", 'DateTime'>
    readonly expiresAt: FieldRef<"WebSocketConnection", 'DateTime'>
    readonly ipAddress: FieldRef<"WebSocketConnection", 'String'>
    readonly userAgent: FieldRef<"WebSocketConnection", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WebSocketConnection findUnique
   */
  export type WebSocketConnectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSocketConnection
     */
    select?: WebSocketConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSocketConnection
     */
    omit?: WebSocketConnectionOmit<ExtArgs> | null
    /**
     * Filter, which WebSocketConnection to fetch.
     */
    where: WebSocketConnectionWhereUniqueInput
  }

  /**
   * WebSocketConnection findUniqueOrThrow
   */
  export type WebSocketConnectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSocketConnection
     */
    select?: WebSocketConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSocketConnection
     */
    omit?: WebSocketConnectionOmit<ExtArgs> | null
    /**
     * Filter, which WebSocketConnection to fetch.
     */
    where: WebSocketConnectionWhereUniqueInput
  }

  /**
   * WebSocketConnection findFirst
   */
  export type WebSocketConnectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSocketConnection
     */
    select?: WebSocketConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSocketConnection
     */
    omit?: WebSocketConnectionOmit<ExtArgs> | null
    /**
     * Filter, which WebSocketConnection to fetch.
     */
    where?: WebSocketConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebSocketConnections to fetch.
     */
    orderBy?: WebSocketConnectionOrderByWithRelationInput | WebSocketConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebSocketConnections.
     */
    cursor?: WebSocketConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebSocketConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebSocketConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebSocketConnections.
     */
    distinct?: WebSocketConnectionScalarFieldEnum | WebSocketConnectionScalarFieldEnum[]
  }

  /**
   * WebSocketConnection findFirstOrThrow
   */
  export type WebSocketConnectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSocketConnection
     */
    select?: WebSocketConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSocketConnection
     */
    omit?: WebSocketConnectionOmit<ExtArgs> | null
    /**
     * Filter, which WebSocketConnection to fetch.
     */
    where?: WebSocketConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebSocketConnections to fetch.
     */
    orderBy?: WebSocketConnectionOrderByWithRelationInput | WebSocketConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebSocketConnections.
     */
    cursor?: WebSocketConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebSocketConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebSocketConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebSocketConnections.
     */
    distinct?: WebSocketConnectionScalarFieldEnum | WebSocketConnectionScalarFieldEnum[]
  }

  /**
   * WebSocketConnection findMany
   */
  export type WebSocketConnectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSocketConnection
     */
    select?: WebSocketConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSocketConnection
     */
    omit?: WebSocketConnectionOmit<ExtArgs> | null
    /**
     * Filter, which WebSocketConnections to fetch.
     */
    where?: WebSocketConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebSocketConnections to fetch.
     */
    orderBy?: WebSocketConnectionOrderByWithRelationInput | WebSocketConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebSocketConnections.
     */
    cursor?: WebSocketConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebSocketConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebSocketConnections.
     */
    skip?: number
    distinct?: WebSocketConnectionScalarFieldEnum | WebSocketConnectionScalarFieldEnum[]
  }

  /**
   * WebSocketConnection create
   */
  export type WebSocketConnectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSocketConnection
     */
    select?: WebSocketConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSocketConnection
     */
    omit?: WebSocketConnectionOmit<ExtArgs> | null
    /**
     * The data needed to create a WebSocketConnection.
     */
    data: XOR<WebSocketConnectionCreateInput, WebSocketConnectionUncheckedCreateInput>
  }

  /**
   * WebSocketConnection createMany
   */
  export type WebSocketConnectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebSocketConnections.
     */
    data: WebSocketConnectionCreateManyInput | WebSocketConnectionCreateManyInput[]
  }

  /**
   * WebSocketConnection createManyAndReturn
   */
  export type WebSocketConnectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSocketConnection
     */
    select?: WebSocketConnectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebSocketConnection
     */
    omit?: WebSocketConnectionOmit<ExtArgs> | null
    /**
     * The data used to create many WebSocketConnections.
     */
    data: WebSocketConnectionCreateManyInput | WebSocketConnectionCreateManyInput[]
  }

  /**
   * WebSocketConnection update
   */
  export type WebSocketConnectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSocketConnection
     */
    select?: WebSocketConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSocketConnection
     */
    omit?: WebSocketConnectionOmit<ExtArgs> | null
    /**
     * The data needed to update a WebSocketConnection.
     */
    data: XOR<WebSocketConnectionUpdateInput, WebSocketConnectionUncheckedUpdateInput>
    /**
     * Choose, which WebSocketConnection to update.
     */
    where: WebSocketConnectionWhereUniqueInput
  }

  /**
   * WebSocketConnection updateMany
   */
  export type WebSocketConnectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebSocketConnections.
     */
    data: XOR<WebSocketConnectionUpdateManyMutationInput, WebSocketConnectionUncheckedUpdateManyInput>
    /**
     * Filter which WebSocketConnections to update
     */
    where?: WebSocketConnectionWhereInput
    /**
     * Limit how many WebSocketConnections to update.
     */
    limit?: number
  }

  /**
   * WebSocketConnection updateManyAndReturn
   */
  export type WebSocketConnectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSocketConnection
     */
    select?: WebSocketConnectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebSocketConnection
     */
    omit?: WebSocketConnectionOmit<ExtArgs> | null
    /**
     * The data used to update WebSocketConnections.
     */
    data: XOR<WebSocketConnectionUpdateManyMutationInput, WebSocketConnectionUncheckedUpdateManyInput>
    /**
     * Filter which WebSocketConnections to update
     */
    where?: WebSocketConnectionWhereInput
    /**
     * Limit how many WebSocketConnections to update.
     */
    limit?: number
  }

  /**
   * WebSocketConnection upsert
   */
  export type WebSocketConnectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSocketConnection
     */
    select?: WebSocketConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSocketConnection
     */
    omit?: WebSocketConnectionOmit<ExtArgs> | null
    /**
     * The filter to search for the WebSocketConnection to update in case it exists.
     */
    where: WebSocketConnectionWhereUniqueInput
    /**
     * In case the WebSocketConnection found by the `where` argument doesn't exist, create a new WebSocketConnection with this data.
     */
    create: XOR<WebSocketConnectionCreateInput, WebSocketConnectionUncheckedCreateInput>
    /**
     * In case the WebSocketConnection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebSocketConnectionUpdateInput, WebSocketConnectionUncheckedUpdateInput>
  }

  /**
   * WebSocketConnection delete
   */
  export type WebSocketConnectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSocketConnection
     */
    select?: WebSocketConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSocketConnection
     */
    omit?: WebSocketConnectionOmit<ExtArgs> | null
    /**
     * Filter which WebSocketConnection to delete.
     */
    where: WebSocketConnectionWhereUniqueInput
  }

  /**
   * WebSocketConnection deleteMany
   */
  export type WebSocketConnectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebSocketConnections to delete
     */
    where?: WebSocketConnectionWhereInput
    /**
     * Limit how many WebSocketConnections to delete.
     */
    limit?: number
  }

  /**
   * WebSocketConnection without action
   */
  export type WebSocketConnectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSocketConnection
     */
    select?: WebSocketConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSocketConnection
     */
    omit?: WebSocketConnectionOmit<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    dataRetentionDays: number | null
  }

  export type UserSumAggregateOutputType = {
    dataRetentionDays: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    anonymousId: string | null
    email: string | null
    username: string | null
    isAnonymous: boolean | null
    lastLogin: Date | null
    dataSharing: $Enums.UserDataSharing | null
    allowAnalytics: boolean | null
    dataRetentionDays: number | null
    verificationStatus: $Enums.VerificationStatus | null
    professionalType: string | null
    licenseNumber: string | null
    verifiedAt: Date | null
    encryptedProfile: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    anonymousId: string | null
    email: string | null
    username: string | null
    isAnonymous: boolean | null
    lastLogin: Date | null
    dataSharing: $Enums.UserDataSharing | null
    allowAnalytics: boolean | null
    dataRetentionDays: number | null
    verificationStatus: $Enums.VerificationStatus | null
    professionalType: string | null
    licenseNumber: string | null
    verifiedAt: Date | null
    encryptedProfile: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    anonymousId: number
    email: number
    username: number
    isAnonymous: number
    lastLogin: number
    dataSharing: number
    allowAnalytics: number
    dataRetentionDays: number
    verificationStatus: number
    professionalType: number
    licenseNumber: number
    verifiedAt: number
    encryptedProfile: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    dataRetentionDays?: true
  }

  export type UserSumAggregateInputType = {
    dataRetentionDays?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    anonymousId?: true
    email?: true
    username?: true
    isAnonymous?: true
    lastLogin?: true
    dataSharing?: true
    allowAnalytics?: true
    dataRetentionDays?: true
    verificationStatus?: true
    professionalType?: true
    licenseNumber?: true
    verifiedAt?: true
    encryptedProfile?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    anonymousId?: true
    email?: true
    username?: true
    isAnonymous?: true
    lastLogin?: true
    dataSharing?: true
    allowAnalytics?: true
    dataRetentionDays?: true
    verificationStatus?: true
    professionalType?: true
    licenseNumber?: true
    verifiedAt?: true
    encryptedProfile?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    anonymousId?: true
    email?: true
    username?: true
    isAnonymous?: true
    lastLogin?: true
    dataSharing?: true
    allowAnalytics?: true
    dataRetentionDays?: true
    verificationStatus?: true
    professionalType?: true
    licenseNumber?: true
    verifiedAt?: true
    encryptedProfile?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    anonymousId: string | null
    email: string | null
    username: string | null
    isAnonymous: boolean
    lastLogin: Date | null
    dataSharing: $Enums.UserDataSharing
    allowAnalytics: boolean
    dataRetentionDays: number | null
    verificationStatus: $Enums.VerificationStatus
    professionalType: string | null
    licenseNumber: string | null
    verifiedAt: Date | null
    encryptedProfile: Uint8Array | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    anonymousId?: boolean
    email?: boolean
    username?: boolean
    isAnonymous?: boolean
    lastLogin?: boolean
    dataSharing?: boolean
    allowAnalytics?: boolean
    dataRetentionDays?: boolean
    verificationStatus?: boolean
    professionalType?: boolean
    licenseNumber?: boolean
    verifiedAt?: boolean
    encryptedProfile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    moodEntries?: boolean | User$moodEntriesArgs<ExtArgs>
    safetyPlans?: boolean | User$safetyPlansArgs<ExtArgs>
    userProfile?: boolean | User$userProfileArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    challenges?: boolean | User$challengesArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    emergencyContacts?: boolean | User$emergencyContactsArgs<ExtArgs>
    journalEntries?: boolean | User$journalEntriesArgs<ExtArgs>
    breathingSessions?: boolean | User$breathingSessionsArgs<ExtArgs>
    groundingSessions?: boolean | User$groundingSessionsArgs<ExtArgs>
    selfHelpInteractions?: boolean | User$selfHelpInteractionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    anonymousId?: boolean
    email?: boolean
    username?: boolean
    isAnonymous?: boolean
    lastLogin?: boolean
    dataSharing?: boolean
    allowAnalytics?: boolean
    dataRetentionDays?: boolean
    verificationStatus?: boolean
    professionalType?: boolean
    licenseNumber?: boolean
    verifiedAt?: boolean
    encryptedProfile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    anonymousId?: boolean
    email?: boolean
    username?: boolean
    isAnonymous?: boolean
    lastLogin?: boolean
    dataSharing?: boolean
    allowAnalytics?: boolean
    dataRetentionDays?: boolean
    verificationStatus?: boolean
    professionalType?: boolean
    licenseNumber?: boolean
    verifiedAt?: boolean
    encryptedProfile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    anonymousId?: boolean
    email?: boolean
    username?: boolean
    isAnonymous?: boolean
    lastLogin?: boolean
    dataSharing?: boolean
    allowAnalytics?: boolean
    dataRetentionDays?: boolean
    verificationStatus?: boolean
    professionalType?: boolean
    licenseNumber?: boolean
    verifiedAt?: boolean
    encryptedProfile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "anonymousId" | "email" | "username" | "isAnonymous" | "lastLogin" | "dataSharing" | "allowAnalytics" | "dataRetentionDays" | "verificationStatus" | "professionalType" | "licenseNumber" | "verifiedAt" | "encryptedProfile" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moodEntries?: boolean | User$moodEntriesArgs<ExtArgs>
    safetyPlans?: boolean | User$safetyPlansArgs<ExtArgs>
    userProfile?: boolean | User$userProfileArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    challenges?: boolean | User$challengesArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    emergencyContacts?: boolean | User$emergencyContactsArgs<ExtArgs>
    journalEntries?: boolean | User$journalEntriesArgs<ExtArgs>
    breathingSessions?: boolean | User$breathingSessionsArgs<ExtArgs>
    groundingSessions?: boolean | User$groundingSessionsArgs<ExtArgs>
    selfHelpInteractions?: boolean | User$selfHelpInteractionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      moodEntries: Prisma.$MoodEntryPayload<ExtArgs>[]
      safetyPlans: Prisma.$SafetyPlanPayload<ExtArgs>[]
      userProfile: Prisma.$UserProfilePayload<ExtArgs> | null
      achievements: Prisma.$UserAchievementPayload<ExtArgs>[]
      challenges: Prisma.$UserChallengePayload<ExtArgs>[]
      activities: Prisma.$UserActivityPayload<ExtArgs>[]
      emergencyContacts: Prisma.$EmergencyContactPayload<ExtArgs>[]
      journalEntries: Prisma.$JournalEntryPayload<ExtArgs>[]
      breathingSessions: Prisma.$BreathingSessionPayload<ExtArgs>[]
      groundingSessions: Prisma.$GroundingSessionPayload<ExtArgs>[]
      selfHelpInteractions: Prisma.$SelfHelpInteractionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      anonymousId: string | null
      email: string | null
      username: string | null
      isAnonymous: boolean
      lastLogin: Date | null
      dataSharing: $Enums.UserDataSharing
      allowAnalytics: boolean
      dataRetentionDays: number | null
      verificationStatus: $Enums.VerificationStatus
      professionalType: string | null
      licenseNumber: string | null
      verifiedAt: Date | null
      encryptedProfile: Uint8Array | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    moodEntries<T extends User$moodEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$moodEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    safetyPlans<T extends User$safetyPlansArgs<ExtArgs> = {}>(args?: Subset<T, User$safetyPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetyPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userProfile<T extends User$userProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$userProfileArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    challenges<T extends User$challengesArgs<ExtArgs> = {}>(args?: Subset<T, User$challengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emergencyContacts<T extends User$emergencyContactsArgs<ExtArgs> = {}>(args?: Subset<T, User$emergencyContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journalEntries<T extends User$journalEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$journalEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    breathingSessions<T extends User$breathingSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$breathingSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreathingSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groundingSessions<T extends User$groundingSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$groundingSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroundingSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    selfHelpInteractions<T extends User$selfHelpInteractionsArgs<ExtArgs> = {}>(args?: Subset<T, User$selfHelpInteractionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelfHelpInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly anonymousId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly isAnonymous: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly dataSharing: FieldRef<"User", 'UserDataSharing'>
    readonly allowAnalytics: FieldRef<"User", 'Boolean'>
    readonly dataRetentionDays: FieldRef<"User", 'Int'>
    readonly verificationStatus: FieldRef<"User", 'VerificationStatus'>
    readonly professionalType: FieldRef<"User", 'String'>
    readonly licenseNumber: FieldRef<"User", 'String'>
    readonly verifiedAt: FieldRef<"User", 'DateTime'>
    readonly encryptedProfile: FieldRef<"User", 'Bytes'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.moodEntries
   */
  export type User$moodEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    where?: MoodEntryWhereInput
    orderBy?: MoodEntryOrderByWithRelationInput | MoodEntryOrderByWithRelationInput[]
    cursor?: MoodEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MoodEntryScalarFieldEnum | MoodEntryScalarFieldEnum[]
  }

  /**
   * User.safetyPlans
   */
  export type User$safetyPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlan
     */
    select?: SafetyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlan
     */
    omit?: SafetyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanInclude<ExtArgs> | null
    where?: SafetyPlanWhereInput
    orderBy?: SafetyPlanOrderByWithRelationInput | SafetyPlanOrderByWithRelationInput[]
    cursor?: SafetyPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SafetyPlanScalarFieldEnum | SafetyPlanScalarFieldEnum[]
  }

  /**
   * User.userProfile
   */
  export type User$userProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * User.challenges
   */
  export type User$challengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    where?: UserChallengeWhereInput
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    cursor?: UserChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserChallengeScalarFieldEnum | UserChallengeScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    where?: UserActivityWhereInput
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    cursor?: UserActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * User.emergencyContacts
   */
  export type User$emergencyContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    where?: EmergencyContactWhereInput
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    cursor?: EmergencyContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * User.journalEntries
   */
  export type User$journalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    where?: JournalEntryWhereInput
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    cursor?: JournalEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * User.breathingSessions
   */
  export type User$breathingSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingSession
     */
    select?: BreathingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingSession
     */
    omit?: BreathingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingSessionInclude<ExtArgs> | null
    where?: BreathingSessionWhereInput
    orderBy?: BreathingSessionOrderByWithRelationInput | BreathingSessionOrderByWithRelationInput[]
    cursor?: BreathingSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreathingSessionScalarFieldEnum | BreathingSessionScalarFieldEnum[]
  }

  /**
   * User.groundingSessions
   */
  export type User$groundingSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingSession
     */
    select?: GroundingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingSession
     */
    omit?: GroundingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingSessionInclude<ExtArgs> | null
    where?: GroundingSessionWhereInput
    orderBy?: GroundingSessionOrderByWithRelationInput | GroundingSessionOrderByWithRelationInput[]
    cursor?: GroundingSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroundingSessionScalarFieldEnum | GroundingSessionScalarFieldEnum[]
  }

  /**
   * User.selfHelpInteractions
   */
  export type User$selfHelpInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpInteraction
     */
    select?: SelfHelpInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpInteraction
     */
    omit?: SelfHelpInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpInteractionInclude<ExtArgs> | null
    where?: SelfHelpInteractionWhereInput
    orderBy?: SelfHelpInteractionOrderByWithRelationInput | SelfHelpInteractionOrderByWithRelationInput[]
    cursor?: SelfHelpInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SelfHelpInteractionScalarFieldEnum | SelfHelpInteractionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model MoodEntry
   */

  export type AggregateMoodEntry = {
    _count: MoodEntryCountAggregateOutputType | null
    _avg: MoodEntryAvgAggregateOutputType | null
    _sum: MoodEntrySumAggregateOutputType | null
    _min: MoodEntryMinAggregateOutputType | null
    _max: MoodEntryMaxAggregateOutputType | null
  }

  export type MoodEntryAvgAggregateOutputType = {
    mood: number | null
    sleepHours: number | null
    socialInteraction: number | null
  }

  export type MoodEntrySumAggregateOutputType = {
    mood: number | null
    sleepHours: number | null
    socialInteraction: number | null
  }

  export type MoodEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mood: number | null
    sleepHours: number | null
    notes: string | null
    weather: string | null
    medication: boolean | null
    socialInteraction: number | null
    timestamp: Date | null
  }

  export type MoodEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mood: number | null
    sleepHours: number | null
    notes: string | null
    weather: string | null
    medication: boolean | null
    socialInteraction: number | null
    timestamp: Date | null
  }

  export type MoodEntryCountAggregateOutputType = {
    id: number
    userId: number
    mood: number
    emotions: number
    triggers: number
    activities: number
    sleepHours: number
    notes: number
    weather: number
    medication: number
    socialInteraction: number
    timestamp: number
    _all: number
  }


  export type MoodEntryAvgAggregateInputType = {
    mood?: true
    sleepHours?: true
    socialInteraction?: true
  }

  export type MoodEntrySumAggregateInputType = {
    mood?: true
    sleepHours?: true
    socialInteraction?: true
  }

  export type MoodEntryMinAggregateInputType = {
    id?: true
    userId?: true
    mood?: true
    sleepHours?: true
    notes?: true
    weather?: true
    medication?: true
    socialInteraction?: true
    timestamp?: true
  }

  export type MoodEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    mood?: true
    sleepHours?: true
    notes?: true
    weather?: true
    medication?: true
    socialInteraction?: true
    timestamp?: true
  }

  export type MoodEntryCountAggregateInputType = {
    id?: true
    userId?: true
    mood?: true
    emotions?: true
    triggers?: true
    activities?: true
    sleepHours?: true
    notes?: true
    weather?: true
    medication?: true
    socialInteraction?: true
    timestamp?: true
    _all?: true
  }

  export type MoodEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoodEntry to aggregate.
     */
    where?: MoodEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodEntries to fetch.
     */
    orderBy?: MoodEntryOrderByWithRelationInput | MoodEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MoodEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MoodEntries
    **/
    _count?: true | MoodEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MoodEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MoodEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MoodEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MoodEntryMaxAggregateInputType
  }

  export type GetMoodEntryAggregateType<T extends MoodEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateMoodEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMoodEntry[P]>
      : GetScalarType<T[P], AggregateMoodEntry[P]>
  }




  export type MoodEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoodEntryWhereInput
    orderBy?: MoodEntryOrderByWithAggregationInput | MoodEntryOrderByWithAggregationInput[]
    by: MoodEntryScalarFieldEnum[] | MoodEntryScalarFieldEnum
    having?: MoodEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MoodEntryCountAggregateInputType | true
    _avg?: MoodEntryAvgAggregateInputType
    _sum?: MoodEntrySumAggregateInputType
    _min?: MoodEntryMinAggregateInputType
    _max?: MoodEntryMaxAggregateInputType
  }

  export type MoodEntryGroupByOutputType = {
    id: string
    userId: string
    mood: number
    emotions: JsonValue
    triggers: JsonValue
    activities: JsonValue
    sleepHours: number | null
    notes: string | null
    weather: string | null
    medication: boolean | null
    socialInteraction: number | null
    timestamp: Date
    _count: MoodEntryCountAggregateOutputType | null
    _avg: MoodEntryAvgAggregateOutputType | null
    _sum: MoodEntrySumAggregateOutputType | null
    _min: MoodEntryMinAggregateOutputType | null
    _max: MoodEntryMaxAggregateOutputType | null
  }

  type GetMoodEntryGroupByPayload<T extends MoodEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MoodEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MoodEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MoodEntryGroupByOutputType[P]>
            : GetScalarType<T[P], MoodEntryGroupByOutputType[P]>
        }
      >
    >


  export type MoodEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mood?: boolean
    emotions?: boolean
    triggers?: boolean
    activities?: boolean
    sleepHours?: boolean
    notes?: boolean
    weather?: boolean
    medication?: boolean
    socialInteraction?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moodEntry"]>

  export type MoodEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mood?: boolean
    emotions?: boolean
    triggers?: boolean
    activities?: boolean
    sleepHours?: boolean
    notes?: boolean
    weather?: boolean
    medication?: boolean
    socialInteraction?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moodEntry"]>

  export type MoodEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mood?: boolean
    emotions?: boolean
    triggers?: boolean
    activities?: boolean
    sleepHours?: boolean
    notes?: boolean
    weather?: boolean
    medication?: boolean
    socialInteraction?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moodEntry"]>

  export type MoodEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    mood?: boolean
    emotions?: boolean
    triggers?: boolean
    activities?: boolean
    sleepHours?: boolean
    notes?: boolean
    weather?: boolean
    medication?: boolean
    socialInteraction?: boolean
    timestamp?: boolean
  }

  export type MoodEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "mood" | "emotions" | "triggers" | "activities" | "sleepHours" | "notes" | "weather" | "medication" | "socialInteraction" | "timestamp", ExtArgs["result"]["moodEntry"]>
  export type MoodEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MoodEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MoodEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MoodEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MoodEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      mood: number
      emotions: Prisma.JsonValue
      triggers: Prisma.JsonValue
      activities: Prisma.JsonValue
      sleepHours: number | null
      notes: string | null
      weather: string | null
      medication: boolean | null
      socialInteraction: number | null
      timestamp: Date
    }, ExtArgs["result"]["moodEntry"]>
    composites: {}
  }

  type MoodEntryGetPayload<S extends boolean | null | undefined | MoodEntryDefaultArgs> = $Result.GetResult<Prisma.$MoodEntryPayload, S>

  type MoodEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MoodEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: MoodEntryCountAggregateInputType | true
    }

  export interface MoodEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MoodEntry'], meta: { name: 'MoodEntry' } }
    /**
     * Find zero or one MoodEntry that matches the filter.
     * @param {MoodEntryFindUniqueArgs} args - Arguments to find a MoodEntry
     * @example
     * // Get one MoodEntry
     * const moodEntry = await prisma.moodEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MoodEntryFindUniqueArgs>(args: SelectSubset<T, MoodEntryFindUniqueArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MoodEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MoodEntryFindUniqueOrThrowArgs} args - Arguments to find a MoodEntry
     * @example
     * // Get one MoodEntry
     * const moodEntry = await prisma.moodEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MoodEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, MoodEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MoodEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryFindFirstArgs} args - Arguments to find a MoodEntry
     * @example
     * // Get one MoodEntry
     * const moodEntry = await prisma.moodEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MoodEntryFindFirstArgs>(args?: SelectSubset<T, MoodEntryFindFirstArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MoodEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryFindFirstOrThrowArgs} args - Arguments to find a MoodEntry
     * @example
     * // Get one MoodEntry
     * const moodEntry = await prisma.moodEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MoodEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, MoodEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MoodEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MoodEntries
     * const moodEntries = await prisma.moodEntry.findMany()
     * 
     * // Get first 10 MoodEntries
     * const moodEntries = await prisma.moodEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moodEntryWithIdOnly = await prisma.moodEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MoodEntryFindManyArgs>(args?: SelectSubset<T, MoodEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MoodEntry.
     * @param {MoodEntryCreateArgs} args - Arguments to create a MoodEntry.
     * @example
     * // Create one MoodEntry
     * const MoodEntry = await prisma.moodEntry.create({
     *   data: {
     *     // ... data to create a MoodEntry
     *   }
     * })
     * 
     */
    create<T extends MoodEntryCreateArgs>(args: SelectSubset<T, MoodEntryCreateArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MoodEntries.
     * @param {MoodEntryCreateManyArgs} args - Arguments to create many MoodEntries.
     * @example
     * // Create many MoodEntries
     * const moodEntry = await prisma.moodEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MoodEntryCreateManyArgs>(args?: SelectSubset<T, MoodEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MoodEntries and returns the data saved in the database.
     * @param {MoodEntryCreateManyAndReturnArgs} args - Arguments to create many MoodEntries.
     * @example
     * // Create many MoodEntries
     * const moodEntry = await prisma.moodEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MoodEntries and only return the `id`
     * const moodEntryWithIdOnly = await prisma.moodEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MoodEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, MoodEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MoodEntry.
     * @param {MoodEntryDeleteArgs} args - Arguments to delete one MoodEntry.
     * @example
     * // Delete one MoodEntry
     * const MoodEntry = await prisma.moodEntry.delete({
     *   where: {
     *     // ... filter to delete one MoodEntry
     *   }
     * })
     * 
     */
    delete<T extends MoodEntryDeleteArgs>(args: SelectSubset<T, MoodEntryDeleteArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MoodEntry.
     * @param {MoodEntryUpdateArgs} args - Arguments to update one MoodEntry.
     * @example
     * // Update one MoodEntry
     * const moodEntry = await prisma.moodEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MoodEntryUpdateArgs>(args: SelectSubset<T, MoodEntryUpdateArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MoodEntries.
     * @param {MoodEntryDeleteManyArgs} args - Arguments to filter MoodEntries to delete.
     * @example
     * // Delete a few MoodEntries
     * const { count } = await prisma.moodEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MoodEntryDeleteManyArgs>(args?: SelectSubset<T, MoodEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MoodEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MoodEntries
     * const moodEntry = await prisma.moodEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MoodEntryUpdateManyArgs>(args: SelectSubset<T, MoodEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MoodEntries and returns the data updated in the database.
     * @param {MoodEntryUpdateManyAndReturnArgs} args - Arguments to update many MoodEntries.
     * @example
     * // Update many MoodEntries
     * const moodEntry = await prisma.moodEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MoodEntries and only return the `id`
     * const moodEntryWithIdOnly = await prisma.moodEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MoodEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, MoodEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MoodEntry.
     * @param {MoodEntryUpsertArgs} args - Arguments to update or create a MoodEntry.
     * @example
     * // Update or create a MoodEntry
     * const moodEntry = await prisma.moodEntry.upsert({
     *   create: {
     *     // ... data to create a MoodEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MoodEntry we want to update
     *   }
     * })
     */
    upsert<T extends MoodEntryUpsertArgs>(args: SelectSubset<T, MoodEntryUpsertArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MoodEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryCountArgs} args - Arguments to filter MoodEntries to count.
     * @example
     * // Count the number of MoodEntries
     * const count = await prisma.moodEntry.count({
     *   where: {
     *     // ... the filter for the MoodEntries we want to count
     *   }
     * })
    **/
    count<T extends MoodEntryCountArgs>(
      args?: Subset<T, MoodEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MoodEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MoodEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MoodEntryAggregateArgs>(args: Subset<T, MoodEntryAggregateArgs>): Prisma.PrismaPromise<GetMoodEntryAggregateType<T>>

    /**
     * Group by MoodEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MoodEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MoodEntryGroupByArgs['orderBy'] }
        : { orderBy?: MoodEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MoodEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMoodEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MoodEntry model
   */
  readonly fields: MoodEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MoodEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MoodEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MoodEntry model
   */
  interface MoodEntryFieldRefs {
    readonly id: FieldRef<"MoodEntry", 'String'>
    readonly userId: FieldRef<"MoodEntry", 'String'>
    readonly mood: FieldRef<"MoodEntry", 'Int'>
    readonly emotions: FieldRef<"MoodEntry", 'Json'>
    readonly triggers: FieldRef<"MoodEntry", 'Json'>
    readonly activities: FieldRef<"MoodEntry", 'Json'>
    readonly sleepHours: FieldRef<"MoodEntry", 'Float'>
    readonly notes: FieldRef<"MoodEntry", 'String'>
    readonly weather: FieldRef<"MoodEntry", 'String'>
    readonly medication: FieldRef<"MoodEntry", 'Boolean'>
    readonly socialInteraction: FieldRef<"MoodEntry", 'Int'>
    readonly timestamp: FieldRef<"MoodEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MoodEntry findUnique
   */
  export type MoodEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter, which MoodEntry to fetch.
     */
    where: MoodEntryWhereUniqueInput
  }

  /**
   * MoodEntry findUniqueOrThrow
   */
  export type MoodEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter, which MoodEntry to fetch.
     */
    where: MoodEntryWhereUniqueInput
  }

  /**
   * MoodEntry findFirst
   */
  export type MoodEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter, which MoodEntry to fetch.
     */
    where?: MoodEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodEntries to fetch.
     */
    orderBy?: MoodEntryOrderByWithRelationInput | MoodEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoodEntries.
     */
    cursor?: MoodEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoodEntries.
     */
    distinct?: MoodEntryScalarFieldEnum | MoodEntryScalarFieldEnum[]
  }

  /**
   * MoodEntry findFirstOrThrow
   */
  export type MoodEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter, which MoodEntry to fetch.
     */
    where?: MoodEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodEntries to fetch.
     */
    orderBy?: MoodEntryOrderByWithRelationInput | MoodEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoodEntries.
     */
    cursor?: MoodEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoodEntries.
     */
    distinct?: MoodEntryScalarFieldEnum | MoodEntryScalarFieldEnum[]
  }

  /**
   * MoodEntry findMany
   */
  export type MoodEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter, which MoodEntries to fetch.
     */
    where?: MoodEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodEntries to fetch.
     */
    orderBy?: MoodEntryOrderByWithRelationInput | MoodEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MoodEntries.
     */
    cursor?: MoodEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodEntries.
     */
    skip?: number
    distinct?: MoodEntryScalarFieldEnum | MoodEntryScalarFieldEnum[]
  }

  /**
   * MoodEntry create
   */
  export type MoodEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a MoodEntry.
     */
    data: XOR<MoodEntryCreateInput, MoodEntryUncheckedCreateInput>
  }

  /**
   * MoodEntry createMany
   */
  export type MoodEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MoodEntries.
     */
    data: MoodEntryCreateManyInput | MoodEntryCreateManyInput[]
  }

  /**
   * MoodEntry createManyAndReturn
   */
  export type MoodEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * The data used to create many MoodEntries.
     */
    data: MoodEntryCreateManyInput | MoodEntryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MoodEntry update
   */
  export type MoodEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a MoodEntry.
     */
    data: XOR<MoodEntryUpdateInput, MoodEntryUncheckedUpdateInput>
    /**
     * Choose, which MoodEntry to update.
     */
    where: MoodEntryWhereUniqueInput
  }

  /**
   * MoodEntry updateMany
   */
  export type MoodEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MoodEntries.
     */
    data: XOR<MoodEntryUpdateManyMutationInput, MoodEntryUncheckedUpdateManyInput>
    /**
     * Filter which MoodEntries to update
     */
    where?: MoodEntryWhereInput
    /**
     * Limit how many MoodEntries to update.
     */
    limit?: number
  }

  /**
   * MoodEntry updateManyAndReturn
   */
  export type MoodEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * The data used to update MoodEntries.
     */
    data: XOR<MoodEntryUpdateManyMutationInput, MoodEntryUncheckedUpdateManyInput>
    /**
     * Filter which MoodEntries to update
     */
    where?: MoodEntryWhereInput
    /**
     * Limit how many MoodEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MoodEntry upsert
   */
  export type MoodEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the MoodEntry to update in case it exists.
     */
    where: MoodEntryWhereUniqueInput
    /**
     * In case the MoodEntry found by the `where` argument doesn't exist, create a new MoodEntry with this data.
     */
    create: XOR<MoodEntryCreateInput, MoodEntryUncheckedCreateInput>
    /**
     * In case the MoodEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MoodEntryUpdateInput, MoodEntryUncheckedUpdateInput>
  }

  /**
   * MoodEntry delete
   */
  export type MoodEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter which MoodEntry to delete.
     */
    where: MoodEntryWhereUniqueInput
  }

  /**
   * MoodEntry deleteMany
   */
  export type MoodEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoodEntries to delete
     */
    where?: MoodEntryWhereInput
    /**
     * Limit how many MoodEntries to delete.
     */
    limit?: number
  }

  /**
   * MoodEntry without action
   */
  export type MoodEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
  }


  /**
   * Model SafetyPlan
   */

  export type AggregateSafetyPlan = {
    _count: SafetyPlanCountAggregateOutputType | null
    _avg: SafetyPlanAvgAggregateOutputType | null
    _sum: SafetyPlanSumAggregateOutputType | null
    _min: SafetyPlanMinAggregateOutputType | null
    _max: SafetyPlanMaxAggregateOutputType | null
  }

  export type SafetyPlanAvgAggregateOutputType = {
    version: number | null
  }

  export type SafetyPlanSumAggregateOutputType = {
    version: number | null
  }

  export type SafetyPlanMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    version: number | null
    isActive: boolean | null
    encryptedContent: Uint8Array | null
    contentHash: string | null
    emergencyShare: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SafetyPlanMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    version: number | null
    isActive: boolean | null
    encryptedContent: Uint8Array | null
    contentHash: string | null
    emergencyShare: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SafetyPlanCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    version: number
    isActive: number
    encryptedContent: number
    contentHash: number
    sharedWith: number
    emergencyShare: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SafetyPlanAvgAggregateInputType = {
    version?: true
  }

  export type SafetyPlanSumAggregateInputType = {
    version?: true
  }

  export type SafetyPlanMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    version?: true
    isActive?: true
    encryptedContent?: true
    contentHash?: true
    emergencyShare?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SafetyPlanMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    version?: true
    isActive?: true
    encryptedContent?: true
    contentHash?: true
    emergencyShare?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SafetyPlanCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    version?: true
    isActive?: true
    encryptedContent?: true
    contentHash?: true
    sharedWith?: true
    emergencyShare?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SafetyPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SafetyPlan to aggregate.
     */
    where?: SafetyPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyPlans to fetch.
     */
    orderBy?: SafetyPlanOrderByWithRelationInput | SafetyPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SafetyPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SafetyPlans
    **/
    _count?: true | SafetyPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SafetyPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SafetyPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SafetyPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SafetyPlanMaxAggregateInputType
  }

  export type GetSafetyPlanAggregateType<T extends SafetyPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateSafetyPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSafetyPlan[P]>
      : GetScalarType<T[P], AggregateSafetyPlan[P]>
  }




  export type SafetyPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SafetyPlanWhereInput
    orderBy?: SafetyPlanOrderByWithAggregationInput | SafetyPlanOrderByWithAggregationInput[]
    by: SafetyPlanScalarFieldEnum[] | SafetyPlanScalarFieldEnum
    having?: SafetyPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SafetyPlanCountAggregateInputType | true
    _avg?: SafetyPlanAvgAggregateInputType
    _sum?: SafetyPlanSumAggregateInputType
    _min?: SafetyPlanMinAggregateInputType
    _max?: SafetyPlanMaxAggregateInputType
  }

  export type SafetyPlanGroupByOutputType = {
    id: string
    userId: string
    title: string
    version: number
    isActive: boolean
    encryptedContent: Uint8Array
    contentHash: string
    sharedWith: JsonValue | null
    emergencyShare: boolean
    createdAt: Date
    updatedAt: Date
    _count: SafetyPlanCountAggregateOutputType | null
    _avg: SafetyPlanAvgAggregateOutputType | null
    _sum: SafetyPlanSumAggregateOutputType | null
    _min: SafetyPlanMinAggregateOutputType | null
    _max: SafetyPlanMaxAggregateOutputType | null
  }

  type GetSafetyPlanGroupByPayload<T extends SafetyPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SafetyPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SafetyPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SafetyPlanGroupByOutputType[P]>
            : GetScalarType<T[P], SafetyPlanGroupByOutputType[P]>
        }
      >
    >


  export type SafetyPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    version?: boolean
    isActive?: boolean
    encryptedContent?: boolean
    contentHash?: boolean
    sharedWith?: boolean
    emergencyShare?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    versions?: boolean | SafetyPlan$versionsArgs<ExtArgs>
    _count?: boolean | SafetyPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["safetyPlan"]>

  export type SafetyPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    version?: boolean
    isActive?: boolean
    encryptedContent?: boolean
    contentHash?: boolean
    sharedWith?: boolean
    emergencyShare?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["safetyPlan"]>

  export type SafetyPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    version?: boolean
    isActive?: boolean
    encryptedContent?: boolean
    contentHash?: boolean
    sharedWith?: boolean
    emergencyShare?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["safetyPlan"]>

  export type SafetyPlanSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    version?: boolean
    isActive?: boolean
    encryptedContent?: boolean
    contentHash?: boolean
    sharedWith?: boolean
    emergencyShare?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SafetyPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "version" | "isActive" | "encryptedContent" | "contentHash" | "sharedWith" | "emergencyShare" | "createdAt" | "updatedAt", ExtArgs["result"]["safetyPlan"]>
  export type SafetyPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    versions?: boolean | SafetyPlan$versionsArgs<ExtArgs>
    _count?: boolean | SafetyPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SafetyPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SafetyPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SafetyPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SafetyPlan"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      versions: Prisma.$SafetyPlanVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      version: number
      isActive: boolean
      encryptedContent: Uint8Array
      contentHash: string
      sharedWith: Prisma.JsonValue | null
      emergencyShare: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["safetyPlan"]>
    composites: {}
  }

  type SafetyPlanGetPayload<S extends boolean | null | undefined | SafetyPlanDefaultArgs> = $Result.GetResult<Prisma.$SafetyPlanPayload, S>

  type SafetyPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SafetyPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SafetyPlanCountAggregateInputType | true
    }

  export interface SafetyPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SafetyPlan'], meta: { name: 'SafetyPlan' } }
    /**
     * Find zero or one SafetyPlan that matches the filter.
     * @param {SafetyPlanFindUniqueArgs} args - Arguments to find a SafetyPlan
     * @example
     * // Get one SafetyPlan
     * const safetyPlan = await prisma.safetyPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SafetyPlanFindUniqueArgs>(args: SelectSubset<T, SafetyPlanFindUniqueArgs<ExtArgs>>): Prisma__SafetyPlanClient<$Result.GetResult<Prisma.$SafetyPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SafetyPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SafetyPlanFindUniqueOrThrowArgs} args - Arguments to find a SafetyPlan
     * @example
     * // Get one SafetyPlan
     * const safetyPlan = await prisma.safetyPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SafetyPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, SafetyPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SafetyPlanClient<$Result.GetResult<Prisma.$SafetyPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SafetyPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyPlanFindFirstArgs} args - Arguments to find a SafetyPlan
     * @example
     * // Get one SafetyPlan
     * const safetyPlan = await prisma.safetyPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SafetyPlanFindFirstArgs>(args?: SelectSubset<T, SafetyPlanFindFirstArgs<ExtArgs>>): Prisma__SafetyPlanClient<$Result.GetResult<Prisma.$SafetyPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SafetyPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyPlanFindFirstOrThrowArgs} args - Arguments to find a SafetyPlan
     * @example
     * // Get one SafetyPlan
     * const safetyPlan = await prisma.safetyPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SafetyPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, SafetyPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__SafetyPlanClient<$Result.GetResult<Prisma.$SafetyPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SafetyPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SafetyPlans
     * const safetyPlans = await prisma.safetyPlan.findMany()
     * 
     * // Get first 10 SafetyPlans
     * const safetyPlans = await prisma.safetyPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const safetyPlanWithIdOnly = await prisma.safetyPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SafetyPlanFindManyArgs>(args?: SelectSubset<T, SafetyPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetyPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SafetyPlan.
     * @param {SafetyPlanCreateArgs} args - Arguments to create a SafetyPlan.
     * @example
     * // Create one SafetyPlan
     * const SafetyPlan = await prisma.safetyPlan.create({
     *   data: {
     *     // ... data to create a SafetyPlan
     *   }
     * })
     * 
     */
    create<T extends SafetyPlanCreateArgs>(args: SelectSubset<T, SafetyPlanCreateArgs<ExtArgs>>): Prisma__SafetyPlanClient<$Result.GetResult<Prisma.$SafetyPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SafetyPlans.
     * @param {SafetyPlanCreateManyArgs} args - Arguments to create many SafetyPlans.
     * @example
     * // Create many SafetyPlans
     * const safetyPlan = await prisma.safetyPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SafetyPlanCreateManyArgs>(args?: SelectSubset<T, SafetyPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SafetyPlans and returns the data saved in the database.
     * @param {SafetyPlanCreateManyAndReturnArgs} args - Arguments to create many SafetyPlans.
     * @example
     * // Create many SafetyPlans
     * const safetyPlan = await prisma.safetyPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SafetyPlans and only return the `id`
     * const safetyPlanWithIdOnly = await prisma.safetyPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SafetyPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, SafetyPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetyPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SafetyPlan.
     * @param {SafetyPlanDeleteArgs} args - Arguments to delete one SafetyPlan.
     * @example
     * // Delete one SafetyPlan
     * const SafetyPlan = await prisma.safetyPlan.delete({
     *   where: {
     *     // ... filter to delete one SafetyPlan
     *   }
     * })
     * 
     */
    delete<T extends SafetyPlanDeleteArgs>(args: SelectSubset<T, SafetyPlanDeleteArgs<ExtArgs>>): Prisma__SafetyPlanClient<$Result.GetResult<Prisma.$SafetyPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SafetyPlan.
     * @param {SafetyPlanUpdateArgs} args - Arguments to update one SafetyPlan.
     * @example
     * // Update one SafetyPlan
     * const safetyPlan = await prisma.safetyPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SafetyPlanUpdateArgs>(args: SelectSubset<T, SafetyPlanUpdateArgs<ExtArgs>>): Prisma__SafetyPlanClient<$Result.GetResult<Prisma.$SafetyPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SafetyPlans.
     * @param {SafetyPlanDeleteManyArgs} args - Arguments to filter SafetyPlans to delete.
     * @example
     * // Delete a few SafetyPlans
     * const { count } = await prisma.safetyPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SafetyPlanDeleteManyArgs>(args?: SelectSubset<T, SafetyPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SafetyPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SafetyPlans
     * const safetyPlan = await prisma.safetyPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SafetyPlanUpdateManyArgs>(args: SelectSubset<T, SafetyPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SafetyPlans and returns the data updated in the database.
     * @param {SafetyPlanUpdateManyAndReturnArgs} args - Arguments to update many SafetyPlans.
     * @example
     * // Update many SafetyPlans
     * const safetyPlan = await prisma.safetyPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SafetyPlans and only return the `id`
     * const safetyPlanWithIdOnly = await prisma.safetyPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SafetyPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, SafetyPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetyPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SafetyPlan.
     * @param {SafetyPlanUpsertArgs} args - Arguments to update or create a SafetyPlan.
     * @example
     * // Update or create a SafetyPlan
     * const safetyPlan = await prisma.safetyPlan.upsert({
     *   create: {
     *     // ... data to create a SafetyPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SafetyPlan we want to update
     *   }
     * })
     */
    upsert<T extends SafetyPlanUpsertArgs>(args: SelectSubset<T, SafetyPlanUpsertArgs<ExtArgs>>): Prisma__SafetyPlanClient<$Result.GetResult<Prisma.$SafetyPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SafetyPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyPlanCountArgs} args - Arguments to filter SafetyPlans to count.
     * @example
     * // Count the number of SafetyPlans
     * const count = await prisma.safetyPlan.count({
     *   where: {
     *     // ... the filter for the SafetyPlans we want to count
     *   }
     * })
    **/
    count<T extends SafetyPlanCountArgs>(
      args?: Subset<T, SafetyPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SafetyPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SafetyPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SafetyPlanAggregateArgs>(args: Subset<T, SafetyPlanAggregateArgs>): Prisma.PrismaPromise<GetSafetyPlanAggregateType<T>>

    /**
     * Group by SafetyPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SafetyPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SafetyPlanGroupByArgs['orderBy'] }
        : { orderBy?: SafetyPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SafetyPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSafetyPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SafetyPlan model
   */
  readonly fields: SafetyPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SafetyPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SafetyPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    versions<T extends SafetyPlan$versionsArgs<ExtArgs> = {}>(args?: Subset<T, SafetyPlan$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetyPlanVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SafetyPlan model
   */
  interface SafetyPlanFieldRefs {
    readonly id: FieldRef<"SafetyPlan", 'String'>
    readonly userId: FieldRef<"SafetyPlan", 'String'>
    readonly title: FieldRef<"SafetyPlan", 'String'>
    readonly version: FieldRef<"SafetyPlan", 'Int'>
    readonly isActive: FieldRef<"SafetyPlan", 'Boolean'>
    readonly encryptedContent: FieldRef<"SafetyPlan", 'Bytes'>
    readonly contentHash: FieldRef<"SafetyPlan", 'String'>
    readonly sharedWith: FieldRef<"SafetyPlan", 'Json'>
    readonly emergencyShare: FieldRef<"SafetyPlan", 'Boolean'>
    readonly createdAt: FieldRef<"SafetyPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"SafetyPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SafetyPlan findUnique
   */
  export type SafetyPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlan
     */
    select?: SafetyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlan
     */
    omit?: SafetyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanInclude<ExtArgs> | null
    /**
     * Filter, which SafetyPlan to fetch.
     */
    where: SafetyPlanWhereUniqueInput
  }

  /**
   * SafetyPlan findUniqueOrThrow
   */
  export type SafetyPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlan
     */
    select?: SafetyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlan
     */
    omit?: SafetyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanInclude<ExtArgs> | null
    /**
     * Filter, which SafetyPlan to fetch.
     */
    where: SafetyPlanWhereUniqueInput
  }

  /**
   * SafetyPlan findFirst
   */
  export type SafetyPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlan
     */
    select?: SafetyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlan
     */
    omit?: SafetyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanInclude<ExtArgs> | null
    /**
     * Filter, which SafetyPlan to fetch.
     */
    where?: SafetyPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyPlans to fetch.
     */
    orderBy?: SafetyPlanOrderByWithRelationInput | SafetyPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SafetyPlans.
     */
    cursor?: SafetyPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SafetyPlans.
     */
    distinct?: SafetyPlanScalarFieldEnum | SafetyPlanScalarFieldEnum[]
  }

  /**
   * SafetyPlan findFirstOrThrow
   */
  export type SafetyPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlan
     */
    select?: SafetyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlan
     */
    omit?: SafetyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanInclude<ExtArgs> | null
    /**
     * Filter, which SafetyPlan to fetch.
     */
    where?: SafetyPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyPlans to fetch.
     */
    orderBy?: SafetyPlanOrderByWithRelationInput | SafetyPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SafetyPlans.
     */
    cursor?: SafetyPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SafetyPlans.
     */
    distinct?: SafetyPlanScalarFieldEnum | SafetyPlanScalarFieldEnum[]
  }

  /**
   * SafetyPlan findMany
   */
  export type SafetyPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlan
     */
    select?: SafetyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlan
     */
    omit?: SafetyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanInclude<ExtArgs> | null
    /**
     * Filter, which SafetyPlans to fetch.
     */
    where?: SafetyPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyPlans to fetch.
     */
    orderBy?: SafetyPlanOrderByWithRelationInput | SafetyPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SafetyPlans.
     */
    cursor?: SafetyPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyPlans.
     */
    skip?: number
    distinct?: SafetyPlanScalarFieldEnum | SafetyPlanScalarFieldEnum[]
  }

  /**
   * SafetyPlan create
   */
  export type SafetyPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlan
     */
    select?: SafetyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlan
     */
    omit?: SafetyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a SafetyPlan.
     */
    data: XOR<SafetyPlanCreateInput, SafetyPlanUncheckedCreateInput>
  }

  /**
   * SafetyPlan createMany
   */
  export type SafetyPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SafetyPlans.
     */
    data: SafetyPlanCreateManyInput | SafetyPlanCreateManyInput[]
  }

  /**
   * SafetyPlan createManyAndReturn
   */
  export type SafetyPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlan
     */
    select?: SafetyPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlan
     */
    omit?: SafetyPlanOmit<ExtArgs> | null
    /**
     * The data used to create many SafetyPlans.
     */
    data: SafetyPlanCreateManyInput | SafetyPlanCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SafetyPlan update
   */
  export type SafetyPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlan
     */
    select?: SafetyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlan
     */
    omit?: SafetyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a SafetyPlan.
     */
    data: XOR<SafetyPlanUpdateInput, SafetyPlanUncheckedUpdateInput>
    /**
     * Choose, which SafetyPlan to update.
     */
    where: SafetyPlanWhereUniqueInput
  }

  /**
   * SafetyPlan updateMany
   */
  export type SafetyPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SafetyPlans.
     */
    data: XOR<SafetyPlanUpdateManyMutationInput, SafetyPlanUncheckedUpdateManyInput>
    /**
     * Filter which SafetyPlans to update
     */
    where?: SafetyPlanWhereInput
    /**
     * Limit how many SafetyPlans to update.
     */
    limit?: number
  }

  /**
   * SafetyPlan updateManyAndReturn
   */
  export type SafetyPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlan
     */
    select?: SafetyPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlan
     */
    omit?: SafetyPlanOmit<ExtArgs> | null
    /**
     * The data used to update SafetyPlans.
     */
    data: XOR<SafetyPlanUpdateManyMutationInput, SafetyPlanUncheckedUpdateManyInput>
    /**
     * Filter which SafetyPlans to update
     */
    where?: SafetyPlanWhereInput
    /**
     * Limit how many SafetyPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SafetyPlan upsert
   */
  export type SafetyPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlan
     */
    select?: SafetyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlan
     */
    omit?: SafetyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the SafetyPlan to update in case it exists.
     */
    where: SafetyPlanWhereUniqueInput
    /**
     * In case the SafetyPlan found by the `where` argument doesn't exist, create a new SafetyPlan with this data.
     */
    create: XOR<SafetyPlanCreateInput, SafetyPlanUncheckedCreateInput>
    /**
     * In case the SafetyPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SafetyPlanUpdateInput, SafetyPlanUncheckedUpdateInput>
  }

  /**
   * SafetyPlan delete
   */
  export type SafetyPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlan
     */
    select?: SafetyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlan
     */
    omit?: SafetyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanInclude<ExtArgs> | null
    /**
     * Filter which SafetyPlan to delete.
     */
    where: SafetyPlanWhereUniqueInput
  }

  /**
   * SafetyPlan deleteMany
   */
  export type SafetyPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SafetyPlans to delete
     */
    where?: SafetyPlanWhereInput
    /**
     * Limit how many SafetyPlans to delete.
     */
    limit?: number
  }

  /**
   * SafetyPlan.versions
   */
  export type SafetyPlan$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlanVersion
     */
    select?: SafetyPlanVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlanVersion
     */
    omit?: SafetyPlanVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanVersionInclude<ExtArgs> | null
    where?: SafetyPlanVersionWhereInput
    orderBy?: SafetyPlanVersionOrderByWithRelationInput | SafetyPlanVersionOrderByWithRelationInput[]
    cursor?: SafetyPlanVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SafetyPlanVersionScalarFieldEnum | SafetyPlanVersionScalarFieldEnum[]
  }

  /**
   * SafetyPlan without action
   */
  export type SafetyPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlan
     */
    select?: SafetyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlan
     */
    omit?: SafetyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanInclude<ExtArgs> | null
  }


  /**
   * Model SafetyPlanVersion
   */

  export type AggregateSafetyPlanVersion = {
    _count: SafetyPlanVersionCountAggregateOutputType | null
    _avg: SafetyPlanVersionAvgAggregateOutputType | null
    _sum: SafetyPlanVersionSumAggregateOutputType | null
    _min: SafetyPlanVersionMinAggregateOutputType | null
    _max: SafetyPlanVersionMaxAggregateOutputType | null
  }

  export type SafetyPlanVersionAvgAggregateOutputType = {
    version: number | null
  }

  export type SafetyPlanVersionSumAggregateOutputType = {
    version: number | null
  }

  export type SafetyPlanVersionMinAggregateOutputType = {
    id: string | null
    safetyPlanId: string | null
    version: number | null
    changeLog: string | null
    encryptedContent: Uint8Array | null
    contentHash: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type SafetyPlanVersionMaxAggregateOutputType = {
    id: string | null
    safetyPlanId: string | null
    version: number | null
    changeLog: string | null
    encryptedContent: Uint8Array | null
    contentHash: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type SafetyPlanVersionCountAggregateOutputType = {
    id: number
    safetyPlanId: number
    version: number
    changeLog: number
    encryptedContent: number
    contentHash: number
    createdAt: number
    createdBy: number
    _all: number
  }


  export type SafetyPlanVersionAvgAggregateInputType = {
    version?: true
  }

  export type SafetyPlanVersionSumAggregateInputType = {
    version?: true
  }

  export type SafetyPlanVersionMinAggregateInputType = {
    id?: true
    safetyPlanId?: true
    version?: true
    changeLog?: true
    encryptedContent?: true
    contentHash?: true
    createdAt?: true
    createdBy?: true
  }

  export type SafetyPlanVersionMaxAggregateInputType = {
    id?: true
    safetyPlanId?: true
    version?: true
    changeLog?: true
    encryptedContent?: true
    contentHash?: true
    createdAt?: true
    createdBy?: true
  }

  export type SafetyPlanVersionCountAggregateInputType = {
    id?: true
    safetyPlanId?: true
    version?: true
    changeLog?: true
    encryptedContent?: true
    contentHash?: true
    createdAt?: true
    createdBy?: true
    _all?: true
  }

  export type SafetyPlanVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SafetyPlanVersion to aggregate.
     */
    where?: SafetyPlanVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyPlanVersions to fetch.
     */
    orderBy?: SafetyPlanVersionOrderByWithRelationInput | SafetyPlanVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SafetyPlanVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyPlanVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyPlanVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SafetyPlanVersions
    **/
    _count?: true | SafetyPlanVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SafetyPlanVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SafetyPlanVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SafetyPlanVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SafetyPlanVersionMaxAggregateInputType
  }

  export type GetSafetyPlanVersionAggregateType<T extends SafetyPlanVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateSafetyPlanVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSafetyPlanVersion[P]>
      : GetScalarType<T[P], AggregateSafetyPlanVersion[P]>
  }




  export type SafetyPlanVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SafetyPlanVersionWhereInput
    orderBy?: SafetyPlanVersionOrderByWithAggregationInput | SafetyPlanVersionOrderByWithAggregationInput[]
    by: SafetyPlanVersionScalarFieldEnum[] | SafetyPlanVersionScalarFieldEnum
    having?: SafetyPlanVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SafetyPlanVersionCountAggregateInputType | true
    _avg?: SafetyPlanVersionAvgAggregateInputType
    _sum?: SafetyPlanVersionSumAggregateInputType
    _min?: SafetyPlanVersionMinAggregateInputType
    _max?: SafetyPlanVersionMaxAggregateInputType
  }

  export type SafetyPlanVersionGroupByOutputType = {
    id: string
    safetyPlanId: string
    version: number
    changeLog: string | null
    encryptedContent: Uint8Array
    contentHash: string
    createdAt: Date
    createdBy: string
    _count: SafetyPlanVersionCountAggregateOutputType | null
    _avg: SafetyPlanVersionAvgAggregateOutputType | null
    _sum: SafetyPlanVersionSumAggregateOutputType | null
    _min: SafetyPlanVersionMinAggregateOutputType | null
    _max: SafetyPlanVersionMaxAggregateOutputType | null
  }

  type GetSafetyPlanVersionGroupByPayload<T extends SafetyPlanVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SafetyPlanVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SafetyPlanVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SafetyPlanVersionGroupByOutputType[P]>
            : GetScalarType<T[P], SafetyPlanVersionGroupByOutputType[P]>
        }
      >
    >


  export type SafetyPlanVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    safetyPlanId?: boolean
    version?: boolean
    changeLog?: boolean
    encryptedContent?: boolean
    contentHash?: boolean
    createdAt?: boolean
    createdBy?: boolean
    safetyPlan?: boolean | SafetyPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["safetyPlanVersion"]>

  export type SafetyPlanVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    safetyPlanId?: boolean
    version?: boolean
    changeLog?: boolean
    encryptedContent?: boolean
    contentHash?: boolean
    createdAt?: boolean
    createdBy?: boolean
    safetyPlan?: boolean | SafetyPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["safetyPlanVersion"]>

  export type SafetyPlanVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    safetyPlanId?: boolean
    version?: boolean
    changeLog?: boolean
    encryptedContent?: boolean
    contentHash?: boolean
    createdAt?: boolean
    createdBy?: boolean
    safetyPlan?: boolean | SafetyPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["safetyPlanVersion"]>

  export type SafetyPlanVersionSelectScalar = {
    id?: boolean
    safetyPlanId?: boolean
    version?: boolean
    changeLog?: boolean
    encryptedContent?: boolean
    contentHash?: boolean
    createdAt?: boolean
    createdBy?: boolean
  }

  export type SafetyPlanVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "safetyPlanId" | "version" | "changeLog" | "encryptedContent" | "contentHash" | "createdAt" | "createdBy", ExtArgs["result"]["safetyPlanVersion"]>
  export type SafetyPlanVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    safetyPlan?: boolean | SafetyPlanDefaultArgs<ExtArgs>
  }
  export type SafetyPlanVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    safetyPlan?: boolean | SafetyPlanDefaultArgs<ExtArgs>
  }
  export type SafetyPlanVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    safetyPlan?: boolean | SafetyPlanDefaultArgs<ExtArgs>
  }

  export type $SafetyPlanVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SafetyPlanVersion"
    objects: {
      safetyPlan: Prisma.$SafetyPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      safetyPlanId: string
      version: number
      changeLog: string | null
      encryptedContent: Uint8Array
      contentHash: string
      createdAt: Date
      createdBy: string
    }, ExtArgs["result"]["safetyPlanVersion"]>
    composites: {}
  }

  type SafetyPlanVersionGetPayload<S extends boolean | null | undefined | SafetyPlanVersionDefaultArgs> = $Result.GetResult<Prisma.$SafetyPlanVersionPayload, S>

  type SafetyPlanVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SafetyPlanVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SafetyPlanVersionCountAggregateInputType | true
    }

  export interface SafetyPlanVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SafetyPlanVersion'], meta: { name: 'SafetyPlanVersion' } }
    /**
     * Find zero or one SafetyPlanVersion that matches the filter.
     * @param {SafetyPlanVersionFindUniqueArgs} args - Arguments to find a SafetyPlanVersion
     * @example
     * // Get one SafetyPlanVersion
     * const safetyPlanVersion = await prisma.safetyPlanVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SafetyPlanVersionFindUniqueArgs>(args: SelectSubset<T, SafetyPlanVersionFindUniqueArgs<ExtArgs>>): Prisma__SafetyPlanVersionClient<$Result.GetResult<Prisma.$SafetyPlanVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SafetyPlanVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SafetyPlanVersionFindUniqueOrThrowArgs} args - Arguments to find a SafetyPlanVersion
     * @example
     * // Get one SafetyPlanVersion
     * const safetyPlanVersion = await prisma.safetyPlanVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SafetyPlanVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, SafetyPlanVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SafetyPlanVersionClient<$Result.GetResult<Prisma.$SafetyPlanVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SafetyPlanVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyPlanVersionFindFirstArgs} args - Arguments to find a SafetyPlanVersion
     * @example
     * // Get one SafetyPlanVersion
     * const safetyPlanVersion = await prisma.safetyPlanVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SafetyPlanVersionFindFirstArgs>(args?: SelectSubset<T, SafetyPlanVersionFindFirstArgs<ExtArgs>>): Prisma__SafetyPlanVersionClient<$Result.GetResult<Prisma.$SafetyPlanVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SafetyPlanVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyPlanVersionFindFirstOrThrowArgs} args - Arguments to find a SafetyPlanVersion
     * @example
     * // Get one SafetyPlanVersion
     * const safetyPlanVersion = await prisma.safetyPlanVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SafetyPlanVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, SafetyPlanVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SafetyPlanVersionClient<$Result.GetResult<Prisma.$SafetyPlanVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SafetyPlanVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyPlanVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SafetyPlanVersions
     * const safetyPlanVersions = await prisma.safetyPlanVersion.findMany()
     * 
     * // Get first 10 SafetyPlanVersions
     * const safetyPlanVersions = await prisma.safetyPlanVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const safetyPlanVersionWithIdOnly = await prisma.safetyPlanVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SafetyPlanVersionFindManyArgs>(args?: SelectSubset<T, SafetyPlanVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetyPlanVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SafetyPlanVersion.
     * @param {SafetyPlanVersionCreateArgs} args - Arguments to create a SafetyPlanVersion.
     * @example
     * // Create one SafetyPlanVersion
     * const SafetyPlanVersion = await prisma.safetyPlanVersion.create({
     *   data: {
     *     // ... data to create a SafetyPlanVersion
     *   }
     * })
     * 
     */
    create<T extends SafetyPlanVersionCreateArgs>(args: SelectSubset<T, SafetyPlanVersionCreateArgs<ExtArgs>>): Prisma__SafetyPlanVersionClient<$Result.GetResult<Prisma.$SafetyPlanVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SafetyPlanVersions.
     * @param {SafetyPlanVersionCreateManyArgs} args - Arguments to create many SafetyPlanVersions.
     * @example
     * // Create many SafetyPlanVersions
     * const safetyPlanVersion = await prisma.safetyPlanVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SafetyPlanVersionCreateManyArgs>(args?: SelectSubset<T, SafetyPlanVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SafetyPlanVersions and returns the data saved in the database.
     * @param {SafetyPlanVersionCreateManyAndReturnArgs} args - Arguments to create many SafetyPlanVersions.
     * @example
     * // Create many SafetyPlanVersions
     * const safetyPlanVersion = await prisma.safetyPlanVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SafetyPlanVersions and only return the `id`
     * const safetyPlanVersionWithIdOnly = await prisma.safetyPlanVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SafetyPlanVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, SafetyPlanVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetyPlanVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SafetyPlanVersion.
     * @param {SafetyPlanVersionDeleteArgs} args - Arguments to delete one SafetyPlanVersion.
     * @example
     * // Delete one SafetyPlanVersion
     * const SafetyPlanVersion = await prisma.safetyPlanVersion.delete({
     *   where: {
     *     // ... filter to delete one SafetyPlanVersion
     *   }
     * })
     * 
     */
    delete<T extends SafetyPlanVersionDeleteArgs>(args: SelectSubset<T, SafetyPlanVersionDeleteArgs<ExtArgs>>): Prisma__SafetyPlanVersionClient<$Result.GetResult<Prisma.$SafetyPlanVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SafetyPlanVersion.
     * @param {SafetyPlanVersionUpdateArgs} args - Arguments to update one SafetyPlanVersion.
     * @example
     * // Update one SafetyPlanVersion
     * const safetyPlanVersion = await prisma.safetyPlanVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SafetyPlanVersionUpdateArgs>(args: SelectSubset<T, SafetyPlanVersionUpdateArgs<ExtArgs>>): Prisma__SafetyPlanVersionClient<$Result.GetResult<Prisma.$SafetyPlanVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SafetyPlanVersions.
     * @param {SafetyPlanVersionDeleteManyArgs} args - Arguments to filter SafetyPlanVersions to delete.
     * @example
     * // Delete a few SafetyPlanVersions
     * const { count } = await prisma.safetyPlanVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SafetyPlanVersionDeleteManyArgs>(args?: SelectSubset<T, SafetyPlanVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SafetyPlanVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyPlanVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SafetyPlanVersions
     * const safetyPlanVersion = await prisma.safetyPlanVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SafetyPlanVersionUpdateManyArgs>(args: SelectSubset<T, SafetyPlanVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SafetyPlanVersions and returns the data updated in the database.
     * @param {SafetyPlanVersionUpdateManyAndReturnArgs} args - Arguments to update many SafetyPlanVersions.
     * @example
     * // Update many SafetyPlanVersions
     * const safetyPlanVersion = await prisma.safetyPlanVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SafetyPlanVersions and only return the `id`
     * const safetyPlanVersionWithIdOnly = await prisma.safetyPlanVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SafetyPlanVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, SafetyPlanVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetyPlanVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SafetyPlanVersion.
     * @param {SafetyPlanVersionUpsertArgs} args - Arguments to update or create a SafetyPlanVersion.
     * @example
     * // Update or create a SafetyPlanVersion
     * const safetyPlanVersion = await prisma.safetyPlanVersion.upsert({
     *   create: {
     *     // ... data to create a SafetyPlanVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SafetyPlanVersion we want to update
     *   }
     * })
     */
    upsert<T extends SafetyPlanVersionUpsertArgs>(args: SelectSubset<T, SafetyPlanVersionUpsertArgs<ExtArgs>>): Prisma__SafetyPlanVersionClient<$Result.GetResult<Prisma.$SafetyPlanVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SafetyPlanVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyPlanVersionCountArgs} args - Arguments to filter SafetyPlanVersions to count.
     * @example
     * // Count the number of SafetyPlanVersions
     * const count = await prisma.safetyPlanVersion.count({
     *   where: {
     *     // ... the filter for the SafetyPlanVersions we want to count
     *   }
     * })
    **/
    count<T extends SafetyPlanVersionCountArgs>(
      args?: Subset<T, SafetyPlanVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SafetyPlanVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SafetyPlanVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyPlanVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SafetyPlanVersionAggregateArgs>(args: Subset<T, SafetyPlanVersionAggregateArgs>): Prisma.PrismaPromise<GetSafetyPlanVersionAggregateType<T>>

    /**
     * Group by SafetyPlanVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyPlanVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SafetyPlanVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SafetyPlanVersionGroupByArgs['orderBy'] }
        : { orderBy?: SafetyPlanVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SafetyPlanVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSafetyPlanVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SafetyPlanVersion model
   */
  readonly fields: SafetyPlanVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SafetyPlanVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SafetyPlanVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    safetyPlan<T extends SafetyPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SafetyPlanDefaultArgs<ExtArgs>>): Prisma__SafetyPlanClient<$Result.GetResult<Prisma.$SafetyPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SafetyPlanVersion model
   */
  interface SafetyPlanVersionFieldRefs {
    readonly id: FieldRef<"SafetyPlanVersion", 'String'>
    readonly safetyPlanId: FieldRef<"SafetyPlanVersion", 'String'>
    readonly version: FieldRef<"SafetyPlanVersion", 'Int'>
    readonly changeLog: FieldRef<"SafetyPlanVersion", 'String'>
    readonly encryptedContent: FieldRef<"SafetyPlanVersion", 'Bytes'>
    readonly contentHash: FieldRef<"SafetyPlanVersion", 'String'>
    readonly createdAt: FieldRef<"SafetyPlanVersion", 'DateTime'>
    readonly createdBy: FieldRef<"SafetyPlanVersion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SafetyPlanVersion findUnique
   */
  export type SafetyPlanVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlanVersion
     */
    select?: SafetyPlanVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlanVersion
     */
    omit?: SafetyPlanVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanVersionInclude<ExtArgs> | null
    /**
     * Filter, which SafetyPlanVersion to fetch.
     */
    where: SafetyPlanVersionWhereUniqueInput
  }

  /**
   * SafetyPlanVersion findUniqueOrThrow
   */
  export type SafetyPlanVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlanVersion
     */
    select?: SafetyPlanVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlanVersion
     */
    omit?: SafetyPlanVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanVersionInclude<ExtArgs> | null
    /**
     * Filter, which SafetyPlanVersion to fetch.
     */
    where: SafetyPlanVersionWhereUniqueInput
  }

  /**
   * SafetyPlanVersion findFirst
   */
  export type SafetyPlanVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlanVersion
     */
    select?: SafetyPlanVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlanVersion
     */
    omit?: SafetyPlanVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanVersionInclude<ExtArgs> | null
    /**
     * Filter, which SafetyPlanVersion to fetch.
     */
    where?: SafetyPlanVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyPlanVersions to fetch.
     */
    orderBy?: SafetyPlanVersionOrderByWithRelationInput | SafetyPlanVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SafetyPlanVersions.
     */
    cursor?: SafetyPlanVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyPlanVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyPlanVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SafetyPlanVersions.
     */
    distinct?: SafetyPlanVersionScalarFieldEnum | SafetyPlanVersionScalarFieldEnum[]
  }

  /**
   * SafetyPlanVersion findFirstOrThrow
   */
  export type SafetyPlanVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlanVersion
     */
    select?: SafetyPlanVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlanVersion
     */
    omit?: SafetyPlanVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanVersionInclude<ExtArgs> | null
    /**
     * Filter, which SafetyPlanVersion to fetch.
     */
    where?: SafetyPlanVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyPlanVersions to fetch.
     */
    orderBy?: SafetyPlanVersionOrderByWithRelationInput | SafetyPlanVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SafetyPlanVersions.
     */
    cursor?: SafetyPlanVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyPlanVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyPlanVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SafetyPlanVersions.
     */
    distinct?: SafetyPlanVersionScalarFieldEnum | SafetyPlanVersionScalarFieldEnum[]
  }

  /**
   * SafetyPlanVersion findMany
   */
  export type SafetyPlanVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlanVersion
     */
    select?: SafetyPlanVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlanVersion
     */
    omit?: SafetyPlanVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanVersionInclude<ExtArgs> | null
    /**
     * Filter, which SafetyPlanVersions to fetch.
     */
    where?: SafetyPlanVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyPlanVersions to fetch.
     */
    orderBy?: SafetyPlanVersionOrderByWithRelationInput | SafetyPlanVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SafetyPlanVersions.
     */
    cursor?: SafetyPlanVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyPlanVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyPlanVersions.
     */
    skip?: number
    distinct?: SafetyPlanVersionScalarFieldEnum | SafetyPlanVersionScalarFieldEnum[]
  }

  /**
   * SafetyPlanVersion create
   */
  export type SafetyPlanVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlanVersion
     */
    select?: SafetyPlanVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlanVersion
     */
    omit?: SafetyPlanVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a SafetyPlanVersion.
     */
    data: XOR<SafetyPlanVersionCreateInput, SafetyPlanVersionUncheckedCreateInput>
  }

  /**
   * SafetyPlanVersion createMany
   */
  export type SafetyPlanVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SafetyPlanVersions.
     */
    data: SafetyPlanVersionCreateManyInput | SafetyPlanVersionCreateManyInput[]
  }

  /**
   * SafetyPlanVersion createManyAndReturn
   */
  export type SafetyPlanVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlanVersion
     */
    select?: SafetyPlanVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlanVersion
     */
    omit?: SafetyPlanVersionOmit<ExtArgs> | null
    /**
     * The data used to create many SafetyPlanVersions.
     */
    data: SafetyPlanVersionCreateManyInput | SafetyPlanVersionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SafetyPlanVersion update
   */
  export type SafetyPlanVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlanVersion
     */
    select?: SafetyPlanVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlanVersion
     */
    omit?: SafetyPlanVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a SafetyPlanVersion.
     */
    data: XOR<SafetyPlanVersionUpdateInput, SafetyPlanVersionUncheckedUpdateInput>
    /**
     * Choose, which SafetyPlanVersion to update.
     */
    where: SafetyPlanVersionWhereUniqueInput
  }

  /**
   * SafetyPlanVersion updateMany
   */
  export type SafetyPlanVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SafetyPlanVersions.
     */
    data: XOR<SafetyPlanVersionUpdateManyMutationInput, SafetyPlanVersionUncheckedUpdateManyInput>
    /**
     * Filter which SafetyPlanVersions to update
     */
    where?: SafetyPlanVersionWhereInput
    /**
     * Limit how many SafetyPlanVersions to update.
     */
    limit?: number
  }

  /**
   * SafetyPlanVersion updateManyAndReturn
   */
  export type SafetyPlanVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlanVersion
     */
    select?: SafetyPlanVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlanVersion
     */
    omit?: SafetyPlanVersionOmit<ExtArgs> | null
    /**
     * The data used to update SafetyPlanVersions.
     */
    data: XOR<SafetyPlanVersionUpdateManyMutationInput, SafetyPlanVersionUncheckedUpdateManyInput>
    /**
     * Filter which SafetyPlanVersions to update
     */
    where?: SafetyPlanVersionWhereInput
    /**
     * Limit how many SafetyPlanVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SafetyPlanVersion upsert
   */
  export type SafetyPlanVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlanVersion
     */
    select?: SafetyPlanVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlanVersion
     */
    omit?: SafetyPlanVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the SafetyPlanVersion to update in case it exists.
     */
    where: SafetyPlanVersionWhereUniqueInput
    /**
     * In case the SafetyPlanVersion found by the `where` argument doesn't exist, create a new SafetyPlanVersion with this data.
     */
    create: XOR<SafetyPlanVersionCreateInput, SafetyPlanVersionUncheckedCreateInput>
    /**
     * In case the SafetyPlanVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SafetyPlanVersionUpdateInput, SafetyPlanVersionUncheckedUpdateInput>
  }

  /**
   * SafetyPlanVersion delete
   */
  export type SafetyPlanVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlanVersion
     */
    select?: SafetyPlanVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlanVersion
     */
    omit?: SafetyPlanVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanVersionInclude<ExtArgs> | null
    /**
     * Filter which SafetyPlanVersion to delete.
     */
    where: SafetyPlanVersionWhereUniqueInput
  }

  /**
   * SafetyPlanVersion deleteMany
   */
  export type SafetyPlanVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SafetyPlanVersions to delete
     */
    where?: SafetyPlanVersionWhereInput
    /**
     * Limit how many SafetyPlanVersions to delete.
     */
    limit?: number
  }

  /**
   * SafetyPlanVersion without action
   */
  export type SafetyPlanVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyPlanVersion
     */
    select?: SafetyPlanVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SafetyPlanVersion
     */
    omit?: SafetyPlanVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetyPlanVersionInclude<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileAvgAggregateOutputType = {
    level: number | null
    totalXP: number | null
  }

  export type UserProfileSumAggregateOutputType = {
    level: number | null
    totalXP: number | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    displayName: string | null
    level: number | null
    totalXP: number | null
    joinDate: Date | null
    lastActiveDate: Date | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    displayName: string | null
    level: number | null
    totalXP: number | null
    joinDate: Date | null
    lastActiveDate: Date | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    userId: number
    displayName: number
    level: number
    totalXP: number
    preferences: number
    stats: number
    joinDate: number
    lastActiveDate: number
    _all: number
  }


  export type UserProfileAvgAggregateInputType = {
    level?: true
    totalXP?: true
  }

  export type UserProfileSumAggregateInputType = {
    level?: true
    totalXP?: true
  }

  export type UserProfileMinAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    level?: true
    totalXP?: true
    joinDate?: true
    lastActiveDate?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    level?: true
    totalXP?: true
    joinDate?: true
    lastActiveDate?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    level?: true
    totalXP?: true
    preferences?: true
    stats?: true
    joinDate?: true
    lastActiveDate?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _avg?: UserProfileAvgAggregateInputType
    _sum?: UserProfileSumAggregateInputType
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: string
    userId: string
    displayName: string
    level: number
    totalXP: number
    preferences: JsonValue
    stats: JsonValue
    joinDate: Date
    lastActiveDate: Date
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    level?: boolean
    totalXP?: boolean
    preferences?: boolean
    stats?: boolean
    joinDate?: boolean
    lastActiveDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    level?: boolean
    totalXP?: boolean
    preferences?: boolean
    stats?: boolean
    joinDate?: boolean
    lastActiveDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    level?: boolean
    totalXP?: boolean
    preferences?: boolean
    stats?: boolean
    joinDate?: boolean
    lastActiveDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    displayName?: boolean
    level?: boolean
    totalXP?: boolean
    preferences?: boolean
    stats?: boolean
    joinDate?: boolean
    lastActiveDate?: boolean
  }

  export type UserProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "displayName" | "level" | "totalXP" | "preferences" | "stats" | "joinDate" | "lastActiveDate", ExtArgs["result"]["userProfile"]>
  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      displayName: string
      level: number
      totalXP: number
      preferences: Prisma.JsonValue
      stats: Prisma.JsonValue
      joinDate: Date
      lastActiveDate: Date
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles and returns the data updated in the database.
     * @param {UserProfileUpdateManyAndReturnArgs} args - Arguments to update many UserProfiles.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'String'>
    readonly userId: FieldRef<"UserProfile", 'String'>
    readonly displayName: FieldRef<"UserProfile", 'String'>
    readonly level: FieldRef<"UserProfile", 'Int'>
    readonly totalXP: FieldRef<"UserProfile", 'Int'>
    readonly preferences: FieldRef<"UserProfile", 'Json'>
    readonly stats: FieldRef<"UserProfile", 'Json'>
    readonly joinDate: FieldRef<"UserProfile", 'DateTime'>
    readonly lastActiveDate: FieldRef<"UserProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile updateManyAndReturn
   */
  export type UserProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    xpReward: number | null
    pointReward: number | null
  }

  export type AchievementSumAggregateOutputType = {
    xpReward: number | null
    pointReward: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.AchievementCategory | null
    rarity: $Enums.AchievementRarity | null
    xpReward: number | null
    pointReward: number | null
    icon: string | null
    color: string | null
    isActive: boolean | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.AchievementCategory | null
    rarity: $Enums.AchievementRarity | null
    xpReward: number | null
    pointReward: number | null
    icon: string | null
    color: string | null
    isActive: boolean | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    rarity: number
    requirements: number
    xpReward: number
    pointReward: number
    icon: number
    color: number
    isActive: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    xpReward?: true
    pointReward?: true
  }

  export type AchievementSumAggregateInputType = {
    xpReward?: true
    pointReward?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    rarity?: true
    xpReward?: true
    pointReward?: true
    icon?: true
    color?: true
    isActive?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    rarity?: true
    xpReward?: true
    pointReward?: true
    icon?: true
    color?: true
    isActive?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    rarity?: true
    requirements?: true
    xpReward?: true
    pointReward?: true
    icon?: true
    color?: true
    isActive?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    name: string
    description: string
    category: $Enums.AchievementCategory
    rarity: $Enums.AchievementRarity
    requirements: JsonValue
    xpReward: number
    pointReward: number
    icon: string | null
    color: string | null
    isActive: boolean
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    rarity?: boolean
    requirements?: boolean
    xpReward?: boolean
    pointReward?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    userAchievements?: boolean | Achievement$userAchievementsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    rarity?: boolean
    requirements?: boolean
    xpReward?: boolean
    pointReward?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    rarity?: boolean
    requirements?: boolean
    xpReward?: boolean
    pointReward?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    rarity?: boolean
    requirements?: boolean
    xpReward?: boolean
    pointReward?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
  }

  export type AchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "rarity" | "requirements" | "xpReward" | "pointReward" | "icon" | "color" | "isActive", ExtArgs["result"]["achievement"]>
  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAchievements?: boolean | Achievement$userAchievementsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      userAchievements: Prisma.$UserAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      category: $Enums.AchievementCategory
      rarity: $Enums.AchievementRarity
      requirements: Prisma.JsonValue
      xpReward: number
      pointReward: number
      icon: string | null
      color: string | null
      isActive: boolean
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements and returns the data updated in the database.
     * @param {AchievementUpdateManyAndReturnArgs} args - Arguments to update many Achievements.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, AchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userAchievements<T extends Achievement$userAchievementsArgs<ExtArgs> = {}>(args?: Subset<T, Achievement$userAchievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly name: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly category: FieldRef<"Achievement", 'AchievementCategory'>
    readonly rarity: FieldRef<"Achievement", 'AchievementRarity'>
    readonly requirements: FieldRef<"Achievement", 'Json'>
    readonly xpReward: FieldRef<"Achievement", 'Int'>
    readonly pointReward: FieldRef<"Achievement", 'Int'>
    readonly icon: FieldRef<"Achievement", 'String'>
    readonly color: FieldRef<"Achievement", 'String'>
    readonly isActive: FieldRef<"Achievement", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement updateManyAndReturn
   */
  export type AchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to delete.
     */
    limit?: number
  }

  /**
   * Achievement.userAchievements
   */
  export type Achievement$userAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model UserAchievement
   */

  export type AggregateUserAchievement = {
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  export type UserAchievementAvgAggregateOutputType = {
    progress: number | null
  }

  export type UserAchievementSumAggregateOutputType = {
    progress: number | null
  }

  export type UserAchievementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    progress: number | null
    isUnlocked: boolean | null
    unlockedAt: Date | null
    createdAt: Date | null
  }

  export type UserAchievementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    progress: number | null
    isUnlocked: boolean | null
    unlockedAt: Date | null
    createdAt: Date | null
  }

  export type UserAchievementCountAggregateOutputType = {
    id: number
    userId: number
    achievementId: number
    progress: number
    isUnlocked: number
    unlockedAt: number
    createdAt: number
    _all: number
  }


  export type UserAchievementAvgAggregateInputType = {
    progress?: true
  }

  export type UserAchievementSumAggregateInputType = {
    progress?: true
  }

  export type UserAchievementMinAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    progress?: true
    isUnlocked?: true
    unlockedAt?: true
    createdAt?: true
  }

  export type UserAchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    progress?: true
    isUnlocked?: true
    unlockedAt?: true
    createdAt?: true
  }

  export type UserAchievementCountAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    progress?: true
    isUnlocked?: true
    unlockedAt?: true
    createdAt?: true
    _all?: true
  }

  export type UserAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievement to aggregate.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAchievements
    **/
    _count?: true | UserAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAchievementMaxAggregateInputType
  }

  export type GetUserAchievementAggregateType<T extends UserAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAchievement[P]>
      : GetScalarType<T[P], AggregateUserAchievement[P]>
  }




  export type UserAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithAggregationInput | UserAchievementOrderByWithAggregationInput[]
    by: UserAchievementScalarFieldEnum[] | UserAchievementScalarFieldEnum
    having?: UserAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAchievementCountAggregateInputType | true
    _avg?: UserAchievementAvgAggregateInputType
    _sum?: UserAchievementSumAggregateInputType
    _min?: UserAchievementMinAggregateInputType
    _max?: UserAchievementMaxAggregateInputType
  }

  export type UserAchievementGroupByOutputType = {
    id: string
    userId: string
    achievementId: string
    progress: number
    isUnlocked: boolean
    unlockedAt: Date | null
    createdAt: Date
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  type GetUserAchievementGroupByPayload<T extends UserAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
        }
      >
    >


  export type UserAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    progress?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    progress?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    progress?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    progress?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
  }

  export type UserAchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "achievementId" | "progress" | "isUnlocked" | "unlockedAt" | "createdAt", ExtArgs["result"]["userAchievement"]>
  export type UserAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }

  export type $UserAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAchievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      achievement: Prisma.$AchievementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      achievementId: string
      progress: number
      isUnlocked: boolean
      unlockedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["userAchievement"]>
    composites: {}
  }

  type UserAchievementGetPayload<S extends boolean | null | undefined | UserAchievementDefaultArgs> = $Result.GetResult<Prisma.$UserAchievementPayload, S>

  type UserAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserAchievementCountAggregateInputType | true
    }

  export interface UserAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAchievement'], meta: { name: 'UserAchievement' } }
    /**
     * Find zero or one UserAchievement that matches the filter.
     * @param {UserAchievementFindUniqueArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAchievementFindUniqueArgs>(args: SelectSubset<T, UserAchievementFindUniqueArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAchievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAchievementFindUniqueOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAchievementFindFirstArgs>(args?: SelectSubset<T, UserAchievementFindFirstArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany()
     * 
     * // Get first 10 UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAchievementFindManyArgs>(args?: SelectSubset<T, UserAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAchievement.
     * @param {UserAchievementCreateArgs} args - Arguments to create a UserAchievement.
     * @example
     * // Create one UserAchievement
     * const UserAchievement = await prisma.userAchievement.create({
     *   data: {
     *     // ... data to create a UserAchievement
     *   }
     * })
     * 
     */
    create<T extends UserAchievementCreateArgs>(args: SelectSubset<T, UserAchievementCreateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAchievements.
     * @param {UserAchievementCreateManyArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAchievementCreateManyArgs>(args?: SelectSubset<T, UserAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAchievements and returns the data saved in the database.
     * @param {UserAchievementCreateManyAndReturnArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAchievement.
     * @param {UserAchievementDeleteArgs} args - Arguments to delete one UserAchievement.
     * @example
     * // Delete one UserAchievement
     * const UserAchievement = await prisma.userAchievement.delete({
     *   where: {
     *     // ... filter to delete one UserAchievement
     *   }
     * })
     * 
     */
    delete<T extends UserAchievementDeleteArgs>(args: SelectSubset<T, UserAchievementDeleteArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAchievement.
     * @param {UserAchievementUpdateArgs} args - Arguments to update one UserAchievement.
     * @example
     * // Update one UserAchievement
     * const userAchievement = await prisma.userAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAchievementUpdateArgs>(args: SelectSubset<T, UserAchievementUpdateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAchievements.
     * @param {UserAchievementDeleteManyArgs} args - Arguments to filter UserAchievements to delete.
     * @example
     * // Delete a few UserAchievements
     * const { count } = await prisma.userAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAchievementDeleteManyArgs>(args?: SelectSubset<T, UserAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAchievementUpdateManyArgs>(args: SelectSubset<T, UserAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements and returns the data updated in the database.
     * @param {UserAchievementUpdateManyAndReturnArgs} args - Arguments to update many UserAchievements.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAchievement.
     * @param {UserAchievementUpsertArgs} args - Arguments to update or create a UserAchievement.
     * @example
     * // Update or create a UserAchievement
     * const userAchievement = await prisma.userAchievement.upsert({
     *   create: {
     *     // ... data to create a UserAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAchievement we want to update
     *   }
     * })
     */
    upsert<T extends UserAchievementUpsertArgs>(args: SelectSubset<T, UserAchievementUpsertArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementCountArgs} args - Arguments to filter UserAchievements to count.
     * @example
     * // Count the number of UserAchievements
     * const count = await prisma.userAchievement.count({
     *   where: {
     *     // ... the filter for the UserAchievements we want to count
     *   }
     * })
    **/
    count<T extends UserAchievementCountArgs>(
      args?: Subset<T, UserAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAchievementAggregateArgs>(args: Subset<T, UserAchievementAggregateArgs>): Prisma.PrismaPromise<GetUserAchievementAggregateType<T>>

    /**
     * Group by UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAchievementGroupByArgs['orderBy'] }
        : { orderBy?: UserAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAchievement model
   */
  readonly fields: UserAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    achievement<T extends AchievementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementDefaultArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAchievement model
   */
  interface UserAchievementFieldRefs {
    readonly id: FieldRef<"UserAchievement", 'String'>
    readonly userId: FieldRef<"UserAchievement", 'String'>
    readonly achievementId: FieldRef<"UserAchievement", 'String'>
    readonly progress: FieldRef<"UserAchievement", 'Float'>
    readonly isUnlocked: FieldRef<"UserAchievement", 'Boolean'>
    readonly unlockedAt: FieldRef<"UserAchievement", 'DateTime'>
    readonly createdAt: FieldRef<"UserAchievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAchievement findUnique
   */
  export type UserAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findUniqueOrThrow
   */
  export type UserAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findFirst
   */
  export type UserAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findFirstOrThrow
   */
  export type UserAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findMany
   */
  export type UserAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievements to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement create
   */
  export type UserAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAchievement.
     */
    data: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
  }

  /**
   * UserAchievement createMany
   */
  export type UserAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
  }

  /**
   * UserAchievement createManyAndReturn
   */
  export type UserAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement update
   */
  export type UserAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAchievement.
     */
    data: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
    /**
     * Choose, which UserAchievement to update.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement updateMany
   */
  export type UserAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to update.
     */
    limit?: number
  }

  /**
   * UserAchievement updateManyAndReturn
   */
  export type UserAchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement upsert
   */
  export type UserAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAchievement to update in case it exists.
     */
    where: UserAchievementWhereUniqueInput
    /**
     * In case the UserAchievement found by the `where` argument doesn't exist, create a new UserAchievement with this data.
     */
    create: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
    /**
     * In case the UserAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
  }

  /**
   * UserAchievement delete
   */
  export type UserAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter which UserAchievement to delete.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement deleteMany
   */
  export type UserAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievements to delete
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to delete.
     */
    limit?: number
  }

  /**
   * UserAchievement without action
   */
  export type UserAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
  }


  /**
   * Model Challenge
   */

  export type AggregateChallenge = {
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  export type ChallengeAvgAggregateOutputType = {
    duration: number | null
    xpReward: number | null
    pointReward: number | null
  }

  export type ChallengeSumAggregateOutputType = {
    duration: number | null
    xpReward: number | null
    pointReward: number | null
  }

  export type ChallengeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.ChallengeType | null
    difficulty: $Enums.ChallengeDifficulty | null
    duration: number | null
    xpReward: number | null
    pointReward: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
  }

  export type ChallengeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.ChallengeType | null
    difficulty: $Enums.ChallengeDifficulty | null
    duration: number | null
    xpReward: number | null
    pointReward: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
  }

  export type ChallengeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    difficulty: number
    requirements: number
    duration: number
    xpReward: number
    pointReward: number
    startDate: number
    endDate: number
    isActive: number
    _all: number
  }


  export type ChallengeAvgAggregateInputType = {
    duration?: true
    xpReward?: true
    pointReward?: true
  }

  export type ChallengeSumAggregateInputType = {
    duration?: true
    xpReward?: true
    pointReward?: true
  }

  export type ChallengeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    difficulty?: true
    duration?: true
    xpReward?: true
    pointReward?: true
    startDate?: true
    endDate?: true
    isActive?: true
  }

  export type ChallengeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    difficulty?: true
    duration?: true
    xpReward?: true
    pointReward?: true
    startDate?: true
    endDate?: true
    isActive?: true
  }

  export type ChallengeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    difficulty?: true
    requirements?: true
    duration?: true
    xpReward?: true
    pointReward?: true
    startDate?: true
    endDate?: true
    isActive?: true
    _all?: true
  }

  export type ChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenge to aggregate.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Challenges
    **/
    _count?: true | ChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeMaxAggregateInputType
  }

  export type GetChallengeAggregateType<T extends ChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallenge[P]>
      : GetScalarType<T[P], AggregateChallenge[P]>
  }




  export type ChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithAggregationInput | ChallengeOrderByWithAggregationInput[]
    by: ChallengeScalarFieldEnum[] | ChallengeScalarFieldEnum
    having?: ChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeCountAggregateInputType | true
    _avg?: ChallengeAvgAggregateInputType
    _sum?: ChallengeSumAggregateInputType
    _min?: ChallengeMinAggregateInputType
    _max?: ChallengeMaxAggregateInputType
  }

  export type ChallengeGroupByOutputType = {
    id: string
    name: string
    description: string
    type: $Enums.ChallengeType
    difficulty: $Enums.ChallengeDifficulty
    requirements: JsonValue
    duration: number
    xpReward: number
    pointReward: number
    startDate: Date | null
    endDate: Date | null
    isActive: boolean
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  type GetChallengeGroupByPayload<T extends ChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    difficulty?: boolean
    requirements?: boolean
    duration?: boolean
    xpReward?: boolean
    pointReward?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    userChallenges?: boolean | Challenge$userChallengesArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    difficulty?: boolean
    requirements?: boolean
    duration?: boolean
    xpReward?: boolean
    pointReward?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    difficulty?: boolean
    requirements?: boolean
    duration?: boolean
    xpReward?: boolean
    pointReward?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    difficulty?: boolean
    requirements?: boolean
    duration?: boolean
    xpReward?: boolean
    pointReward?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
  }

  export type ChallengeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "difficulty" | "requirements" | "duration" | "xpReward" | "pointReward" | "startDate" | "endDate" | "isActive", ExtArgs["result"]["challenge"]>
  export type ChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userChallenges?: boolean | Challenge$userChallengesArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChallengeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Challenge"
    objects: {
      userChallenges: Prisma.$UserChallengePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      type: $Enums.ChallengeType
      difficulty: $Enums.ChallengeDifficulty
      requirements: Prisma.JsonValue
      duration: number
      xpReward: number
      pointReward: number
      startDate: Date | null
      endDate: Date | null
      isActive: boolean
    }, ExtArgs["result"]["challenge"]>
    composites: {}
  }

  type ChallengeGetPayload<S extends boolean | null | undefined | ChallengeDefaultArgs> = $Result.GetResult<Prisma.$ChallengePayload, S>

  type ChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ChallengeCountAggregateInputType | true
    }

  export interface ChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Challenge'], meta: { name: 'Challenge' } }
    /**
     * Find zero or one Challenge that matches the filter.
     * @param {ChallengeFindUniqueArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeFindUniqueArgs>(args: SelectSubset<T, ChallengeFindUniqueArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Challenge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeFindUniqueOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Challenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeFindFirstArgs>(args?: SelectSubset<T, ChallengeFindFirstArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Challenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Challenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Challenges
     * const challenges = await prisma.challenge.findMany()
     * 
     * // Get first 10 Challenges
     * const challenges = await prisma.challenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeWithIdOnly = await prisma.challenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeFindManyArgs>(args?: SelectSubset<T, ChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Challenge.
     * @param {ChallengeCreateArgs} args - Arguments to create a Challenge.
     * @example
     * // Create one Challenge
     * const Challenge = await prisma.challenge.create({
     *   data: {
     *     // ... data to create a Challenge
     *   }
     * })
     * 
     */
    create<T extends ChallengeCreateArgs>(args: SelectSubset<T, ChallengeCreateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Challenges.
     * @param {ChallengeCreateManyArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeCreateManyArgs>(args?: SelectSubset<T, ChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Challenges and returns the data saved in the database.
     * @param {ChallengeCreateManyAndReturnArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Challenges and only return the `id`
     * const challengeWithIdOnly = await prisma.challenge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Challenge.
     * @param {ChallengeDeleteArgs} args - Arguments to delete one Challenge.
     * @example
     * // Delete one Challenge
     * const Challenge = await prisma.challenge.delete({
     *   where: {
     *     // ... filter to delete one Challenge
     *   }
     * })
     * 
     */
    delete<T extends ChallengeDeleteArgs>(args: SelectSubset<T, ChallengeDeleteArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Challenge.
     * @param {ChallengeUpdateArgs} args - Arguments to update one Challenge.
     * @example
     * // Update one Challenge
     * const challenge = await prisma.challenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeUpdateArgs>(args: SelectSubset<T, ChallengeUpdateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Challenges.
     * @param {ChallengeDeleteManyArgs} args - Arguments to filter Challenges to delete.
     * @example
     * // Delete a few Challenges
     * const { count } = await prisma.challenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeDeleteManyArgs>(args?: SelectSubset<T, ChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Challenges
     * const challenge = await prisma.challenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeUpdateManyArgs>(args: SelectSubset<T, ChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenges and returns the data updated in the database.
     * @param {ChallengeUpdateManyAndReturnArgs} args - Arguments to update many Challenges.
     * @example
     * // Update many Challenges
     * const challenge = await prisma.challenge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Challenges and only return the `id`
     * const challengeWithIdOnly = await prisma.challenge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Challenge.
     * @param {ChallengeUpsertArgs} args - Arguments to update or create a Challenge.
     * @example
     * // Update or create a Challenge
     * const challenge = await prisma.challenge.upsert({
     *   create: {
     *     // ... data to create a Challenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Challenge we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeUpsertArgs>(args: SelectSubset<T, ChallengeUpsertArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeCountArgs} args - Arguments to filter Challenges to count.
     * @example
     * // Count the number of Challenges
     * const count = await prisma.challenge.count({
     *   where: {
     *     // ... the filter for the Challenges we want to count
     *   }
     * })
    **/
    count<T extends ChallengeCountArgs>(
      args?: Subset<T, ChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeAggregateArgs>(args: Subset<T, ChallengeAggregateArgs>): Prisma.PrismaPromise<GetChallengeAggregateType<T>>

    /**
     * Group by Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Challenge model
   */
  readonly fields: ChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Challenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userChallenges<T extends Challenge$userChallengesArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$userChallengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Challenge model
   */
  interface ChallengeFieldRefs {
    readonly id: FieldRef<"Challenge", 'String'>
    readonly name: FieldRef<"Challenge", 'String'>
    readonly description: FieldRef<"Challenge", 'String'>
    readonly type: FieldRef<"Challenge", 'ChallengeType'>
    readonly difficulty: FieldRef<"Challenge", 'ChallengeDifficulty'>
    readonly requirements: FieldRef<"Challenge", 'Json'>
    readonly duration: FieldRef<"Challenge", 'Int'>
    readonly xpReward: FieldRef<"Challenge", 'Int'>
    readonly pointReward: FieldRef<"Challenge", 'Int'>
    readonly startDate: FieldRef<"Challenge", 'DateTime'>
    readonly endDate: FieldRef<"Challenge", 'DateTime'>
    readonly isActive: FieldRef<"Challenge", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Challenge findUnique
   */
  export type ChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findUniqueOrThrow
   */
  export type ChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findFirst
   */
  export type ChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findFirstOrThrow
   */
  export type ChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findMany
   */
  export type ChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenges to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge create
   */
  export type ChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a Challenge.
     */
    data: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
  }

  /**
   * Challenge createMany
   */
  export type ChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
  }

  /**
   * Challenge createManyAndReturn
   */
  export type ChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
  }

  /**
   * Challenge update
   */
  export type ChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a Challenge.
     */
    data: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
    /**
     * Choose, which Challenge to update.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge updateMany
   */
  export type ChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Challenges.
     */
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyInput>
    /**
     * Filter which Challenges to update
     */
    where?: ChallengeWhereInput
    /**
     * Limit how many Challenges to update.
     */
    limit?: number
  }

  /**
   * Challenge updateManyAndReturn
   */
  export type ChallengeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * The data used to update Challenges.
     */
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyInput>
    /**
     * Filter which Challenges to update
     */
    where?: ChallengeWhereInput
    /**
     * Limit how many Challenges to update.
     */
    limit?: number
  }

  /**
   * Challenge upsert
   */
  export type ChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the Challenge to update in case it exists.
     */
    where: ChallengeWhereUniqueInput
    /**
     * In case the Challenge found by the `where` argument doesn't exist, create a new Challenge with this data.
     */
    create: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
    /**
     * In case the Challenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
  }

  /**
   * Challenge delete
   */
  export type ChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter which Challenge to delete.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge deleteMany
   */
  export type ChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenges to delete
     */
    where?: ChallengeWhereInput
    /**
     * Limit how many Challenges to delete.
     */
    limit?: number
  }

  /**
   * Challenge.userChallenges
   */
  export type Challenge$userChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    where?: UserChallengeWhereInput
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    cursor?: UserChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserChallengeScalarFieldEnum | UserChallengeScalarFieldEnum[]
  }

  /**
   * Challenge without action
   */
  export type ChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
  }


  /**
   * Model UserChallenge
   */

  export type AggregateUserChallenge = {
    _count: UserChallengeCountAggregateOutputType | null
    _avg: UserChallengeAvgAggregateOutputType | null
    _sum: UserChallengeSumAggregateOutputType | null
    _min: UserChallengeMinAggregateOutputType | null
    _max: UserChallengeMaxAggregateOutputType | null
  }

  export type UserChallengeAvgAggregateOutputType = {
    progress: number | null
  }

  export type UserChallengeSumAggregateOutputType = {
    progress: number | null
  }

  export type UserChallengeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    challengeId: string | null
    progress: number | null
    isCompleted: boolean | null
    completedAt: Date | null
    startedAt: Date | null
  }

  export type UserChallengeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    challengeId: string | null
    progress: number | null
    isCompleted: boolean | null
    completedAt: Date | null
    startedAt: Date | null
  }

  export type UserChallengeCountAggregateOutputType = {
    id: number
    userId: number
    challengeId: number
    progress: number
    isCompleted: number
    completedAt: number
    startedAt: number
    data: number
    _all: number
  }


  export type UserChallengeAvgAggregateInputType = {
    progress?: true
  }

  export type UserChallengeSumAggregateInputType = {
    progress?: true
  }

  export type UserChallengeMinAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    progress?: true
    isCompleted?: true
    completedAt?: true
    startedAt?: true
  }

  export type UserChallengeMaxAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    progress?: true
    isCompleted?: true
    completedAt?: true
    startedAt?: true
  }

  export type UserChallengeCountAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    progress?: true
    isCompleted?: true
    completedAt?: true
    startedAt?: true
    data?: true
    _all?: true
  }

  export type UserChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserChallenge to aggregate.
     */
    where?: UserChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChallenges to fetch.
     */
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserChallenges
    **/
    _count?: true | UserChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserChallengeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserChallengeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserChallengeMaxAggregateInputType
  }

  export type GetUserChallengeAggregateType<T extends UserChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserChallenge[P]>
      : GetScalarType<T[P], AggregateUserChallenge[P]>
  }




  export type UserChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserChallengeWhereInput
    orderBy?: UserChallengeOrderByWithAggregationInput | UserChallengeOrderByWithAggregationInput[]
    by: UserChallengeScalarFieldEnum[] | UserChallengeScalarFieldEnum
    having?: UserChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserChallengeCountAggregateInputType | true
    _avg?: UserChallengeAvgAggregateInputType
    _sum?: UserChallengeSumAggregateInputType
    _min?: UserChallengeMinAggregateInputType
    _max?: UserChallengeMaxAggregateInputType
  }

  export type UserChallengeGroupByOutputType = {
    id: string
    userId: string
    challengeId: string
    progress: number
    isCompleted: boolean
    completedAt: Date | null
    startedAt: Date
    data: JsonValue | null
    _count: UserChallengeCountAggregateOutputType | null
    _avg: UserChallengeAvgAggregateOutputType | null
    _sum: UserChallengeSumAggregateOutputType | null
    _min: UserChallengeMinAggregateOutputType | null
    _max: UserChallengeMaxAggregateOutputType | null
  }

  type GetUserChallengeGroupByPayload<T extends UserChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], UserChallengeGroupByOutputType[P]>
        }
      >
    >


  export type UserChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    progress?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    startedAt?: boolean
    data?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userChallenge"]>

  export type UserChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    progress?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    startedAt?: boolean
    data?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userChallenge"]>

  export type UserChallengeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    progress?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    startedAt?: boolean
    data?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userChallenge"]>

  export type UserChallengeSelectScalar = {
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    progress?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    startedAt?: boolean
    data?: boolean
  }

  export type UserChallengeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "challengeId" | "progress" | "isCompleted" | "completedAt" | "startedAt" | "data", ExtArgs["result"]["userChallenge"]>
  export type UserChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type UserChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type UserChallengeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $UserChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserChallenge"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      challengeId: string
      progress: number
      isCompleted: boolean
      completedAt: Date | null
      startedAt: Date
      data: Prisma.JsonValue | null
    }, ExtArgs["result"]["userChallenge"]>
    composites: {}
  }

  type UserChallengeGetPayload<S extends boolean | null | undefined | UserChallengeDefaultArgs> = $Result.GetResult<Prisma.$UserChallengePayload, S>

  type UserChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserChallengeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserChallengeCountAggregateInputType | true
    }

  export interface UserChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserChallenge'], meta: { name: 'UserChallenge' } }
    /**
     * Find zero or one UserChallenge that matches the filter.
     * @param {UserChallengeFindUniqueArgs} args - Arguments to find a UserChallenge
     * @example
     * // Get one UserChallenge
     * const userChallenge = await prisma.userChallenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserChallengeFindUniqueArgs>(args: SelectSubset<T, UserChallengeFindUniqueArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserChallenge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserChallengeFindUniqueOrThrowArgs} args - Arguments to find a UserChallenge
     * @example
     * // Get one UserChallenge
     * const userChallenge = await prisma.userChallenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserChallenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeFindFirstArgs} args - Arguments to find a UserChallenge
     * @example
     * // Get one UserChallenge
     * const userChallenge = await prisma.userChallenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserChallengeFindFirstArgs>(args?: SelectSubset<T, UserChallengeFindFirstArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserChallenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeFindFirstOrThrowArgs} args - Arguments to find a UserChallenge
     * @example
     * // Get one UserChallenge
     * const userChallenge = await prisma.userChallenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserChallenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserChallenges
     * const userChallenges = await prisma.userChallenge.findMany()
     * 
     * // Get first 10 UserChallenges
     * const userChallenges = await prisma.userChallenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userChallengeWithIdOnly = await prisma.userChallenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserChallengeFindManyArgs>(args?: SelectSubset<T, UserChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserChallenge.
     * @param {UserChallengeCreateArgs} args - Arguments to create a UserChallenge.
     * @example
     * // Create one UserChallenge
     * const UserChallenge = await prisma.userChallenge.create({
     *   data: {
     *     // ... data to create a UserChallenge
     *   }
     * })
     * 
     */
    create<T extends UserChallengeCreateArgs>(args: SelectSubset<T, UserChallengeCreateArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserChallenges.
     * @param {UserChallengeCreateManyArgs} args - Arguments to create many UserChallenges.
     * @example
     * // Create many UserChallenges
     * const userChallenge = await prisma.userChallenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserChallengeCreateManyArgs>(args?: SelectSubset<T, UserChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserChallenges and returns the data saved in the database.
     * @param {UserChallengeCreateManyAndReturnArgs} args - Arguments to create many UserChallenges.
     * @example
     * // Create many UserChallenges
     * const userChallenge = await prisma.userChallenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserChallenges and only return the `id`
     * const userChallengeWithIdOnly = await prisma.userChallenge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserChallenge.
     * @param {UserChallengeDeleteArgs} args - Arguments to delete one UserChallenge.
     * @example
     * // Delete one UserChallenge
     * const UserChallenge = await prisma.userChallenge.delete({
     *   where: {
     *     // ... filter to delete one UserChallenge
     *   }
     * })
     * 
     */
    delete<T extends UserChallengeDeleteArgs>(args: SelectSubset<T, UserChallengeDeleteArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserChallenge.
     * @param {UserChallengeUpdateArgs} args - Arguments to update one UserChallenge.
     * @example
     * // Update one UserChallenge
     * const userChallenge = await prisma.userChallenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserChallengeUpdateArgs>(args: SelectSubset<T, UserChallengeUpdateArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserChallenges.
     * @param {UserChallengeDeleteManyArgs} args - Arguments to filter UserChallenges to delete.
     * @example
     * // Delete a few UserChallenges
     * const { count } = await prisma.userChallenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserChallengeDeleteManyArgs>(args?: SelectSubset<T, UserChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserChallenges
     * const userChallenge = await prisma.userChallenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserChallengeUpdateManyArgs>(args: SelectSubset<T, UserChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserChallenges and returns the data updated in the database.
     * @param {UserChallengeUpdateManyAndReturnArgs} args - Arguments to update many UserChallenges.
     * @example
     * // Update many UserChallenges
     * const userChallenge = await prisma.userChallenge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserChallenges and only return the `id`
     * const userChallengeWithIdOnly = await prisma.userChallenge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserChallengeUpdateManyAndReturnArgs>(args: SelectSubset<T, UserChallengeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserChallenge.
     * @param {UserChallengeUpsertArgs} args - Arguments to update or create a UserChallenge.
     * @example
     * // Update or create a UserChallenge
     * const userChallenge = await prisma.userChallenge.upsert({
     *   create: {
     *     // ... data to create a UserChallenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserChallenge we want to update
     *   }
     * })
     */
    upsert<T extends UserChallengeUpsertArgs>(args: SelectSubset<T, UserChallengeUpsertArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeCountArgs} args - Arguments to filter UserChallenges to count.
     * @example
     * // Count the number of UserChallenges
     * const count = await prisma.userChallenge.count({
     *   where: {
     *     // ... the filter for the UserChallenges we want to count
     *   }
     * })
    **/
    count<T extends UserChallengeCountArgs>(
      args?: Subset<T, UserChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserChallengeAggregateArgs>(args: Subset<T, UserChallengeAggregateArgs>): Prisma.PrismaPromise<GetUserChallengeAggregateType<T>>

    /**
     * Group by UserChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserChallengeGroupByArgs['orderBy'] }
        : { orderBy?: UserChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserChallenge model
   */
  readonly fields: UserChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserChallenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserChallenge model
   */
  interface UserChallengeFieldRefs {
    readonly id: FieldRef<"UserChallenge", 'String'>
    readonly userId: FieldRef<"UserChallenge", 'String'>
    readonly challengeId: FieldRef<"UserChallenge", 'String'>
    readonly progress: FieldRef<"UserChallenge", 'Float'>
    readonly isCompleted: FieldRef<"UserChallenge", 'Boolean'>
    readonly completedAt: FieldRef<"UserChallenge", 'DateTime'>
    readonly startedAt: FieldRef<"UserChallenge", 'DateTime'>
    readonly data: FieldRef<"UserChallenge", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * UserChallenge findUnique
   */
  export type UserChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter, which UserChallenge to fetch.
     */
    where: UserChallengeWhereUniqueInput
  }

  /**
   * UserChallenge findUniqueOrThrow
   */
  export type UserChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter, which UserChallenge to fetch.
     */
    where: UserChallengeWhereUniqueInput
  }

  /**
   * UserChallenge findFirst
   */
  export type UserChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter, which UserChallenge to fetch.
     */
    where?: UserChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChallenges to fetch.
     */
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserChallenges.
     */
    cursor?: UserChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserChallenges.
     */
    distinct?: UserChallengeScalarFieldEnum | UserChallengeScalarFieldEnum[]
  }

  /**
   * UserChallenge findFirstOrThrow
   */
  export type UserChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter, which UserChallenge to fetch.
     */
    where?: UserChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChallenges to fetch.
     */
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserChallenges.
     */
    cursor?: UserChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserChallenges.
     */
    distinct?: UserChallengeScalarFieldEnum | UserChallengeScalarFieldEnum[]
  }

  /**
   * UserChallenge findMany
   */
  export type UserChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter, which UserChallenges to fetch.
     */
    where?: UserChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChallenges to fetch.
     */
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserChallenges.
     */
    cursor?: UserChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChallenges.
     */
    skip?: number
    distinct?: UserChallengeScalarFieldEnum | UserChallengeScalarFieldEnum[]
  }

  /**
   * UserChallenge create
   */
  export type UserChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserChallenge.
     */
    data: XOR<UserChallengeCreateInput, UserChallengeUncheckedCreateInput>
  }

  /**
   * UserChallenge createMany
   */
  export type UserChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserChallenges.
     */
    data: UserChallengeCreateManyInput | UserChallengeCreateManyInput[]
  }

  /**
   * UserChallenge createManyAndReturn
   */
  export type UserChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * The data used to create many UserChallenges.
     */
    data: UserChallengeCreateManyInput | UserChallengeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserChallenge update
   */
  export type UserChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserChallenge.
     */
    data: XOR<UserChallengeUpdateInput, UserChallengeUncheckedUpdateInput>
    /**
     * Choose, which UserChallenge to update.
     */
    where: UserChallengeWhereUniqueInput
  }

  /**
   * UserChallenge updateMany
   */
  export type UserChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserChallenges.
     */
    data: XOR<UserChallengeUpdateManyMutationInput, UserChallengeUncheckedUpdateManyInput>
    /**
     * Filter which UserChallenges to update
     */
    where?: UserChallengeWhereInput
    /**
     * Limit how many UserChallenges to update.
     */
    limit?: number
  }

  /**
   * UserChallenge updateManyAndReturn
   */
  export type UserChallengeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * The data used to update UserChallenges.
     */
    data: XOR<UserChallengeUpdateManyMutationInput, UserChallengeUncheckedUpdateManyInput>
    /**
     * Filter which UserChallenges to update
     */
    where?: UserChallengeWhereInput
    /**
     * Limit how many UserChallenges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserChallenge upsert
   */
  export type UserChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserChallenge to update in case it exists.
     */
    where: UserChallengeWhereUniqueInput
    /**
     * In case the UserChallenge found by the `where` argument doesn't exist, create a new UserChallenge with this data.
     */
    create: XOR<UserChallengeCreateInput, UserChallengeUncheckedCreateInput>
    /**
     * In case the UserChallenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserChallengeUpdateInput, UserChallengeUncheckedUpdateInput>
  }

  /**
   * UserChallenge delete
   */
  export type UserChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter which UserChallenge to delete.
     */
    where: UserChallengeWhereUniqueInput
  }

  /**
   * UserChallenge deleteMany
   */
  export type UserChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserChallenges to delete
     */
    where?: UserChallengeWhereInput
    /**
     * Limit how many UserChallenges to delete.
     */
    limit?: number
  }

  /**
   * UserChallenge without action
   */
  export type UserChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
  }


  /**
   * Model UserActivity
   */

  export type AggregateUserActivity = {
    _count: UserActivityCountAggregateOutputType | null
    _avg: UserActivityAvgAggregateOutputType | null
    _sum: UserActivitySumAggregateOutputType | null
    _min: UserActivityMinAggregateOutputType | null
    _max: UserActivityMaxAggregateOutputType | null
  }

  export type UserActivityAvgAggregateOutputType = {
    xpEarned: number | null
    pointsEarned: number | null
  }

  export type UserActivitySumAggregateOutputType = {
    xpEarned: number | null
    pointsEarned: number | null
  }

  export type UserActivityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ActivityType | null
    description: string | null
    xpEarned: number | null
    pointsEarned: number | null
    timestamp: Date | null
  }

  export type UserActivityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ActivityType | null
    description: string | null
    xpEarned: number | null
    pointsEarned: number | null
    timestamp: Date | null
  }

  export type UserActivityCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    description: number
    xpEarned: number
    pointsEarned: number
    metadata: number
    timestamp: number
    _all: number
  }


  export type UserActivityAvgAggregateInputType = {
    xpEarned?: true
    pointsEarned?: true
  }

  export type UserActivitySumAggregateInputType = {
    xpEarned?: true
    pointsEarned?: true
  }

  export type UserActivityMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    description?: true
    xpEarned?: true
    pointsEarned?: true
    timestamp?: true
  }

  export type UserActivityMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    description?: true
    xpEarned?: true
    pointsEarned?: true
    timestamp?: true
  }

  export type UserActivityCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    description?: true
    xpEarned?: true
    pointsEarned?: true
    metadata?: true
    timestamp?: true
    _all?: true
  }

  export type UserActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserActivity to aggregate.
     */
    where?: UserActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivities to fetch.
     */
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserActivities
    **/
    _count?: true | UserActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserActivityMaxAggregateInputType
  }

  export type GetUserActivityAggregateType<T extends UserActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateUserActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserActivity[P]>
      : GetScalarType<T[P], AggregateUserActivity[P]>
  }




  export type UserActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserActivityWhereInput
    orderBy?: UserActivityOrderByWithAggregationInput | UserActivityOrderByWithAggregationInput[]
    by: UserActivityScalarFieldEnum[] | UserActivityScalarFieldEnum
    having?: UserActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserActivityCountAggregateInputType | true
    _avg?: UserActivityAvgAggregateInputType
    _sum?: UserActivitySumAggregateInputType
    _min?: UserActivityMinAggregateInputType
    _max?: UserActivityMaxAggregateInputType
  }

  export type UserActivityGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.ActivityType
    description: string
    xpEarned: number
    pointsEarned: number
    metadata: JsonValue | null
    timestamp: Date
    _count: UserActivityCountAggregateOutputType | null
    _avg: UserActivityAvgAggregateOutputType | null
    _sum: UserActivitySumAggregateOutputType | null
    _min: UserActivityMinAggregateOutputType | null
    _max: UserActivityMaxAggregateOutputType | null
  }

  type GetUserActivityGroupByPayload<T extends UserActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserActivityGroupByOutputType[P]>
            : GetScalarType<T[P], UserActivityGroupByOutputType[P]>
        }
      >
    >


  export type UserActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    description?: boolean
    xpEarned?: boolean
    pointsEarned?: boolean
    metadata?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userActivity"]>

  export type UserActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    description?: boolean
    xpEarned?: boolean
    pointsEarned?: boolean
    metadata?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userActivity"]>

  export type UserActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    description?: boolean
    xpEarned?: boolean
    pointsEarned?: boolean
    metadata?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userActivity"]>

  export type UserActivitySelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    description?: boolean
    xpEarned?: boolean
    pointsEarned?: boolean
    metadata?: boolean
    timestamp?: boolean
  }

  export type UserActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "description" | "xpEarned" | "pointsEarned" | "metadata" | "timestamp", ExtArgs["result"]["userActivity"]>
  export type UserActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserActivity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.ActivityType
      description: string
      xpEarned: number
      pointsEarned: number
      metadata: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["userActivity"]>
    composites: {}
  }

  type UserActivityGetPayload<S extends boolean | null | undefined | UserActivityDefaultArgs> = $Result.GetResult<Prisma.$UserActivityPayload, S>

  type UserActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserActivityCountAggregateInputType | true
    }

  export interface UserActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserActivity'], meta: { name: 'UserActivity' } }
    /**
     * Find zero or one UserActivity that matches the filter.
     * @param {UserActivityFindUniqueArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserActivityFindUniqueArgs>(args: SelectSubset<T, UserActivityFindUniqueArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserActivityFindUniqueOrThrowArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, UserActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityFindFirstArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserActivityFindFirstArgs>(args?: SelectSubset<T, UserActivityFindFirstArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityFindFirstOrThrowArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, UserActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserActivities
     * const userActivities = await prisma.userActivity.findMany()
     * 
     * // Get first 10 UserActivities
     * const userActivities = await prisma.userActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userActivityWithIdOnly = await prisma.userActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserActivityFindManyArgs>(args?: SelectSubset<T, UserActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserActivity.
     * @param {UserActivityCreateArgs} args - Arguments to create a UserActivity.
     * @example
     * // Create one UserActivity
     * const UserActivity = await prisma.userActivity.create({
     *   data: {
     *     // ... data to create a UserActivity
     *   }
     * })
     * 
     */
    create<T extends UserActivityCreateArgs>(args: SelectSubset<T, UserActivityCreateArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserActivities.
     * @param {UserActivityCreateManyArgs} args - Arguments to create many UserActivities.
     * @example
     * // Create many UserActivities
     * const userActivity = await prisma.userActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserActivityCreateManyArgs>(args?: SelectSubset<T, UserActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserActivities and returns the data saved in the database.
     * @param {UserActivityCreateManyAndReturnArgs} args - Arguments to create many UserActivities.
     * @example
     * // Create many UserActivities
     * const userActivity = await prisma.userActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserActivities and only return the `id`
     * const userActivityWithIdOnly = await prisma.userActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, UserActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserActivity.
     * @param {UserActivityDeleteArgs} args - Arguments to delete one UserActivity.
     * @example
     * // Delete one UserActivity
     * const UserActivity = await prisma.userActivity.delete({
     *   where: {
     *     // ... filter to delete one UserActivity
     *   }
     * })
     * 
     */
    delete<T extends UserActivityDeleteArgs>(args: SelectSubset<T, UserActivityDeleteArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserActivity.
     * @param {UserActivityUpdateArgs} args - Arguments to update one UserActivity.
     * @example
     * // Update one UserActivity
     * const userActivity = await prisma.userActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserActivityUpdateArgs>(args: SelectSubset<T, UserActivityUpdateArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserActivities.
     * @param {UserActivityDeleteManyArgs} args - Arguments to filter UserActivities to delete.
     * @example
     * // Delete a few UserActivities
     * const { count } = await prisma.userActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserActivityDeleteManyArgs>(args?: SelectSubset<T, UserActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserActivities
     * const userActivity = await prisma.userActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserActivityUpdateManyArgs>(args: SelectSubset<T, UserActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserActivities and returns the data updated in the database.
     * @param {UserActivityUpdateManyAndReturnArgs} args - Arguments to update many UserActivities.
     * @example
     * // Update many UserActivities
     * const userActivity = await prisma.userActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserActivities and only return the `id`
     * const userActivityWithIdOnly = await prisma.userActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, UserActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserActivity.
     * @param {UserActivityUpsertArgs} args - Arguments to update or create a UserActivity.
     * @example
     * // Update or create a UserActivity
     * const userActivity = await prisma.userActivity.upsert({
     *   create: {
     *     // ... data to create a UserActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserActivity we want to update
     *   }
     * })
     */
    upsert<T extends UserActivityUpsertArgs>(args: SelectSubset<T, UserActivityUpsertArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityCountArgs} args - Arguments to filter UserActivities to count.
     * @example
     * // Count the number of UserActivities
     * const count = await prisma.userActivity.count({
     *   where: {
     *     // ... the filter for the UserActivities we want to count
     *   }
     * })
    **/
    count<T extends UserActivityCountArgs>(
      args?: Subset<T, UserActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserActivityAggregateArgs>(args: Subset<T, UserActivityAggregateArgs>): Prisma.PrismaPromise<GetUserActivityAggregateType<T>>

    /**
     * Group by UserActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserActivityGroupByArgs['orderBy'] }
        : { orderBy?: UserActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserActivity model
   */
  readonly fields: UserActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserActivity model
   */
  interface UserActivityFieldRefs {
    readonly id: FieldRef<"UserActivity", 'String'>
    readonly userId: FieldRef<"UserActivity", 'String'>
    readonly type: FieldRef<"UserActivity", 'ActivityType'>
    readonly description: FieldRef<"UserActivity", 'String'>
    readonly xpEarned: FieldRef<"UserActivity", 'Int'>
    readonly pointsEarned: FieldRef<"UserActivity", 'Int'>
    readonly metadata: FieldRef<"UserActivity", 'Json'>
    readonly timestamp: FieldRef<"UserActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserActivity findUnique
   */
  export type UserActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter, which UserActivity to fetch.
     */
    where: UserActivityWhereUniqueInput
  }

  /**
   * UserActivity findUniqueOrThrow
   */
  export type UserActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter, which UserActivity to fetch.
     */
    where: UserActivityWhereUniqueInput
  }

  /**
   * UserActivity findFirst
   */
  export type UserActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter, which UserActivity to fetch.
     */
    where?: UserActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivities to fetch.
     */
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActivities.
     */
    cursor?: UserActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActivities.
     */
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * UserActivity findFirstOrThrow
   */
  export type UserActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter, which UserActivity to fetch.
     */
    where?: UserActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivities to fetch.
     */
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActivities.
     */
    cursor?: UserActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActivities.
     */
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * UserActivity findMany
   */
  export type UserActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter, which UserActivities to fetch.
     */
    where?: UserActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivities to fetch.
     */
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserActivities.
     */
    cursor?: UserActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivities.
     */
    skip?: number
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * UserActivity create
   */
  export type UserActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a UserActivity.
     */
    data: XOR<UserActivityCreateInput, UserActivityUncheckedCreateInput>
  }

  /**
   * UserActivity createMany
   */
  export type UserActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserActivities.
     */
    data: UserActivityCreateManyInput | UserActivityCreateManyInput[]
  }

  /**
   * UserActivity createManyAndReturn
   */
  export type UserActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * The data used to create many UserActivities.
     */
    data: UserActivityCreateManyInput | UserActivityCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserActivity update
   */
  export type UserActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a UserActivity.
     */
    data: XOR<UserActivityUpdateInput, UserActivityUncheckedUpdateInput>
    /**
     * Choose, which UserActivity to update.
     */
    where: UserActivityWhereUniqueInput
  }

  /**
   * UserActivity updateMany
   */
  export type UserActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserActivities.
     */
    data: XOR<UserActivityUpdateManyMutationInput, UserActivityUncheckedUpdateManyInput>
    /**
     * Filter which UserActivities to update
     */
    where?: UserActivityWhereInput
    /**
     * Limit how many UserActivities to update.
     */
    limit?: number
  }

  /**
   * UserActivity updateManyAndReturn
   */
  export type UserActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * The data used to update UserActivities.
     */
    data: XOR<UserActivityUpdateManyMutationInput, UserActivityUncheckedUpdateManyInput>
    /**
     * Filter which UserActivities to update
     */
    where?: UserActivityWhereInput
    /**
     * Limit how many UserActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserActivity upsert
   */
  export type UserActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the UserActivity to update in case it exists.
     */
    where: UserActivityWhereUniqueInput
    /**
     * In case the UserActivity found by the `where` argument doesn't exist, create a new UserActivity with this data.
     */
    create: XOR<UserActivityCreateInput, UserActivityUncheckedCreateInput>
    /**
     * In case the UserActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserActivityUpdateInput, UserActivityUncheckedUpdateInput>
  }

  /**
   * UserActivity delete
   */
  export type UserActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter which UserActivity to delete.
     */
    where: UserActivityWhereUniqueInput
  }

  /**
   * UserActivity deleteMany
   */
  export type UserActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserActivities to delete
     */
    where?: UserActivityWhereInput
    /**
     * Limit how many UserActivities to delete.
     */
    limit?: number
  }

  /**
   * UserActivity without action
   */
  export type UserActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
  }


  /**
   * Model JournalEntry
   */

  export type AggregateJournalEntry = {
    _count: JournalEntryCountAggregateOutputType | null
    _avg: JournalEntryAvgAggregateOutputType | null
    _sum: JournalEntrySumAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  export type JournalEntryAvgAggregateOutputType = {
    mood: number | null
    sentimentScore: number | null
    wordCount: number | null
  }

  export type JournalEntrySumAggregateOutputType = {
    mood: number | null
    sentimentScore: number | null
    wordCount: number | null
  }

  export type JournalEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    promptId: string | null
    promptText: string | null
    entryType: $Enums.JournalType | null
    encryptedContent: Uint8Array | null
    contentHash: string | null
    keyDerivationSalt: Uint8Array | null
    mood: number | null
    sentimentScore: number | null
    isPrivate: boolean | null
    shareWithTherapist: boolean | null
    wordCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    promptId: string | null
    promptText: string | null
    entryType: $Enums.JournalType | null
    encryptedContent: Uint8Array | null
    contentHash: string | null
    keyDerivationSalt: Uint8Array | null
    mood: number | null
    sentimentScore: number | null
    isPrivate: boolean | null
    shareWithTherapist: boolean | null
    wordCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalEntryCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    promptId: number
    promptText: number
    entryType: number
    encryptedContent: number
    contentHash: number
    keyDerivationSalt: number
    mood: number
    sentimentScore: number
    emotions: number
    tags: number
    isPrivate: number
    shareWithTherapist: number
    wordCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JournalEntryAvgAggregateInputType = {
    mood?: true
    sentimentScore?: true
    wordCount?: true
  }

  export type JournalEntrySumAggregateInputType = {
    mood?: true
    sentimentScore?: true
    wordCount?: true
  }

  export type JournalEntryMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    promptId?: true
    promptText?: true
    entryType?: true
    encryptedContent?: true
    contentHash?: true
    keyDerivationSalt?: true
    mood?: true
    sentimentScore?: true
    isPrivate?: true
    shareWithTherapist?: true
    wordCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    promptId?: true
    promptText?: true
    entryType?: true
    encryptedContent?: true
    contentHash?: true
    keyDerivationSalt?: true
    mood?: true
    sentimentScore?: true
    isPrivate?: true
    shareWithTherapist?: true
    wordCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalEntryCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    promptId?: true
    promptText?: true
    entryType?: true
    encryptedContent?: true
    contentHash?: true
    keyDerivationSalt?: true
    mood?: true
    sentimentScore?: true
    emotions?: true
    tags?: true
    isPrivate?: true
    shareWithTherapist?: true
    wordCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JournalEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntry to aggregate.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalEntries
    **/
    _count?: true | JournalEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalEntryMaxAggregateInputType
  }

  export type GetJournalEntryAggregateType<T extends JournalEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalEntry[P]>
      : GetScalarType<T[P], AggregateJournalEntry[P]>
  }




  export type JournalEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
    orderBy?: JournalEntryOrderByWithAggregationInput | JournalEntryOrderByWithAggregationInput[]
    by: JournalEntryScalarFieldEnum[] | JournalEntryScalarFieldEnum
    having?: JournalEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalEntryCountAggregateInputType | true
    _avg?: JournalEntryAvgAggregateInputType
    _sum?: JournalEntrySumAggregateInputType
    _min?: JournalEntryMinAggregateInputType
    _max?: JournalEntryMaxAggregateInputType
  }

  export type JournalEntryGroupByOutputType = {
    id: string
    userId: string
    title: string | null
    promptId: string | null
    promptText: string | null
    entryType: $Enums.JournalType
    encryptedContent: Uint8Array
    contentHash: string
    keyDerivationSalt: Uint8Array
    mood: number | null
    sentimentScore: number | null
    emotions: JsonValue | null
    tags: JsonValue | null
    isPrivate: boolean
    shareWithTherapist: boolean
    wordCount: number | null
    createdAt: Date
    updatedAt: Date
    _count: JournalEntryCountAggregateOutputType | null
    _avg: JournalEntryAvgAggregateOutputType | null
    _sum: JournalEntrySumAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  type GetJournalEntryGroupByPayload<T extends JournalEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
            : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
        }
      >
    >


  export type JournalEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    promptId?: boolean
    promptText?: boolean
    entryType?: boolean
    encryptedContent?: boolean
    contentHash?: boolean
    keyDerivationSalt?: boolean
    mood?: boolean
    sentimentScore?: boolean
    emotions?: boolean
    tags?: boolean
    isPrivate?: boolean
    shareWithTherapist?: boolean
    wordCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    promptId?: boolean
    promptText?: boolean
    entryType?: boolean
    encryptedContent?: boolean
    contentHash?: boolean
    keyDerivationSalt?: boolean
    mood?: boolean
    sentimentScore?: boolean
    emotions?: boolean
    tags?: boolean
    isPrivate?: boolean
    shareWithTherapist?: boolean
    wordCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    promptId?: boolean
    promptText?: boolean
    entryType?: boolean
    encryptedContent?: boolean
    contentHash?: boolean
    keyDerivationSalt?: boolean
    mood?: boolean
    sentimentScore?: boolean
    emotions?: boolean
    tags?: boolean
    isPrivate?: boolean
    shareWithTherapist?: boolean
    wordCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    promptId?: boolean
    promptText?: boolean
    entryType?: boolean
    encryptedContent?: boolean
    contentHash?: boolean
    keyDerivationSalt?: boolean
    mood?: boolean
    sentimentScore?: boolean
    emotions?: boolean
    tags?: boolean
    isPrivate?: boolean
    shareWithTherapist?: boolean
    wordCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JournalEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "promptId" | "promptText" | "entryType" | "encryptedContent" | "contentHash" | "keyDerivationSalt" | "mood" | "sentimentScore" | "emotions" | "tags" | "isPrivate" | "shareWithTherapist" | "wordCount" | "createdAt" | "updatedAt", ExtArgs["result"]["journalEntry"]>
  export type JournalEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JournalEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JournalEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $JournalEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string | null
      promptId: string | null
      promptText: string | null
      entryType: $Enums.JournalType
      encryptedContent: Uint8Array
      contentHash: string
      keyDerivationSalt: Uint8Array
      mood: number | null
      sentimentScore: number | null
      emotions: Prisma.JsonValue | null
      tags: Prisma.JsonValue | null
      isPrivate: boolean
      shareWithTherapist: boolean
      wordCount: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["journalEntry"]>
    composites: {}
  }

  type JournalEntryGetPayload<S extends boolean | null | undefined | JournalEntryDefaultArgs> = $Result.GetResult<Prisma.$JournalEntryPayload, S>

  type JournalEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: JournalEntryCountAggregateInputType | true
    }

  export interface JournalEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalEntry'], meta: { name: 'JournalEntry' } }
    /**
     * Find zero or one JournalEntry that matches the filter.
     * @param {JournalEntryFindUniqueArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalEntryFindUniqueArgs>(args: SelectSubset<T, JournalEntryFindUniqueArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalEntryFindUniqueOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalEntryFindFirstArgs>(args?: SelectSubset<T, JournalEntryFindFirstArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany()
     * 
     * // Get first 10 JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalEntryFindManyArgs>(args?: SelectSubset<T, JournalEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalEntry.
     * @param {JournalEntryCreateArgs} args - Arguments to create a JournalEntry.
     * @example
     * // Create one JournalEntry
     * const JournalEntry = await prisma.journalEntry.create({
     *   data: {
     *     // ... data to create a JournalEntry
     *   }
     * })
     * 
     */
    create<T extends JournalEntryCreateArgs>(args: SelectSubset<T, JournalEntryCreateArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalEntries.
     * @param {JournalEntryCreateManyArgs} args - Arguments to create many JournalEntries.
     * @example
     * // Create many JournalEntries
     * const journalEntry = await prisma.journalEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalEntryCreateManyArgs>(args?: SelectSubset<T, JournalEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalEntries and returns the data saved in the database.
     * @param {JournalEntryCreateManyAndReturnArgs} args - Arguments to create many JournalEntries.
     * @example
     * // Create many JournalEntries
     * const journalEntry = await prisma.journalEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalEntries and only return the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalEntry.
     * @param {JournalEntryDeleteArgs} args - Arguments to delete one JournalEntry.
     * @example
     * // Delete one JournalEntry
     * const JournalEntry = await prisma.journalEntry.delete({
     *   where: {
     *     // ... filter to delete one JournalEntry
     *   }
     * })
     * 
     */
    delete<T extends JournalEntryDeleteArgs>(args: SelectSubset<T, JournalEntryDeleteArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalEntry.
     * @param {JournalEntryUpdateArgs} args - Arguments to update one JournalEntry.
     * @example
     * // Update one JournalEntry
     * const journalEntry = await prisma.journalEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalEntryUpdateArgs>(args: SelectSubset<T, JournalEntryUpdateArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalEntries.
     * @param {JournalEntryDeleteManyArgs} args - Arguments to filter JournalEntries to delete.
     * @example
     * // Delete a few JournalEntries
     * const { count } = await prisma.journalEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalEntryDeleteManyArgs>(args?: SelectSubset<T, JournalEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalEntries
     * const journalEntry = await prisma.journalEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalEntryUpdateManyArgs>(args: SelectSubset<T, JournalEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalEntries and returns the data updated in the database.
     * @param {JournalEntryUpdateManyAndReturnArgs} args - Arguments to update many JournalEntries.
     * @example
     * // Update many JournalEntries
     * const journalEntry = await prisma.journalEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalEntries and only return the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalEntry.
     * @param {JournalEntryUpsertArgs} args - Arguments to update or create a JournalEntry.
     * @example
     * // Update or create a JournalEntry
     * const journalEntry = await prisma.journalEntry.upsert({
     *   create: {
     *     // ... data to create a JournalEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalEntry we want to update
     *   }
     * })
     */
    upsert<T extends JournalEntryUpsertArgs>(args: SelectSubset<T, JournalEntryUpsertArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryCountArgs} args - Arguments to filter JournalEntries to count.
     * @example
     * // Count the number of JournalEntries
     * const count = await prisma.journalEntry.count({
     *   where: {
     *     // ... the filter for the JournalEntries we want to count
     *   }
     * })
    **/
    count<T extends JournalEntryCountArgs>(
      args?: Subset<T, JournalEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalEntryAggregateArgs>(args: Subset<T, JournalEntryAggregateArgs>): Prisma.PrismaPromise<GetJournalEntryAggregateType<T>>

    /**
     * Group by JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalEntryGroupByArgs['orderBy'] }
        : { orderBy?: JournalEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalEntry model
   */
  readonly fields: JournalEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalEntry model
   */
  interface JournalEntryFieldRefs {
    readonly id: FieldRef<"JournalEntry", 'String'>
    readonly userId: FieldRef<"JournalEntry", 'String'>
    readonly title: FieldRef<"JournalEntry", 'String'>
    readonly promptId: FieldRef<"JournalEntry", 'String'>
    readonly promptText: FieldRef<"JournalEntry", 'String'>
    readonly entryType: FieldRef<"JournalEntry", 'JournalType'>
    readonly encryptedContent: FieldRef<"JournalEntry", 'Bytes'>
    readonly contentHash: FieldRef<"JournalEntry", 'String'>
    readonly keyDerivationSalt: FieldRef<"JournalEntry", 'Bytes'>
    readonly mood: FieldRef<"JournalEntry", 'Int'>
    readonly sentimentScore: FieldRef<"JournalEntry", 'Float'>
    readonly emotions: FieldRef<"JournalEntry", 'Json'>
    readonly tags: FieldRef<"JournalEntry", 'Json'>
    readonly isPrivate: FieldRef<"JournalEntry", 'Boolean'>
    readonly shareWithTherapist: FieldRef<"JournalEntry", 'Boolean'>
    readonly wordCount: FieldRef<"JournalEntry", 'Int'>
    readonly createdAt: FieldRef<"JournalEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"JournalEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JournalEntry findUnique
   */
  export type JournalEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry findUniqueOrThrow
   */
  export type JournalEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry findFirst
   */
  export type JournalEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry findFirstOrThrow
   */
  export type JournalEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry findMany
   */
  export type JournalEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntries to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry create
   */
  export type JournalEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalEntry.
     */
    data: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
  }

  /**
   * JournalEntry createMany
   */
  export type JournalEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalEntries.
     */
    data: JournalEntryCreateManyInput | JournalEntryCreateManyInput[]
  }

  /**
   * JournalEntry createManyAndReturn
   */
  export type JournalEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * The data used to create many JournalEntries.
     */
    data: JournalEntryCreateManyInput | JournalEntryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalEntry update
   */
  export type JournalEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalEntry.
     */
    data: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
    /**
     * Choose, which JournalEntry to update.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry updateMany
   */
  export type JournalEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalEntries.
     */
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyInput>
    /**
     * Filter which JournalEntries to update
     */
    where?: JournalEntryWhereInput
    /**
     * Limit how many JournalEntries to update.
     */
    limit?: number
  }

  /**
   * JournalEntry updateManyAndReturn
   */
  export type JournalEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * The data used to update JournalEntries.
     */
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyInput>
    /**
     * Filter which JournalEntries to update
     */
    where?: JournalEntryWhereInput
    /**
     * Limit how many JournalEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalEntry upsert
   */
  export type JournalEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalEntry to update in case it exists.
     */
    where: JournalEntryWhereUniqueInput
    /**
     * In case the JournalEntry found by the `where` argument doesn't exist, create a new JournalEntry with this data.
     */
    create: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
    /**
     * In case the JournalEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
  }

  /**
   * JournalEntry delete
   */
  export type JournalEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter which JournalEntry to delete.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry deleteMany
   */
  export type JournalEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntries to delete
     */
    where?: JournalEntryWhereInput
    /**
     * Limit how many JournalEntries to delete.
     */
    limit?: number
  }

  /**
   * JournalEntry without action
   */
  export type JournalEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
  }


  /**
   * Model BreathingExercise
   */

  export type AggregateBreathingExercise = {
    _count: BreathingExerciseCountAggregateOutputType | null
    _avg: BreathingExerciseAvgAggregateOutputType | null
    _sum: BreathingExerciseSumAggregateOutputType | null
    _min: BreathingExerciseMinAggregateOutputType | null
    _max: BreathingExerciseMaxAggregateOutputType | null
  }

  export type BreathingExerciseAvgAggregateOutputType = {
    inhaleSeconds: number | null
    holdSeconds: number | null
    exhaleSeconds: number | null
    pauseSeconds: number | null
    cyclesRecommended: number | null
  }

  export type BreathingExerciseSumAggregateOutputType = {
    inhaleSeconds: number | null
    holdSeconds: number | null
    exhaleSeconds: number | null
    pauseSeconds: number | null
    cyclesRecommended: number | null
  }

  export type BreathingExerciseMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    technique: $Enums.BreathingTechnique | null
    difficulty: $Enums.ExerciseDifficulty | null
    inhaleSeconds: number | null
    holdSeconds: number | null
    exhaleSeconds: number | null
    pauseSeconds: number | null
    cyclesRecommended: number | null
    visualGuideUrl: string | null
    audioGuideUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type BreathingExerciseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    technique: $Enums.BreathingTechnique | null
    difficulty: $Enums.ExerciseDifficulty | null
    inhaleSeconds: number | null
    holdSeconds: number | null
    exhaleSeconds: number | null
    pauseSeconds: number | null
    cyclesRecommended: number | null
    visualGuideUrl: string | null
    audioGuideUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type BreathingExerciseCountAggregateOutputType = {
    id: number
    name: number
    description: number
    technique: number
    difficulty: number
    inhaleSeconds: number
    holdSeconds: number
    exhaleSeconds: number
    pauseSeconds: number
    cyclesRecommended: number
    instructions: number
    visualGuideUrl: number
    audioGuideUrl: number
    benefits: number
    bestFor: number
    contraindications: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type BreathingExerciseAvgAggregateInputType = {
    inhaleSeconds?: true
    holdSeconds?: true
    exhaleSeconds?: true
    pauseSeconds?: true
    cyclesRecommended?: true
  }

  export type BreathingExerciseSumAggregateInputType = {
    inhaleSeconds?: true
    holdSeconds?: true
    exhaleSeconds?: true
    pauseSeconds?: true
    cyclesRecommended?: true
  }

  export type BreathingExerciseMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    technique?: true
    difficulty?: true
    inhaleSeconds?: true
    holdSeconds?: true
    exhaleSeconds?: true
    pauseSeconds?: true
    cyclesRecommended?: true
    visualGuideUrl?: true
    audioGuideUrl?: true
    isActive?: true
    createdAt?: true
  }

  export type BreathingExerciseMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    technique?: true
    difficulty?: true
    inhaleSeconds?: true
    holdSeconds?: true
    exhaleSeconds?: true
    pauseSeconds?: true
    cyclesRecommended?: true
    visualGuideUrl?: true
    audioGuideUrl?: true
    isActive?: true
    createdAt?: true
  }

  export type BreathingExerciseCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    technique?: true
    difficulty?: true
    inhaleSeconds?: true
    holdSeconds?: true
    exhaleSeconds?: true
    pauseSeconds?: true
    cyclesRecommended?: true
    instructions?: true
    visualGuideUrl?: true
    audioGuideUrl?: true
    benefits?: true
    bestFor?: true
    contraindications?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type BreathingExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreathingExercise to aggregate.
     */
    where?: BreathingExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreathingExercises to fetch.
     */
    orderBy?: BreathingExerciseOrderByWithRelationInput | BreathingExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BreathingExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreathingExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreathingExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BreathingExercises
    **/
    _count?: true | BreathingExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BreathingExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BreathingExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BreathingExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BreathingExerciseMaxAggregateInputType
  }

  export type GetBreathingExerciseAggregateType<T extends BreathingExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateBreathingExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBreathingExercise[P]>
      : GetScalarType<T[P], AggregateBreathingExercise[P]>
  }




  export type BreathingExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreathingExerciseWhereInput
    orderBy?: BreathingExerciseOrderByWithAggregationInput | BreathingExerciseOrderByWithAggregationInput[]
    by: BreathingExerciseScalarFieldEnum[] | BreathingExerciseScalarFieldEnum
    having?: BreathingExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BreathingExerciseCountAggregateInputType | true
    _avg?: BreathingExerciseAvgAggregateInputType
    _sum?: BreathingExerciseSumAggregateInputType
    _min?: BreathingExerciseMinAggregateInputType
    _max?: BreathingExerciseMaxAggregateInputType
  }

  export type BreathingExerciseGroupByOutputType = {
    id: string
    name: string
    description: string
    technique: $Enums.BreathingTechnique
    difficulty: $Enums.ExerciseDifficulty
    inhaleSeconds: number
    holdSeconds: number | null
    exhaleSeconds: number
    pauseSeconds: number | null
    cyclesRecommended: number
    instructions: JsonValue
    visualGuideUrl: string | null
    audioGuideUrl: string | null
    benefits: JsonValue
    bestFor: JsonValue
    contraindications: JsonValue | null
    isActive: boolean
    createdAt: Date
    _count: BreathingExerciseCountAggregateOutputType | null
    _avg: BreathingExerciseAvgAggregateOutputType | null
    _sum: BreathingExerciseSumAggregateOutputType | null
    _min: BreathingExerciseMinAggregateOutputType | null
    _max: BreathingExerciseMaxAggregateOutputType | null
  }

  type GetBreathingExerciseGroupByPayload<T extends BreathingExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BreathingExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BreathingExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BreathingExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], BreathingExerciseGroupByOutputType[P]>
        }
      >
    >


  export type BreathingExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    technique?: boolean
    difficulty?: boolean
    inhaleSeconds?: boolean
    holdSeconds?: boolean
    exhaleSeconds?: boolean
    pauseSeconds?: boolean
    cyclesRecommended?: boolean
    instructions?: boolean
    visualGuideUrl?: boolean
    audioGuideUrl?: boolean
    benefits?: boolean
    bestFor?: boolean
    contraindications?: boolean
    isActive?: boolean
    createdAt?: boolean
    sessions?: boolean | BreathingExercise$sessionsArgs<ExtArgs>
    _count?: boolean | BreathingExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breathingExercise"]>

  export type BreathingExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    technique?: boolean
    difficulty?: boolean
    inhaleSeconds?: boolean
    holdSeconds?: boolean
    exhaleSeconds?: boolean
    pauseSeconds?: boolean
    cyclesRecommended?: boolean
    instructions?: boolean
    visualGuideUrl?: boolean
    audioGuideUrl?: boolean
    benefits?: boolean
    bestFor?: boolean
    contraindications?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["breathingExercise"]>

  export type BreathingExerciseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    technique?: boolean
    difficulty?: boolean
    inhaleSeconds?: boolean
    holdSeconds?: boolean
    exhaleSeconds?: boolean
    pauseSeconds?: boolean
    cyclesRecommended?: boolean
    instructions?: boolean
    visualGuideUrl?: boolean
    audioGuideUrl?: boolean
    benefits?: boolean
    bestFor?: boolean
    contraindications?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["breathingExercise"]>

  export type BreathingExerciseSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    technique?: boolean
    difficulty?: boolean
    inhaleSeconds?: boolean
    holdSeconds?: boolean
    exhaleSeconds?: boolean
    pauseSeconds?: boolean
    cyclesRecommended?: boolean
    instructions?: boolean
    visualGuideUrl?: boolean
    audioGuideUrl?: boolean
    benefits?: boolean
    bestFor?: boolean
    contraindications?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type BreathingExerciseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "technique" | "difficulty" | "inhaleSeconds" | "holdSeconds" | "exhaleSeconds" | "pauseSeconds" | "cyclesRecommended" | "instructions" | "visualGuideUrl" | "audioGuideUrl" | "benefits" | "bestFor" | "contraindications" | "isActive" | "createdAt", ExtArgs["result"]["breathingExercise"]>
  export type BreathingExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | BreathingExercise$sessionsArgs<ExtArgs>
    _count?: boolean | BreathingExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BreathingExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BreathingExerciseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BreathingExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BreathingExercise"
    objects: {
      sessions: Prisma.$BreathingSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      technique: $Enums.BreathingTechnique
      difficulty: $Enums.ExerciseDifficulty
      inhaleSeconds: number
      holdSeconds: number | null
      exhaleSeconds: number
      pauseSeconds: number | null
      cyclesRecommended: number
      instructions: Prisma.JsonValue
      visualGuideUrl: string | null
      audioGuideUrl: string | null
      benefits: Prisma.JsonValue
      bestFor: Prisma.JsonValue
      contraindications: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["breathingExercise"]>
    composites: {}
  }

  type BreathingExerciseGetPayload<S extends boolean | null | undefined | BreathingExerciseDefaultArgs> = $Result.GetResult<Prisma.$BreathingExercisePayload, S>

  type BreathingExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BreathingExerciseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: BreathingExerciseCountAggregateInputType | true
    }

  export interface BreathingExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BreathingExercise'], meta: { name: 'BreathingExercise' } }
    /**
     * Find zero or one BreathingExercise that matches the filter.
     * @param {BreathingExerciseFindUniqueArgs} args - Arguments to find a BreathingExercise
     * @example
     * // Get one BreathingExercise
     * const breathingExercise = await prisma.breathingExercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BreathingExerciseFindUniqueArgs>(args: SelectSubset<T, BreathingExerciseFindUniqueArgs<ExtArgs>>): Prisma__BreathingExerciseClient<$Result.GetResult<Prisma.$BreathingExercisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BreathingExercise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BreathingExerciseFindUniqueOrThrowArgs} args - Arguments to find a BreathingExercise
     * @example
     * // Get one BreathingExercise
     * const breathingExercise = await prisma.breathingExercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BreathingExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, BreathingExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BreathingExerciseClient<$Result.GetResult<Prisma.$BreathingExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BreathingExercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreathingExerciseFindFirstArgs} args - Arguments to find a BreathingExercise
     * @example
     * // Get one BreathingExercise
     * const breathingExercise = await prisma.breathingExercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BreathingExerciseFindFirstArgs>(args?: SelectSubset<T, BreathingExerciseFindFirstArgs<ExtArgs>>): Prisma__BreathingExerciseClient<$Result.GetResult<Prisma.$BreathingExercisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BreathingExercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreathingExerciseFindFirstOrThrowArgs} args - Arguments to find a BreathingExercise
     * @example
     * // Get one BreathingExercise
     * const breathingExercise = await prisma.breathingExercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BreathingExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, BreathingExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__BreathingExerciseClient<$Result.GetResult<Prisma.$BreathingExercisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BreathingExercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreathingExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BreathingExercises
     * const breathingExercises = await prisma.breathingExercise.findMany()
     * 
     * // Get first 10 BreathingExercises
     * const breathingExercises = await prisma.breathingExercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const breathingExerciseWithIdOnly = await prisma.breathingExercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BreathingExerciseFindManyArgs>(args?: SelectSubset<T, BreathingExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreathingExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BreathingExercise.
     * @param {BreathingExerciseCreateArgs} args - Arguments to create a BreathingExercise.
     * @example
     * // Create one BreathingExercise
     * const BreathingExercise = await prisma.breathingExercise.create({
     *   data: {
     *     // ... data to create a BreathingExercise
     *   }
     * })
     * 
     */
    create<T extends BreathingExerciseCreateArgs>(args: SelectSubset<T, BreathingExerciseCreateArgs<ExtArgs>>): Prisma__BreathingExerciseClient<$Result.GetResult<Prisma.$BreathingExercisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BreathingExercises.
     * @param {BreathingExerciseCreateManyArgs} args - Arguments to create many BreathingExercises.
     * @example
     * // Create many BreathingExercises
     * const breathingExercise = await prisma.breathingExercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BreathingExerciseCreateManyArgs>(args?: SelectSubset<T, BreathingExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BreathingExercises and returns the data saved in the database.
     * @param {BreathingExerciseCreateManyAndReturnArgs} args - Arguments to create many BreathingExercises.
     * @example
     * // Create many BreathingExercises
     * const breathingExercise = await prisma.breathingExercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BreathingExercises and only return the `id`
     * const breathingExerciseWithIdOnly = await prisma.breathingExercise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BreathingExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, BreathingExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreathingExercisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BreathingExercise.
     * @param {BreathingExerciseDeleteArgs} args - Arguments to delete one BreathingExercise.
     * @example
     * // Delete one BreathingExercise
     * const BreathingExercise = await prisma.breathingExercise.delete({
     *   where: {
     *     // ... filter to delete one BreathingExercise
     *   }
     * })
     * 
     */
    delete<T extends BreathingExerciseDeleteArgs>(args: SelectSubset<T, BreathingExerciseDeleteArgs<ExtArgs>>): Prisma__BreathingExerciseClient<$Result.GetResult<Prisma.$BreathingExercisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BreathingExercise.
     * @param {BreathingExerciseUpdateArgs} args - Arguments to update one BreathingExercise.
     * @example
     * // Update one BreathingExercise
     * const breathingExercise = await prisma.breathingExercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BreathingExerciseUpdateArgs>(args: SelectSubset<T, BreathingExerciseUpdateArgs<ExtArgs>>): Prisma__BreathingExerciseClient<$Result.GetResult<Prisma.$BreathingExercisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BreathingExercises.
     * @param {BreathingExerciseDeleteManyArgs} args - Arguments to filter BreathingExercises to delete.
     * @example
     * // Delete a few BreathingExercises
     * const { count } = await prisma.breathingExercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BreathingExerciseDeleteManyArgs>(args?: SelectSubset<T, BreathingExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BreathingExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreathingExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BreathingExercises
     * const breathingExercise = await prisma.breathingExercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BreathingExerciseUpdateManyArgs>(args: SelectSubset<T, BreathingExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BreathingExercises and returns the data updated in the database.
     * @param {BreathingExerciseUpdateManyAndReturnArgs} args - Arguments to update many BreathingExercises.
     * @example
     * // Update many BreathingExercises
     * const breathingExercise = await prisma.breathingExercise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BreathingExercises and only return the `id`
     * const breathingExerciseWithIdOnly = await prisma.breathingExercise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BreathingExerciseUpdateManyAndReturnArgs>(args: SelectSubset<T, BreathingExerciseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreathingExercisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BreathingExercise.
     * @param {BreathingExerciseUpsertArgs} args - Arguments to update or create a BreathingExercise.
     * @example
     * // Update or create a BreathingExercise
     * const breathingExercise = await prisma.breathingExercise.upsert({
     *   create: {
     *     // ... data to create a BreathingExercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BreathingExercise we want to update
     *   }
     * })
     */
    upsert<T extends BreathingExerciseUpsertArgs>(args: SelectSubset<T, BreathingExerciseUpsertArgs<ExtArgs>>): Prisma__BreathingExerciseClient<$Result.GetResult<Prisma.$BreathingExercisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BreathingExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreathingExerciseCountArgs} args - Arguments to filter BreathingExercises to count.
     * @example
     * // Count the number of BreathingExercises
     * const count = await prisma.breathingExercise.count({
     *   where: {
     *     // ... the filter for the BreathingExercises we want to count
     *   }
     * })
    **/
    count<T extends BreathingExerciseCountArgs>(
      args?: Subset<T, BreathingExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BreathingExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BreathingExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreathingExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BreathingExerciseAggregateArgs>(args: Subset<T, BreathingExerciseAggregateArgs>): Prisma.PrismaPromise<GetBreathingExerciseAggregateType<T>>

    /**
     * Group by BreathingExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreathingExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BreathingExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BreathingExerciseGroupByArgs['orderBy'] }
        : { orderBy?: BreathingExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BreathingExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBreathingExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BreathingExercise model
   */
  readonly fields: BreathingExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BreathingExercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BreathingExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends BreathingExercise$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, BreathingExercise$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreathingSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BreathingExercise model
   */
  interface BreathingExerciseFieldRefs {
    readonly id: FieldRef<"BreathingExercise", 'String'>
    readonly name: FieldRef<"BreathingExercise", 'String'>
    readonly description: FieldRef<"BreathingExercise", 'String'>
    readonly technique: FieldRef<"BreathingExercise", 'BreathingTechnique'>
    readonly difficulty: FieldRef<"BreathingExercise", 'ExerciseDifficulty'>
    readonly inhaleSeconds: FieldRef<"BreathingExercise", 'Int'>
    readonly holdSeconds: FieldRef<"BreathingExercise", 'Int'>
    readonly exhaleSeconds: FieldRef<"BreathingExercise", 'Int'>
    readonly pauseSeconds: FieldRef<"BreathingExercise", 'Int'>
    readonly cyclesRecommended: FieldRef<"BreathingExercise", 'Int'>
    readonly instructions: FieldRef<"BreathingExercise", 'Json'>
    readonly visualGuideUrl: FieldRef<"BreathingExercise", 'String'>
    readonly audioGuideUrl: FieldRef<"BreathingExercise", 'String'>
    readonly benefits: FieldRef<"BreathingExercise", 'Json'>
    readonly bestFor: FieldRef<"BreathingExercise", 'Json'>
    readonly contraindications: FieldRef<"BreathingExercise", 'Json'>
    readonly isActive: FieldRef<"BreathingExercise", 'Boolean'>
    readonly createdAt: FieldRef<"BreathingExercise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BreathingExercise findUnique
   */
  export type BreathingExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingExercise
     */
    select?: BreathingExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingExercise
     */
    omit?: BreathingExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingExerciseInclude<ExtArgs> | null
    /**
     * Filter, which BreathingExercise to fetch.
     */
    where: BreathingExerciseWhereUniqueInput
  }

  /**
   * BreathingExercise findUniqueOrThrow
   */
  export type BreathingExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingExercise
     */
    select?: BreathingExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingExercise
     */
    omit?: BreathingExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingExerciseInclude<ExtArgs> | null
    /**
     * Filter, which BreathingExercise to fetch.
     */
    where: BreathingExerciseWhereUniqueInput
  }

  /**
   * BreathingExercise findFirst
   */
  export type BreathingExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingExercise
     */
    select?: BreathingExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingExercise
     */
    omit?: BreathingExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingExerciseInclude<ExtArgs> | null
    /**
     * Filter, which BreathingExercise to fetch.
     */
    where?: BreathingExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreathingExercises to fetch.
     */
    orderBy?: BreathingExerciseOrderByWithRelationInput | BreathingExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreathingExercises.
     */
    cursor?: BreathingExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreathingExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreathingExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreathingExercises.
     */
    distinct?: BreathingExerciseScalarFieldEnum | BreathingExerciseScalarFieldEnum[]
  }

  /**
   * BreathingExercise findFirstOrThrow
   */
  export type BreathingExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingExercise
     */
    select?: BreathingExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingExercise
     */
    omit?: BreathingExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingExerciseInclude<ExtArgs> | null
    /**
     * Filter, which BreathingExercise to fetch.
     */
    where?: BreathingExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreathingExercises to fetch.
     */
    orderBy?: BreathingExerciseOrderByWithRelationInput | BreathingExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreathingExercises.
     */
    cursor?: BreathingExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreathingExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreathingExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreathingExercises.
     */
    distinct?: BreathingExerciseScalarFieldEnum | BreathingExerciseScalarFieldEnum[]
  }

  /**
   * BreathingExercise findMany
   */
  export type BreathingExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingExercise
     */
    select?: BreathingExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingExercise
     */
    omit?: BreathingExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingExerciseInclude<ExtArgs> | null
    /**
     * Filter, which BreathingExercises to fetch.
     */
    where?: BreathingExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreathingExercises to fetch.
     */
    orderBy?: BreathingExerciseOrderByWithRelationInput | BreathingExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BreathingExercises.
     */
    cursor?: BreathingExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreathingExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreathingExercises.
     */
    skip?: number
    distinct?: BreathingExerciseScalarFieldEnum | BreathingExerciseScalarFieldEnum[]
  }

  /**
   * BreathingExercise create
   */
  export type BreathingExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingExercise
     */
    select?: BreathingExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingExercise
     */
    omit?: BreathingExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a BreathingExercise.
     */
    data: XOR<BreathingExerciseCreateInput, BreathingExerciseUncheckedCreateInput>
  }

  /**
   * BreathingExercise createMany
   */
  export type BreathingExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BreathingExercises.
     */
    data: BreathingExerciseCreateManyInput | BreathingExerciseCreateManyInput[]
  }

  /**
   * BreathingExercise createManyAndReturn
   */
  export type BreathingExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingExercise
     */
    select?: BreathingExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingExercise
     */
    omit?: BreathingExerciseOmit<ExtArgs> | null
    /**
     * The data used to create many BreathingExercises.
     */
    data: BreathingExerciseCreateManyInput | BreathingExerciseCreateManyInput[]
  }

  /**
   * BreathingExercise update
   */
  export type BreathingExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingExercise
     */
    select?: BreathingExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingExercise
     */
    omit?: BreathingExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a BreathingExercise.
     */
    data: XOR<BreathingExerciseUpdateInput, BreathingExerciseUncheckedUpdateInput>
    /**
     * Choose, which BreathingExercise to update.
     */
    where: BreathingExerciseWhereUniqueInput
  }

  /**
   * BreathingExercise updateMany
   */
  export type BreathingExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BreathingExercises.
     */
    data: XOR<BreathingExerciseUpdateManyMutationInput, BreathingExerciseUncheckedUpdateManyInput>
    /**
     * Filter which BreathingExercises to update
     */
    where?: BreathingExerciseWhereInput
    /**
     * Limit how many BreathingExercises to update.
     */
    limit?: number
  }

  /**
   * BreathingExercise updateManyAndReturn
   */
  export type BreathingExerciseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingExercise
     */
    select?: BreathingExerciseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingExercise
     */
    omit?: BreathingExerciseOmit<ExtArgs> | null
    /**
     * The data used to update BreathingExercises.
     */
    data: XOR<BreathingExerciseUpdateManyMutationInput, BreathingExerciseUncheckedUpdateManyInput>
    /**
     * Filter which BreathingExercises to update
     */
    where?: BreathingExerciseWhereInput
    /**
     * Limit how many BreathingExercises to update.
     */
    limit?: number
  }

  /**
   * BreathingExercise upsert
   */
  export type BreathingExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingExercise
     */
    select?: BreathingExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingExercise
     */
    omit?: BreathingExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the BreathingExercise to update in case it exists.
     */
    where: BreathingExerciseWhereUniqueInput
    /**
     * In case the BreathingExercise found by the `where` argument doesn't exist, create a new BreathingExercise with this data.
     */
    create: XOR<BreathingExerciseCreateInput, BreathingExerciseUncheckedCreateInput>
    /**
     * In case the BreathingExercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BreathingExerciseUpdateInput, BreathingExerciseUncheckedUpdateInput>
  }

  /**
   * BreathingExercise delete
   */
  export type BreathingExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingExercise
     */
    select?: BreathingExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingExercise
     */
    omit?: BreathingExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingExerciseInclude<ExtArgs> | null
    /**
     * Filter which BreathingExercise to delete.
     */
    where: BreathingExerciseWhereUniqueInput
  }

  /**
   * BreathingExercise deleteMany
   */
  export type BreathingExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreathingExercises to delete
     */
    where?: BreathingExerciseWhereInput
    /**
     * Limit how many BreathingExercises to delete.
     */
    limit?: number
  }

  /**
   * BreathingExercise.sessions
   */
  export type BreathingExercise$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingSession
     */
    select?: BreathingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingSession
     */
    omit?: BreathingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingSessionInclude<ExtArgs> | null
    where?: BreathingSessionWhereInput
    orderBy?: BreathingSessionOrderByWithRelationInput | BreathingSessionOrderByWithRelationInput[]
    cursor?: BreathingSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreathingSessionScalarFieldEnum | BreathingSessionScalarFieldEnum[]
  }

  /**
   * BreathingExercise without action
   */
  export type BreathingExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingExercise
     */
    select?: BreathingExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingExercise
     */
    omit?: BreathingExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingExerciseInclude<ExtArgs> | null
  }


  /**
   * Model BreathingSession
   */

  export type AggregateBreathingSession = {
    _count: BreathingSessionCountAggregateOutputType | null
    _avg: BreathingSessionAvgAggregateOutputType | null
    _sum: BreathingSessionSumAggregateOutputType | null
    _min: BreathingSessionMinAggregateOutputType | null
    _max: BreathingSessionMaxAggregateOutputType | null
  }

  export type BreathingSessionAvgAggregateOutputType = {
    duration: number | null
    cyclesCompleted: number | null
    moodBefore: number | null
    moodAfter: number | null
    anxietyBefore: number | null
    anxietyAfter: number | null
    averageBreathRate: number | null
    heartRateBefore: number | null
    heartRateAfter: number | null
    rating: number | null
  }

  export type BreathingSessionSumAggregateOutputType = {
    duration: number | null
    cyclesCompleted: number | null
    moodBefore: number | null
    moodAfter: number | null
    anxietyBefore: number | null
    anxietyAfter: number | null
    averageBreathRate: number | null
    heartRateBefore: number | null
    heartRateAfter: number | null
    rating: number | null
  }

  export type BreathingSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    exerciseId: string | null
    startedAt: Date | null
    completedAt: Date | null
    duration: number | null
    cyclesCompleted: number | null
    moodBefore: number | null
    moodAfter: number | null
    anxietyBefore: number | null
    anxietyAfter: number | null
    averageBreathRate: number | null
    heartRateBefore: number | null
    heartRateAfter: number | null
    wasHelpful: boolean | null
    rating: number | null
    notes: string | null
  }

  export type BreathingSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    exerciseId: string | null
    startedAt: Date | null
    completedAt: Date | null
    duration: number | null
    cyclesCompleted: number | null
    moodBefore: number | null
    moodAfter: number | null
    anxietyBefore: number | null
    anxietyAfter: number | null
    averageBreathRate: number | null
    heartRateBefore: number | null
    heartRateAfter: number | null
    wasHelpful: boolean | null
    rating: number | null
    notes: string | null
  }

  export type BreathingSessionCountAggregateOutputType = {
    id: number
    userId: number
    exerciseId: number
    startedAt: number
    completedAt: number
    duration: number
    cyclesCompleted: number
    moodBefore: number
    moodAfter: number
    anxietyBefore: number
    anxietyAfter: number
    averageBreathRate: number
    heartRateBefore: number
    heartRateAfter: number
    wasHelpful: number
    rating: number
    notes: number
    _all: number
  }


  export type BreathingSessionAvgAggregateInputType = {
    duration?: true
    cyclesCompleted?: true
    moodBefore?: true
    moodAfter?: true
    anxietyBefore?: true
    anxietyAfter?: true
    averageBreathRate?: true
    heartRateBefore?: true
    heartRateAfter?: true
    rating?: true
  }

  export type BreathingSessionSumAggregateInputType = {
    duration?: true
    cyclesCompleted?: true
    moodBefore?: true
    moodAfter?: true
    anxietyBefore?: true
    anxietyAfter?: true
    averageBreathRate?: true
    heartRateBefore?: true
    heartRateAfter?: true
    rating?: true
  }

  export type BreathingSessionMinAggregateInputType = {
    id?: true
    userId?: true
    exerciseId?: true
    startedAt?: true
    completedAt?: true
    duration?: true
    cyclesCompleted?: true
    moodBefore?: true
    moodAfter?: true
    anxietyBefore?: true
    anxietyAfter?: true
    averageBreathRate?: true
    heartRateBefore?: true
    heartRateAfter?: true
    wasHelpful?: true
    rating?: true
    notes?: true
  }

  export type BreathingSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    exerciseId?: true
    startedAt?: true
    completedAt?: true
    duration?: true
    cyclesCompleted?: true
    moodBefore?: true
    moodAfter?: true
    anxietyBefore?: true
    anxietyAfter?: true
    averageBreathRate?: true
    heartRateBefore?: true
    heartRateAfter?: true
    wasHelpful?: true
    rating?: true
    notes?: true
  }

  export type BreathingSessionCountAggregateInputType = {
    id?: true
    userId?: true
    exerciseId?: true
    startedAt?: true
    completedAt?: true
    duration?: true
    cyclesCompleted?: true
    moodBefore?: true
    moodAfter?: true
    anxietyBefore?: true
    anxietyAfter?: true
    averageBreathRate?: true
    heartRateBefore?: true
    heartRateAfter?: true
    wasHelpful?: true
    rating?: true
    notes?: true
    _all?: true
  }

  export type BreathingSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreathingSession to aggregate.
     */
    where?: BreathingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreathingSessions to fetch.
     */
    orderBy?: BreathingSessionOrderByWithRelationInput | BreathingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BreathingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreathingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreathingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BreathingSessions
    **/
    _count?: true | BreathingSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BreathingSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BreathingSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BreathingSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BreathingSessionMaxAggregateInputType
  }

  export type GetBreathingSessionAggregateType<T extends BreathingSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateBreathingSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBreathingSession[P]>
      : GetScalarType<T[P], AggregateBreathingSession[P]>
  }




  export type BreathingSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreathingSessionWhereInput
    orderBy?: BreathingSessionOrderByWithAggregationInput | BreathingSessionOrderByWithAggregationInput[]
    by: BreathingSessionScalarFieldEnum[] | BreathingSessionScalarFieldEnum
    having?: BreathingSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BreathingSessionCountAggregateInputType | true
    _avg?: BreathingSessionAvgAggregateInputType
    _sum?: BreathingSessionSumAggregateInputType
    _min?: BreathingSessionMinAggregateInputType
    _max?: BreathingSessionMaxAggregateInputType
  }

  export type BreathingSessionGroupByOutputType = {
    id: string
    userId: string
    exerciseId: string
    startedAt: Date
    completedAt: Date | null
    duration: number | null
    cyclesCompleted: number
    moodBefore: number | null
    moodAfter: number | null
    anxietyBefore: number | null
    anxietyAfter: number | null
    averageBreathRate: number | null
    heartRateBefore: number | null
    heartRateAfter: number | null
    wasHelpful: boolean | null
    rating: number | null
    notes: string | null
    _count: BreathingSessionCountAggregateOutputType | null
    _avg: BreathingSessionAvgAggregateOutputType | null
    _sum: BreathingSessionSumAggregateOutputType | null
    _min: BreathingSessionMinAggregateOutputType | null
    _max: BreathingSessionMaxAggregateOutputType | null
  }

  type GetBreathingSessionGroupByPayload<T extends BreathingSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BreathingSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BreathingSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BreathingSessionGroupByOutputType[P]>
            : GetScalarType<T[P], BreathingSessionGroupByOutputType[P]>
        }
      >
    >


  export type BreathingSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    exerciseId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    cyclesCompleted?: boolean
    moodBefore?: boolean
    moodAfter?: boolean
    anxietyBefore?: boolean
    anxietyAfter?: boolean
    averageBreathRate?: boolean
    heartRateBefore?: boolean
    heartRateAfter?: boolean
    wasHelpful?: boolean
    rating?: boolean
    notes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | BreathingExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breathingSession"]>

  export type BreathingSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    exerciseId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    cyclesCompleted?: boolean
    moodBefore?: boolean
    moodAfter?: boolean
    anxietyBefore?: boolean
    anxietyAfter?: boolean
    averageBreathRate?: boolean
    heartRateBefore?: boolean
    heartRateAfter?: boolean
    wasHelpful?: boolean
    rating?: boolean
    notes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | BreathingExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breathingSession"]>

  export type BreathingSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    exerciseId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    cyclesCompleted?: boolean
    moodBefore?: boolean
    moodAfter?: boolean
    anxietyBefore?: boolean
    anxietyAfter?: boolean
    averageBreathRate?: boolean
    heartRateBefore?: boolean
    heartRateAfter?: boolean
    wasHelpful?: boolean
    rating?: boolean
    notes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | BreathingExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breathingSession"]>

  export type BreathingSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    exerciseId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    cyclesCompleted?: boolean
    moodBefore?: boolean
    moodAfter?: boolean
    anxietyBefore?: boolean
    anxietyAfter?: boolean
    averageBreathRate?: boolean
    heartRateBefore?: boolean
    heartRateAfter?: boolean
    wasHelpful?: boolean
    rating?: boolean
    notes?: boolean
  }

  export type BreathingSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "exerciseId" | "startedAt" | "completedAt" | "duration" | "cyclesCompleted" | "moodBefore" | "moodAfter" | "anxietyBefore" | "anxietyAfter" | "averageBreathRate" | "heartRateBefore" | "heartRateAfter" | "wasHelpful" | "rating" | "notes", ExtArgs["result"]["breathingSession"]>
  export type BreathingSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | BreathingExerciseDefaultArgs<ExtArgs>
  }
  export type BreathingSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | BreathingExerciseDefaultArgs<ExtArgs>
  }
  export type BreathingSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | BreathingExerciseDefaultArgs<ExtArgs>
  }

  export type $BreathingSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BreathingSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      exercise: Prisma.$BreathingExercisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      exerciseId: string
      startedAt: Date
      completedAt: Date | null
      duration: number | null
      cyclesCompleted: number
      moodBefore: number | null
      moodAfter: number | null
      anxietyBefore: number | null
      anxietyAfter: number | null
      averageBreathRate: number | null
      heartRateBefore: number | null
      heartRateAfter: number | null
      wasHelpful: boolean | null
      rating: number | null
      notes: string | null
    }, ExtArgs["result"]["breathingSession"]>
    composites: {}
  }

  type BreathingSessionGetPayload<S extends boolean | null | undefined | BreathingSessionDefaultArgs> = $Result.GetResult<Prisma.$BreathingSessionPayload, S>

  type BreathingSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BreathingSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: BreathingSessionCountAggregateInputType | true
    }

  export interface BreathingSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BreathingSession'], meta: { name: 'BreathingSession' } }
    /**
     * Find zero or one BreathingSession that matches the filter.
     * @param {BreathingSessionFindUniqueArgs} args - Arguments to find a BreathingSession
     * @example
     * // Get one BreathingSession
     * const breathingSession = await prisma.breathingSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BreathingSessionFindUniqueArgs>(args: SelectSubset<T, BreathingSessionFindUniqueArgs<ExtArgs>>): Prisma__BreathingSessionClient<$Result.GetResult<Prisma.$BreathingSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BreathingSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BreathingSessionFindUniqueOrThrowArgs} args - Arguments to find a BreathingSession
     * @example
     * // Get one BreathingSession
     * const breathingSession = await prisma.breathingSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BreathingSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, BreathingSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BreathingSessionClient<$Result.GetResult<Prisma.$BreathingSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BreathingSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreathingSessionFindFirstArgs} args - Arguments to find a BreathingSession
     * @example
     * // Get one BreathingSession
     * const breathingSession = await prisma.breathingSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BreathingSessionFindFirstArgs>(args?: SelectSubset<T, BreathingSessionFindFirstArgs<ExtArgs>>): Prisma__BreathingSessionClient<$Result.GetResult<Prisma.$BreathingSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BreathingSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreathingSessionFindFirstOrThrowArgs} args - Arguments to find a BreathingSession
     * @example
     * // Get one BreathingSession
     * const breathingSession = await prisma.breathingSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BreathingSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, BreathingSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BreathingSessionClient<$Result.GetResult<Prisma.$BreathingSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BreathingSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreathingSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BreathingSessions
     * const breathingSessions = await prisma.breathingSession.findMany()
     * 
     * // Get first 10 BreathingSessions
     * const breathingSessions = await prisma.breathingSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const breathingSessionWithIdOnly = await prisma.breathingSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BreathingSessionFindManyArgs>(args?: SelectSubset<T, BreathingSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreathingSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BreathingSession.
     * @param {BreathingSessionCreateArgs} args - Arguments to create a BreathingSession.
     * @example
     * // Create one BreathingSession
     * const BreathingSession = await prisma.breathingSession.create({
     *   data: {
     *     // ... data to create a BreathingSession
     *   }
     * })
     * 
     */
    create<T extends BreathingSessionCreateArgs>(args: SelectSubset<T, BreathingSessionCreateArgs<ExtArgs>>): Prisma__BreathingSessionClient<$Result.GetResult<Prisma.$BreathingSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BreathingSessions.
     * @param {BreathingSessionCreateManyArgs} args - Arguments to create many BreathingSessions.
     * @example
     * // Create many BreathingSessions
     * const breathingSession = await prisma.breathingSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BreathingSessionCreateManyArgs>(args?: SelectSubset<T, BreathingSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BreathingSessions and returns the data saved in the database.
     * @param {BreathingSessionCreateManyAndReturnArgs} args - Arguments to create many BreathingSessions.
     * @example
     * // Create many BreathingSessions
     * const breathingSession = await prisma.breathingSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BreathingSessions and only return the `id`
     * const breathingSessionWithIdOnly = await prisma.breathingSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BreathingSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, BreathingSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreathingSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BreathingSession.
     * @param {BreathingSessionDeleteArgs} args - Arguments to delete one BreathingSession.
     * @example
     * // Delete one BreathingSession
     * const BreathingSession = await prisma.breathingSession.delete({
     *   where: {
     *     // ... filter to delete one BreathingSession
     *   }
     * })
     * 
     */
    delete<T extends BreathingSessionDeleteArgs>(args: SelectSubset<T, BreathingSessionDeleteArgs<ExtArgs>>): Prisma__BreathingSessionClient<$Result.GetResult<Prisma.$BreathingSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BreathingSession.
     * @param {BreathingSessionUpdateArgs} args - Arguments to update one BreathingSession.
     * @example
     * // Update one BreathingSession
     * const breathingSession = await prisma.breathingSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BreathingSessionUpdateArgs>(args: SelectSubset<T, BreathingSessionUpdateArgs<ExtArgs>>): Prisma__BreathingSessionClient<$Result.GetResult<Prisma.$BreathingSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BreathingSessions.
     * @param {BreathingSessionDeleteManyArgs} args - Arguments to filter BreathingSessions to delete.
     * @example
     * // Delete a few BreathingSessions
     * const { count } = await prisma.breathingSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BreathingSessionDeleteManyArgs>(args?: SelectSubset<T, BreathingSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BreathingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreathingSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BreathingSessions
     * const breathingSession = await prisma.breathingSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BreathingSessionUpdateManyArgs>(args: SelectSubset<T, BreathingSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BreathingSessions and returns the data updated in the database.
     * @param {BreathingSessionUpdateManyAndReturnArgs} args - Arguments to update many BreathingSessions.
     * @example
     * // Update many BreathingSessions
     * const breathingSession = await prisma.breathingSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BreathingSessions and only return the `id`
     * const breathingSessionWithIdOnly = await prisma.breathingSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BreathingSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, BreathingSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreathingSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BreathingSession.
     * @param {BreathingSessionUpsertArgs} args - Arguments to update or create a BreathingSession.
     * @example
     * // Update or create a BreathingSession
     * const breathingSession = await prisma.breathingSession.upsert({
     *   create: {
     *     // ... data to create a BreathingSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BreathingSession we want to update
     *   }
     * })
     */
    upsert<T extends BreathingSessionUpsertArgs>(args: SelectSubset<T, BreathingSessionUpsertArgs<ExtArgs>>): Prisma__BreathingSessionClient<$Result.GetResult<Prisma.$BreathingSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BreathingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreathingSessionCountArgs} args - Arguments to filter BreathingSessions to count.
     * @example
     * // Count the number of BreathingSessions
     * const count = await prisma.breathingSession.count({
     *   where: {
     *     // ... the filter for the BreathingSessions we want to count
     *   }
     * })
    **/
    count<T extends BreathingSessionCountArgs>(
      args?: Subset<T, BreathingSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BreathingSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BreathingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreathingSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BreathingSessionAggregateArgs>(args: Subset<T, BreathingSessionAggregateArgs>): Prisma.PrismaPromise<GetBreathingSessionAggregateType<T>>

    /**
     * Group by BreathingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreathingSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BreathingSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BreathingSessionGroupByArgs['orderBy'] }
        : { orderBy?: BreathingSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BreathingSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBreathingSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BreathingSession model
   */
  readonly fields: BreathingSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BreathingSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BreathingSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exercise<T extends BreathingExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BreathingExerciseDefaultArgs<ExtArgs>>): Prisma__BreathingExerciseClient<$Result.GetResult<Prisma.$BreathingExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BreathingSession model
   */
  interface BreathingSessionFieldRefs {
    readonly id: FieldRef<"BreathingSession", 'String'>
    readonly userId: FieldRef<"BreathingSession", 'String'>
    readonly exerciseId: FieldRef<"BreathingSession", 'String'>
    readonly startedAt: FieldRef<"BreathingSession", 'DateTime'>
    readonly completedAt: FieldRef<"BreathingSession", 'DateTime'>
    readonly duration: FieldRef<"BreathingSession", 'Int'>
    readonly cyclesCompleted: FieldRef<"BreathingSession", 'Int'>
    readonly moodBefore: FieldRef<"BreathingSession", 'Int'>
    readonly moodAfter: FieldRef<"BreathingSession", 'Int'>
    readonly anxietyBefore: FieldRef<"BreathingSession", 'Int'>
    readonly anxietyAfter: FieldRef<"BreathingSession", 'Int'>
    readonly averageBreathRate: FieldRef<"BreathingSession", 'Float'>
    readonly heartRateBefore: FieldRef<"BreathingSession", 'Int'>
    readonly heartRateAfter: FieldRef<"BreathingSession", 'Int'>
    readonly wasHelpful: FieldRef<"BreathingSession", 'Boolean'>
    readonly rating: FieldRef<"BreathingSession", 'Int'>
    readonly notes: FieldRef<"BreathingSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BreathingSession findUnique
   */
  export type BreathingSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingSession
     */
    select?: BreathingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingSession
     */
    omit?: BreathingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingSessionInclude<ExtArgs> | null
    /**
     * Filter, which BreathingSession to fetch.
     */
    where: BreathingSessionWhereUniqueInput
  }

  /**
   * BreathingSession findUniqueOrThrow
   */
  export type BreathingSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingSession
     */
    select?: BreathingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingSession
     */
    omit?: BreathingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingSessionInclude<ExtArgs> | null
    /**
     * Filter, which BreathingSession to fetch.
     */
    where: BreathingSessionWhereUniqueInput
  }

  /**
   * BreathingSession findFirst
   */
  export type BreathingSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingSession
     */
    select?: BreathingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingSession
     */
    omit?: BreathingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingSessionInclude<ExtArgs> | null
    /**
     * Filter, which BreathingSession to fetch.
     */
    where?: BreathingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreathingSessions to fetch.
     */
    orderBy?: BreathingSessionOrderByWithRelationInput | BreathingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreathingSessions.
     */
    cursor?: BreathingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreathingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreathingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreathingSessions.
     */
    distinct?: BreathingSessionScalarFieldEnum | BreathingSessionScalarFieldEnum[]
  }

  /**
   * BreathingSession findFirstOrThrow
   */
  export type BreathingSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingSession
     */
    select?: BreathingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingSession
     */
    omit?: BreathingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingSessionInclude<ExtArgs> | null
    /**
     * Filter, which BreathingSession to fetch.
     */
    where?: BreathingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreathingSessions to fetch.
     */
    orderBy?: BreathingSessionOrderByWithRelationInput | BreathingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreathingSessions.
     */
    cursor?: BreathingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreathingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreathingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreathingSessions.
     */
    distinct?: BreathingSessionScalarFieldEnum | BreathingSessionScalarFieldEnum[]
  }

  /**
   * BreathingSession findMany
   */
  export type BreathingSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingSession
     */
    select?: BreathingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingSession
     */
    omit?: BreathingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingSessionInclude<ExtArgs> | null
    /**
     * Filter, which BreathingSessions to fetch.
     */
    where?: BreathingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreathingSessions to fetch.
     */
    orderBy?: BreathingSessionOrderByWithRelationInput | BreathingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BreathingSessions.
     */
    cursor?: BreathingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreathingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreathingSessions.
     */
    skip?: number
    distinct?: BreathingSessionScalarFieldEnum | BreathingSessionScalarFieldEnum[]
  }

  /**
   * BreathingSession create
   */
  export type BreathingSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingSession
     */
    select?: BreathingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingSession
     */
    omit?: BreathingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a BreathingSession.
     */
    data: XOR<BreathingSessionCreateInput, BreathingSessionUncheckedCreateInput>
  }

  /**
   * BreathingSession createMany
   */
  export type BreathingSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BreathingSessions.
     */
    data: BreathingSessionCreateManyInput | BreathingSessionCreateManyInput[]
  }

  /**
   * BreathingSession createManyAndReturn
   */
  export type BreathingSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingSession
     */
    select?: BreathingSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingSession
     */
    omit?: BreathingSessionOmit<ExtArgs> | null
    /**
     * The data used to create many BreathingSessions.
     */
    data: BreathingSessionCreateManyInput | BreathingSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BreathingSession update
   */
  export type BreathingSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingSession
     */
    select?: BreathingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingSession
     */
    omit?: BreathingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a BreathingSession.
     */
    data: XOR<BreathingSessionUpdateInput, BreathingSessionUncheckedUpdateInput>
    /**
     * Choose, which BreathingSession to update.
     */
    where: BreathingSessionWhereUniqueInput
  }

  /**
   * BreathingSession updateMany
   */
  export type BreathingSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BreathingSessions.
     */
    data: XOR<BreathingSessionUpdateManyMutationInput, BreathingSessionUncheckedUpdateManyInput>
    /**
     * Filter which BreathingSessions to update
     */
    where?: BreathingSessionWhereInput
    /**
     * Limit how many BreathingSessions to update.
     */
    limit?: number
  }

  /**
   * BreathingSession updateManyAndReturn
   */
  export type BreathingSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingSession
     */
    select?: BreathingSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingSession
     */
    omit?: BreathingSessionOmit<ExtArgs> | null
    /**
     * The data used to update BreathingSessions.
     */
    data: XOR<BreathingSessionUpdateManyMutationInput, BreathingSessionUncheckedUpdateManyInput>
    /**
     * Filter which BreathingSessions to update
     */
    where?: BreathingSessionWhereInput
    /**
     * Limit how many BreathingSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BreathingSession upsert
   */
  export type BreathingSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingSession
     */
    select?: BreathingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingSession
     */
    omit?: BreathingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the BreathingSession to update in case it exists.
     */
    where: BreathingSessionWhereUniqueInput
    /**
     * In case the BreathingSession found by the `where` argument doesn't exist, create a new BreathingSession with this data.
     */
    create: XOR<BreathingSessionCreateInput, BreathingSessionUncheckedCreateInput>
    /**
     * In case the BreathingSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BreathingSessionUpdateInput, BreathingSessionUncheckedUpdateInput>
  }

  /**
   * BreathingSession delete
   */
  export type BreathingSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingSession
     */
    select?: BreathingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingSession
     */
    omit?: BreathingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingSessionInclude<ExtArgs> | null
    /**
     * Filter which BreathingSession to delete.
     */
    where: BreathingSessionWhereUniqueInput
  }

  /**
   * BreathingSession deleteMany
   */
  export type BreathingSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreathingSessions to delete
     */
    where?: BreathingSessionWhereInput
    /**
     * Limit how many BreathingSessions to delete.
     */
    limit?: number
  }

  /**
   * BreathingSession without action
   */
  export type BreathingSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreathingSession
     */
    select?: BreathingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreathingSession
     */
    omit?: BreathingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreathingSessionInclude<ExtArgs> | null
  }


  /**
   * Model GroundingTechnique
   */

  export type AggregateGroundingTechnique = {
    _count: GroundingTechniqueCountAggregateOutputType | null
    _avg: GroundingTechniqueAvgAggregateOutputType | null
    _sum: GroundingTechniqueSumAggregateOutputType | null
    _min: GroundingTechniqueMinAggregateOutputType | null
    _max: GroundingTechniqueMaxAggregateOutputType | null
  }

  export type GroundingTechniqueAvgAggregateOutputType = {
    duration: number | null
  }

  export type GroundingTechniqueSumAggregateOutputType = {
    duration: number | null
  }

  export type GroundingTechniqueMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.GroundingType | null
    category: $Enums.GroundingCategory | null
    duration: number | null
    audioGuideUrl: string | null
    videoGuideUrl: string | null
    evidenceLevel: $Enums.EvidenceLevel | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type GroundingTechniqueMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.GroundingType | null
    category: $Enums.GroundingCategory | null
    duration: number | null
    audioGuideUrl: string | null
    videoGuideUrl: string | null
    evidenceLevel: $Enums.EvidenceLevel | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type GroundingTechniqueCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    category: number
    instructions: number
    duration: number
    materials: number
    audioGuideUrl: number
    videoGuideUrl: number
    imageGuides: number
    evidenceLevel: number
    bestFor: number
    contraindications: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type GroundingTechniqueAvgAggregateInputType = {
    duration?: true
  }

  export type GroundingTechniqueSumAggregateInputType = {
    duration?: true
  }

  export type GroundingTechniqueMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    category?: true
    duration?: true
    audioGuideUrl?: true
    videoGuideUrl?: true
    evidenceLevel?: true
    isActive?: true
    createdAt?: true
  }

  export type GroundingTechniqueMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    category?: true
    duration?: true
    audioGuideUrl?: true
    videoGuideUrl?: true
    evidenceLevel?: true
    isActive?: true
    createdAt?: true
  }

  export type GroundingTechniqueCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    category?: true
    instructions?: true
    duration?: true
    materials?: true
    audioGuideUrl?: true
    videoGuideUrl?: true
    imageGuides?: true
    evidenceLevel?: true
    bestFor?: true
    contraindications?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type GroundingTechniqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroundingTechnique to aggregate.
     */
    where?: GroundingTechniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroundingTechniques to fetch.
     */
    orderBy?: GroundingTechniqueOrderByWithRelationInput | GroundingTechniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroundingTechniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroundingTechniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroundingTechniques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroundingTechniques
    **/
    _count?: true | GroundingTechniqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroundingTechniqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroundingTechniqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroundingTechniqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroundingTechniqueMaxAggregateInputType
  }

  export type GetGroundingTechniqueAggregateType<T extends GroundingTechniqueAggregateArgs> = {
        [P in keyof T & keyof AggregateGroundingTechnique]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroundingTechnique[P]>
      : GetScalarType<T[P], AggregateGroundingTechnique[P]>
  }




  export type GroundingTechniqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroundingTechniqueWhereInput
    orderBy?: GroundingTechniqueOrderByWithAggregationInput | GroundingTechniqueOrderByWithAggregationInput[]
    by: GroundingTechniqueScalarFieldEnum[] | GroundingTechniqueScalarFieldEnum
    having?: GroundingTechniqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroundingTechniqueCountAggregateInputType | true
    _avg?: GroundingTechniqueAvgAggregateInputType
    _sum?: GroundingTechniqueSumAggregateInputType
    _min?: GroundingTechniqueMinAggregateInputType
    _max?: GroundingTechniqueMaxAggregateInputType
  }

  export type GroundingTechniqueGroupByOutputType = {
    id: string
    name: string
    description: string
    type: $Enums.GroundingType
    category: $Enums.GroundingCategory
    instructions: JsonValue
    duration: number
    materials: JsonValue | null
    audioGuideUrl: string | null
    videoGuideUrl: string | null
    imageGuides: JsonValue | null
    evidenceLevel: $Enums.EvidenceLevel
    bestFor: JsonValue
    contraindications: JsonValue | null
    isActive: boolean
    createdAt: Date
    _count: GroundingTechniqueCountAggregateOutputType | null
    _avg: GroundingTechniqueAvgAggregateOutputType | null
    _sum: GroundingTechniqueSumAggregateOutputType | null
    _min: GroundingTechniqueMinAggregateOutputType | null
    _max: GroundingTechniqueMaxAggregateOutputType | null
  }

  type GetGroundingTechniqueGroupByPayload<T extends GroundingTechniqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroundingTechniqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroundingTechniqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroundingTechniqueGroupByOutputType[P]>
            : GetScalarType<T[P], GroundingTechniqueGroupByOutputType[P]>
        }
      >
    >


  export type GroundingTechniqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    instructions?: boolean
    duration?: boolean
    materials?: boolean
    audioGuideUrl?: boolean
    videoGuideUrl?: boolean
    imageGuides?: boolean
    evidenceLevel?: boolean
    bestFor?: boolean
    contraindications?: boolean
    isActive?: boolean
    createdAt?: boolean
    sessions?: boolean | GroundingTechnique$sessionsArgs<ExtArgs>
    _count?: boolean | GroundingTechniqueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groundingTechnique"]>

  export type GroundingTechniqueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    instructions?: boolean
    duration?: boolean
    materials?: boolean
    audioGuideUrl?: boolean
    videoGuideUrl?: boolean
    imageGuides?: boolean
    evidenceLevel?: boolean
    bestFor?: boolean
    contraindications?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["groundingTechnique"]>

  export type GroundingTechniqueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    instructions?: boolean
    duration?: boolean
    materials?: boolean
    audioGuideUrl?: boolean
    videoGuideUrl?: boolean
    imageGuides?: boolean
    evidenceLevel?: boolean
    bestFor?: boolean
    contraindications?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["groundingTechnique"]>

  export type GroundingTechniqueSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    instructions?: boolean
    duration?: boolean
    materials?: boolean
    audioGuideUrl?: boolean
    videoGuideUrl?: boolean
    imageGuides?: boolean
    evidenceLevel?: boolean
    bestFor?: boolean
    contraindications?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type GroundingTechniqueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "category" | "instructions" | "duration" | "materials" | "audioGuideUrl" | "videoGuideUrl" | "imageGuides" | "evidenceLevel" | "bestFor" | "contraindications" | "isActive" | "createdAt", ExtArgs["result"]["groundingTechnique"]>
  export type GroundingTechniqueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | GroundingTechnique$sessionsArgs<ExtArgs>
    _count?: boolean | GroundingTechniqueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroundingTechniqueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GroundingTechniqueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GroundingTechniquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroundingTechnique"
    objects: {
      sessions: Prisma.$GroundingSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      type: $Enums.GroundingType
      category: $Enums.GroundingCategory
      instructions: Prisma.JsonValue
      duration: number
      materials: Prisma.JsonValue | null
      audioGuideUrl: string | null
      videoGuideUrl: string | null
      imageGuides: Prisma.JsonValue | null
      evidenceLevel: $Enums.EvidenceLevel
      bestFor: Prisma.JsonValue
      contraindications: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["groundingTechnique"]>
    composites: {}
  }

  type GroundingTechniqueGetPayload<S extends boolean | null | undefined | GroundingTechniqueDefaultArgs> = $Result.GetResult<Prisma.$GroundingTechniquePayload, S>

  type GroundingTechniqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroundingTechniqueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: GroundingTechniqueCountAggregateInputType | true
    }

  export interface GroundingTechniqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroundingTechnique'], meta: { name: 'GroundingTechnique' } }
    /**
     * Find zero or one GroundingTechnique that matches the filter.
     * @param {GroundingTechniqueFindUniqueArgs} args - Arguments to find a GroundingTechnique
     * @example
     * // Get one GroundingTechnique
     * const groundingTechnique = await prisma.groundingTechnique.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroundingTechniqueFindUniqueArgs>(args: SelectSubset<T, GroundingTechniqueFindUniqueArgs<ExtArgs>>): Prisma__GroundingTechniqueClient<$Result.GetResult<Prisma.$GroundingTechniquePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroundingTechnique that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroundingTechniqueFindUniqueOrThrowArgs} args - Arguments to find a GroundingTechnique
     * @example
     * // Get one GroundingTechnique
     * const groundingTechnique = await prisma.groundingTechnique.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroundingTechniqueFindUniqueOrThrowArgs>(args: SelectSubset<T, GroundingTechniqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroundingTechniqueClient<$Result.GetResult<Prisma.$GroundingTechniquePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroundingTechnique that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundingTechniqueFindFirstArgs} args - Arguments to find a GroundingTechnique
     * @example
     * // Get one GroundingTechnique
     * const groundingTechnique = await prisma.groundingTechnique.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroundingTechniqueFindFirstArgs>(args?: SelectSubset<T, GroundingTechniqueFindFirstArgs<ExtArgs>>): Prisma__GroundingTechniqueClient<$Result.GetResult<Prisma.$GroundingTechniquePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroundingTechnique that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundingTechniqueFindFirstOrThrowArgs} args - Arguments to find a GroundingTechnique
     * @example
     * // Get one GroundingTechnique
     * const groundingTechnique = await prisma.groundingTechnique.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroundingTechniqueFindFirstOrThrowArgs>(args?: SelectSubset<T, GroundingTechniqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroundingTechniqueClient<$Result.GetResult<Prisma.$GroundingTechniquePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroundingTechniques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundingTechniqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroundingTechniques
     * const groundingTechniques = await prisma.groundingTechnique.findMany()
     * 
     * // Get first 10 GroundingTechniques
     * const groundingTechniques = await prisma.groundingTechnique.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groundingTechniqueWithIdOnly = await prisma.groundingTechnique.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroundingTechniqueFindManyArgs>(args?: SelectSubset<T, GroundingTechniqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroundingTechniquePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroundingTechnique.
     * @param {GroundingTechniqueCreateArgs} args - Arguments to create a GroundingTechnique.
     * @example
     * // Create one GroundingTechnique
     * const GroundingTechnique = await prisma.groundingTechnique.create({
     *   data: {
     *     // ... data to create a GroundingTechnique
     *   }
     * })
     * 
     */
    create<T extends GroundingTechniqueCreateArgs>(args: SelectSubset<T, GroundingTechniqueCreateArgs<ExtArgs>>): Prisma__GroundingTechniqueClient<$Result.GetResult<Prisma.$GroundingTechniquePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroundingTechniques.
     * @param {GroundingTechniqueCreateManyArgs} args - Arguments to create many GroundingTechniques.
     * @example
     * // Create many GroundingTechniques
     * const groundingTechnique = await prisma.groundingTechnique.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroundingTechniqueCreateManyArgs>(args?: SelectSubset<T, GroundingTechniqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroundingTechniques and returns the data saved in the database.
     * @param {GroundingTechniqueCreateManyAndReturnArgs} args - Arguments to create many GroundingTechniques.
     * @example
     * // Create many GroundingTechniques
     * const groundingTechnique = await prisma.groundingTechnique.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroundingTechniques and only return the `id`
     * const groundingTechniqueWithIdOnly = await prisma.groundingTechnique.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroundingTechniqueCreateManyAndReturnArgs>(args?: SelectSubset<T, GroundingTechniqueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroundingTechniquePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroundingTechnique.
     * @param {GroundingTechniqueDeleteArgs} args - Arguments to delete one GroundingTechnique.
     * @example
     * // Delete one GroundingTechnique
     * const GroundingTechnique = await prisma.groundingTechnique.delete({
     *   where: {
     *     // ... filter to delete one GroundingTechnique
     *   }
     * })
     * 
     */
    delete<T extends GroundingTechniqueDeleteArgs>(args: SelectSubset<T, GroundingTechniqueDeleteArgs<ExtArgs>>): Prisma__GroundingTechniqueClient<$Result.GetResult<Prisma.$GroundingTechniquePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroundingTechnique.
     * @param {GroundingTechniqueUpdateArgs} args - Arguments to update one GroundingTechnique.
     * @example
     * // Update one GroundingTechnique
     * const groundingTechnique = await prisma.groundingTechnique.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroundingTechniqueUpdateArgs>(args: SelectSubset<T, GroundingTechniqueUpdateArgs<ExtArgs>>): Prisma__GroundingTechniqueClient<$Result.GetResult<Prisma.$GroundingTechniquePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroundingTechniques.
     * @param {GroundingTechniqueDeleteManyArgs} args - Arguments to filter GroundingTechniques to delete.
     * @example
     * // Delete a few GroundingTechniques
     * const { count } = await prisma.groundingTechnique.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroundingTechniqueDeleteManyArgs>(args?: SelectSubset<T, GroundingTechniqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroundingTechniques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundingTechniqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroundingTechniques
     * const groundingTechnique = await prisma.groundingTechnique.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroundingTechniqueUpdateManyArgs>(args: SelectSubset<T, GroundingTechniqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroundingTechniques and returns the data updated in the database.
     * @param {GroundingTechniqueUpdateManyAndReturnArgs} args - Arguments to update many GroundingTechniques.
     * @example
     * // Update many GroundingTechniques
     * const groundingTechnique = await prisma.groundingTechnique.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroundingTechniques and only return the `id`
     * const groundingTechniqueWithIdOnly = await prisma.groundingTechnique.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroundingTechniqueUpdateManyAndReturnArgs>(args: SelectSubset<T, GroundingTechniqueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroundingTechniquePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroundingTechnique.
     * @param {GroundingTechniqueUpsertArgs} args - Arguments to update or create a GroundingTechnique.
     * @example
     * // Update or create a GroundingTechnique
     * const groundingTechnique = await prisma.groundingTechnique.upsert({
     *   create: {
     *     // ... data to create a GroundingTechnique
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroundingTechnique we want to update
     *   }
     * })
     */
    upsert<T extends GroundingTechniqueUpsertArgs>(args: SelectSubset<T, GroundingTechniqueUpsertArgs<ExtArgs>>): Prisma__GroundingTechniqueClient<$Result.GetResult<Prisma.$GroundingTechniquePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroundingTechniques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundingTechniqueCountArgs} args - Arguments to filter GroundingTechniques to count.
     * @example
     * // Count the number of GroundingTechniques
     * const count = await prisma.groundingTechnique.count({
     *   where: {
     *     // ... the filter for the GroundingTechniques we want to count
     *   }
     * })
    **/
    count<T extends GroundingTechniqueCountArgs>(
      args?: Subset<T, GroundingTechniqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroundingTechniqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroundingTechnique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundingTechniqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroundingTechniqueAggregateArgs>(args: Subset<T, GroundingTechniqueAggregateArgs>): Prisma.PrismaPromise<GetGroundingTechniqueAggregateType<T>>

    /**
     * Group by GroundingTechnique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundingTechniqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroundingTechniqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroundingTechniqueGroupByArgs['orderBy'] }
        : { orderBy?: GroundingTechniqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroundingTechniqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroundingTechniqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroundingTechnique model
   */
  readonly fields: GroundingTechniqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroundingTechnique.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroundingTechniqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends GroundingTechnique$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, GroundingTechnique$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroundingSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroundingTechnique model
   */
  interface GroundingTechniqueFieldRefs {
    readonly id: FieldRef<"GroundingTechnique", 'String'>
    readonly name: FieldRef<"GroundingTechnique", 'String'>
    readonly description: FieldRef<"GroundingTechnique", 'String'>
    readonly type: FieldRef<"GroundingTechnique", 'GroundingType'>
    readonly category: FieldRef<"GroundingTechnique", 'GroundingCategory'>
    readonly instructions: FieldRef<"GroundingTechnique", 'Json'>
    readonly duration: FieldRef<"GroundingTechnique", 'Int'>
    readonly materials: FieldRef<"GroundingTechnique", 'Json'>
    readonly audioGuideUrl: FieldRef<"GroundingTechnique", 'String'>
    readonly videoGuideUrl: FieldRef<"GroundingTechnique", 'String'>
    readonly imageGuides: FieldRef<"GroundingTechnique", 'Json'>
    readonly evidenceLevel: FieldRef<"GroundingTechnique", 'EvidenceLevel'>
    readonly bestFor: FieldRef<"GroundingTechnique", 'Json'>
    readonly contraindications: FieldRef<"GroundingTechnique", 'Json'>
    readonly isActive: FieldRef<"GroundingTechnique", 'Boolean'>
    readonly createdAt: FieldRef<"GroundingTechnique", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroundingTechnique findUnique
   */
  export type GroundingTechniqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingTechnique
     */
    select?: GroundingTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingTechnique
     */
    omit?: GroundingTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingTechniqueInclude<ExtArgs> | null
    /**
     * Filter, which GroundingTechnique to fetch.
     */
    where: GroundingTechniqueWhereUniqueInput
  }

  /**
   * GroundingTechnique findUniqueOrThrow
   */
  export type GroundingTechniqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingTechnique
     */
    select?: GroundingTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingTechnique
     */
    omit?: GroundingTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingTechniqueInclude<ExtArgs> | null
    /**
     * Filter, which GroundingTechnique to fetch.
     */
    where: GroundingTechniqueWhereUniqueInput
  }

  /**
   * GroundingTechnique findFirst
   */
  export type GroundingTechniqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingTechnique
     */
    select?: GroundingTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingTechnique
     */
    omit?: GroundingTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingTechniqueInclude<ExtArgs> | null
    /**
     * Filter, which GroundingTechnique to fetch.
     */
    where?: GroundingTechniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroundingTechniques to fetch.
     */
    orderBy?: GroundingTechniqueOrderByWithRelationInput | GroundingTechniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroundingTechniques.
     */
    cursor?: GroundingTechniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroundingTechniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroundingTechniques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroundingTechniques.
     */
    distinct?: GroundingTechniqueScalarFieldEnum | GroundingTechniqueScalarFieldEnum[]
  }

  /**
   * GroundingTechnique findFirstOrThrow
   */
  export type GroundingTechniqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingTechnique
     */
    select?: GroundingTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingTechnique
     */
    omit?: GroundingTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingTechniqueInclude<ExtArgs> | null
    /**
     * Filter, which GroundingTechnique to fetch.
     */
    where?: GroundingTechniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroundingTechniques to fetch.
     */
    orderBy?: GroundingTechniqueOrderByWithRelationInput | GroundingTechniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroundingTechniques.
     */
    cursor?: GroundingTechniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroundingTechniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroundingTechniques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroundingTechniques.
     */
    distinct?: GroundingTechniqueScalarFieldEnum | GroundingTechniqueScalarFieldEnum[]
  }

  /**
   * GroundingTechnique findMany
   */
  export type GroundingTechniqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingTechnique
     */
    select?: GroundingTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingTechnique
     */
    omit?: GroundingTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingTechniqueInclude<ExtArgs> | null
    /**
     * Filter, which GroundingTechniques to fetch.
     */
    where?: GroundingTechniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroundingTechniques to fetch.
     */
    orderBy?: GroundingTechniqueOrderByWithRelationInput | GroundingTechniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroundingTechniques.
     */
    cursor?: GroundingTechniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroundingTechniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroundingTechniques.
     */
    skip?: number
    distinct?: GroundingTechniqueScalarFieldEnum | GroundingTechniqueScalarFieldEnum[]
  }

  /**
   * GroundingTechnique create
   */
  export type GroundingTechniqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingTechnique
     */
    select?: GroundingTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingTechnique
     */
    omit?: GroundingTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingTechniqueInclude<ExtArgs> | null
    /**
     * The data needed to create a GroundingTechnique.
     */
    data: XOR<GroundingTechniqueCreateInput, GroundingTechniqueUncheckedCreateInput>
  }

  /**
   * GroundingTechnique createMany
   */
  export type GroundingTechniqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroundingTechniques.
     */
    data: GroundingTechniqueCreateManyInput | GroundingTechniqueCreateManyInput[]
  }

  /**
   * GroundingTechnique createManyAndReturn
   */
  export type GroundingTechniqueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingTechnique
     */
    select?: GroundingTechniqueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingTechnique
     */
    omit?: GroundingTechniqueOmit<ExtArgs> | null
    /**
     * The data used to create many GroundingTechniques.
     */
    data: GroundingTechniqueCreateManyInput | GroundingTechniqueCreateManyInput[]
  }

  /**
   * GroundingTechnique update
   */
  export type GroundingTechniqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingTechnique
     */
    select?: GroundingTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingTechnique
     */
    omit?: GroundingTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingTechniqueInclude<ExtArgs> | null
    /**
     * The data needed to update a GroundingTechnique.
     */
    data: XOR<GroundingTechniqueUpdateInput, GroundingTechniqueUncheckedUpdateInput>
    /**
     * Choose, which GroundingTechnique to update.
     */
    where: GroundingTechniqueWhereUniqueInput
  }

  /**
   * GroundingTechnique updateMany
   */
  export type GroundingTechniqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroundingTechniques.
     */
    data: XOR<GroundingTechniqueUpdateManyMutationInput, GroundingTechniqueUncheckedUpdateManyInput>
    /**
     * Filter which GroundingTechniques to update
     */
    where?: GroundingTechniqueWhereInput
    /**
     * Limit how many GroundingTechniques to update.
     */
    limit?: number
  }

  /**
   * GroundingTechnique updateManyAndReturn
   */
  export type GroundingTechniqueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingTechnique
     */
    select?: GroundingTechniqueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingTechnique
     */
    omit?: GroundingTechniqueOmit<ExtArgs> | null
    /**
     * The data used to update GroundingTechniques.
     */
    data: XOR<GroundingTechniqueUpdateManyMutationInput, GroundingTechniqueUncheckedUpdateManyInput>
    /**
     * Filter which GroundingTechniques to update
     */
    where?: GroundingTechniqueWhereInput
    /**
     * Limit how many GroundingTechniques to update.
     */
    limit?: number
  }

  /**
   * GroundingTechnique upsert
   */
  export type GroundingTechniqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingTechnique
     */
    select?: GroundingTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingTechnique
     */
    omit?: GroundingTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingTechniqueInclude<ExtArgs> | null
    /**
     * The filter to search for the GroundingTechnique to update in case it exists.
     */
    where: GroundingTechniqueWhereUniqueInput
    /**
     * In case the GroundingTechnique found by the `where` argument doesn't exist, create a new GroundingTechnique with this data.
     */
    create: XOR<GroundingTechniqueCreateInput, GroundingTechniqueUncheckedCreateInput>
    /**
     * In case the GroundingTechnique was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroundingTechniqueUpdateInput, GroundingTechniqueUncheckedUpdateInput>
  }

  /**
   * GroundingTechnique delete
   */
  export type GroundingTechniqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingTechnique
     */
    select?: GroundingTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingTechnique
     */
    omit?: GroundingTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingTechniqueInclude<ExtArgs> | null
    /**
     * Filter which GroundingTechnique to delete.
     */
    where: GroundingTechniqueWhereUniqueInput
  }

  /**
   * GroundingTechnique deleteMany
   */
  export type GroundingTechniqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroundingTechniques to delete
     */
    where?: GroundingTechniqueWhereInput
    /**
     * Limit how many GroundingTechniques to delete.
     */
    limit?: number
  }

  /**
   * GroundingTechnique.sessions
   */
  export type GroundingTechnique$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingSession
     */
    select?: GroundingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingSession
     */
    omit?: GroundingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingSessionInclude<ExtArgs> | null
    where?: GroundingSessionWhereInput
    orderBy?: GroundingSessionOrderByWithRelationInput | GroundingSessionOrderByWithRelationInput[]
    cursor?: GroundingSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroundingSessionScalarFieldEnum | GroundingSessionScalarFieldEnum[]
  }

  /**
   * GroundingTechnique without action
   */
  export type GroundingTechniqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingTechnique
     */
    select?: GroundingTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingTechnique
     */
    omit?: GroundingTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingTechniqueInclude<ExtArgs> | null
  }


  /**
   * Model GroundingSession
   */

  export type AggregateGroundingSession = {
    _count: GroundingSessionCountAggregateOutputType | null
    _avg: GroundingSessionAvgAggregateOutputType | null
    _sum: GroundingSessionSumAggregateOutputType | null
    _min: GroundingSessionMinAggregateOutputType | null
    _max: GroundingSessionMaxAggregateOutputType | null
  }

  export type GroundingSessionAvgAggregateOutputType = {
    duration: number | null
    severityBefore: number | null
    severityAfter: number | null
    panicBefore: number | null
    panicAfter: number | null
    dissociationBefore: number | null
    dissociationAfter: number | null
    completionRate: number | null
    rating: number | null
  }

  export type GroundingSessionSumAggregateOutputType = {
    duration: number | null
    severityBefore: number | null
    severityAfter: number | null
    panicBefore: number | null
    panicAfter: number | null
    dissociationBefore: number | null
    dissociationAfter: number | null
    completionRate: number | null
    rating: number | null
  }

  export type GroundingSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    techniqueId: string | null
    startedAt: Date | null
    completedAt: Date | null
    duration: number | null
    triggerType: string | null
    severityBefore: number | null
    severityAfter: number | null
    panicBefore: number | null
    panicAfter: number | null
    dissociationBefore: number | null
    dissociationAfter: number | null
    completionRate: number | null
    wasHelpful: boolean | null
    rating: number | null
    notes: string | null
    wouldUseAgain: boolean | null
  }

  export type GroundingSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    techniqueId: string | null
    startedAt: Date | null
    completedAt: Date | null
    duration: number | null
    triggerType: string | null
    severityBefore: number | null
    severityAfter: number | null
    panicBefore: number | null
    panicAfter: number | null
    dissociationBefore: number | null
    dissociationAfter: number | null
    completionRate: number | null
    wasHelpful: boolean | null
    rating: number | null
    notes: string | null
    wouldUseAgain: boolean | null
  }

  export type GroundingSessionCountAggregateOutputType = {
    id: number
    userId: number
    techniqueId: number
    startedAt: number
    completedAt: number
    duration: number
    triggerType: number
    severityBefore: number
    severityAfter: number
    panicBefore: number
    panicAfter: number
    dissociationBefore: number
    dissociationAfter: number
    stepsCompleted: number
    completionRate: number
    wasHelpful: number
    rating: number
    notes: number
    wouldUseAgain: number
    _all: number
  }


  export type GroundingSessionAvgAggregateInputType = {
    duration?: true
    severityBefore?: true
    severityAfter?: true
    panicBefore?: true
    panicAfter?: true
    dissociationBefore?: true
    dissociationAfter?: true
    completionRate?: true
    rating?: true
  }

  export type GroundingSessionSumAggregateInputType = {
    duration?: true
    severityBefore?: true
    severityAfter?: true
    panicBefore?: true
    panicAfter?: true
    dissociationBefore?: true
    dissociationAfter?: true
    completionRate?: true
    rating?: true
  }

  export type GroundingSessionMinAggregateInputType = {
    id?: true
    userId?: true
    techniqueId?: true
    startedAt?: true
    completedAt?: true
    duration?: true
    triggerType?: true
    severityBefore?: true
    severityAfter?: true
    panicBefore?: true
    panicAfter?: true
    dissociationBefore?: true
    dissociationAfter?: true
    completionRate?: true
    wasHelpful?: true
    rating?: true
    notes?: true
    wouldUseAgain?: true
  }

  export type GroundingSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    techniqueId?: true
    startedAt?: true
    completedAt?: true
    duration?: true
    triggerType?: true
    severityBefore?: true
    severityAfter?: true
    panicBefore?: true
    panicAfter?: true
    dissociationBefore?: true
    dissociationAfter?: true
    completionRate?: true
    wasHelpful?: true
    rating?: true
    notes?: true
    wouldUseAgain?: true
  }

  export type GroundingSessionCountAggregateInputType = {
    id?: true
    userId?: true
    techniqueId?: true
    startedAt?: true
    completedAt?: true
    duration?: true
    triggerType?: true
    severityBefore?: true
    severityAfter?: true
    panicBefore?: true
    panicAfter?: true
    dissociationBefore?: true
    dissociationAfter?: true
    stepsCompleted?: true
    completionRate?: true
    wasHelpful?: true
    rating?: true
    notes?: true
    wouldUseAgain?: true
    _all?: true
  }

  export type GroundingSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroundingSession to aggregate.
     */
    where?: GroundingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroundingSessions to fetch.
     */
    orderBy?: GroundingSessionOrderByWithRelationInput | GroundingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroundingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroundingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroundingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroundingSessions
    **/
    _count?: true | GroundingSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroundingSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroundingSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroundingSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroundingSessionMaxAggregateInputType
  }

  export type GetGroundingSessionAggregateType<T extends GroundingSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateGroundingSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroundingSession[P]>
      : GetScalarType<T[P], AggregateGroundingSession[P]>
  }




  export type GroundingSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroundingSessionWhereInput
    orderBy?: GroundingSessionOrderByWithAggregationInput | GroundingSessionOrderByWithAggregationInput[]
    by: GroundingSessionScalarFieldEnum[] | GroundingSessionScalarFieldEnum
    having?: GroundingSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroundingSessionCountAggregateInputType | true
    _avg?: GroundingSessionAvgAggregateInputType
    _sum?: GroundingSessionSumAggregateInputType
    _min?: GroundingSessionMinAggregateInputType
    _max?: GroundingSessionMaxAggregateInputType
  }

  export type GroundingSessionGroupByOutputType = {
    id: string
    userId: string
    techniqueId: string
    startedAt: Date
    completedAt: Date | null
    duration: number | null
    triggerType: string | null
    severityBefore: number | null
    severityAfter: number | null
    panicBefore: number | null
    panicAfter: number | null
    dissociationBefore: number | null
    dissociationAfter: number | null
    stepsCompleted: JsonValue | null
    completionRate: number | null
    wasHelpful: boolean | null
    rating: number | null
    notes: string | null
    wouldUseAgain: boolean | null
    _count: GroundingSessionCountAggregateOutputType | null
    _avg: GroundingSessionAvgAggregateOutputType | null
    _sum: GroundingSessionSumAggregateOutputType | null
    _min: GroundingSessionMinAggregateOutputType | null
    _max: GroundingSessionMaxAggregateOutputType | null
  }

  type GetGroundingSessionGroupByPayload<T extends GroundingSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroundingSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroundingSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroundingSessionGroupByOutputType[P]>
            : GetScalarType<T[P], GroundingSessionGroupByOutputType[P]>
        }
      >
    >


  export type GroundingSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    techniqueId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    triggerType?: boolean
    severityBefore?: boolean
    severityAfter?: boolean
    panicBefore?: boolean
    panicAfter?: boolean
    dissociationBefore?: boolean
    dissociationAfter?: boolean
    stepsCompleted?: boolean
    completionRate?: boolean
    wasHelpful?: boolean
    rating?: boolean
    notes?: boolean
    wouldUseAgain?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    technique?: boolean | GroundingTechniqueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groundingSession"]>

  export type GroundingSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    techniqueId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    triggerType?: boolean
    severityBefore?: boolean
    severityAfter?: boolean
    panicBefore?: boolean
    panicAfter?: boolean
    dissociationBefore?: boolean
    dissociationAfter?: boolean
    stepsCompleted?: boolean
    completionRate?: boolean
    wasHelpful?: boolean
    rating?: boolean
    notes?: boolean
    wouldUseAgain?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    technique?: boolean | GroundingTechniqueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groundingSession"]>

  export type GroundingSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    techniqueId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    triggerType?: boolean
    severityBefore?: boolean
    severityAfter?: boolean
    panicBefore?: boolean
    panicAfter?: boolean
    dissociationBefore?: boolean
    dissociationAfter?: boolean
    stepsCompleted?: boolean
    completionRate?: boolean
    wasHelpful?: boolean
    rating?: boolean
    notes?: boolean
    wouldUseAgain?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    technique?: boolean | GroundingTechniqueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groundingSession"]>

  export type GroundingSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    techniqueId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    triggerType?: boolean
    severityBefore?: boolean
    severityAfter?: boolean
    panicBefore?: boolean
    panicAfter?: boolean
    dissociationBefore?: boolean
    dissociationAfter?: boolean
    stepsCompleted?: boolean
    completionRate?: boolean
    wasHelpful?: boolean
    rating?: boolean
    notes?: boolean
    wouldUseAgain?: boolean
  }

  export type GroundingSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "techniqueId" | "startedAt" | "completedAt" | "duration" | "triggerType" | "severityBefore" | "severityAfter" | "panicBefore" | "panicAfter" | "dissociationBefore" | "dissociationAfter" | "stepsCompleted" | "completionRate" | "wasHelpful" | "rating" | "notes" | "wouldUseAgain", ExtArgs["result"]["groundingSession"]>
  export type GroundingSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    technique?: boolean | GroundingTechniqueDefaultArgs<ExtArgs>
  }
  export type GroundingSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    technique?: boolean | GroundingTechniqueDefaultArgs<ExtArgs>
  }
  export type GroundingSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    technique?: boolean | GroundingTechniqueDefaultArgs<ExtArgs>
  }

  export type $GroundingSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroundingSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      technique: Prisma.$GroundingTechniquePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      techniqueId: string
      startedAt: Date
      completedAt: Date | null
      duration: number | null
      triggerType: string | null
      severityBefore: number | null
      severityAfter: number | null
      panicBefore: number | null
      panicAfter: number | null
      dissociationBefore: number | null
      dissociationAfter: number | null
      stepsCompleted: Prisma.JsonValue | null
      completionRate: number | null
      wasHelpful: boolean | null
      rating: number | null
      notes: string | null
      wouldUseAgain: boolean | null
    }, ExtArgs["result"]["groundingSession"]>
    composites: {}
  }

  type GroundingSessionGetPayload<S extends boolean | null | undefined | GroundingSessionDefaultArgs> = $Result.GetResult<Prisma.$GroundingSessionPayload, S>

  type GroundingSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroundingSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: GroundingSessionCountAggregateInputType | true
    }

  export interface GroundingSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroundingSession'], meta: { name: 'GroundingSession' } }
    /**
     * Find zero or one GroundingSession that matches the filter.
     * @param {GroundingSessionFindUniqueArgs} args - Arguments to find a GroundingSession
     * @example
     * // Get one GroundingSession
     * const groundingSession = await prisma.groundingSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroundingSessionFindUniqueArgs>(args: SelectSubset<T, GroundingSessionFindUniqueArgs<ExtArgs>>): Prisma__GroundingSessionClient<$Result.GetResult<Prisma.$GroundingSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroundingSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroundingSessionFindUniqueOrThrowArgs} args - Arguments to find a GroundingSession
     * @example
     * // Get one GroundingSession
     * const groundingSession = await prisma.groundingSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroundingSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, GroundingSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroundingSessionClient<$Result.GetResult<Prisma.$GroundingSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroundingSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundingSessionFindFirstArgs} args - Arguments to find a GroundingSession
     * @example
     * // Get one GroundingSession
     * const groundingSession = await prisma.groundingSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroundingSessionFindFirstArgs>(args?: SelectSubset<T, GroundingSessionFindFirstArgs<ExtArgs>>): Prisma__GroundingSessionClient<$Result.GetResult<Prisma.$GroundingSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroundingSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundingSessionFindFirstOrThrowArgs} args - Arguments to find a GroundingSession
     * @example
     * // Get one GroundingSession
     * const groundingSession = await prisma.groundingSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroundingSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, GroundingSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroundingSessionClient<$Result.GetResult<Prisma.$GroundingSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroundingSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundingSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroundingSessions
     * const groundingSessions = await prisma.groundingSession.findMany()
     * 
     * // Get first 10 GroundingSessions
     * const groundingSessions = await prisma.groundingSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groundingSessionWithIdOnly = await prisma.groundingSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroundingSessionFindManyArgs>(args?: SelectSubset<T, GroundingSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroundingSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroundingSession.
     * @param {GroundingSessionCreateArgs} args - Arguments to create a GroundingSession.
     * @example
     * // Create one GroundingSession
     * const GroundingSession = await prisma.groundingSession.create({
     *   data: {
     *     // ... data to create a GroundingSession
     *   }
     * })
     * 
     */
    create<T extends GroundingSessionCreateArgs>(args: SelectSubset<T, GroundingSessionCreateArgs<ExtArgs>>): Prisma__GroundingSessionClient<$Result.GetResult<Prisma.$GroundingSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroundingSessions.
     * @param {GroundingSessionCreateManyArgs} args - Arguments to create many GroundingSessions.
     * @example
     * // Create many GroundingSessions
     * const groundingSession = await prisma.groundingSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroundingSessionCreateManyArgs>(args?: SelectSubset<T, GroundingSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroundingSessions and returns the data saved in the database.
     * @param {GroundingSessionCreateManyAndReturnArgs} args - Arguments to create many GroundingSessions.
     * @example
     * // Create many GroundingSessions
     * const groundingSession = await prisma.groundingSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroundingSessions and only return the `id`
     * const groundingSessionWithIdOnly = await prisma.groundingSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroundingSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, GroundingSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroundingSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroundingSession.
     * @param {GroundingSessionDeleteArgs} args - Arguments to delete one GroundingSession.
     * @example
     * // Delete one GroundingSession
     * const GroundingSession = await prisma.groundingSession.delete({
     *   where: {
     *     // ... filter to delete one GroundingSession
     *   }
     * })
     * 
     */
    delete<T extends GroundingSessionDeleteArgs>(args: SelectSubset<T, GroundingSessionDeleteArgs<ExtArgs>>): Prisma__GroundingSessionClient<$Result.GetResult<Prisma.$GroundingSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroundingSession.
     * @param {GroundingSessionUpdateArgs} args - Arguments to update one GroundingSession.
     * @example
     * // Update one GroundingSession
     * const groundingSession = await prisma.groundingSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroundingSessionUpdateArgs>(args: SelectSubset<T, GroundingSessionUpdateArgs<ExtArgs>>): Prisma__GroundingSessionClient<$Result.GetResult<Prisma.$GroundingSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroundingSessions.
     * @param {GroundingSessionDeleteManyArgs} args - Arguments to filter GroundingSessions to delete.
     * @example
     * // Delete a few GroundingSessions
     * const { count } = await prisma.groundingSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroundingSessionDeleteManyArgs>(args?: SelectSubset<T, GroundingSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroundingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundingSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroundingSessions
     * const groundingSession = await prisma.groundingSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroundingSessionUpdateManyArgs>(args: SelectSubset<T, GroundingSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroundingSessions and returns the data updated in the database.
     * @param {GroundingSessionUpdateManyAndReturnArgs} args - Arguments to update many GroundingSessions.
     * @example
     * // Update many GroundingSessions
     * const groundingSession = await prisma.groundingSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroundingSessions and only return the `id`
     * const groundingSessionWithIdOnly = await prisma.groundingSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroundingSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, GroundingSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroundingSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroundingSession.
     * @param {GroundingSessionUpsertArgs} args - Arguments to update or create a GroundingSession.
     * @example
     * // Update or create a GroundingSession
     * const groundingSession = await prisma.groundingSession.upsert({
     *   create: {
     *     // ... data to create a GroundingSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroundingSession we want to update
     *   }
     * })
     */
    upsert<T extends GroundingSessionUpsertArgs>(args: SelectSubset<T, GroundingSessionUpsertArgs<ExtArgs>>): Prisma__GroundingSessionClient<$Result.GetResult<Prisma.$GroundingSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroundingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundingSessionCountArgs} args - Arguments to filter GroundingSessions to count.
     * @example
     * // Count the number of GroundingSessions
     * const count = await prisma.groundingSession.count({
     *   where: {
     *     // ... the filter for the GroundingSessions we want to count
     *   }
     * })
    **/
    count<T extends GroundingSessionCountArgs>(
      args?: Subset<T, GroundingSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroundingSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroundingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundingSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroundingSessionAggregateArgs>(args: Subset<T, GroundingSessionAggregateArgs>): Prisma.PrismaPromise<GetGroundingSessionAggregateType<T>>

    /**
     * Group by GroundingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroundingSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroundingSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroundingSessionGroupByArgs['orderBy'] }
        : { orderBy?: GroundingSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroundingSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroundingSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroundingSession model
   */
  readonly fields: GroundingSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroundingSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroundingSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    technique<T extends GroundingTechniqueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroundingTechniqueDefaultArgs<ExtArgs>>): Prisma__GroundingTechniqueClient<$Result.GetResult<Prisma.$GroundingTechniquePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroundingSession model
   */
  interface GroundingSessionFieldRefs {
    readonly id: FieldRef<"GroundingSession", 'String'>
    readonly userId: FieldRef<"GroundingSession", 'String'>
    readonly techniqueId: FieldRef<"GroundingSession", 'String'>
    readonly startedAt: FieldRef<"GroundingSession", 'DateTime'>
    readonly completedAt: FieldRef<"GroundingSession", 'DateTime'>
    readonly duration: FieldRef<"GroundingSession", 'Int'>
    readonly triggerType: FieldRef<"GroundingSession", 'String'>
    readonly severityBefore: FieldRef<"GroundingSession", 'Int'>
    readonly severityAfter: FieldRef<"GroundingSession", 'Int'>
    readonly panicBefore: FieldRef<"GroundingSession", 'Int'>
    readonly panicAfter: FieldRef<"GroundingSession", 'Int'>
    readonly dissociationBefore: FieldRef<"GroundingSession", 'Int'>
    readonly dissociationAfter: FieldRef<"GroundingSession", 'Int'>
    readonly stepsCompleted: FieldRef<"GroundingSession", 'Json'>
    readonly completionRate: FieldRef<"GroundingSession", 'Float'>
    readonly wasHelpful: FieldRef<"GroundingSession", 'Boolean'>
    readonly rating: FieldRef<"GroundingSession", 'Int'>
    readonly notes: FieldRef<"GroundingSession", 'String'>
    readonly wouldUseAgain: FieldRef<"GroundingSession", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * GroundingSession findUnique
   */
  export type GroundingSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingSession
     */
    select?: GroundingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingSession
     */
    omit?: GroundingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingSessionInclude<ExtArgs> | null
    /**
     * Filter, which GroundingSession to fetch.
     */
    where: GroundingSessionWhereUniqueInput
  }

  /**
   * GroundingSession findUniqueOrThrow
   */
  export type GroundingSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingSession
     */
    select?: GroundingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingSession
     */
    omit?: GroundingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingSessionInclude<ExtArgs> | null
    /**
     * Filter, which GroundingSession to fetch.
     */
    where: GroundingSessionWhereUniqueInput
  }

  /**
   * GroundingSession findFirst
   */
  export type GroundingSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingSession
     */
    select?: GroundingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingSession
     */
    omit?: GroundingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingSessionInclude<ExtArgs> | null
    /**
     * Filter, which GroundingSession to fetch.
     */
    where?: GroundingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroundingSessions to fetch.
     */
    orderBy?: GroundingSessionOrderByWithRelationInput | GroundingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroundingSessions.
     */
    cursor?: GroundingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroundingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroundingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroundingSessions.
     */
    distinct?: GroundingSessionScalarFieldEnum | GroundingSessionScalarFieldEnum[]
  }

  /**
   * GroundingSession findFirstOrThrow
   */
  export type GroundingSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingSession
     */
    select?: GroundingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingSession
     */
    omit?: GroundingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingSessionInclude<ExtArgs> | null
    /**
     * Filter, which GroundingSession to fetch.
     */
    where?: GroundingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroundingSessions to fetch.
     */
    orderBy?: GroundingSessionOrderByWithRelationInput | GroundingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroundingSessions.
     */
    cursor?: GroundingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroundingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroundingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroundingSessions.
     */
    distinct?: GroundingSessionScalarFieldEnum | GroundingSessionScalarFieldEnum[]
  }

  /**
   * GroundingSession findMany
   */
  export type GroundingSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingSession
     */
    select?: GroundingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingSession
     */
    omit?: GroundingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingSessionInclude<ExtArgs> | null
    /**
     * Filter, which GroundingSessions to fetch.
     */
    where?: GroundingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroundingSessions to fetch.
     */
    orderBy?: GroundingSessionOrderByWithRelationInput | GroundingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroundingSessions.
     */
    cursor?: GroundingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroundingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroundingSessions.
     */
    skip?: number
    distinct?: GroundingSessionScalarFieldEnum | GroundingSessionScalarFieldEnum[]
  }

  /**
   * GroundingSession create
   */
  export type GroundingSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingSession
     */
    select?: GroundingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingSession
     */
    omit?: GroundingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a GroundingSession.
     */
    data: XOR<GroundingSessionCreateInput, GroundingSessionUncheckedCreateInput>
  }

  /**
   * GroundingSession createMany
   */
  export type GroundingSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroundingSessions.
     */
    data: GroundingSessionCreateManyInput | GroundingSessionCreateManyInput[]
  }

  /**
   * GroundingSession createManyAndReturn
   */
  export type GroundingSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingSession
     */
    select?: GroundingSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingSession
     */
    omit?: GroundingSessionOmit<ExtArgs> | null
    /**
     * The data used to create many GroundingSessions.
     */
    data: GroundingSessionCreateManyInput | GroundingSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroundingSession update
   */
  export type GroundingSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingSession
     */
    select?: GroundingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingSession
     */
    omit?: GroundingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a GroundingSession.
     */
    data: XOR<GroundingSessionUpdateInput, GroundingSessionUncheckedUpdateInput>
    /**
     * Choose, which GroundingSession to update.
     */
    where: GroundingSessionWhereUniqueInput
  }

  /**
   * GroundingSession updateMany
   */
  export type GroundingSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroundingSessions.
     */
    data: XOR<GroundingSessionUpdateManyMutationInput, GroundingSessionUncheckedUpdateManyInput>
    /**
     * Filter which GroundingSessions to update
     */
    where?: GroundingSessionWhereInput
    /**
     * Limit how many GroundingSessions to update.
     */
    limit?: number
  }

  /**
   * GroundingSession updateManyAndReturn
   */
  export type GroundingSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingSession
     */
    select?: GroundingSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingSession
     */
    omit?: GroundingSessionOmit<ExtArgs> | null
    /**
     * The data used to update GroundingSessions.
     */
    data: XOR<GroundingSessionUpdateManyMutationInput, GroundingSessionUncheckedUpdateManyInput>
    /**
     * Filter which GroundingSessions to update
     */
    where?: GroundingSessionWhereInput
    /**
     * Limit how many GroundingSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroundingSession upsert
   */
  export type GroundingSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingSession
     */
    select?: GroundingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingSession
     */
    omit?: GroundingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the GroundingSession to update in case it exists.
     */
    where: GroundingSessionWhereUniqueInput
    /**
     * In case the GroundingSession found by the `where` argument doesn't exist, create a new GroundingSession with this data.
     */
    create: XOR<GroundingSessionCreateInput, GroundingSessionUncheckedCreateInput>
    /**
     * In case the GroundingSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroundingSessionUpdateInput, GroundingSessionUncheckedUpdateInput>
  }

  /**
   * GroundingSession delete
   */
  export type GroundingSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingSession
     */
    select?: GroundingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingSession
     */
    omit?: GroundingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingSessionInclude<ExtArgs> | null
    /**
     * Filter which GroundingSession to delete.
     */
    where: GroundingSessionWhereUniqueInput
  }

  /**
   * GroundingSession deleteMany
   */
  export type GroundingSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroundingSessions to delete
     */
    where?: GroundingSessionWhereInput
    /**
     * Limit how many GroundingSessions to delete.
     */
    limit?: number
  }

  /**
   * GroundingSession without action
   */
  export type GroundingSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroundingSession
     */
    select?: GroundingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroundingSession
     */
    omit?: GroundingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroundingSessionInclude<ExtArgs> | null
  }


  /**
   * Model SelfHelpResource
   */

  export type AggregateSelfHelpResource = {
    _count: SelfHelpResourceCountAggregateOutputType | null
    _avg: SelfHelpResourceAvgAggregateOutputType | null
    _sum: SelfHelpResourceSumAggregateOutputType | null
    _min: SelfHelpResourceMinAggregateOutputType | null
    _max: SelfHelpResourceMaxAggregateOutputType | null
  }

  export type SelfHelpResourceAvgAggregateOutputType = {
    duration: number | null
    viewCount: number | null
    helpfulCount: number | null
    averageRating: number | null
  }

  export type SelfHelpResourceSumAggregateOutputType = {
    duration: number | null
    viewCount: number | null
    helpfulCount: number | null
    averageRating: number | null
  }

  export type SelfHelpResourceMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: $Enums.SelfHelpCategory | null
    type: $Enums.ResourceType | null
    content: string | null
    url: string | null
    mediaUrl: string | null
    thumbnailUrl: string | null
    duration: number | null
    difficulty: $Enums.ExerciseDifficulty | null
    evidenceLevel: $Enums.EvidenceLevel | null
    viewCount: number | null
    helpfulCount: number | null
    averageRating: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SelfHelpResourceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: $Enums.SelfHelpCategory | null
    type: $Enums.ResourceType | null
    content: string | null
    url: string | null
    mediaUrl: string | null
    thumbnailUrl: string | null
    duration: number | null
    difficulty: $Enums.ExerciseDifficulty | null
    evidenceLevel: $Enums.EvidenceLevel | null
    viewCount: number | null
    helpfulCount: number | null
    averageRating: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SelfHelpResourceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    type: number
    content: number
    url: number
    mediaUrl: number
    thumbnailUrl: number
    duration: number
    difficulty: number
    evidenceLevel: number
    tags: number
    conditions: number
    symptoms: number
    viewCount: number
    helpfulCount: number
    averageRating: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SelfHelpResourceAvgAggregateInputType = {
    duration?: true
    viewCount?: true
    helpfulCount?: true
    averageRating?: true
  }

  export type SelfHelpResourceSumAggregateInputType = {
    duration?: true
    viewCount?: true
    helpfulCount?: true
    averageRating?: true
  }

  export type SelfHelpResourceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    type?: true
    content?: true
    url?: true
    mediaUrl?: true
    thumbnailUrl?: true
    duration?: true
    difficulty?: true
    evidenceLevel?: true
    viewCount?: true
    helpfulCount?: true
    averageRating?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SelfHelpResourceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    type?: true
    content?: true
    url?: true
    mediaUrl?: true
    thumbnailUrl?: true
    duration?: true
    difficulty?: true
    evidenceLevel?: true
    viewCount?: true
    helpfulCount?: true
    averageRating?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SelfHelpResourceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    type?: true
    content?: true
    url?: true
    mediaUrl?: true
    thumbnailUrl?: true
    duration?: true
    difficulty?: true
    evidenceLevel?: true
    tags?: true
    conditions?: true
    symptoms?: true
    viewCount?: true
    helpfulCount?: true
    averageRating?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SelfHelpResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SelfHelpResource to aggregate.
     */
    where?: SelfHelpResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelfHelpResources to fetch.
     */
    orderBy?: SelfHelpResourceOrderByWithRelationInput | SelfHelpResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SelfHelpResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelfHelpResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelfHelpResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SelfHelpResources
    **/
    _count?: true | SelfHelpResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SelfHelpResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SelfHelpResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SelfHelpResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SelfHelpResourceMaxAggregateInputType
  }

  export type GetSelfHelpResourceAggregateType<T extends SelfHelpResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateSelfHelpResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSelfHelpResource[P]>
      : GetScalarType<T[P], AggregateSelfHelpResource[P]>
  }




  export type SelfHelpResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SelfHelpResourceWhereInput
    orderBy?: SelfHelpResourceOrderByWithAggregationInput | SelfHelpResourceOrderByWithAggregationInput[]
    by: SelfHelpResourceScalarFieldEnum[] | SelfHelpResourceScalarFieldEnum
    having?: SelfHelpResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SelfHelpResourceCountAggregateInputType | true
    _avg?: SelfHelpResourceAvgAggregateInputType
    _sum?: SelfHelpResourceSumAggregateInputType
    _min?: SelfHelpResourceMinAggregateInputType
    _max?: SelfHelpResourceMaxAggregateInputType
  }

  export type SelfHelpResourceGroupByOutputType = {
    id: string
    title: string
    description: string
    category: $Enums.SelfHelpCategory
    type: $Enums.ResourceType
    content: string | null
    url: string | null
    mediaUrl: string | null
    thumbnailUrl: string | null
    duration: number | null
    difficulty: $Enums.ExerciseDifficulty
    evidenceLevel: $Enums.EvidenceLevel
    tags: JsonValue
    conditions: JsonValue | null
    symptoms: JsonValue | null
    viewCount: number
    helpfulCount: number
    averageRating: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SelfHelpResourceCountAggregateOutputType | null
    _avg: SelfHelpResourceAvgAggregateOutputType | null
    _sum: SelfHelpResourceSumAggregateOutputType | null
    _min: SelfHelpResourceMinAggregateOutputType | null
    _max: SelfHelpResourceMaxAggregateOutputType | null
  }

  type GetSelfHelpResourceGroupByPayload<T extends SelfHelpResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SelfHelpResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SelfHelpResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SelfHelpResourceGroupByOutputType[P]>
            : GetScalarType<T[P], SelfHelpResourceGroupByOutputType[P]>
        }
      >
    >


  export type SelfHelpResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    content?: boolean
    url?: boolean
    mediaUrl?: boolean
    thumbnailUrl?: boolean
    duration?: boolean
    difficulty?: boolean
    evidenceLevel?: boolean
    tags?: boolean
    conditions?: boolean
    symptoms?: boolean
    viewCount?: boolean
    helpfulCount?: boolean
    averageRating?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    interactions?: boolean | SelfHelpResource$interactionsArgs<ExtArgs>
    _count?: boolean | SelfHelpResourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["selfHelpResource"]>

  export type SelfHelpResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    content?: boolean
    url?: boolean
    mediaUrl?: boolean
    thumbnailUrl?: boolean
    duration?: boolean
    difficulty?: boolean
    evidenceLevel?: boolean
    tags?: boolean
    conditions?: boolean
    symptoms?: boolean
    viewCount?: boolean
    helpfulCount?: boolean
    averageRating?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["selfHelpResource"]>

  export type SelfHelpResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    content?: boolean
    url?: boolean
    mediaUrl?: boolean
    thumbnailUrl?: boolean
    duration?: boolean
    difficulty?: boolean
    evidenceLevel?: boolean
    tags?: boolean
    conditions?: boolean
    symptoms?: boolean
    viewCount?: boolean
    helpfulCount?: boolean
    averageRating?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["selfHelpResource"]>

  export type SelfHelpResourceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    content?: boolean
    url?: boolean
    mediaUrl?: boolean
    thumbnailUrl?: boolean
    duration?: boolean
    difficulty?: boolean
    evidenceLevel?: boolean
    tags?: boolean
    conditions?: boolean
    symptoms?: boolean
    viewCount?: boolean
    helpfulCount?: boolean
    averageRating?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SelfHelpResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "category" | "type" | "content" | "url" | "mediaUrl" | "thumbnailUrl" | "duration" | "difficulty" | "evidenceLevel" | "tags" | "conditions" | "symptoms" | "viewCount" | "helpfulCount" | "averageRating" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["selfHelpResource"]>
  export type SelfHelpResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interactions?: boolean | SelfHelpResource$interactionsArgs<ExtArgs>
    _count?: boolean | SelfHelpResourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SelfHelpResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SelfHelpResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SelfHelpResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SelfHelpResource"
    objects: {
      interactions: Prisma.$SelfHelpInteractionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      category: $Enums.SelfHelpCategory
      type: $Enums.ResourceType
      content: string | null
      url: string | null
      mediaUrl: string | null
      thumbnailUrl: string | null
      duration: number | null
      difficulty: $Enums.ExerciseDifficulty
      evidenceLevel: $Enums.EvidenceLevel
      tags: Prisma.JsonValue
      conditions: Prisma.JsonValue | null
      symptoms: Prisma.JsonValue | null
      viewCount: number
      helpfulCount: number
      averageRating: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["selfHelpResource"]>
    composites: {}
  }

  type SelfHelpResourceGetPayload<S extends boolean | null | undefined | SelfHelpResourceDefaultArgs> = $Result.GetResult<Prisma.$SelfHelpResourcePayload, S>

  type SelfHelpResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SelfHelpResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SelfHelpResourceCountAggregateInputType | true
    }

  export interface SelfHelpResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SelfHelpResource'], meta: { name: 'SelfHelpResource' } }
    /**
     * Find zero or one SelfHelpResource that matches the filter.
     * @param {SelfHelpResourceFindUniqueArgs} args - Arguments to find a SelfHelpResource
     * @example
     * // Get one SelfHelpResource
     * const selfHelpResource = await prisma.selfHelpResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SelfHelpResourceFindUniqueArgs>(args: SelectSubset<T, SelfHelpResourceFindUniqueArgs<ExtArgs>>): Prisma__SelfHelpResourceClient<$Result.GetResult<Prisma.$SelfHelpResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SelfHelpResource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SelfHelpResourceFindUniqueOrThrowArgs} args - Arguments to find a SelfHelpResource
     * @example
     * // Get one SelfHelpResource
     * const selfHelpResource = await prisma.selfHelpResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SelfHelpResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, SelfHelpResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SelfHelpResourceClient<$Result.GetResult<Prisma.$SelfHelpResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SelfHelpResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfHelpResourceFindFirstArgs} args - Arguments to find a SelfHelpResource
     * @example
     * // Get one SelfHelpResource
     * const selfHelpResource = await prisma.selfHelpResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SelfHelpResourceFindFirstArgs>(args?: SelectSubset<T, SelfHelpResourceFindFirstArgs<ExtArgs>>): Prisma__SelfHelpResourceClient<$Result.GetResult<Prisma.$SelfHelpResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SelfHelpResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfHelpResourceFindFirstOrThrowArgs} args - Arguments to find a SelfHelpResource
     * @example
     * // Get one SelfHelpResource
     * const selfHelpResource = await prisma.selfHelpResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SelfHelpResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, SelfHelpResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SelfHelpResourceClient<$Result.GetResult<Prisma.$SelfHelpResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SelfHelpResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfHelpResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SelfHelpResources
     * const selfHelpResources = await prisma.selfHelpResource.findMany()
     * 
     * // Get first 10 SelfHelpResources
     * const selfHelpResources = await prisma.selfHelpResource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const selfHelpResourceWithIdOnly = await prisma.selfHelpResource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SelfHelpResourceFindManyArgs>(args?: SelectSubset<T, SelfHelpResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelfHelpResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SelfHelpResource.
     * @param {SelfHelpResourceCreateArgs} args - Arguments to create a SelfHelpResource.
     * @example
     * // Create one SelfHelpResource
     * const SelfHelpResource = await prisma.selfHelpResource.create({
     *   data: {
     *     // ... data to create a SelfHelpResource
     *   }
     * })
     * 
     */
    create<T extends SelfHelpResourceCreateArgs>(args: SelectSubset<T, SelfHelpResourceCreateArgs<ExtArgs>>): Prisma__SelfHelpResourceClient<$Result.GetResult<Prisma.$SelfHelpResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SelfHelpResources.
     * @param {SelfHelpResourceCreateManyArgs} args - Arguments to create many SelfHelpResources.
     * @example
     * // Create many SelfHelpResources
     * const selfHelpResource = await prisma.selfHelpResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SelfHelpResourceCreateManyArgs>(args?: SelectSubset<T, SelfHelpResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SelfHelpResources and returns the data saved in the database.
     * @param {SelfHelpResourceCreateManyAndReturnArgs} args - Arguments to create many SelfHelpResources.
     * @example
     * // Create many SelfHelpResources
     * const selfHelpResource = await prisma.selfHelpResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SelfHelpResources and only return the `id`
     * const selfHelpResourceWithIdOnly = await prisma.selfHelpResource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SelfHelpResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, SelfHelpResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelfHelpResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SelfHelpResource.
     * @param {SelfHelpResourceDeleteArgs} args - Arguments to delete one SelfHelpResource.
     * @example
     * // Delete one SelfHelpResource
     * const SelfHelpResource = await prisma.selfHelpResource.delete({
     *   where: {
     *     // ... filter to delete one SelfHelpResource
     *   }
     * })
     * 
     */
    delete<T extends SelfHelpResourceDeleteArgs>(args: SelectSubset<T, SelfHelpResourceDeleteArgs<ExtArgs>>): Prisma__SelfHelpResourceClient<$Result.GetResult<Prisma.$SelfHelpResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SelfHelpResource.
     * @param {SelfHelpResourceUpdateArgs} args - Arguments to update one SelfHelpResource.
     * @example
     * // Update one SelfHelpResource
     * const selfHelpResource = await prisma.selfHelpResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SelfHelpResourceUpdateArgs>(args: SelectSubset<T, SelfHelpResourceUpdateArgs<ExtArgs>>): Prisma__SelfHelpResourceClient<$Result.GetResult<Prisma.$SelfHelpResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SelfHelpResources.
     * @param {SelfHelpResourceDeleteManyArgs} args - Arguments to filter SelfHelpResources to delete.
     * @example
     * // Delete a few SelfHelpResources
     * const { count } = await prisma.selfHelpResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SelfHelpResourceDeleteManyArgs>(args?: SelectSubset<T, SelfHelpResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SelfHelpResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfHelpResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SelfHelpResources
     * const selfHelpResource = await prisma.selfHelpResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SelfHelpResourceUpdateManyArgs>(args: SelectSubset<T, SelfHelpResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SelfHelpResources and returns the data updated in the database.
     * @param {SelfHelpResourceUpdateManyAndReturnArgs} args - Arguments to update many SelfHelpResources.
     * @example
     * // Update many SelfHelpResources
     * const selfHelpResource = await prisma.selfHelpResource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SelfHelpResources and only return the `id`
     * const selfHelpResourceWithIdOnly = await prisma.selfHelpResource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SelfHelpResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, SelfHelpResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelfHelpResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SelfHelpResource.
     * @param {SelfHelpResourceUpsertArgs} args - Arguments to update or create a SelfHelpResource.
     * @example
     * // Update or create a SelfHelpResource
     * const selfHelpResource = await prisma.selfHelpResource.upsert({
     *   create: {
     *     // ... data to create a SelfHelpResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SelfHelpResource we want to update
     *   }
     * })
     */
    upsert<T extends SelfHelpResourceUpsertArgs>(args: SelectSubset<T, SelfHelpResourceUpsertArgs<ExtArgs>>): Prisma__SelfHelpResourceClient<$Result.GetResult<Prisma.$SelfHelpResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SelfHelpResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfHelpResourceCountArgs} args - Arguments to filter SelfHelpResources to count.
     * @example
     * // Count the number of SelfHelpResources
     * const count = await prisma.selfHelpResource.count({
     *   where: {
     *     // ... the filter for the SelfHelpResources we want to count
     *   }
     * })
    **/
    count<T extends SelfHelpResourceCountArgs>(
      args?: Subset<T, SelfHelpResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SelfHelpResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SelfHelpResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfHelpResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SelfHelpResourceAggregateArgs>(args: Subset<T, SelfHelpResourceAggregateArgs>): Prisma.PrismaPromise<GetSelfHelpResourceAggregateType<T>>

    /**
     * Group by SelfHelpResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfHelpResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SelfHelpResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SelfHelpResourceGroupByArgs['orderBy'] }
        : { orderBy?: SelfHelpResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SelfHelpResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSelfHelpResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SelfHelpResource model
   */
  readonly fields: SelfHelpResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SelfHelpResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SelfHelpResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interactions<T extends SelfHelpResource$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, SelfHelpResource$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelfHelpInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SelfHelpResource model
   */
  interface SelfHelpResourceFieldRefs {
    readonly id: FieldRef<"SelfHelpResource", 'String'>
    readonly title: FieldRef<"SelfHelpResource", 'String'>
    readonly description: FieldRef<"SelfHelpResource", 'String'>
    readonly category: FieldRef<"SelfHelpResource", 'SelfHelpCategory'>
    readonly type: FieldRef<"SelfHelpResource", 'ResourceType'>
    readonly content: FieldRef<"SelfHelpResource", 'String'>
    readonly url: FieldRef<"SelfHelpResource", 'String'>
    readonly mediaUrl: FieldRef<"SelfHelpResource", 'String'>
    readonly thumbnailUrl: FieldRef<"SelfHelpResource", 'String'>
    readonly duration: FieldRef<"SelfHelpResource", 'Int'>
    readonly difficulty: FieldRef<"SelfHelpResource", 'ExerciseDifficulty'>
    readonly evidenceLevel: FieldRef<"SelfHelpResource", 'EvidenceLevel'>
    readonly tags: FieldRef<"SelfHelpResource", 'Json'>
    readonly conditions: FieldRef<"SelfHelpResource", 'Json'>
    readonly symptoms: FieldRef<"SelfHelpResource", 'Json'>
    readonly viewCount: FieldRef<"SelfHelpResource", 'Int'>
    readonly helpfulCount: FieldRef<"SelfHelpResource", 'Int'>
    readonly averageRating: FieldRef<"SelfHelpResource", 'Float'>
    readonly isActive: FieldRef<"SelfHelpResource", 'Boolean'>
    readonly createdAt: FieldRef<"SelfHelpResource", 'DateTime'>
    readonly updatedAt: FieldRef<"SelfHelpResource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SelfHelpResource findUnique
   */
  export type SelfHelpResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpResource
     */
    select?: SelfHelpResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpResource
     */
    omit?: SelfHelpResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpResourceInclude<ExtArgs> | null
    /**
     * Filter, which SelfHelpResource to fetch.
     */
    where: SelfHelpResourceWhereUniqueInput
  }

  /**
   * SelfHelpResource findUniqueOrThrow
   */
  export type SelfHelpResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpResource
     */
    select?: SelfHelpResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpResource
     */
    omit?: SelfHelpResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpResourceInclude<ExtArgs> | null
    /**
     * Filter, which SelfHelpResource to fetch.
     */
    where: SelfHelpResourceWhereUniqueInput
  }

  /**
   * SelfHelpResource findFirst
   */
  export type SelfHelpResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpResource
     */
    select?: SelfHelpResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpResource
     */
    omit?: SelfHelpResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpResourceInclude<ExtArgs> | null
    /**
     * Filter, which SelfHelpResource to fetch.
     */
    where?: SelfHelpResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelfHelpResources to fetch.
     */
    orderBy?: SelfHelpResourceOrderByWithRelationInput | SelfHelpResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SelfHelpResources.
     */
    cursor?: SelfHelpResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelfHelpResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelfHelpResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SelfHelpResources.
     */
    distinct?: SelfHelpResourceScalarFieldEnum | SelfHelpResourceScalarFieldEnum[]
  }

  /**
   * SelfHelpResource findFirstOrThrow
   */
  export type SelfHelpResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpResource
     */
    select?: SelfHelpResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpResource
     */
    omit?: SelfHelpResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpResourceInclude<ExtArgs> | null
    /**
     * Filter, which SelfHelpResource to fetch.
     */
    where?: SelfHelpResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelfHelpResources to fetch.
     */
    orderBy?: SelfHelpResourceOrderByWithRelationInput | SelfHelpResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SelfHelpResources.
     */
    cursor?: SelfHelpResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelfHelpResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelfHelpResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SelfHelpResources.
     */
    distinct?: SelfHelpResourceScalarFieldEnum | SelfHelpResourceScalarFieldEnum[]
  }

  /**
   * SelfHelpResource findMany
   */
  export type SelfHelpResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpResource
     */
    select?: SelfHelpResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpResource
     */
    omit?: SelfHelpResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpResourceInclude<ExtArgs> | null
    /**
     * Filter, which SelfHelpResources to fetch.
     */
    where?: SelfHelpResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelfHelpResources to fetch.
     */
    orderBy?: SelfHelpResourceOrderByWithRelationInput | SelfHelpResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SelfHelpResources.
     */
    cursor?: SelfHelpResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelfHelpResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelfHelpResources.
     */
    skip?: number
    distinct?: SelfHelpResourceScalarFieldEnum | SelfHelpResourceScalarFieldEnum[]
  }

  /**
   * SelfHelpResource create
   */
  export type SelfHelpResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpResource
     */
    select?: SelfHelpResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpResource
     */
    omit?: SelfHelpResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a SelfHelpResource.
     */
    data: XOR<SelfHelpResourceCreateInput, SelfHelpResourceUncheckedCreateInput>
  }

  /**
   * SelfHelpResource createMany
   */
  export type SelfHelpResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SelfHelpResources.
     */
    data: SelfHelpResourceCreateManyInput | SelfHelpResourceCreateManyInput[]
  }

  /**
   * SelfHelpResource createManyAndReturn
   */
  export type SelfHelpResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpResource
     */
    select?: SelfHelpResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpResource
     */
    omit?: SelfHelpResourceOmit<ExtArgs> | null
    /**
     * The data used to create many SelfHelpResources.
     */
    data: SelfHelpResourceCreateManyInput | SelfHelpResourceCreateManyInput[]
  }

  /**
   * SelfHelpResource update
   */
  export type SelfHelpResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpResource
     */
    select?: SelfHelpResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpResource
     */
    omit?: SelfHelpResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a SelfHelpResource.
     */
    data: XOR<SelfHelpResourceUpdateInput, SelfHelpResourceUncheckedUpdateInput>
    /**
     * Choose, which SelfHelpResource to update.
     */
    where: SelfHelpResourceWhereUniqueInput
  }

  /**
   * SelfHelpResource updateMany
   */
  export type SelfHelpResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SelfHelpResources.
     */
    data: XOR<SelfHelpResourceUpdateManyMutationInput, SelfHelpResourceUncheckedUpdateManyInput>
    /**
     * Filter which SelfHelpResources to update
     */
    where?: SelfHelpResourceWhereInput
    /**
     * Limit how many SelfHelpResources to update.
     */
    limit?: number
  }

  /**
   * SelfHelpResource updateManyAndReturn
   */
  export type SelfHelpResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpResource
     */
    select?: SelfHelpResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpResource
     */
    omit?: SelfHelpResourceOmit<ExtArgs> | null
    /**
     * The data used to update SelfHelpResources.
     */
    data: XOR<SelfHelpResourceUpdateManyMutationInput, SelfHelpResourceUncheckedUpdateManyInput>
    /**
     * Filter which SelfHelpResources to update
     */
    where?: SelfHelpResourceWhereInput
    /**
     * Limit how many SelfHelpResources to update.
     */
    limit?: number
  }

  /**
   * SelfHelpResource upsert
   */
  export type SelfHelpResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpResource
     */
    select?: SelfHelpResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpResource
     */
    omit?: SelfHelpResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the SelfHelpResource to update in case it exists.
     */
    where: SelfHelpResourceWhereUniqueInput
    /**
     * In case the SelfHelpResource found by the `where` argument doesn't exist, create a new SelfHelpResource with this data.
     */
    create: XOR<SelfHelpResourceCreateInput, SelfHelpResourceUncheckedCreateInput>
    /**
     * In case the SelfHelpResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SelfHelpResourceUpdateInput, SelfHelpResourceUncheckedUpdateInput>
  }

  /**
   * SelfHelpResource delete
   */
  export type SelfHelpResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpResource
     */
    select?: SelfHelpResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpResource
     */
    omit?: SelfHelpResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpResourceInclude<ExtArgs> | null
    /**
     * Filter which SelfHelpResource to delete.
     */
    where: SelfHelpResourceWhereUniqueInput
  }

  /**
   * SelfHelpResource deleteMany
   */
  export type SelfHelpResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SelfHelpResources to delete
     */
    where?: SelfHelpResourceWhereInput
    /**
     * Limit how many SelfHelpResources to delete.
     */
    limit?: number
  }

  /**
   * SelfHelpResource.interactions
   */
  export type SelfHelpResource$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpInteraction
     */
    select?: SelfHelpInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpInteraction
     */
    omit?: SelfHelpInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpInteractionInclude<ExtArgs> | null
    where?: SelfHelpInteractionWhereInput
    orderBy?: SelfHelpInteractionOrderByWithRelationInput | SelfHelpInteractionOrderByWithRelationInput[]
    cursor?: SelfHelpInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SelfHelpInteractionScalarFieldEnum | SelfHelpInteractionScalarFieldEnum[]
  }

  /**
   * SelfHelpResource without action
   */
  export type SelfHelpResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpResource
     */
    select?: SelfHelpResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpResource
     */
    omit?: SelfHelpResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpResourceInclude<ExtArgs> | null
  }


  /**
   * Model SelfHelpInteraction
   */

  export type AggregateSelfHelpInteraction = {
    _count: SelfHelpInteractionCountAggregateOutputType | null
    _avg: SelfHelpInteractionAvgAggregateOutputType | null
    _sum: SelfHelpInteractionSumAggregateOutputType | null
    _min: SelfHelpInteractionMinAggregateOutputType | null
    _max: SelfHelpInteractionMaxAggregateOutputType | null
  }

  export type SelfHelpInteractionAvgAggregateOutputType = {
    duration: number | null
    rating: number | null
    moodBefore: number | null
    moodAfter: number | null
  }

  export type SelfHelpInteractionSumAggregateOutputType = {
    duration: number | null
    rating: number | null
    moodBefore: number | null
    moodAfter: number | null
  }

  export type SelfHelpInteractionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resourceId: string | null
    interactionType: $Enums.InteractionType | null
    startedAt: Date | null
    completedAt: Date | null
    duration: number | null
    wasHelpful: boolean | null
    rating: number | null
    notes: string | null
    moodBefore: number | null
    moodAfter: number | null
  }

  export type SelfHelpInteractionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resourceId: string | null
    interactionType: $Enums.InteractionType | null
    startedAt: Date | null
    completedAt: Date | null
    duration: number | null
    wasHelpful: boolean | null
    rating: number | null
    notes: string | null
    moodBefore: number | null
    moodAfter: number | null
  }

  export type SelfHelpInteractionCountAggregateOutputType = {
    id: number
    userId: number
    resourceId: number
    interactionType: number
    startedAt: number
    completedAt: number
    duration: number
    wasHelpful: number
    rating: number
    notes: number
    moodBefore: number
    moodAfter: number
    _all: number
  }


  export type SelfHelpInteractionAvgAggregateInputType = {
    duration?: true
    rating?: true
    moodBefore?: true
    moodAfter?: true
  }

  export type SelfHelpInteractionSumAggregateInputType = {
    duration?: true
    rating?: true
    moodBefore?: true
    moodAfter?: true
  }

  export type SelfHelpInteractionMinAggregateInputType = {
    id?: true
    userId?: true
    resourceId?: true
    interactionType?: true
    startedAt?: true
    completedAt?: true
    duration?: true
    wasHelpful?: true
    rating?: true
    notes?: true
    moodBefore?: true
    moodAfter?: true
  }

  export type SelfHelpInteractionMaxAggregateInputType = {
    id?: true
    userId?: true
    resourceId?: true
    interactionType?: true
    startedAt?: true
    completedAt?: true
    duration?: true
    wasHelpful?: true
    rating?: true
    notes?: true
    moodBefore?: true
    moodAfter?: true
  }

  export type SelfHelpInteractionCountAggregateInputType = {
    id?: true
    userId?: true
    resourceId?: true
    interactionType?: true
    startedAt?: true
    completedAt?: true
    duration?: true
    wasHelpful?: true
    rating?: true
    notes?: true
    moodBefore?: true
    moodAfter?: true
    _all?: true
  }

  export type SelfHelpInteractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SelfHelpInteraction to aggregate.
     */
    where?: SelfHelpInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelfHelpInteractions to fetch.
     */
    orderBy?: SelfHelpInteractionOrderByWithRelationInput | SelfHelpInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SelfHelpInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelfHelpInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelfHelpInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SelfHelpInteractions
    **/
    _count?: true | SelfHelpInteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SelfHelpInteractionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SelfHelpInteractionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SelfHelpInteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SelfHelpInteractionMaxAggregateInputType
  }

  export type GetSelfHelpInteractionAggregateType<T extends SelfHelpInteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateSelfHelpInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSelfHelpInteraction[P]>
      : GetScalarType<T[P], AggregateSelfHelpInteraction[P]>
  }




  export type SelfHelpInteractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SelfHelpInteractionWhereInput
    orderBy?: SelfHelpInteractionOrderByWithAggregationInput | SelfHelpInteractionOrderByWithAggregationInput[]
    by: SelfHelpInteractionScalarFieldEnum[] | SelfHelpInteractionScalarFieldEnum
    having?: SelfHelpInteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SelfHelpInteractionCountAggregateInputType | true
    _avg?: SelfHelpInteractionAvgAggregateInputType
    _sum?: SelfHelpInteractionSumAggregateInputType
    _min?: SelfHelpInteractionMinAggregateInputType
    _max?: SelfHelpInteractionMaxAggregateInputType
  }

  export type SelfHelpInteractionGroupByOutputType = {
    id: string
    userId: string
    resourceId: string
    interactionType: $Enums.InteractionType
    startedAt: Date
    completedAt: Date | null
    duration: number | null
    wasHelpful: boolean | null
    rating: number | null
    notes: string | null
    moodBefore: number | null
    moodAfter: number | null
    _count: SelfHelpInteractionCountAggregateOutputType | null
    _avg: SelfHelpInteractionAvgAggregateOutputType | null
    _sum: SelfHelpInteractionSumAggregateOutputType | null
    _min: SelfHelpInteractionMinAggregateOutputType | null
    _max: SelfHelpInteractionMaxAggregateOutputType | null
  }

  type GetSelfHelpInteractionGroupByPayload<T extends SelfHelpInteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SelfHelpInteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SelfHelpInteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SelfHelpInteractionGroupByOutputType[P]>
            : GetScalarType<T[P], SelfHelpInteractionGroupByOutputType[P]>
        }
      >
    >


  export type SelfHelpInteractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resourceId?: boolean
    interactionType?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    wasHelpful?: boolean
    rating?: boolean
    notes?: boolean
    moodBefore?: boolean
    moodAfter?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resource?: boolean | SelfHelpResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["selfHelpInteraction"]>

  export type SelfHelpInteractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resourceId?: boolean
    interactionType?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    wasHelpful?: boolean
    rating?: boolean
    notes?: boolean
    moodBefore?: boolean
    moodAfter?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resource?: boolean | SelfHelpResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["selfHelpInteraction"]>

  export type SelfHelpInteractionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resourceId?: boolean
    interactionType?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    wasHelpful?: boolean
    rating?: boolean
    notes?: boolean
    moodBefore?: boolean
    moodAfter?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resource?: boolean | SelfHelpResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["selfHelpInteraction"]>

  export type SelfHelpInteractionSelectScalar = {
    id?: boolean
    userId?: boolean
    resourceId?: boolean
    interactionType?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    wasHelpful?: boolean
    rating?: boolean
    notes?: boolean
    moodBefore?: boolean
    moodAfter?: boolean
  }

  export type SelfHelpInteractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "resourceId" | "interactionType" | "startedAt" | "completedAt" | "duration" | "wasHelpful" | "rating" | "notes" | "moodBefore" | "moodAfter", ExtArgs["result"]["selfHelpInteraction"]>
  export type SelfHelpInteractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resource?: boolean | SelfHelpResourceDefaultArgs<ExtArgs>
  }
  export type SelfHelpInteractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resource?: boolean | SelfHelpResourceDefaultArgs<ExtArgs>
  }
  export type SelfHelpInteractionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resource?: boolean | SelfHelpResourceDefaultArgs<ExtArgs>
  }

  export type $SelfHelpInteractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SelfHelpInteraction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      resource: Prisma.$SelfHelpResourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      resourceId: string
      interactionType: $Enums.InteractionType
      startedAt: Date
      completedAt: Date | null
      duration: number | null
      wasHelpful: boolean | null
      rating: number | null
      notes: string | null
      moodBefore: number | null
      moodAfter: number | null
    }, ExtArgs["result"]["selfHelpInteraction"]>
    composites: {}
  }

  type SelfHelpInteractionGetPayload<S extends boolean | null | undefined | SelfHelpInteractionDefaultArgs> = $Result.GetResult<Prisma.$SelfHelpInteractionPayload, S>

  type SelfHelpInteractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SelfHelpInteractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SelfHelpInteractionCountAggregateInputType | true
    }

  export interface SelfHelpInteractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SelfHelpInteraction'], meta: { name: 'SelfHelpInteraction' } }
    /**
     * Find zero or one SelfHelpInteraction that matches the filter.
     * @param {SelfHelpInteractionFindUniqueArgs} args - Arguments to find a SelfHelpInteraction
     * @example
     * // Get one SelfHelpInteraction
     * const selfHelpInteraction = await prisma.selfHelpInteraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SelfHelpInteractionFindUniqueArgs>(args: SelectSubset<T, SelfHelpInteractionFindUniqueArgs<ExtArgs>>): Prisma__SelfHelpInteractionClient<$Result.GetResult<Prisma.$SelfHelpInteractionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SelfHelpInteraction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SelfHelpInteractionFindUniqueOrThrowArgs} args - Arguments to find a SelfHelpInteraction
     * @example
     * // Get one SelfHelpInteraction
     * const selfHelpInteraction = await prisma.selfHelpInteraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SelfHelpInteractionFindUniqueOrThrowArgs>(args: SelectSubset<T, SelfHelpInteractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SelfHelpInteractionClient<$Result.GetResult<Prisma.$SelfHelpInteractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SelfHelpInteraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfHelpInteractionFindFirstArgs} args - Arguments to find a SelfHelpInteraction
     * @example
     * // Get one SelfHelpInteraction
     * const selfHelpInteraction = await prisma.selfHelpInteraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SelfHelpInteractionFindFirstArgs>(args?: SelectSubset<T, SelfHelpInteractionFindFirstArgs<ExtArgs>>): Prisma__SelfHelpInteractionClient<$Result.GetResult<Prisma.$SelfHelpInteractionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SelfHelpInteraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfHelpInteractionFindFirstOrThrowArgs} args - Arguments to find a SelfHelpInteraction
     * @example
     * // Get one SelfHelpInteraction
     * const selfHelpInteraction = await prisma.selfHelpInteraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SelfHelpInteractionFindFirstOrThrowArgs>(args?: SelectSubset<T, SelfHelpInteractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SelfHelpInteractionClient<$Result.GetResult<Prisma.$SelfHelpInteractionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SelfHelpInteractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfHelpInteractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SelfHelpInteractions
     * const selfHelpInteractions = await prisma.selfHelpInteraction.findMany()
     * 
     * // Get first 10 SelfHelpInteractions
     * const selfHelpInteractions = await prisma.selfHelpInteraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const selfHelpInteractionWithIdOnly = await prisma.selfHelpInteraction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SelfHelpInteractionFindManyArgs>(args?: SelectSubset<T, SelfHelpInteractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelfHelpInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SelfHelpInteraction.
     * @param {SelfHelpInteractionCreateArgs} args - Arguments to create a SelfHelpInteraction.
     * @example
     * // Create one SelfHelpInteraction
     * const SelfHelpInteraction = await prisma.selfHelpInteraction.create({
     *   data: {
     *     // ... data to create a SelfHelpInteraction
     *   }
     * })
     * 
     */
    create<T extends SelfHelpInteractionCreateArgs>(args: SelectSubset<T, SelfHelpInteractionCreateArgs<ExtArgs>>): Prisma__SelfHelpInteractionClient<$Result.GetResult<Prisma.$SelfHelpInteractionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SelfHelpInteractions.
     * @param {SelfHelpInteractionCreateManyArgs} args - Arguments to create many SelfHelpInteractions.
     * @example
     * // Create many SelfHelpInteractions
     * const selfHelpInteraction = await prisma.selfHelpInteraction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SelfHelpInteractionCreateManyArgs>(args?: SelectSubset<T, SelfHelpInteractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SelfHelpInteractions and returns the data saved in the database.
     * @param {SelfHelpInteractionCreateManyAndReturnArgs} args - Arguments to create many SelfHelpInteractions.
     * @example
     * // Create many SelfHelpInteractions
     * const selfHelpInteraction = await prisma.selfHelpInteraction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SelfHelpInteractions and only return the `id`
     * const selfHelpInteractionWithIdOnly = await prisma.selfHelpInteraction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SelfHelpInteractionCreateManyAndReturnArgs>(args?: SelectSubset<T, SelfHelpInteractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelfHelpInteractionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SelfHelpInteraction.
     * @param {SelfHelpInteractionDeleteArgs} args - Arguments to delete one SelfHelpInteraction.
     * @example
     * // Delete one SelfHelpInteraction
     * const SelfHelpInteraction = await prisma.selfHelpInteraction.delete({
     *   where: {
     *     // ... filter to delete one SelfHelpInteraction
     *   }
     * })
     * 
     */
    delete<T extends SelfHelpInteractionDeleteArgs>(args: SelectSubset<T, SelfHelpInteractionDeleteArgs<ExtArgs>>): Prisma__SelfHelpInteractionClient<$Result.GetResult<Prisma.$SelfHelpInteractionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SelfHelpInteraction.
     * @param {SelfHelpInteractionUpdateArgs} args - Arguments to update one SelfHelpInteraction.
     * @example
     * // Update one SelfHelpInteraction
     * const selfHelpInteraction = await prisma.selfHelpInteraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SelfHelpInteractionUpdateArgs>(args: SelectSubset<T, SelfHelpInteractionUpdateArgs<ExtArgs>>): Prisma__SelfHelpInteractionClient<$Result.GetResult<Prisma.$SelfHelpInteractionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SelfHelpInteractions.
     * @param {SelfHelpInteractionDeleteManyArgs} args - Arguments to filter SelfHelpInteractions to delete.
     * @example
     * // Delete a few SelfHelpInteractions
     * const { count } = await prisma.selfHelpInteraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SelfHelpInteractionDeleteManyArgs>(args?: SelectSubset<T, SelfHelpInteractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SelfHelpInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfHelpInteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SelfHelpInteractions
     * const selfHelpInteraction = await prisma.selfHelpInteraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SelfHelpInteractionUpdateManyArgs>(args: SelectSubset<T, SelfHelpInteractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SelfHelpInteractions and returns the data updated in the database.
     * @param {SelfHelpInteractionUpdateManyAndReturnArgs} args - Arguments to update many SelfHelpInteractions.
     * @example
     * // Update many SelfHelpInteractions
     * const selfHelpInteraction = await prisma.selfHelpInteraction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SelfHelpInteractions and only return the `id`
     * const selfHelpInteractionWithIdOnly = await prisma.selfHelpInteraction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SelfHelpInteractionUpdateManyAndReturnArgs>(args: SelectSubset<T, SelfHelpInteractionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelfHelpInteractionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SelfHelpInteraction.
     * @param {SelfHelpInteractionUpsertArgs} args - Arguments to update or create a SelfHelpInteraction.
     * @example
     * // Update or create a SelfHelpInteraction
     * const selfHelpInteraction = await prisma.selfHelpInteraction.upsert({
     *   create: {
     *     // ... data to create a SelfHelpInteraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SelfHelpInteraction we want to update
     *   }
     * })
     */
    upsert<T extends SelfHelpInteractionUpsertArgs>(args: SelectSubset<T, SelfHelpInteractionUpsertArgs<ExtArgs>>): Prisma__SelfHelpInteractionClient<$Result.GetResult<Prisma.$SelfHelpInteractionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SelfHelpInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfHelpInteractionCountArgs} args - Arguments to filter SelfHelpInteractions to count.
     * @example
     * // Count the number of SelfHelpInteractions
     * const count = await prisma.selfHelpInteraction.count({
     *   where: {
     *     // ... the filter for the SelfHelpInteractions we want to count
     *   }
     * })
    **/
    count<T extends SelfHelpInteractionCountArgs>(
      args?: Subset<T, SelfHelpInteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SelfHelpInteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SelfHelpInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfHelpInteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SelfHelpInteractionAggregateArgs>(args: Subset<T, SelfHelpInteractionAggregateArgs>): Prisma.PrismaPromise<GetSelfHelpInteractionAggregateType<T>>

    /**
     * Group by SelfHelpInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfHelpInteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SelfHelpInteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SelfHelpInteractionGroupByArgs['orderBy'] }
        : { orderBy?: SelfHelpInteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SelfHelpInteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSelfHelpInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SelfHelpInteraction model
   */
  readonly fields: SelfHelpInteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SelfHelpInteraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SelfHelpInteractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resource<T extends SelfHelpResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SelfHelpResourceDefaultArgs<ExtArgs>>): Prisma__SelfHelpResourceClient<$Result.GetResult<Prisma.$SelfHelpResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SelfHelpInteraction model
   */
  interface SelfHelpInteractionFieldRefs {
    readonly id: FieldRef<"SelfHelpInteraction", 'String'>
    readonly userId: FieldRef<"SelfHelpInteraction", 'String'>
    readonly resourceId: FieldRef<"SelfHelpInteraction", 'String'>
    readonly interactionType: FieldRef<"SelfHelpInteraction", 'InteractionType'>
    readonly startedAt: FieldRef<"SelfHelpInteraction", 'DateTime'>
    readonly completedAt: FieldRef<"SelfHelpInteraction", 'DateTime'>
    readonly duration: FieldRef<"SelfHelpInteraction", 'Int'>
    readonly wasHelpful: FieldRef<"SelfHelpInteraction", 'Boolean'>
    readonly rating: FieldRef<"SelfHelpInteraction", 'Int'>
    readonly notes: FieldRef<"SelfHelpInteraction", 'String'>
    readonly moodBefore: FieldRef<"SelfHelpInteraction", 'Int'>
    readonly moodAfter: FieldRef<"SelfHelpInteraction", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SelfHelpInteraction findUnique
   */
  export type SelfHelpInteractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpInteraction
     */
    select?: SelfHelpInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpInteraction
     */
    omit?: SelfHelpInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpInteractionInclude<ExtArgs> | null
    /**
     * Filter, which SelfHelpInteraction to fetch.
     */
    where: SelfHelpInteractionWhereUniqueInput
  }

  /**
   * SelfHelpInteraction findUniqueOrThrow
   */
  export type SelfHelpInteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpInteraction
     */
    select?: SelfHelpInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpInteraction
     */
    omit?: SelfHelpInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpInteractionInclude<ExtArgs> | null
    /**
     * Filter, which SelfHelpInteraction to fetch.
     */
    where: SelfHelpInteractionWhereUniqueInput
  }

  /**
   * SelfHelpInteraction findFirst
   */
  export type SelfHelpInteractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpInteraction
     */
    select?: SelfHelpInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpInteraction
     */
    omit?: SelfHelpInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpInteractionInclude<ExtArgs> | null
    /**
     * Filter, which SelfHelpInteraction to fetch.
     */
    where?: SelfHelpInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelfHelpInteractions to fetch.
     */
    orderBy?: SelfHelpInteractionOrderByWithRelationInput | SelfHelpInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SelfHelpInteractions.
     */
    cursor?: SelfHelpInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelfHelpInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelfHelpInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SelfHelpInteractions.
     */
    distinct?: SelfHelpInteractionScalarFieldEnum | SelfHelpInteractionScalarFieldEnum[]
  }

  /**
   * SelfHelpInteraction findFirstOrThrow
   */
  export type SelfHelpInteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpInteraction
     */
    select?: SelfHelpInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpInteraction
     */
    omit?: SelfHelpInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpInteractionInclude<ExtArgs> | null
    /**
     * Filter, which SelfHelpInteraction to fetch.
     */
    where?: SelfHelpInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelfHelpInteractions to fetch.
     */
    orderBy?: SelfHelpInteractionOrderByWithRelationInput | SelfHelpInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SelfHelpInteractions.
     */
    cursor?: SelfHelpInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelfHelpInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelfHelpInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SelfHelpInteractions.
     */
    distinct?: SelfHelpInteractionScalarFieldEnum | SelfHelpInteractionScalarFieldEnum[]
  }

  /**
   * SelfHelpInteraction findMany
   */
  export type SelfHelpInteractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpInteraction
     */
    select?: SelfHelpInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpInteraction
     */
    omit?: SelfHelpInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpInteractionInclude<ExtArgs> | null
    /**
     * Filter, which SelfHelpInteractions to fetch.
     */
    where?: SelfHelpInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelfHelpInteractions to fetch.
     */
    orderBy?: SelfHelpInteractionOrderByWithRelationInput | SelfHelpInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SelfHelpInteractions.
     */
    cursor?: SelfHelpInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelfHelpInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelfHelpInteractions.
     */
    skip?: number
    distinct?: SelfHelpInteractionScalarFieldEnum | SelfHelpInteractionScalarFieldEnum[]
  }

  /**
   * SelfHelpInteraction create
   */
  export type SelfHelpInteractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpInteraction
     */
    select?: SelfHelpInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpInteraction
     */
    omit?: SelfHelpInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpInteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a SelfHelpInteraction.
     */
    data: XOR<SelfHelpInteractionCreateInput, SelfHelpInteractionUncheckedCreateInput>
  }

  /**
   * SelfHelpInteraction createMany
   */
  export type SelfHelpInteractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SelfHelpInteractions.
     */
    data: SelfHelpInteractionCreateManyInput | SelfHelpInteractionCreateManyInput[]
  }

  /**
   * SelfHelpInteraction createManyAndReturn
   */
  export type SelfHelpInteractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpInteraction
     */
    select?: SelfHelpInteractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpInteraction
     */
    omit?: SelfHelpInteractionOmit<ExtArgs> | null
    /**
     * The data used to create many SelfHelpInteractions.
     */
    data: SelfHelpInteractionCreateManyInput | SelfHelpInteractionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpInteractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SelfHelpInteraction update
   */
  export type SelfHelpInteractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpInteraction
     */
    select?: SelfHelpInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpInteraction
     */
    omit?: SelfHelpInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpInteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a SelfHelpInteraction.
     */
    data: XOR<SelfHelpInteractionUpdateInput, SelfHelpInteractionUncheckedUpdateInput>
    /**
     * Choose, which SelfHelpInteraction to update.
     */
    where: SelfHelpInteractionWhereUniqueInput
  }

  /**
   * SelfHelpInteraction updateMany
   */
  export type SelfHelpInteractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SelfHelpInteractions.
     */
    data: XOR<SelfHelpInteractionUpdateManyMutationInput, SelfHelpInteractionUncheckedUpdateManyInput>
    /**
     * Filter which SelfHelpInteractions to update
     */
    where?: SelfHelpInteractionWhereInput
    /**
     * Limit how many SelfHelpInteractions to update.
     */
    limit?: number
  }

  /**
   * SelfHelpInteraction updateManyAndReturn
   */
  export type SelfHelpInteractionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpInteraction
     */
    select?: SelfHelpInteractionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpInteraction
     */
    omit?: SelfHelpInteractionOmit<ExtArgs> | null
    /**
     * The data used to update SelfHelpInteractions.
     */
    data: XOR<SelfHelpInteractionUpdateManyMutationInput, SelfHelpInteractionUncheckedUpdateManyInput>
    /**
     * Filter which SelfHelpInteractions to update
     */
    where?: SelfHelpInteractionWhereInput
    /**
     * Limit how many SelfHelpInteractions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpInteractionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SelfHelpInteraction upsert
   */
  export type SelfHelpInteractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpInteraction
     */
    select?: SelfHelpInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpInteraction
     */
    omit?: SelfHelpInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpInteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the SelfHelpInteraction to update in case it exists.
     */
    where: SelfHelpInteractionWhereUniqueInput
    /**
     * In case the SelfHelpInteraction found by the `where` argument doesn't exist, create a new SelfHelpInteraction with this data.
     */
    create: XOR<SelfHelpInteractionCreateInput, SelfHelpInteractionUncheckedCreateInput>
    /**
     * In case the SelfHelpInteraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SelfHelpInteractionUpdateInput, SelfHelpInteractionUncheckedUpdateInput>
  }

  /**
   * SelfHelpInteraction delete
   */
  export type SelfHelpInteractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpInteraction
     */
    select?: SelfHelpInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpInteraction
     */
    omit?: SelfHelpInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpInteractionInclude<ExtArgs> | null
    /**
     * Filter which SelfHelpInteraction to delete.
     */
    where: SelfHelpInteractionWhereUniqueInput
  }

  /**
   * SelfHelpInteraction deleteMany
   */
  export type SelfHelpInteractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SelfHelpInteractions to delete
     */
    where?: SelfHelpInteractionWhereInput
    /**
     * Limit how many SelfHelpInteractions to delete.
     */
    limit?: number
  }

  /**
   * SelfHelpInteraction without action
   */
  export type SelfHelpInteractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfHelpInteraction
     */
    select?: SelfHelpInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfHelpInteraction
     */
    omit?: SelfHelpInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfHelpInteractionInclude<ExtArgs> | null
  }


  /**
   * Model AITherapist
   */

  export type AggregateAITherapist = {
    _count: AITherapistCountAggregateOutputType | null
    _avg: AITherapistAvgAggregateOutputType | null
    _sum: AITherapistSumAggregateOutputType | null
    _min: AITherapistMinAggregateOutputType | null
    _max: AITherapistMaxAggregateOutputType | null
  }

  export type AITherapistAvgAggregateOutputType = {
    sessionsCompleted: number | null
    userRating: number | null
    responseTime: number | null
  }

  export type AITherapistSumAggregateOutputType = {
    sessionsCompleted: number | null
    userRating: number | null
    responseTime: number | null
  }

  export type AITherapistMinAggregateOutputType = {
    id: string | null
    therapistId: string | null
    name: string | null
    avatar: string | null
    personality: string | null
    description: string | null
    specialties: string | null
    approaches: string | null
    bestFor: string | null
    features: string | null
    availability: string | null
    sessionsCompleted: number | null
    userRating: number | null
    responseTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AITherapistMaxAggregateOutputType = {
    id: string | null
    therapistId: string | null
    name: string | null
    avatar: string | null
    personality: string | null
    description: string | null
    specialties: string | null
    approaches: string | null
    bestFor: string | null
    features: string | null
    availability: string | null
    sessionsCompleted: number | null
    userRating: number | null
    responseTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AITherapistCountAggregateOutputType = {
    id: number
    therapistId: number
    name: number
    avatar: number
    personality: number
    description: number
    specialties: number
    approaches: number
    bestFor: number
    features: number
    availability: number
    sessionsCompleted: number
    userRating: number
    responseTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AITherapistAvgAggregateInputType = {
    sessionsCompleted?: true
    userRating?: true
    responseTime?: true
  }

  export type AITherapistSumAggregateInputType = {
    sessionsCompleted?: true
    userRating?: true
    responseTime?: true
  }

  export type AITherapistMinAggregateInputType = {
    id?: true
    therapistId?: true
    name?: true
    avatar?: true
    personality?: true
    description?: true
    specialties?: true
    approaches?: true
    bestFor?: true
    features?: true
    availability?: true
    sessionsCompleted?: true
    userRating?: true
    responseTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AITherapistMaxAggregateInputType = {
    id?: true
    therapistId?: true
    name?: true
    avatar?: true
    personality?: true
    description?: true
    specialties?: true
    approaches?: true
    bestFor?: true
    features?: true
    availability?: true
    sessionsCompleted?: true
    userRating?: true
    responseTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AITherapistCountAggregateInputType = {
    id?: true
    therapistId?: true
    name?: true
    avatar?: true
    personality?: true
    description?: true
    specialties?: true
    approaches?: true
    bestFor?: true
    features?: true
    availability?: true
    sessionsCompleted?: true
    userRating?: true
    responseTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AITherapistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AITherapist to aggregate.
     */
    where?: AITherapistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapists to fetch.
     */
    orderBy?: AITherapistOrderByWithRelationInput | AITherapistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AITherapistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AITherapists
    **/
    _count?: true | AITherapistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AITherapistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AITherapistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AITherapistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AITherapistMaxAggregateInputType
  }

  export type GetAITherapistAggregateType<T extends AITherapistAggregateArgs> = {
        [P in keyof T & keyof AggregateAITherapist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAITherapist[P]>
      : GetScalarType<T[P], AggregateAITherapist[P]>
  }




  export type AITherapistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AITherapistWhereInput
    orderBy?: AITherapistOrderByWithAggregationInput | AITherapistOrderByWithAggregationInput[]
    by: AITherapistScalarFieldEnum[] | AITherapistScalarFieldEnum
    having?: AITherapistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AITherapistCountAggregateInputType | true
    _avg?: AITherapistAvgAggregateInputType
    _sum?: AITherapistSumAggregateInputType
    _min?: AITherapistMinAggregateInputType
    _max?: AITherapistMaxAggregateInputType
  }

  export type AITherapistGroupByOutputType = {
    id: string
    therapistId: string
    name: string
    avatar: string
    personality: string
    description: string
    specialties: string
    approaches: string
    bestFor: string
    features: string
    availability: string
    sessionsCompleted: number
    userRating: number
    responseTime: number
    createdAt: Date
    updatedAt: Date
    _count: AITherapistCountAggregateOutputType | null
    _avg: AITherapistAvgAggregateOutputType | null
    _sum: AITherapistSumAggregateOutputType | null
    _min: AITherapistMinAggregateOutputType | null
    _max: AITherapistMaxAggregateOutputType | null
  }

  type GetAITherapistGroupByPayload<T extends AITherapistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AITherapistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AITherapistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AITherapistGroupByOutputType[P]>
            : GetScalarType<T[P], AITherapistGroupByOutputType[P]>
        }
      >
    >


  export type AITherapistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    therapistId?: boolean
    name?: boolean
    avatar?: boolean
    personality?: boolean
    description?: boolean
    specialties?: boolean
    approaches?: boolean
    bestFor?: boolean
    features?: boolean
    availability?: boolean
    sessionsCompleted?: boolean
    userRating?: boolean
    responseTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | AITherapist$sessionsArgs<ExtArgs>
    personalizations?: boolean | AITherapist$personalizationsArgs<ExtArgs>
    _count?: boolean | AITherapistCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aITherapist"]>

  export type AITherapistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    therapistId?: boolean
    name?: boolean
    avatar?: boolean
    personality?: boolean
    description?: boolean
    specialties?: boolean
    approaches?: boolean
    bestFor?: boolean
    features?: boolean
    availability?: boolean
    sessionsCompleted?: boolean
    userRating?: boolean
    responseTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aITherapist"]>

  export type AITherapistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    therapistId?: boolean
    name?: boolean
    avatar?: boolean
    personality?: boolean
    description?: boolean
    specialties?: boolean
    approaches?: boolean
    bestFor?: boolean
    features?: boolean
    availability?: boolean
    sessionsCompleted?: boolean
    userRating?: boolean
    responseTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aITherapist"]>

  export type AITherapistSelectScalar = {
    id?: boolean
    therapistId?: boolean
    name?: boolean
    avatar?: boolean
    personality?: boolean
    description?: boolean
    specialties?: boolean
    approaches?: boolean
    bestFor?: boolean
    features?: boolean
    availability?: boolean
    sessionsCompleted?: boolean
    userRating?: boolean
    responseTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AITherapistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "therapistId" | "name" | "avatar" | "personality" | "description" | "specialties" | "approaches" | "bestFor" | "features" | "availability" | "sessionsCompleted" | "userRating" | "responseTime" | "createdAt" | "updatedAt", ExtArgs["result"]["aITherapist"]>
  export type AITherapistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | AITherapist$sessionsArgs<ExtArgs>
    personalizations?: boolean | AITherapist$personalizationsArgs<ExtArgs>
    _count?: boolean | AITherapistCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AITherapistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AITherapistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AITherapistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AITherapist"
    objects: {
      sessions: Prisma.$AITherapySessionPayload<ExtArgs>[]
      personalizations: Prisma.$AIPersonalizationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      therapistId: string
      name: string
      avatar: string
      personality: string
      description: string
      specialties: string
      approaches: string
      bestFor: string
      features: string
      availability: string
      sessionsCompleted: number
      userRating: number
      responseTime: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aITherapist"]>
    composites: {}
  }

  type AITherapistGetPayload<S extends boolean | null | undefined | AITherapistDefaultArgs> = $Result.GetResult<Prisma.$AITherapistPayload, S>

  type AITherapistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AITherapistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AITherapistCountAggregateInputType | true
    }

  export interface AITherapistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AITherapist'], meta: { name: 'AITherapist' } }
    /**
     * Find zero or one AITherapist that matches the filter.
     * @param {AITherapistFindUniqueArgs} args - Arguments to find a AITherapist
     * @example
     * // Get one AITherapist
     * const aITherapist = await prisma.aITherapist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AITherapistFindUniqueArgs>(args: SelectSubset<T, AITherapistFindUniqueArgs<ExtArgs>>): Prisma__AITherapistClient<$Result.GetResult<Prisma.$AITherapistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AITherapist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AITherapistFindUniqueOrThrowArgs} args - Arguments to find a AITherapist
     * @example
     * // Get one AITherapist
     * const aITherapist = await prisma.aITherapist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AITherapistFindUniqueOrThrowArgs>(args: SelectSubset<T, AITherapistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AITherapistClient<$Result.GetResult<Prisma.$AITherapistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AITherapist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapistFindFirstArgs} args - Arguments to find a AITherapist
     * @example
     * // Get one AITherapist
     * const aITherapist = await prisma.aITherapist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AITherapistFindFirstArgs>(args?: SelectSubset<T, AITherapistFindFirstArgs<ExtArgs>>): Prisma__AITherapistClient<$Result.GetResult<Prisma.$AITherapistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AITherapist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapistFindFirstOrThrowArgs} args - Arguments to find a AITherapist
     * @example
     * // Get one AITherapist
     * const aITherapist = await prisma.aITherapist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AITherapistFindFirstOrThrowArgs>(args?: SelectSubset<T, AITherapistFindFirstOrThrowArgs<ExtArgs>>): Prisma__AITherapistClient<$Result.GetResult<Prisma.$AITherapistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AITherapists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AITherapists
     * const aITherapists = await prisma.aITherapist.findMany()
     * 
     * // Get first 10 AITherapists
     * const aITherapists = await prisma.aITherapist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aITherapistWithIdOnly = await prisma.aITherapist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AITherapistFindManyArgs>(args?: SelectSubset<T, AITherapistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITherapistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AITherapist.
     * @param {AITherapistCreateArgs} args - Arguments to create a AITherapist.
     * @example
     * // Create one AITherapist
     * const AITherapist = await prisma.aITherapist.create({
     *   data: {
     *     // ... data to create a AITherapist
     *   }
     * })
     * 
     */
    create<T extends AITherapistCreateArgs>(args: SelectSubset<T, AITherapistCreateArgs<ExtArgs>>): Prisma__AITherapistClient<$Result.GetResult<Prisma.$AITherapistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AITherapists.
     * @param {AITherapistCreateManyArgs} args - Arguments to create many AITherapists.
     * @example
     * // Create many AITherapists
     * const aITherapist = await prisma.aITherapist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AITherapistCreateManyArgs>(args?: SelectSubset<T, AITherapistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AITherapists and returns the data saved in the database.
     * @param {AITherapistCreateManyAndReturnArgs} args - Arguments to create many AITherapists.
     * @example
     * // Create many AITherapists
     * const aITherapist = await prisma.aITherapist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AITherapists and only return the `id`
     * const aITherapistWithIdOnly = await prisma.aITherapist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AITherapistCreateManyAndReturnArgs>(args?: SelectSubset<T, AITherapistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITherapistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AITherapist.
     * @param {AITherapistDeleteArgs} args - Arguments to delete one AITherapist.
     * @example
     * // Delete one AITherapist
     * const AITherapist = await prisma.aITherapist.delete({
     *   where: {
     *     // ... filter to delete one AITherapist
     *   }
     * })
     * 
     */
    delete<T extends AITherapistDeleteArgs>(args: SelectSubset<T, AITherapistDeleteArgs<ExtArgs>>): Prisma__AITherapistClient<$Result.GetResult<Prisma.$AITherapistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AITherapist.
     * @param {AITherapistUpdateArgs} args - Arguments to update one AITherapist.
     * @example
     * // Update one AITherapist
     * const aITherapist = await prisma.aITherapist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AITherapistUpdateArgs>(args: SelectSubset<T, AITherapistUpdateArgs<ExtArgs>>): Prisma__AITherapistClient<$Result.GetResult<Prisma.$AITherapistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AITherapists.
     * @param {AITherapistDeleteManyArgs} args - Arguments to filter AITherapists to delete.
     * @example
     * // Delete a few AITherapists
     * const { count } = await prisma.aITherapist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AITherapistDeleteManyArgs>(args?: SelectSubset<T, AITherapistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AITherapists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AITherapists
     * const aITherapist = await prisma.aITherapist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AITherapistUpdateManyArgs>(args: SelectSubset<T, AITherapistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AITherapists and returns the data updated in the database.
     * @param {AITherapistUpdateManyAndReturnArgs} args - Arguments to update many AITherapists.
     * @example
     * // Update many AITherapists
     * const aITherapist = await prisma.aITherapist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AITherapists and only return the `id`
     * const aITherapistWithIdOnly = await prisma.aITherapist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AITherapistUpdateManyAndReturnArgs>(args: SelectSubset<T, AITherapistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITherapistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AITherapist.
     * @param {AITherapistUpsertArgs} args - Arguments to update or create a AITherapist.
     * @example
     * // Update or create a AITherapist
     * const aITherapist = await prisma.aITherapist.upsert({
     *   create: {
     *     // ... data to create a AITherapist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AITherapist we want to update
     *   }
     * })
     */
    upsert<T extends AITherapistUpsertArgs>(args: SelectSubset<T, AITherapistUpsertArgs<ExtArgs>>): Prisma__AITherapistClient<$Result.GetResult<Prisma.$AITherapistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AITherapists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapistCountArgs} args - Arguments to filter AITherapists to count.
     * @example
     * // Count the number of AITherapists
     * const count = await prisma.aITherapist.count({
     *   where: {
     *     // ... the filter for the AITherapists we want to count
     *   }
     * })
    **/
    count<T extends AITherapistCountArgs>(
      args?: Subset<T, AITherapistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AITherapistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AITherapist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AITherapistAggregateArgs>(args: Subset<T, AITherapistAggregateArgs>): Prisma.PrismaPromise<GetAITherapistAggregateType<T>>

    /**
     * Group by AITherapist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AITherapistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AITherapistGroupByArgs['orderBy'] }
        : { orderBy?: AITherapistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AITherapistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAITherapistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AITherapist model
   */
  readonly fields: AITherapistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AITherapist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AITherapistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends AITherapist$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, AITherapist$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITherapySessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    personalizations<T extends AITherapist$personalizationsArgs<ExtArgs> = {}>(args?: Subset<T, AITherapist$personalizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIPersonalizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AITherapist model
   */
  interface AITherapistFieldRefs {
    readonly id: FieldRef<"AITherapist", 'String'>
    readonly therapistId: FieldRef<"AITherapist", 'String'>
    readonly name: FieldRef<"AITherapist", 'String'>
    readonly avatar: FieldRef<"AITherapist", 'String'>
    readonly personality: FieldRef<"AITherapist", 'String'>
    readonly description: FieldRef<"AITherapist", 'String'>
    readonly specialties: FieldRef<"AITherapist", 'String'>
    readonly approaches: FieldRef<"AITherapist", 'String'>
    readonly bestFor: FieldRef<"AITherapist", 'String'>
    readonly features: FieldRef<"AITherapist", 'String'>
    readonly availability: FieldRef<"AITherapist", 'String'>
    readonly sessionsCompleted: FieldRef<"AITherapist", 'Int'>
    readonly userRating: FieldRef<"AITherapist", 'Float'>
    readonly responseTime: FieldRef<"AITherapist", 'Float'>
    readonly createdAt: FieldRef<"AITherapist", 'DateTime'>
    readonly updatedAt: FieldRef<"AITherapist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AITherapist findUnique
   */
  export type AITherapistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapist
     */
    select?: AITherapistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapist
     */
    omit?: AITherapistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapistInclude<ExtArgs> | null
    /**
     * Filter, which AITherapist to fetch.
     */
    where: AITherapistWhereUniqueInput
  }

  /**
   * AITherapist findUniqueOrThrow
   */
  export type AITherapistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapist
     */
    select?: AITherapistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapist
     */
    omit?: AITherapistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapistInclude<ExtArgs> | null
    /**
     * Filter, which AITherapist to fetch.
     */
    where: AITherapistWhereUniqueInput
  }

  /**
   * AITherapist findFirst
   */
  export type AITherapistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapist
     */
    select?: AITherapistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapist
     */
    omit?: AITherapistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapistInclude<ExtArgs> | null
    /**
     * Filter, which AITherapist to fetch.
     */
    where?: AITherapistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapists to fetch.
     */
    orderBy?: AITherapistOrderByWithRelationInput | AITherapistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AITherapists.
     */
    cursor?: AITherapistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AITherapists.
     */
    distinct?: AITherapistScalarFieldEnum | AITherapistScalarFieldEnum[]
  }

  /**
   * AITherapist findFirstOrThrow
   */
  export type AITherapistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapist
     */
    select?: AITherapistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapist
     */
    omit?: AITherapistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapistInclude<ExtArgs> | null
    /**
     * Filter, which AITherapist to fetch.
     */
    where?: AITherapistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapists to fetch.
     */
    orderBy?: AITherapistOrderByWithRelationInput | AITherapistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AITherapists.
     */
    cursor?: AITherapistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AITherapists.
     */
    distinct?: AITherapistScalarFieldEnum | AITherapistScalarFieldEnum[]
  }

  /**
   * AITherapist findMany
   */
  export type AITherapistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapist
     */
    select?: AITherapistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapist
     */
    omit?: AITherapistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapistInclude<ExtArgs> | null
    /**
     * Filter, which AITherapists to fetch.
     */
    where?: AITherapistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapists to fetch.
     */
    orderBy?: AITherapistOrderByWithRelationInput | AITherapistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AITherapists.
     */
    cursor?: AITherapistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapists.
     */
    skip?: number
    distinct?: AITherapistScalarFieldEnum | AITherapistScalarFieldEnum[]
  }

  /**
   * AITherapist create
   */
  export type AITherapistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapist
     */
    select?: AITherapistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapist
     */
    omit?: AITherapistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapistInclude<ExtArgs> | null
    /**
     * The data needed to create a AITherapist.
     */
    data: XOR<AITherapistCreateInput, AITherapistUncheckedCreateInput>
  }

  /**
   * AITherapist createMany
   */
  export type AITherapistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AITherapists.
     */
    data: AITherapistCreateManyInput | AITherapistCreateManyInput[]
  }

  /**
   * AITherapist createManyAndReturn
   */
  export type AITherapistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapist
     */
    select?: AITherapistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapist
     */
    omit?: AITherapistOmit<ExtArgs> | null
    /**
     * The data used to create many AITherapists.
     */
    data: AITherapistCreateManyInput | AITherapistCreateManyInput[]
  }

  /**
   * AITherapist update
   */
  export type AITherapistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapist
     */
    select?: AITherapistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapist
     */
    omit?: AITherapistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapistInclude<ExtArgs> | null
    /**
     * The data needed to update a AITherapist.
     */
    data: XOR<AITherapistUpdateInput, AITherapistUncheckedUpdateInput>
    /**
     * Choose, which AITherapist to update.
     */
    where: AITherapistWhereUniqueInput
  }

  /**
   * AITherapist updateMany
   */
  export type AITherapistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AITherapists.
     */
    data: XOR<AITherapistUpdateManyMutationInput, AITherapistUncheckedUpdateManyInput>
    /**
     * Filter which AITherapists to update
     */
    where?: AITherapistWhereInput
    /**
     * Limit how many AITherapists to update.
     */
    limit?: number
  }

  /**
   * AITherapist updateManyAndReturn
   */
  export type AITherapistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapist
     */
    select?: AITherapistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapist
     */
    omit?: AITherapistOmit<ExtArgs> | null
    /**
     * The data used to update AITherapists.
     */
    data: XOR<AITherapistUpdateManyMutationInput, AITherapistUncheckedUpdateManyInput>
    /**
     * Filter which AITherapists to update
     */
    where?: AITherapistWhereInput
    /**
     * Limit how many AITherapists to update.
     */
    limit?: number
  }

  /**
   * AITherapist upsert
   */
  export type AITherapistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapist
     */
    select?: AITherapistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapist
     */
    omit?: AITherapistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapistInclude<ExtArgs> | null
    /**
     * The filter to search for the AITherapist to update in case it exists.
     */
    where: AITherapistWhereUniqueInput
    /**
     * In case the AITherapist found by the `where` argument doesn't exist, create a new AITherapist with this data.
     */
    create: XOR<AITherapistCreateInput, AITherapistUncheckedCreateInput>
    /**
     * In case the AITherapist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AITherapistUpdateInput, AITherapistUncheckedUpdateInput>
  }

  /**
   * AITherapist delete
   */
  export type AITherapistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapist
     */
    select?: AITherapistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapist
     */
    omit?: AITherapistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapistInclude<ExtArgs> | null
    /**
     * Filter which AITherapist to delete.
     */
    where: AITherapistWhereUniqueInput
  }

  /**
   * AITherapist deleteMany
   */
  export type AITherapistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AITherapists to delete
     */
    where?: AITherapistWhereInput
    /**
     * Limit how many AITherapists to delete.
     */
    limit?: number
  }

  /**
   * AITherapist.sessions
   */
  export type AITherapist$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapySession
     */
    select?: AITherapySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapySession
     */
    omit?: AITherapySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapySessionInclude<ExtArgs> | null
    where?: AITherapySessionWhereInput
    orderBy?: AITherapySessionOrderByWithRelationInput | AITherapySessionOrderByWithRelationInput[]
    cursor?: AITherapySessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AITherapySessionScalarFieldEnum | AITherapySessionScalarFieldEnum[]
  }

  /**
   * AITherapist.personalizations
   */
  export type AITherapist$personalizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPersonalization
     */
    select?: AIPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPersonalization
     */
    omit?: AIPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPersonalizationInclude<ExtArgs> | null
    where?: AIPersonalizationWhereInput
    orderBy?: AIPersonalizationOrderByWithRelationInput | AIPersonalizationOrderByWithRelationInput[]
    cursor?: AIPersonalizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIPersonalizationScalarFieldEnum | AIPersonalizationScalarFieldEnum[]
  }

  /**
   * AITherapist without action
   */
  export type AITherapistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapist
     */
    select?: AITherapistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapist
     */
    omit?: AITherapistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapistInclude<ExtArgs> | null
  }


  /**
   * Model AITherapySession
   */

  export type AggregateAITherapySession = {
    _count: AITherapySessionCountAggregateOutputType | null
    _avg: AITherapySessionAvgAggregateOutputType | null
    _sum: AITherapySessionSumAggregateOutputType | null
    _min: AITherapySessionMinAggregateOutputType | null
    _max: AITherapySessionMaxAggregateOutputType | null
  }

  export type AITherapySessionAvgAggregateOutputType = {
    duration: number | null
    pausedDuration: number | null
    moodBefore: number | null
    moodAfter: number | null
    anxietyBefore: number | null
    anxietyAfter: number | null
    energyBefore: number | null
    energyAfter: number | null
    crisisLevel: number | null
  }

  export type AITherapySessionSumAggregateOutputType = {
    duration: number | null
    pausedDuration: number | null
    moodBefore: number | null
    moodAfter: number | null
    anxietyBefore: number | null
    anxietyAfter: number | null
    energyBefore: number | null
    energyAfter: number | null
    crisisLevel: number | null
  }

  export type AITherapySessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    therapistId: string | null
    sessionType: $Enums.AISessionType | null
    status: $Enums.AISessionStatus | null
    startedAt: Date | null
    endedAt: Date | null
    duration: number | null
    pausedAt: Date | null
    pausedDuration: number | null
    moodBefore: number | null
    moodAfter: number | null
    anxietyBefore: number | null
    anxietyAfter: number | null
    energyBefore: number | null
    energyAfter: number | null
    encryptedNotes: Uint8Array | null
    encryptedInsights: Uint8Array | null
    encryptedHomework: Uint8Array | null
    encryptedGoals: Uint8Array | null
    topics: string | null
    techniques: string | null
    interventions: string | null
    breakthroughs: string | null
    crisisDetected: boolean | null
    crisisLevel: number | null
    crisisInterventions: string | null
  }

  export type AITherapySessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    therapistId: string | null
    sessionType: $Enums.AISessionType | null
    status: $Enums.AISessionStatus | null
    startedAt: Date | null
    endedAt: Date | null
    duration: number | null
    pausedAt: Date | null
    pausedDuration: number | null
    moodBefore: number | null
    moodAfter: number | null
    anxietyBefore: number | null
    anxietyAfter: number | null
    energyBefore: number | null
    energyAfter: number | null
    encryptedNotes: Uint8Array | null
    encryptedInsights: Uint8Array | null
    encryptedHomework: Uint8Array | null
    encryptedGoals: Uint8Array | null
    topics: string | null
    techniques: string | null
    interventions: string | null
    breakthroughs: string | null
    crisisDetected: boolean | null
    crisisLevel: number | null
    crisisInterventions: string | null
  }

  export type AITherapySessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    therapistId: number
    sessionType: number
    status: number
    startedAt: number
    endedAt: number
    duration: number
    pausedAt: number
    pausedDuration: number
    moodBefore: number
    moodAfter: number
    anxietyBefore: number
    anxietyAfter: number
    energyBefore: number
    energyAfter: number
    encryptedNotes: number
    encryptedInsights: number
    encryptedHomework: number
    encryptedGoals: number
    topics: number
    techniques: number
    interventions: number
    breakthroughs: number
    crisisDetected: number
    crisisLevel: number
    crisisInterventions: number
    _all: number
  }


  export type AITherapySessionAvgAggregateInputType = {
    duration?: true
    pausedDuration?: true
    moodBefore?: true
    moodAfter?: true
    anxietyBefore?: true
    anxietyAfter?: true
    energyBefore?: true
    energyAfter?: true
    crisisLevel?: true
  }

  export type AITherapySessionSumAggregateInputType = {
    duration?: true
    pausedDuration?: true
    moodBefore?: true
    moodAfter?: true
    anxietyBefore?: true
    anxietyAfter?: true
    energyBefore?: true
    energyAfter?: true
    crisisLevel?: true
  }

  export type AITherapySessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    therapistId?: true
    sessionType?: true
    status?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    pausedAt?: true
    pausedDuration?: true
    moodBefore?: true
    moodAfter?: true
    anxietyBefore?: true
    anxietyAfter?: true
    energyBefore?: true
    energyAfter?: true
    encryptedNotes?: true
    encryptedInsights?: true
    encryptedHomework?: true
    encryptedGoals?: true
    topics?: true
    techniques?: true
    interventions?: true
    breakthroughs?: true
    crisisDetected?: true
    crisisLevel?: true
    crisisInterventions?: true
  }

  export type AITherapySessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    therapistId?: true
    sessionType?: true
    status?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    pausedAt?: true
    pausedDuration?: true
    moodBefore?: true
    moodAfter?: true
    anxietyBefore?: true
    anxietyAfter?: true
    energyBefore?: true
    energyAfter?: true
    encryptedNotes?: true
    encryptedInsights?: true
    encryptedHomework?: true
    encryptedGoals?: true
    topics?: true
    techniques?: true
    interventions?: true
    breakthroughs?: true
    crisisDetected?: true
    crisisLevel?: true
    crisisInterventions?: true
  }

  export type AITherapySessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    therapistId?: true
    sessionType?: true
    status?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    pausedAt?: true
    pausedDuration?: true
    moodBefore?: true
    moodAfter?: true
    anxietyBefore?: true
    anxietyAfter?: true
    energyBefore?: true
    energyAfter?: true
    encryptedNotes?: true
    encryptedInsights?: true
    encryptedHomework?: true
    encryptedGoals?: true
    topics?: true
    techniques?: true
    interventions?: true
    breakthroughs?: true
    crisisDetected?: true
    crisisLevel?: true
    crisisInterventions?: true
    _all?: true
  }

  export type AITherapySessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AITherapySession to aggregate.
     */
    where?: AITherapySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapySessions to fetch.
     */
    orderBy?: AITherapySessionOrderByWithRelationInput | AITherapySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AITherapySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AITherapySessions
    **/
    _count?: true | AITherapySessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AITherapySessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AITherapySessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AITherapySessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AITherapySessionMaxAggregateInputType
  }

  export type GetAITherapySessionAggregateType<T extends AITherapySessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAITherapySession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAITherapySession[P]>
      : GetScalarType<T[P], AggregateAITherapySession[P]>
  }




  export type AITherapySessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AITherapySessionWhereInput
    orderBy?: AITherapySessionOrderByWithAggregationInput | AITherapySessionOrderByWithAggregationInput[]
    by: AITherapySessionScalarFieldEnum[] | AITherapySessionScalarFieldEnum
    having?: AITherapySessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AITherapySessionCountAggregateInputType | true
    _avg?: AITherapySessionAvgAggregateInputType
    _sum?: AITherapySessionSumAggregateInputType
    _min?: AITherapySessionMinAggregateInputType
    _max?: AITherapySessionMaxAggregateInputType
  }

  export type AITherapySessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    therapistId: string
    sessionType: $Enums.AISessionType
    status: $Enums.AISessionStatus
    startedAt: Date
    endedAt: Date | null
    duration: number | null
    pausedAt: Date | null
    pausedDuration: number
    moodBefore: number | null
    moodAfter: number | null
    anxietyBefore: number | null
    anxietyAfter: number | null
    energyBefore: number | null
    energyAfter: number | null
    encryptedNotes: Uint8Array | null
    encryptedInsights: Uint8Array | null
    encryptedHomework: Uint8Array | null
    encryptedGoals: Uint8Array | null
    topics: string | null
    techniques: string | null
    interventions: string | null
    breakthroughs: string | null
    crisisDetected: boolean
    crisisLevel: number | null
    crisisInterventions: string | null
    _count: AITherapySessionCountAggregateOutputType | null
    _avg: AITherapySessionAvgAggregateOutputType | null
    _sum: AITherapySessionSumAggregateOutputType | null
    _min: AITherapySessionMinAggregateOutputType | null
    _max: AITherapySessionMaxAggregateOutputType | null
  }

  type GetAITherapySessionGroupByPayload<T extends AITherapySessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AITherapySessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AITherapySessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AITherapySessionGroupByOutputType[P]>
            : GetScalarType<T[P], AITherapySessionGroupByOutputType[P]>
        }
      >
    >


  export type AITherapySessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    therapistId?: boolean
    sessionType?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    pausedAt?: boolean
    pausedDuration?: boolean
    moodBefore?: boolean
    moodAfter?: boolean
    anxietyBefore?: boolean
    anxietyAfter?: boolean
    energyBefore?: boolean
    energyAfter?: boolean
    encryptedNotes?: boolean
    encryptedInsights?: boolean
    encryptedHomework?: boolean
    encryptedGoals?: boolean
    topics?: boolean
    techniques?: boolean
    interventions?: boolean
    breakthroughs?: boolean
    crisisDetected?: boolean
    crisisLevel?: boolean
    crisisInterventions?: boolean
    therapist?: boolean | AITherapistDefaultArgs<ExtArgs>
    messages?: boolean | AITherapySession$messagesArgs<ExtArgs>
    exercises?: boolean | AITherapySession$exercisesArgs<ExtArgs>
    _count?: boolean | AITherapySessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aITherapySession"]>

  export type AITherapySessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    therapistId?: boolean
    sessionType?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    pausedAt?: boolean
    pausedDuration?: boolean
    moodBefore?: boolean
    moodAfter?: boolean
    anxietyBefore?: boolean
    anxietyAfter?: boolean
    energyBefore?: boolean
    energyAfter?: boolean
    encryptedNotes?: boolean
    encryptedInsights?: boolean
    encryptedHomework?: boolean
    encryptedGoals?: boolean
    topics?: boolean
    techniques?: boolean
    interventions?: boolean
    breakthroughs?: boolean
    crisisDetected?: boolean
    crisisLevel?: boolean
    crisisInterventions?: boolean
    therapist?: boolean | AITherapistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aITherapySession"]>

  export type AITherapySessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    therapistId?: boolean
    sessionType?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    pausedAt?: boolean
    pausedDuration?: boolean
    moodBefore?: boolean
    moodAfter?: boolean
    anxietyBefore?: boolean
    anxietyAfter?: boolean
    energyBefore?: boolean
    energyAfter?: boolean
    encryptedNotes?: boolean
    encryptedInsights?: boolean
    encryptedHomework?: boolean
    encryptedGoals?: boolean
    topics?: boolean
    techniques?: boolean
    interventions?: boolean
    breakthroughs?: boolean
    crisisDetected?: boolean
    crisisLevel?: boolean
    crisisInterventions?: boolean
    therapist?: boolean | AITherapistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aITherapySession"]>

  export type AITherapySessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    therapistId?: boolean
    sessionType?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    pausedAt?: boolean
    pausedDuration?: boolean
    moodBefore?: boolean
    moodAfter?: boolean
    anxietyBefore?: boolean
    anxietyAfter?: boolean
    energyBefore?: boolean
    energyAfter?: boolean
    encryptedNotes?: boolean
    encryptedInsights?: boolean
    encryptedHomework?: boolean
    encryptedGoals?: boolean
    topics?: boolean
    techniques?: boolean
    interventions?: boolean
    breakthroughs?: boolean
    crisisDetected?: boolean
    crisisLevel?: boolean
    crisisInterventions?: boolean
  }

  export type AITherapySessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "therapistId" | "sessionType" | "status" | "startedAt" | "endedAt" | "duration" | "pausedAt" | "pausedDuration" | "moodBefore" | "moodAfter" | "anxietyBefore" | "anxietyAfter" | "energyBefore" | "energyAfter" | "encryptedNotes" | "encryptedInsights" | "encryptedHomework" | "encryptedGoals" | "topics" | "techniques" | "interventions" | "breakthroughs" | "crisisDetected" | "crisisLevel" | "crisisInterventions", ExtArgs["result"]["aITherapySession"]>
  export type AITherapySessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    therapist?: boolean | AITherapistDefaultArgs<ExtArgs>
    messages?: boolean | AITherapySession$messagesArgs<ExtArgs>
    exercises?: boolean | AITherapySession$exercisesArgs<ExtArgs>
    _count?: boolean | AITherapySessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AITherapySessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    therapist?: boolean | AITherapistDefaultArgs<ExtArgs>
  }
  export type AITherapySessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    therapist?: boolean | AITherapistDefaultArgs<ExtArgs>
  }

  export type $AITherapySessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AITherapySession"
    objects: {
      therapist: Prisma.$AITherapistPayload<ExtArgs>
      messages: Prisma.$AITherapyMessagePayload<ExtArgs>[]
      exercises: Prisma.$AIExerciseSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      therapistId: string
      sessionType: $Enums.AISessionType
      status: $Enums.AISessionStatus
      startedAt: Date
      endedAt: Date | null
      duration: number | null
      pausedAt: Date | null
      pausedDuration: number
      moodBefore: number | null
      moodAfter: number | null
      anxietyBefore: number | null
      anxietyAfter: number | null
      energyBefore: number | null
      energyAfter: number | null
      encryptedNotes: Uint8Array | null
      encryptedInsights: Uint8Array | null
      encryptedHomework: Uint8Array | null
      encryptedGoals: Uint8Array | null
      topics: string | null
      techniques: string | null
      interventions: string | null
      breakthroughs: string | null
      crisisDetected: boolean
      crisisLevel: number | null
      crisisInterventions: string | null
    }, ExtArgs["result"]["aITherapySession"]>
    composites: {}
  }

  type AITherapySessionGetPayload<S extends boolean | null | undefined | AITherapySessionDefaultArgs> = $Result.GetResult<Prisma.$AITherapySessionPayload, S>

  type AITherapySessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AITherapySessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AITherapySessionCountAggregateInputType | true
    }

  export interface AITherapySessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AITherapySession'], meta: { name: 'AITherapySession' } }
    /**
     * Find zero or one AITherapySession that matches the filter.
     * @param {AITherapySessionFindUniqueArgs} args - Arguments to find a AITherapySession
     * @example
     * // Get one AITherapySession
     * const aITherapySession = await prisma.aITherapySession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AITherapySessionFindUniqueArgs>(args: SelectSubset<T, AITherapySessionFindUniqueArgs<ExtArgs>>): Prisma__AITherapySessionClient<$Result.GetResult<Prisma.$AITherapySessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AITherapySession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AITherapySessionFindUniqueOrThrowArgs} args - Arguments to find a AITherapySession
     * @example
     * // Get one AITherapySession
     * const aITherapySession = await prisma.aITherapySession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AITherapySessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AITherapySessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AITherapySessionClient<$Result.GetResult<Prisma.$AITherapySessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AITherapySession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapySessionFindFirstArgs} args - Arguments to find a AITherapySession
     * @example
     * // Get one AITherapySession
     * const aITherapySession = await prisma.aITherapySession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AITherapySessionFindFirstArgs>(args?: SelectSubset<T, AITherapySessionFindFirstArgs<ExtArgs>>): Prisma__AITherapySessionClient<$Result.GetResult<Prisma.$AITherapySessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AITherapySession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapySessionFindFirstOrThrowArgs} args - Arguments to find a AITherapySession
     * @example
     * // Get one AITherapySession
     * const aITherapySession = await prisma.aITherapySession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AITherapySessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AITherapySessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AITherapySessionClient<$Result.GetResult<Prisma.$AITherapySessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AITherapySessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapySessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AITherapySessions
     * const aITherapySessions = await prisma.aITherapySession.findMany()
     * 
     * // Get first 10 AITherapySessions
     * const aITherapySessions = await prisma.aITherapySession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aITherapySessionWithIdOnly = await prisma.aITherapySession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AITherapySessionFindManyArgs>(args?: SelectSubset<T, AITherapySessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITherapySessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AITherapySession.
     * @param {AITherapySessionCreateArgs} args - Arguments to create a AITherapySession.
     * @example
     * // Create one AITherapySession
     * const AITherapySession = await prisma.aITherapySession.create({
     *   data: {
     *     // ... data to create a AITherapySession
     *   }
     * })
     * 
     */
    create<T extends AITherapySessionCreateArgs>(args: SelectSubset<T, AITherapySessionCreateArgs<ExtArgs>>): Prisma__AITherapySessionClient<$Result.GetResult<Prisma.$AITherapySessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AITherapySessions.
     * @param {AITherapySessionCreateManyArgs} args - Arguments to create many AITherapySessions.
     * @example
     * // Create many AITherapySessions
     * const aITherapySession = await prisma.aITherapySession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AITherapySessionCreateManyArgs>(args?: SelectSubset<T, AITherapySessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AITherapySessions and returns the data saved in the database.
     * @param {AITherapySessionCreateManyAndReturnArgs} args - Arguments to create many AITherapySessions.
     * @example
     * // Create many AITherapySessions
     * const aITherapySession = await prisma.aITherapySession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AITherapySessions and only return the `id`
     * const aITherapySessionWithIdOnly = await prisma.aITherapySession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AITherapySessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AITherapySessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITherapySessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AITherapySession.
     * @param {AITherapySessionDeleteArgs} args - Arguments to delete one AITherapySession.
     * @example
     * // Delete one AITherapySession
     * const AITherapySession = await prisma.aITherapySession.delete({
     *   where: {
     *     // ... filter to delete one AITherapySession
     *   }
     * })
     * 
     */
    delete<T extends AITherapySessionDeleteArgs>(args: SelectSubset<T, AITherapySessionDeleteArgs<ExtArgs>>): Prisma__AITherapySessionClient<$Result.GetResult<Prisma.$AITherapySessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AITherapySession.
     * @param {AITherapySessionUpdateArgs} args - Arguments to update one AITherapySession.
     * @example
     * // Update one AITherapySession
     * const aITherapySession = await prisma.aITherapySession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AITherapySessionUpdateArgs>(args: SelectSubset<T, AITherapySessionUpdateArgs<ExtArgs>>): Prisma__AITherapySessionClient<$Result.GetResult<Prisma.$AITherapySessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AITherapySessions.
     * @param {AITherapySessionDeleteManyArgs} args - Arguments to filter AITherapySessions to delete.
     * @example
     * // Delete a few AITherapySessions
     * const { count } = await prisma.aITherapySession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AITherapySessionDeleteManyArgs>(args?: SelectSubset<T, AITherapySessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AITherapySessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapySessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AITherapySessions
     * const aITherapySession = await prisma.aITherapySession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AITherapySessionUpdateManyArgs>(args: SelectSubset<T, AITherapySessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AITherapySessions and returns the data updated in the database.
     * @param {AITherapySessionUpdateManyAndReturnArgs} args - Arguments to update many AITherapySessions.
     * @example
     * // Update many AITherapySessions
     * const aITherapySession = await prisma.aITherapySession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AITherapySessions and only return the `id`
     * const aITherapySessionWithIdOnly = await prisma.aITherapySession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AITherapySessionUpdateManyAndReturnArgs>(args: SelectSubset<T, AITherapySessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITherapySessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AITherapySession.
     * @param {AITherapySessionUpsertArgs} args - Arguments to update or create a AITherapySession.
     * @example
     * // Update or create a AITherapySession
     * const aITherapySession = await prisma.aITherapySession.upsert({
     *   create: {
     *     // ... data to create a AITherapySession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AITherapySession we want to update
     *   }
     * })
     */
    upsert<T extends AITherapySessionUpsertArgs>(args: SelectSubset<T, AITherapySessionUpsertArgs<ExtArgs>>): Prisma__AITherapySessionClient<$Result.GetResult<Prisma.$AITherapySessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AITherapySessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapySessionCountArgs} args - Arguments to filter AITherapySessions to count.
     * @example
     * // Count the number of AITherapySessions
     * const count = await prisma.aITherapySession.count({
     *   where: {
     *     // ... the filter for the AITherapySessions we want to count
     *   }
     * })
    **/
    count<T extends AITherapySessionCountArgs>(
      args?: Subset<T, AITherapySessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AITherapySessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AITherapySession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapySessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AITherapySessionAggregateArgs>(args: Subset<T, AITherapySessionAggregateArgs>): Prisma.PrismaPromise<GetAITherapySessionAggregateType<T>>

    /**
     * Group by AITherapySession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapySessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AITherapySessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AITherapySessionGroupByArgs['orderBy'] }
        : { orderBy?: AITherapySessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AITherapySessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAITherapySessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AITherapySession model
   */
  readonly fields: AITherapySessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AITherapySession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AITherapySessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    therapist<T extends AITherapistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AITherapistDefaultArgs<ExtArgs>>): Prisma__AITherapistClient<$Result.GetResult<Prisma.$AITherapistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends AITherapySession$messagesArgs<ExtArgs> = {}>(args?: Subset<T, AITherapySession$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITherapyMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exercises<T extends AITherapySession$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, AITherapySession$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIExerciseSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AITherapySession model
   */
  interface AITherapySessionFieldRefs {
    readonly id: FieldRef<"AITherapySession", 'String'>
    readonly sessionToken: FieldRef<"AITherapySession", 'String'>
    readonly userId: FieldRef<"AITherapySession", 'String'>
    readonly therapistId: FieldRef<"AITherapySession", 'String'>
    readonly sessionType: FieldRef<"AITherapySession", 'AISessionType'>
    readonly status: FieldRef<"AITherapySession", 'AISessionStatus'>
    readonly startedAt: FieldRef<"AITherapySession", 'DateTime'>
    readonly endedAt: FieldRef<"AITherapySession", 'DateTime'>
    readonly duration: FieldRef<"AITherapySession", 'Int'>
    readonly pausedAt: FieldRef<"AITherapySession", 'DateTime'>
    readonly pausedDuration: FieldRef<"AITherapySession", 'Int'>
    readonly moodBefore: FieldRef<"AITherapySession", 'Int'>
    readonly moodAfter: FieldRef<"AITherapySession", 'Int'>
    readonly anxietyBefore: FieldRef<"AITherapySession", 'Int'>
    readonly anxietyAfter: FieldRef<"AITherapySession", 'Int'>
    readonly energyBefore: FieldRef<"AITherapySession", 'Int'>
    readonly energyAfter: FieldRef<"AITherapySession", 'Int'>
    readonly encryptedNotes: FieldRef<"AITherapySession", 'Bytes'>
    readonly encryptedInsights: FieldRef<"AITherapySession", 'Bytes'>
    readonly encryptedHomework: FieldRef<"AITherapySession", 'Bytes'>
    readonly encryptedGoals: FieldRef<"AITherapySession", 'Bytes'>
    readonly topics: FieldRef<"AITherapySession", 'String'>
    readonly techniques: FieldRef<"AITherapySession", 'String'>
    readonly interventions: FieldRef<"AITherapySession", 'String'>
    readonly breakthroughs: FieldRef<"AITherapySession", 'String'>
    readonly crisisDetected: FieldRef<"AITherapySession", 'Boolean'>
    readonly crisisLevel: FieldRef<"AITherapySession", 'Int'>
    readonly crisisInterventions: FieldRef<"AITherapySession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AITherapySession findUnique
   */
  export type AITherapySessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapySession
     */
    select?: AITherapySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapySession
     */
    omit?: AITherapySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapySessionInclude<ExtArgs> | null
    /**
     * Filter, which AITherapySession to fetch.
     */
    where: AITherapySessionWhereUniqueInput
  }

  /**
   * AITherapySession findUniqueOrThrow
   */
  export type AITherapySessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapySession
     */
    select?: AITherapySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapySession
     */
    omit?: AITherapySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapySessionInclude<ExtArgs> | null
    /**
     * Filter, which AITherapySession to fetch.
     */
    where: AITherapySessionWhereUniqueInput
  }

  /**
   * AITherapySession findFirst
   */
  export type AITherapySessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapySession
     */
    select?: AITherapySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapySession
     */
    omit?: AITherapySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapySessionInclude<ExtArgs> | null
    /**
     * Filter, which AITherapySession to fetch.
     */
    where?: AITherapySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapySessions to fetch.
     */
    orderBy?: AITherapySessionOrderByWithRelationInput | AITherapySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AITherapySessions.
     */
    cursor?: AITherapySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AITherapySessions.
     */
    distinct?: AITherapySessionScalarFieldEnum | AITherapySessionScalarFieldEnum[]
  }

  /**
   * AITherapySession findFirstOrThrow
   */
  export type AITherapySessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapySession
     */
    select?: AITherapySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapySession
     */
    omit?: AITherapySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapySessionInclude<ExtArgs> | null
    /**
     * Filter, which AITherapySession to fetch.
     */
    where?: AITherapySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapySessions to fetch.
     */
    orderBy?: AITherapySessionOrderByWithRelationInput | AITherapySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AITherapySessions.
     */
    cursor?: AITherapySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AITherapySessions.
     */
    distinct?: AITherapySessionScalarFieldEnum | AITherapySessionScalarFieldEnum[]
  }

  /**
   * AITherapySession findMany
   */
  export type AITherapySessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapySession
     */
    select?: AITherapySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapySession
     */
    omit?: AITherapySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapySessionInclude<ExtArgs> | null
    /**
     * Filter, which AITherapySessions to fetch.
     */
    where?: AITherapySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapySessions to fetch.
     */
    orderBy?: AITherapySessionOrderByWithRelationInput | AITherapySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AITherapySessions.
     */
    cursor?: AITherapySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapySessions.
     */
    skip?: number
    distinct?: AITherapySessionScalarFieldEnum | AITherapySessionScalarFieldEnum[]
  }

  /**
   * AITherapySession create
   */
  export type AITherapySessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapySession
     */
    select?: AITherapySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapySession
     */
    omit?: AITherapySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapySessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AITherapySession.
     */
    data: XOR<AITherapySessionCreateInput, AITherapySessionUncheckedCreateInput>
  }

  /**
   * AITherapySession createMany
   */
  export type AITherapySessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AITherapySessions.
     */
    data: AITherapySessionCreateManyInput | AITherapySessionCreateManyInput[]
  }

  /**
   * AITherapySession createManyAndReturn
   */
  export type AITherapySessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapySession
     */
    select?: AITherapySessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapySession
     */
    omit?: AITherapySessionOmit<ExtArgs> | null
    /**
     * The data used to create many AITherapySessions.
     */
    data: AITherapySessionCreateManyInput | AITherapySessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapySessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AITherapySession update
   */
  export type AITherapySessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapySession
     */
    select?: AITherapySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapySession
     */
    omit?: AITherapySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapySessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AITherapySession.
     */
    data: XOR<AITherapySessionUpdateInput, AITherapySessionUncheckedUpdateInput>
    /**
     * Choose, which AITherapySession to update.
     */
    where: AITherapySessionWhereUniqueInput
  }

  /**
   * AITherapySession updateMany
   */
  export type AITherapySessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AITherapySessions.
     */
    data: XOR<AITherapySessionUpdateManyMutationInput, AITherapySessionUncheckedUpdateManyInput>
    /**
     * Filter which AITherapySessions to update
     */
    where?: AITherapySessionWhereInput
    /**
     * Limit how many AITherapySessions to update.
     */
    limit?: number
  }

  /**
   * AITherapySession updateManyAndReturn
   */
  export type AITherapySessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapySession
     */
    select?: AITherapySessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapySession
     */
    omit?: AITherapySessionOmit<ExtArgs> | null
    /**
     * The data used to update AITherapySessions.
     */
    data: XOR<AITherapySessionUpdateManyMutationInput, AITherapySessionUncheckedUpdateManyInput>
    /**
     * Filter which AITherapySessions to update
     */
    where?: AITherapySessionWhereInput
    /**
     * Limit how many AITherapySessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapySessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AITherapySession upsert
   */
  export type AITherapySessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapySession
     */
    select?: AITherapySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapySession
     */
    omit?: AITherapySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapySessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AITherapySession to update in case it exists.
     */
    where: AITherapySessionWhereUniqueInput
    /**
     * In case the AITherapySession found by the `where` argument doesn't exist, create a new AITherapySession with this data.
     */
    create: XOR<AITherapySessionCreateInput, AITherapySessionUncheckedCreateInput>
    /**
     * In case the AITherapySession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AITherapySessionUpdateInput, AITherapySessionUncheckedUpdateInput>
  }

  /**
   * AITherapySession delete
   */
  export type AITherapySessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapySession
     */
    select?: AITherapySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapySession
     */
    omit?: AITherapySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapySessionInclude<ExtArgs> | null
    /**
     * Filter which AITherapySession to delete.
     */
    where: AITherapySessionWhereUniqueInput
  }

  /**
   * AITherapySession deleteMany
   */
  export type AITherapySessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AITherapySessions to delete
     */
    where?: AITherapySessionWhereInput
    /**
     * Limit how many AITherapySessions to delete.
     */
    limit?: number
  }

  /**
   * AITherapySession.messages
   */
  export type AITherapySession$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyMessage
     */
    select?: AITherapyMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyMessage
     */
    omit?: AITherapyMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapyMessageInclude<ExtArgs> | null
    where?: AITherapyMessageWhereInput
    orderBy?: AITherapyMessageOrderByWithRelationInput | AITherapyMessageOrderByWithRelationInput[]
    cursor?: AITherapyMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AITherapyMessageScalarFieldEnum | AITherapyMessageScalarFieldEnum[]
  }

  /**
   * AITherapySession.exercises
   */
  export type AITherapySession$exercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIExerciseSession
     */
    select?: AIExerciseSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIExerciseSession
     */
    omit?: AIExerciseSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIExerciseSessionInclude<ExtArgs> | null
    where?: AIExerciseSessionWhereInput
    orderBy?: AIExerciseSessionOrderByWithRelationInput | AIExerciseSessionOrderByWithRelationInput[]
    cursor?: AIExerciseSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIExerciseSessionScalarFieldEnum | AIExerciseSessionScalarFieldEnum[]
  }

  /**
   * AITherapySession without action
   */
  export type AITherapySessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapySession
     */
    select?: AITherapySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapySession
     */
    omit?: AITherapySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapySessionInclude<ExtArgs> | null
  }


  /**
   * Model AITherapyMessage
   */

  export type AggregateAITherapyMessage = {
    _count: AITherapyMessageCountAggregateOutputType | null
    _avg: AITherapyMessageAvgAggregateOutputType | null
    _sum: AITherapyMessageSumAggregateOutputType | null
    _min: AITherapyMessageMinAggregateOutputType | null
    _max: AITherapyMessageMaxAggregateOutputType | null
  }

  export type AITherapyMessageAvgAggregateOutputType = {
    sentiment: number | null
    riskScore: number | null
    audioDuration: number | null
  }

  export type AITherapyMessageSumAggregateOutputType = {
    sentiment: number | null
    riskScore: number | null
    audioDuration: number | null
  }

  export type AITherapyMessageMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    messageType: $Enums.AIMessageType | null
    sender: $Enums.AIMessageSender | null
    encryptedContent: Uint8Array | null
    messageHash: string | null
    timestamp: Date | null
    edited: boolean | null
    editedAt: Date | null
    sentiment: number | null
    emotion: string | null
    riskScore: number | null
    techniques: string | null
    hasAudio: boolean | null
    audioDuration: number | null
    audioUrl: string | null
  }

  export type AITherapyMessageMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    messageType: $Enums.AIMessageType | null
    sender: $Enums.AIMessageSender | null
    encryptedContent: Uint8Array | null
    messageHash: string | null
    timestamp: Date | null
    edited: boolean | null
    editedAt: Date | null
    sentiment: number | null
    emotion: string | null
    riskScore: number | null
    techniques: string | null
    hasAudio: boolean | null
    audioDuration: number | null
    audioUrl: string | null
  }

  export type AITherapyMessageCountAggregateOutputType = {
    id: number
    sessionId: number
    messageType: number
    sender: number
    encryptedContent: number
    messageHash: number
    timestamp: number
    edited: number
    editedAt: number
    sentiment: number
    emotion: number
    riskScore: number
    techniques: number
    hasAudio: number
    audioDuration: number
    audioUrl: number
    _all: number
  }


  export type AITherapyMessageAvgAggregateInputType = {
    sentiment?: true
    riskScore?: true
    audioDuration?: true
  }

  export type AITherapyMessageSumAggregateInputType = {
    sentiment?: true
    riskScore?: true
    audioDuration?: true
  }

  export type AITherapyMessageMinAggregateInputType = {
    id?: true
    sessionId?: true
    messageType?: true
    sender?: true
    encryptedContent?: true
    messageHash?: true
    timestamp?: true
    edited?: true
    editedAt?: true
    sentiment?: true
    emotion?: true
    riskScore?: true
    techniques?: true
    hasAudio?: true
    audioDuration?: true
    audioUrl?: true
  }

  export type AITherapyMessageMaxAggregateInputType = {
    id?: true
    sessionId?: true
    messageType?: true
    sender?: true
    encryptedContent?: true
    messageHash?: true
    timestamp?: true
    edited?: true
    editedAt?: true
    sentiment?: true
    emotion?: true
    riskScore?: true
    techniques?: true
    hasAudio?: true
    audioDuration?: true
    audioUrl?: true
  }

  export type AITherapyMessageCountAggregateInputType = {
    id?: true
    sessionId?: true
    messageType?: true
    sender?: true
    encryptedContent?: true
    messageHash?: true
    timestamp?: true
    edited?: true
    editedAt?: true
    sentiment?: true
    emotion?: true
    riskScore?: true
    techniques?: true
    hasAudio?: true
    audioDuration?: true
    audioUrl?: true
    _all?: true
  }

  export type AITherapyMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AITherapyMessage to aggregate.
     */
    where?: AITherapyMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapyMessages to fetch.
     */
    orderBy?: AITherapyMessageOrderByWithRelationInput | AITherapyMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AITherapyMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapyMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapyMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AITherapyMessages
    **/
    _count?: true | AITherapyMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AITherapyMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AITherapyMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AITherapyMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AITherapyMessageMaxAggregateInputType
  }

  export type GetAITherapyMessageAggregateType<T extends AITherapyMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateAITherapyMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAITherapyMessage[P]>
      : GetScalarType<T[P], AggregateAITherapyMessage[P]>
  }




  export type AITherapyMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AITherapyMessageWhereInput
    orderBy?: AITherapyMessageOrderByWithAggregationInput | AITherapyMessageOrderByWithAggregationInput[]
    by: AITherapyMessageScalarFieldEnum[] | AITherapyMessageScalarFieldEnum
    having?: AITherapyMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AITherapyMessageCountAggregateInputType | true
    _avg?: AITherapyMessageAvgAggregateInputType
    _sum?: AITherapyMessageSumAggregateInputType
    _min?: AITherapyMessageMinAggregateInputType
    _max?: AITherapyMessageMaxAggregateInputType
  }

  export type AITherapyMessageGroupByOutputType = {
    id: string
    sessionId: string
    messageType: $Enums.AIMessageType
    sender: $Enums.AIMessageSender
    encryptedContent: Uint8Array
    messageHash: string
    timestamp: Date
    edited: boolean
    editedAt: Date | null
    sentiment: number | null
    emotion: string | null
    riskScore: number | null
    techniques: string | null
    hasAudio: boolean
    audioDuration: number | null
    audioUrl: string | null
    _count: AITherapyMessageCountAggregateOutputType | null
    _avg: AITherapyMessageAvgAggregateOutputType | null
    _sum: AITherapyMessageSumAggregateOutputType | null
    _min: AITherapyMessageMinAggregateOutputType | null
    _max: AITherapyMessageMaxAggregateOutputType | null
  }

  type GetAITherapyMessageGroupByPayload<T extends AITherapyMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AITherapyMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AITherapyMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AITherapyMessageGroupByOutputType[P]>
            : GetScalarType<T[P], AITherapyMessageGroupByOutputType[P]>
        }
      >
    >


  export type AITherapyMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    messageType?: boolean
    sender?: boolean
    encryptedContent?: boolean
    messageHash?: boolean
    timestamp?: boolean
    edited?: boolean
    editedAt?: boolean
    sentiment?: boolean
    emotion?: boolean
    riskScore?: boolean
    techniques?: boolean
    hasAudio?: boolean
    audioDuration?: boolean
    audioUrl?: boolean
    session?: boolean | AITherapySessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aITherapyMessage"]>

  export type AITherapyMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    messageType?: boolean
    sender?: boolean
    encryptedContent?: boolean
    messageHash?: boolean
    timestamp?: boolean
    edited?: boolean
    editedAt?: boolean
    sentiment?: boolean
    emotion?: boolean
    riskScore?: boolean
    techniques?: boolean
    hasAudio?: boolean
    audioDuration?: boolean
    audioUrl?: boolean
    session?: boolean | AITherapySessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aITherapyMessage"]>

  export type AITherapyMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    messageType?: boolean
    sender?: boolean
    encryptedContent?: boolean
    messageHash?: boolean
    timestamp?: boolean
    edited?: boolean
    editedAt?: boolean
    sentiment?: boolean
    emotion?: boolean
    riskScore?: boolean
    techniques?: boolean
    hasAudio?: boolean
    audioDuration?: boolean
    audioUrl?: boolean
    session?: boolean | AITherapySessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aITherapyMessage"]>

  export type AITherapyMessageSelectScalar = {
    id?: boolean
    sessionId?: boolean
    messageType?: boolean
    sender?: boolean
    encryptedContent?: boolean
    messageHash?: boolean
    timestamp?: boolean
    edited?: boolean
    editedAt?: boolean
    sentiment?: boolean
    emotion?: boolean
    riskScore?: boolean
    techniques?: boolean
    hasAudio?: boolean
    audioDuration?: boolean
    audioUrl?: boolean
  }

  export type AITherapyMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "messageType" | "sender" | "encryptedContent" | "messageHash" | "timestamp" | "edited" | "editedAt" | "sentiment" | "emotion" | "riskScore" | "techniques" | "hasAudio" | "audioDuration" | "audioUrl", ExtArgs["result"]["aITherapyMessage"]>
  export type AITherapyMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AITherapySessionDefaultArgs<ExtArgs>
  }
  export type AITherapyMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AITherapySessionDefaultArgs<ExtArgs>
  }
  export type AITherapyMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AITherapySessionDefaultArgs<ExtArgs>
  }

  export type $AITherapyMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AITherapyMessage"
    objects: {
      session: Prisma.$AITherapySessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      messageType: $Enums.AIMessageType
      sender: $Enums.AIMessageSender
      encryptedContent: Uint8Array
      messageHash: string
      timestamp: Date
      edited: boolean
      editedAt: Date | null
      sentiment: number | null
      emotion: string | null
      riskScore: number | null
      techniques: string | null
      hasAudio: boolean
      audioDuration: number | null
      audioUrl: string | null
    }, ExtArgs["result"]["aITherapyMessage"]>
    composites: {}
  }

  type AITherapyMessageGetPayload<S extends boolean | null | undefined | AITherapyMessageDefaultArgs> = $Result.GetResult<Prisma.$AITherapyMessagePayload, S>

  type AITherapyMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AITherapyMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AITherapyMessageCountAggregateInputType | true
    }

  export interface AITherapyMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AITherapyMessage'], meta: { name: 'AITherapyMessage' } }
    /**
     * Find zero or one AITherapyMessage that matches the filter.
     * @param {AITherapyMessageFindUniqueArgs} args - Arguments to find a AITherapyMessage
     * @example
     * // Get one AITherapyMessage
     * const aITherapyMessage = await prisma.aITherapyMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AITherapyMessageFindUniqueArgs>(args: SelectSubset<T, AITherapyMessageFindUniqueArgs<ExtArgs>>): Prisma__AITherapyMessageClient<$Result.GetResult<Prisma.$AITherapyMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AITherapyMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AITherapyMessageFindUniqueOrThrowArgs} args - Arguments to find a AITherapyMessage
     * @example
     * // Get one AITherapyMessage
     * const aITherapyMessage = await prisma.aITherapyMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AITherapyMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, AITherapyMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AITherapyMessageClient<$Result.GetResult<Prisma.$AITherapyMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AITherapyMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyMessageFindFirstArgs} args - Arguments to find a AITherapyMessage
     * @example
     * // Get one AITherapyMessage
     * const aITherapyMessage = await prisma.aITherapyMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AITherapyMessageFindFirstArgs>(args?: SelectSubset<T, AITherapyMessageFindFirstArgs<ExtArgs>>): Prisma__AITherapyMessageClient<$Result.GetResult<Prisma.$AITherapyMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AITherapyMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyMessageFindFirstOrThrowArgs} args - Arguments to find a AITherapyMessage
     * @example
     * // Get one AITherapyMessage
     * const aITherapyMessage = await prisma.aITherapyMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AITherapyMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, AITherapyMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__AITherapyMessageClient<$Result.GetResult<Prisma.$AITherapyMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AITherapyMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AITherapyMessages
     * const aITherapyMessages = await prisma.aITherapyMessage.findMany()
     * 
     * // Get first 10 AITherapyMessages
     * const aITherapyMessages = await prisma.aITherapyMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aITherapyMessageWithIdOnly = await prisma.aITherapyMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AITherapyMessageFindManyArgs>(args?: SelectSubset<T, AITherapyMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITherapyMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AITherapyMessage.
     * @param {AITherapyMessageCreateArgs} args - Arguments to create a AITherapyMessage.
     * @example
     * // Create one AITherapyMessage
     * const AITherapyMessage = await prisma.aITherapyMessage.create({
     *   data: {
     *     // ... data to create a AITherapyMessage
     *   }
     * })
     * 
     */
    create<T extends AITherapyMessageCreateArgs>(args: SelectSubset<T, AITherapyMessageCreateArgs<ExtArgs>>): Prisma__AITherapyMessageClient<$Result.GetResult<Prisma.$AITherapyMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AITherapyMessages.
     * @param {AITherapyMessageCreateManyArgs} args - Arguments to create many AITherapyMessages.
     * @example
     * // Create many AITherapyMessages
     * const aITherapyMessage = await prisma.aITherapyMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AITherapyMessageCreateManyArgs>(args?: SelectSubset<T, AITherapyMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AITherapyMessages and returns the data saved in the database.
     * @param {AITherapyMessageCreateManyAndReturnArgs} args - Arguments to create many AITherapyMessages.
     * @example
     * // Create many AITherapyMessages
     * const aITherapyMessage = await prisma.aITherapyMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AITherapyMessages and only return the `id`
     * const aITherapyMessageWithIdOnly = await prisma.aITherapyMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AITherapyMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, AITherapyMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITherapyMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AITherapyMessage.
     * @param {AITherapyMessageDeleteArgs} args - Arguments to delete one AITherapyMessage.
     * @example
     * // Delete one AITherapyMessage
     * const AITherapyMessage = await prisma.aITherapyMessage.delete({
     *   where: {
     *     // ... filter to delete one AITherapyMessage
     *   }
     * })
     * 
     */
    delete<T extends AITherapyMessageDeleteArgs>(args: SelectSubset<T, AITherapyMessageDeleteArgs<ExtArgs>>): Prisma__AITherapyMessageClient<$Result.GetResult<Prisma.$AITherapyMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AITherapyMessage.
     * @param {AITherapyMessageUpdateArgs} args - Arguments to update one AITherapyMessage.
     * @example
     * // Update one AITherapyMessage
     * const aITherapyMessage = await prisma.aITherapyMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AITherapyMessageUpdateArgs>(args: SelectSubset<T, AITherapyMessageUpdateArgs<ExtArgs>>): Prisma__AITherapyMessageClient<$Result.GetResult<Prisma.$AITherapyMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AITherapyMessages.
     * @param {AITherapyMessageDeleteManyArgs} args - Arguments to filter AITherapyMessages to delete.
     * @example
     * // Delete a few AITherapyMessages
     * const { count } = await prisma.aITherapyMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AITherapyMessageDeleteManyArgs>(args?: SelectSubset<T, AITherapyMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AITherapyMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AITherapyMessages
     * const aITherapyMessage = await prisma.aITherapyMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AITherapyMessageUpdateManyArgs>(args: SelectSubset<T, AITherapyMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AITherapyMessages and returns the data updated in the database.
     * @param {AITherapyMessageUpdateManyAndReturnArgs} args - Arguments to update many AITherapyMessages.
     * @example
     * // Update many AITherapyMessages
     * const aITherapyMessage = await prisma.aITherapyMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AITherapyMessages and only return the `id`
     * const aITherapyMessageWithIdOnly = await prisma.aITherapyMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AITherapyMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, AITherapyMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITherapyMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AITherapyMessage.
     * @param {AITherapyMessageUpsertArgs} args - Arguments to update or create a AITherapyMessage.
     * @example
     * // Update or create a AITherapyMessage
     * const aITherapyMessage = await prisma.aITherapyMessage.upsert({
     *   create: {
     *     // ... data to create a AITherapyMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AITherapyMessage we want to update
     *   }
     * })
     */
    upsert<T extends AITherapyMessageUpsertArgs>(args: SelectSubset<T, AITherapyMessageUpsertArgs<ExtArgs>>): Prisma__AITherapyMessageClient<$Result.GetResult<Prisma.$AITherapyMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AITherapyMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyMessageCountArgs} args - Arguments to filter AITherapyMessages to count.
     * @example
     * // Count the number of AITherapyMessages
     * const count = await prisma.aITherapyMessage.count({
     *   where: {
     *     // ... the filter for the AITherapyMessages we want to count
     *   }
     * })
    **/
    count<T extends AITherapyMessageCountArgs>(
      args?: Subset<T, AITherapyMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AITherapyMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AITherapyMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AITherapyMessageAggregateArgs>(args: Subset<T, AITherapyMessageAggregateArgs>): Prisma.PrismaPromise<GetAITherapyMessageAggregateType<T>>

    /**
     * Group by AITherapyMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AITherapyMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AITherapyMessageGroupByArgs['orderBy'] }
        : { orderBy?: AITherapyMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AITherapyMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAITherapyMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AITherapyMessage model
   */
  readonly fields: AITherapyMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AITherapyMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AITherapyMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends AITherapySessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AITherapySessionDefaultArgs<ExtArgs>>): Prisma__AITherapySessionClient<$Result.GetResult<Prisma.$AITherapySessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AITherapyMessage model
   */
  interface AITherapyMessageFieldRefs {
    readonly id: FieldRef<"AITherapyMessage", 'String'>
    readonly sessionId: FieldRef<"AITherapyMessage", 'String'>
    readonly messageType: FieldRef<"AITherapyMessage", 'AIMessageType'>
    readonly sender: FieldRef<"AITherapyMessage", 'AIMessageSender'>
    readonly encryptedContent: FieldRef<"AITherapyMessage", 'Bytes'>
    readonly messageHash: FieldRef<"AITherapyMessage", 'String'>
    readonly timestamp: FieldRef<"AITherapyMessage", 'DateTime'>
    readonly edited: FieldRef<"AITherapyMessage", 'Boolean'>
    readonly editedAt: FieldRef<"AITherapyMessage", 'DateTime'>
    readonly sentiment: FieldRef<"AITherapyMessage", 'Float'>
    readonly emotion: FieldRef<"AITherapyMessage", 'String'>
    readonly riskScore: FieldRef<"AITherapyMessage", 'Int'>
    readonly techniques: FieldRef<"AITherapyMessage", 'String'>
    readonly hasAudio: FieldRef<"AITherapyMessage", 'Boolean'>
    readonly audioDuration: FieldRef<"AITherapyMessage", 'Int'>
    readonly audioUrl: FieldRef<"AITherapyMessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AITherapyMessage findUnique
   */
  export type AITherapyMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyMessage
     */
    select?: AITherapyMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyMessage
     */
    omit?: AITherapyMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapyMessageInclude<ExtArgs> | null
    /**
     * Filter, which AITherapyMessage to fetch.
     */
    where: AITherapyMessageWhereUniqueInput
  }

  /**
   * AITherapyMessage findUniqueOrThrow
   */
  export type AITherapyMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyMessage
     */
    select?: AITherapyMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyMessage
     */
    omit?: AITherapyMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapyMessageInclude<ExtArgs> | null
    /**
     * Filter, which AITherapyMessage to fetch.
     */
    where: AITherapyMessageWhereUniqueInput
  }

  /**
   * AITherapyMessage findFirst
   */
  export type AITherapyMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyMessage
     */
    select?: AITherapyMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyMessage
     */
    omit?: AITherapyMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapyMessageInclude<ExtArgs> | null
    /**
     * Filter, which AITherapyMessage to fetch.
     */
    where?: AITherapyMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapyMessages to fetch.
     */
    orderBy?: AITherapyMessageOrderByWithRelationInput | AITherapyMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AITherapyMessages.
     */
    cursor?: AITherapyMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapyMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapyMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AITherapyMessages.
     */
    distinct?: AITherapyMessageScalarFieldEnum | AITherapyMessageScalarFieldEnum[]
  }

  /**
   * AITherapyMessage findFirstOrThrow
   */
  export type AITherapyMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyMessage
     */
    select?: AITherapyMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyMessage
     */
    omit?: AITherapyMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapyMessageInclude<ExtArgs> | null
    /**
     * Filter, which AITherapyMessage to fetch.
     */
    where?: AITherapyMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapyMessages to fetch.
     */
    orderBy?: AITherapyMessageOrderByWithRelationInput | AITherapyMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AITherapyMessages.
     */
    cursor?: AITherapyMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapyMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapyMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AITherapyMessages.
     */
    distinct?: AITherapyMessageScalarFieldEnum | AITherapyMessageScalarFieldEnum[]
  }

  /**
   * AITherapyMessage findMany
   */
  export type AITherapyMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyMessage
     */
    select?: AITherapyMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyMessage
     */
    omit?: AITherapyMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapyMessageInclude<ExtArgs> | null
    /**
     * Filter, which AITherapyMessages to fetch.
     */
    where?: AITherapyMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapyMessages to fetch.
     */
    orderBy?: AITherapyMessageOrderByWithRelationInput | AITherapyMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AITherapyMessages.
     */
    cursor?: AITherapyMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapyMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapyMessages.
     */
    skip?: number
    distinct?: AITherapyMessageScalarFieldEnum | AITherapyMessageScalarFieldEnum[]
  }

  /**
   * AITherapyMessage create
   */
  export type AITherapyMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyMessage
     */
    select?: AITherapyMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyMessage
     */
    omit?: AITherapyMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapyMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a AITherapyMessage.
     */
    data: XOR<AITherapyMessageCreateInput, AITherapyMessageUncheckedCreateInput>
  }

  /**
   * AITherapyMessage createMany
   */
  export type AITherapyMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AITherapyMessages.
     */
    data: AITherapyMessageCreateManyInput | AITherapyMessageCreateManyInput[]
  }

  /**
   * AITherapyMessage createManyAndReturn
   */
  export type AITherapyMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyMessage
     */
    select?: AITherapyMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyMessage
     */
    omit?: AITherapyMessageOmit<ExtArgs> | null
    /**
     * The data used to create many AITherapyMessages.
     */
    data: AITherapyMessageCreateManyInput | AITherapyMessageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapyMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AITherapyMessage update
   */
  export type AITherapyMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyMessage
     */
    select?: AITherapyMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyMessage
     */
    omit?: AITherapyMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapyMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a AITherapyMessage.
     */
    data: XOR<AITherapyMessageUpdateInput, AITherapyMessageUncheckedUpdateInput>
    /**
     * Choose, which AITherapyMessage to update.
     */
    where: AITherapyMessageWhereUniqueInput
  }

  /**
   * AITherapyMessage updateMany
   */
  export type AITherapyMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AITherapyMessages.
     */
    data: XOR<AITherapyMessageUpdateManyMutationInput, AITherapyMessageUncheckedUpdateManyInput>
    /**
     * Filter which AITherapyMessages to update
     */
    where?: AITherapyMessageWhereInput
    /**
     * Limit how many AITherapyMessages to update.
     */
    limit?: number
  }

  /**
   * AITherapyMessage updateManyAndReturn
   */
  export type AITherapyMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyMessage
     */
    select?: AITherapyMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyMessage
     */
    omit?: AITherapyMessageOmit<ExtArgs> | null
    /**
     * The data used to update AITherapyMessages.
     */
    data: XOR<AITherapyMessageUpdateManyMutationInput, AITherapyMessageUncheckedUpdateManyInput>
    /**
     * Filter which AITherapyMessages to update
     */
    where?: AITherapyMessageWhereInput
    /**
     * Limit how many AITherapyMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapyMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AITherapyMessage upsert
   */
  export type AITherapyMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyMessage
     */
    select?: AITherapyMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyMessage
     */
    omit?: AITherapyMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapyMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the AITherapyMessage to update in case it exists.
     */
    where: AITherapyMessageWhereUniqueInput
    /**
     * In case the AITherapyMessage found by the `where` argument doesn't exist, create a new AITherapyMessage with this data.
     */
    create: XOR<AITherapyMessageCreateInput, AITherapyMessageUncheckedCreateInput>
    /**
     * In case the AITherapyMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AITherapyMessageUpdateInput, AITherapyMessageUncheckedUpdateInput>
  }

  /**
   * AITherapyMessage delete
   */
  export type AITherapyMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyMessage
     */
    select?: AITherapyMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyMessage
     */
    omit?: AITherapyMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapyMessageInclude<ExtArgs> | null
    /**
     * Filter which AITherapyMessage to delete.
     */
    where: AITherapyMessageWhereUniqueInput
  }

  /**
   * AITherapyMessage deleteMany
   */
  export type AITherapyMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AITherapyMessages to delete
     */
    where?: AITherapyMessageWhereInput
    /**
     * Limit how many AITherapyMessages to delete.
     */
    limit?: number
  }

  /**
   * AITherapyMessage without action
   */
  export type AITherapyMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyMessage
     */
    select?: AITherapyMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyMessage
     */
    omit?: AITherapyMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapyMessageInclude<ExtArgs> | null
  }


  /**
   * Model AIPersonalization
   */

  export type AggregateAIPersonalization = {
    _count: AIPersonalizationCountAggregateOutputType | null
    _min: AIPersonalizationMinAggregateOutputType | null
    _max: AIPersonalizationMaxAggregateOutputType | null
  }

  export type AIPersonalizationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    therapistId: string | null
    preferredStyle: string | null
    preferredTechniques: string | null
    preferredTopics: string | null
    avoidTopics: string | null
    responseLength: string | null
    responseComplexity: string | null
    empathyLevel: string | null
    directness: string | null
    culturalBackground: string | null
    languagePreference: string | null
    timezone: string | null
    pronouns: string | null
    learnedPatterns: string | null
    effectiveTechniques: string | null
    triggerPatterns: string | null
    copingStrategies: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIPersonalizationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    therapistId: string | null
    preferredStyle: string | null
    preferredTechniques: string | null
    preferredTopics: string | null
    avoidTopics: string | null
    responseLength: string | null
    responseComplexity: string | null
    empathyLevel: string | null
    directness: string | null
    culturalBackground: string | null
    languagePreference: string | null
    timezone: string | null
    pronouns: string | null
    learnedPatterns: string | null
    effectiveTechniques: string | null
    triggerPatterns: string | null
    copingStrategies: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIPersonalizationCountAggregateOutputType = {
    id: number
    userId: number
    therapistId: number
    preferredStyle: number
    preferredTechniques: number
    preferredTopics: number
    avoidTopics: number
    responseLength: number
    responseComplexity: number
    empathyLevel: number
    directness: number
    culturalBackground: number
    languagePreference: number
    timezone: number
    pronouns: number
    learnedPatterns: number
    effectiveTechniques: number
    triggerPatterns: number
    copingStrategies: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIPersonalizationMinAggregateInputType = {
    id?: true
    userId?: true
    therapistId?: true
    preferredStyle?: true
    preferredTechniques?: true
    preferredTopics?: true
    avoidTopics?: true
    responseLength?: true
    responseComplexity?: true
    empathyLevel?: true
    directness?: true
    culturalBackground?: true
    languagePreference?: true
    timezone?: true
    pronouns?: true
    learnedPatterns?: true
    effectiveTechniques?: true
    triggerPatterns?: true
    copingStrategies?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIPersonalizationMaxAggregateInputType = {
    id?: true
    userId?: true
    therapistId?: true
    preferredStyle?: true
    preferredTechniques?: true
    preferredTopics?: true
    avoidTopics?: true
    responseLength?: true
    responseComplexity?: true
    empathyLevel?: true
    directness?: true
    culturalBackground?: true
    languagePreference?: true
    timezone?: true
    pronouns?: true
    learnedPatterns?: true
    effectiveTechniques?: true
    triggerPatterns?: true
    copingStrategies?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIPersonalizationCountAggregateInputType = {
    id?: true
    userId?: true
    therapistId?: true
    preferredStyle?: true
    preferredTechniques?: true
    preferredTopics?: true
    avoidTopics?: true
    responseLength?: true
    responseComplexity?: true
    empathyLevel?: true
    directness?: true
    culturalBackground?: true
    languagePreference?: true
    timezone?: true
    pronouns?: true
    learnedPatterns?: true
    effectiveTechniques?: true
    triggerPatterns?: true
    copingStrategies?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIPersonalizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIPersonalization to aggregate.
     */
    where?: AIPersonalizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIPersonalizations to fetch.
     */
    orderBy?: AIPersonalizationOrderByWithRelationInput | AIPersonalizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIPersonalizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIPersonalizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIPersonalizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIPersonalizations
    **/
    _count?: true | AIPersonalizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIPersonalizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIPersonalizationMaxAggregateInputType
  }

  export type GetAIPersonalizationAggregateType<T extends AIPersonalizationAggregateArgs> = {
        [P in keyof T & keyof AggregateAIPersonalization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIPersonalization[P]>
      : GetScalarType<T[P], AggregateAIPersonalization[P]>
  }




  export type AIPersonalizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIPersonalizationWhereInput
    orderBy?: AIPersonalizationOrderByWithAggregationInput | AIPersonalizationOrderByWithAggregationInput[]
    by: AIPersonalizationScalarFieldEnum[] | AIPersonalizationScalarFieldEnum
    having?: AIPersonalizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIPersonalizationCountAggregateInputType | true
    _min?: AIPersonalizationMinAggregateInputType
    _max?: AIPersonalizationMaxAggregateInputType
  }

  export type AIPersonalizationGroupByOutputType = {
    id: string
    userId: string
    therapistId: string | null
    preferredStyle: string | null
    preferredTechniques: string | null
    preferredTopics: string | null
    avoidTopics: string | null
    responseLength: string
    responseComplexity: string
    empathyLevel: string
    directness: string
    culturalBackground: string | null
    languagePreference: string
    timezone: string
    pronouns: string | null
    learnedPatterns: string | null
    effectiveTechniques: string | null
    triggerPatterns: string | null
    copingStrategies: string | null
    createdAt: Date
    updatedAt: Date
    _count: AIPersonalizationCountAggregateOutputType | null
    _min: AIPersonalizationMinAggregateOutputType | null
    _max: AIPersonalizationMaxAggregateOutputType | null
  }

  type GetAIPersonalizationGroupByPayload<T extends AIPersonalizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIPersonalizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIPersonalizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIPersonalizationGroupByOutputType[P]>
            : GetScalarType<T[P], AIPersonalizationGroupByOutputType[P]>
        }
      >
    >


  export type AIPersonalizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    therapistId?: boolean
    preferredStyle?: boolean
    preferredTechniques?: boolean
    preferredTopics?: boolean
    avoidTopics?: boolean
    responseLength?: boolean
    responseComplexity?: boolean
    empathyLevel?: boolean
    directness?: boolean
    culturalBackground?: boolean
    languagePreference?: boolean
    timezone?: boolean
    pronouns?: boolean
    learnedPatterns?: boolean
    effectiveTechniques?: boolean
    triggerPatterns?: boolean
    copingStrategies?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    therapist?: boolean | AIPersonalization$therapistArgs<ExtArgs>
  }, ExtArgs["result"]["aIPersonalization"]>

  export type AIPersonalizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    therapistId?: boolean
    preferredStyle?: boolean
    preferredTechniques?: boolean
    preferredTopics?: boolean
    avoidTopics?: boolean
    responseLength?: boolean
    responseComplexity?: boolean
    empathyLevel?: boolean
    directness?: boolean
    culturalBackground?: boolean
    languagePreference?: boolean
    timezone?: boolean
    pronouns?: boolean
    learnedPatterns?: boolean
    effectiveTechniques?: boolean
    triggerPatterns?: boolean
    copingStrategies?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    therapist?: boolean | AIPersonalization$therapistArgs<ExtArgs>
  }, ExtArgs["result"]["aIPersonalization"]>

  export type AIPersonalizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    therapistId?: boolean
    preferredStyle?: boolean
    preferredTechniques?: boolean
    preferredTopics?: boolean
    avoidTopics?: boolean
    responseLength?: boolean
    responseComplexity?: boolean
    empathyLevel?: boolean
    directness?: boolean
    culturalBackground?: boolean
    languagePreference?: boolean
    timezone?: boolean
    pronouns?: boolean
    learnedPatterns?: boolean
    effectiveTechniques?: boolean
    triggerPatterns?: boolean
    copingStrategies?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    therapist?: boolean | AIPersonalization$therapistArgs<ExtArgs>
  }, ExtArgs["result"]["aIPersonalization"]>

  export type AIPersonalizationSelectScalar = {
    id?: boolean
    userId?: boolean
    therapistId?: boolean
    preferredStyle?: boolean
    preferredTechniques?: boolean
    preferredTopics?: boolean
    avoidTopics?: boolean
    responseLength?: boolean
    responseComplexity?: boolean
    empathyLevel?: boolean
    directness?: boolean
    culturalBackground?: boolean
    languagePreference?: boolean
    timezone?: boolean
    pronouns?: boolean
    learnedPatterns?: boolean
    effectiveTechniques?: boolean
    triggerPatterns?: boolean
    copingStrategies?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIPersonalizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "therapistId" | "preferredStyle" | "preferredTechniques" | "preferredTopics" | "avoidTopics" | "responseLength" | "responseComplexity" | "empathyLevel" | "directness" | "culturalBackground" | "languagePreference" | "timezone" | "pronouns" | "learnedPatterns" | "effectiveTechniques" | "triggerPatterns" | "copingStrategies" | "createdAt" | "updatedAt", ExtArgs["result"]["aIPersonalization"]>
  export type AIPersonalizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    therapist?: boolean | AIPersonalization$therapistArgs<ExtArgs>
  }
  export type AIPersonalizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    therapist?: boolean | AIPersonalization$therapistArgs<ExtArgs>
  }
  export type AIPersonalizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    therapist?: boolean | AIPersonalization$therapistArgs<ExtArgs>
  }

  export type $AIPersonalizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIPersonalization"
    objects: {
      therapist: Prisma.$AITherapistPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      therapistId: string | null
      preferredStyle: string | null
      preferredTechniques: string | null
      preferredTopics: string | null
      avoidTopics: string | null
      responseLength: string
      responseComplexity: string
      empathyLevel: string
      directness: string
      culturalBackground: string | null
      languagePreference: string
      timezone: string
      pronouns: string | null
      learnedPatterns: string | null
      effectiveTechniques: string | null
      triggerPatterns: string | null
      copingStrategies: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIPersonalization"]>
    composites: {}
  }

  type AIPersonalizationGetPayload<S extends boolean | null | undefined | AIPersonalizationDefaultArgs> = $Result.GetResult<Prisma.$AIPersonalizationPayload, S>

  type AIPersonalizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIPersonalizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AIPersonalizationCountAggregateInputType | true
    }

  export interface AIPersonalizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIPersonalization'], meta: { name: 'AIPersonalization' } }
    /**
     * Find zero or one AIPersonalization that matches the filter.
     * @param {AIPersonalizationFindUniqueArgs} args - Arguments to find a AIPersonalization
     * @example
     * // Get one AIPersonalization
     * const aIPersonalization = await prisma.aIPersonalization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIPersonalizationFindUniqueArgs>(args: SelectSubset<T, AIPersonalizationFindUniqueArgs<ExtArgs>>): Prisma__AIPersonalizationClient<$Result.GetResult<Prisma.$AIPersonalizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIPersonalization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIPersonalizationFindUniqueOrThrowArgs} args - Arguments to find a AIPersonalization
     * @example
     * // Get one AIPersonalization
     * const aIPersonalization = await prisma.aIPersonalization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIPersonalizationFindUniqueOrThrowArgs>(args: SelectSubset<T, AIPersonalizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIPersonalizationClient<$Result.GetResult<Prisma.$AIPersonalizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIPersonalization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPersonalizationFindFirstArgs} args - Arguments to find a AIPersonalization
     * @example
     * // Get one AIPersonalization
     * const aIPersonalization = await prisma.aIPersonalization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIPersonalizationFindFirstArgs>(args?: SelectSubset<T, AIPersonalizationFindFirstArgs<ExtArgs>>): Prisma__AIPersonalizationClient<$Result.GetResult<Prisma.$AIPersonalizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIPersonalization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPersonalizationFindFirstOrThrowArgs} args - Arguments to find a AIPersonalization
     * @example
     * // Get one AIPersonalization
     * const aIPersonalization = await prisma.aIPersonalization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIPersonalizationFindFirstOrThrowArgs>(args?: SelectSubset<T, AIPersonalizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIPersonalizationClient<$Result.GetResult<Prisma.$AIPersonalizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIPersonalizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPersonalizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIPersonalizations
     * const aIPersonalizations = await prisma.aIPersonalization.findMany()
     * 
     * // Get first 10 AIPersonalizations
     * const aIPersonalizations = await prisma.aIPersonalization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIPersonalizationWithIdOnly = await prisma.aIPersonalization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIPersonalizationFindManyArgs>(args?: SelectSubset<T, AIPersonalizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIPersonalizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIPersonalization.
     * @param {AIPersonalizationCreateArgs} args - Arguments to create a AIPersonalization.
     * @example
     * // Create one AIPersonalization
     * const AIPersonalization = await prisma.aIPersonalization.create({
     *   data: {
     *     // ... data to create a AIPersonalization
     *   }
     * })
     * 
     */
    create<T extends AIPersonalizationCreateArgs>(args: SelectSubset<T, AIPersonalizationCreateArgs<ExtArgs>>): Prisma__AIPersonalizationClient<$Result.GetResult<Prisma.$AIPersonalizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIPersonalizations.
     * @param {AIPersonalizationCreateManyArgs} args - Arguments to create many AIPersonalizations.
     * @example
     * // Create many AIPersonalizations
     * const aIPersonalization = await prisma.aIPersonalization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIPersonalizationCreateManyArgs>(args?: SelectSubset<T, AIPersonalizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIPersonalizations and returns the data saved in the database.
     * @param {AIPersonalizationCreateManyAndReturnArgs} args - Arguments to create many AIPersonalizations.
     * @example
     * // Create many AIPersonalizations
     * const aIPersonalization = await prisma.aIPersonalization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIPersonalizations and only return the `id`
     * const aIPersonalizationWithIdOnly = await prisma.aIPersonalization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIPersonalizationCreateManyAndReturnArgs>(args?: SelectSubset<T, AIPersonalizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIPersonalizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIPersonalization.
     * @param {AIPersonalizationDeleteArgs} args - Arguments to delete one AIPersonalization.
     * @example
     * // Delete one AIPersonalization
     * const AIPersonalization = await prisma.aIPersonalization.delete({
     *   where: {
     *     // ... filter to delete one AIPersonalization
     *   }
     * })
     * 
     */
    delete<T extends AIPersonalizationDeleteArgs>(args: SelectSubset<T, AIPersonalizationDeleteArgs<ExtArgs>>): Prisma__AIPersonalizationClient<$Result.GetResult<Prisma.$AIPersonalizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIPersonalization.
     * @param {AIPersonalizationUpdateArgs} args - Arguments to update one AIPersonalization.
     * @example
     * // Update one AIPersonalization
     * const aIPersonalization = await prisma.aIPersonalization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIPersonalizationUpdateArgs>(args: SelectSubset<T, AIPersonalizationUpdateArgs<ExtArgs>>): Prisma__AIPersonalizationClient<$Result.GetResult<Prisma.$AIPersonalizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIPersonalizations.
     * @param {AIPersonalizationDeleteManyArgs} args - Arguments to filter AIPersonalizations to delete.
     * @example
     * // Delete a few AIPersonalizations
     * const { count } = await prisma.aIPersonalization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIPersonalizationDeleteManyArgs>(args?: SelectSubset<T, AIPersonalizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIPersonalizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPersonalizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIPersonalizations
     * const aIPersonalization = await prisma.aIPersonalization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIPersonalizationUpdateManyArgs>(args: SelectSubset<T, AIPersonalizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIPersonalizations and returns the data updated in the database.
     * @param {AIPersonalizationUpdateManyAndReturnArgs} args - Arguments to update many AIPersonalizations.
     * @example
     * // Update many AIPersonalizations
     * const aIPersonalization = await prisma.aIPersonalization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIPersonalizations and only return the `id`
     * const aIPersonalizationWithIdOnly = await prisma.aIPersonalization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIPersonalizationUpdateManyAndReturnArgs>(args: SelectSubset<T, AIPersonalizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIPersonalizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIPersonalization.
     * @param {AIPersonalizationUpsertArgs} args - Arguments to update or create a AIPersonalization.
     * @example
     * // Update or create a AIPersonalization
     * const aIPersonalization = await prisma.aIPersonalization.upsert({
     *   create: {
     *     // ... data to create a AIPersonalization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIPersonalization we want to update
     *   }
     * })
     */
    upsert<T extends AIPersonalizationUpsertArgs>(args: SelectSubset<T, AIPersonalizationUpsertArgs<ExtArgs>>): Prisma__AIPersonalizationClient<$Result.GetResult<Prisma.$AIPersonalizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIPersonalizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPersonalizationCountArgs} args - Arguments to filter AIPersonalizations to count.
     * @example
     * // Count the number of AIPersonalizations
     * const count = await prisma.aIPersonalization.count({
     *   where: {
     *     // ... the filter for the AIPersonalizations we want to count
     *   }
     * })
    **/
    count<T extends AIPersonalizationCountArgs>(
      args?: Subset<T, AIPersonalizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIPersonalizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIPersonalization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPersonalizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIPersonalizationAggregateArgs>(args: Subset<T, AIPersonalizationAggregateArgs>): Prisma.PrismaPromise<GetAIPersonalizationAggregateType<T>>

    /**
     * Group by AIPersonalization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPersonalizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIPersonalizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIPersonalizationGroupByArgs['orderBy'] }
        : { orderBy?: AIPersonalizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIPersonalizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIPersonalizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIPersonalization model
   */
  readonly fields: AIPersonalizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIPersonalization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIPersonalizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    therapist<T extends AIPersonalization$therapistArgs<ExtArgs> = {}>(args?: Subset<T, AIPersonalization$therapistArgs<ExtArgs>>): Prisma__AITherapistClient<$Result.GetResult<Prisma.$AITherapistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIPersonalization model
   */
  interface AIPersonalizationFieldRefs {
    readonly id: FieldRef<"AIPersonalization", 'String'>
    readonly userId: FieldRef<"AIPersonalization", 'String'>
    readonly therapistId: FieldRef<"AIPersonalization", 'String'>
    readonly preferredStyle: FieldRef<"AIPersonalization", 'String'>
    readonly preferredTechniques: FieldRef<"AIPersonalization", 'String'>
    readonly preferredTopics: FieldRef<"AIPersonalization", 'String'>
    readonly avoidTopics: FieldRef<"AIPersonalization", 'String'>
    readonly responseLength: FieldRef<"AIPersonalization", 'String'>
    readonly responseComplexity: FieldRef<"AIPersonalization", 'String'>
    readonly empathyLevel: FieldRef<"AIPersonalization", 'String'>
    readonly directness: FieldRef<"AIPersonalization", 'String'>
    readonly culturalBackground: FieldRef<"AIPersonalization", 'String'>
    readonly languagePreference: FieldRef<"AIPersonalization", 'String'>
    readonly timezone: FieldRef<"AIPersonalization", 'String'>
    readonly pronouns: FieldRef<"AIPersonalization", 'String'>
    readonly learnedPatterns: FieldRef<"AIPersonalization", 'String'>
    readonly effectiveTechniques: FieldRef<"AIPersonalization", 'String'>
    readonly triggerPatterns: FieldRef<"AIPersonalization", 'String'>
    readonly copingStrategies: FieldRef<"AIPersonalization", 'String'>
    readonly createdAt: FieldRef<"AIPersonalization", 'DateTime'>
    readonly updatedAt: FieldRef<"AIPersonalization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIPersonalization findUnique
   */
  export type AIPersonalizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPersonalization
     */
    select?: AIPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPersonalization
     */
    omit?: AIPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPersonalizationInclude<ExtArgs> | null
    /**
     * Filter, which AIPersonalization to fetch.
     */
    where: AIPersonalizationWhereUniqueInput
  }

  /**
   * AIPersonalization findUniqueOrThrow
   */
  export type AIPersonalizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPersonalization
     */
    select?: AIPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPersonalization
     */
    omit?: AIPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPersonalizationInclude<ExtArgs> | null
    /**
     * Filter, which AIPersonalization to fetch.
     */
    where: AIPersonalizationWhereUniqueInput
  }

  /**
   * AIPersonalization findFirst
   */
  export type AIPersonalizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPersonalization
     */
    select?: AIPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPersonalization
     */
    omit?: AIPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPersonalizationInclude<ExtArgs> | null
    /**
     * Filter, which AIPersonalization to fetch.
     */
    where?: AIPersonalizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIPersonalizations to fetch.
     */
    orderBy?: AIPersonalizationOrderByWithRelationInput | AIPersonalizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIPersonalizations.
     */
    cursor?: AIPersonalizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIPersonalizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIPersonalizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIPersonalizations.
     */
    distinct?: AIPersonalizationScalarFieldEnum | AIPersonalizationScalarFieldEnum[]
  }

  /**
   * AIPersonalization findFirstOrThrow
   */
  export type AIPersonalizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPersonalization
     */
    select?: AIPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPersonalization
     */
    omit?: AIPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPersonalizationInclude<ExtArgs> | null
    /**
     * Filter, which AIPersonalization to fetch.
     */
    where?: AIPersonalizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIPersonalizations to fetch.
     */
    orderBy?: AIPersonalizationOrderByWithRelationInput | AIPersonalizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIPersonalizations.
     */
    cursor?: AIPersonalizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIPersonalizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIPersonalizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIPersonalizations.
     */
    distinct?: AIPersonalizationScalarFieldEnum | AIPersonalizationScalarFieldEnum[]
  }

  /**
   * AIPersonalization findMany
   */
  export type AIPersonalizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPersonalization
     */
    select?: AIPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPersonalization
     */
    omit?: AIPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPersonalizationInclude<ExtArgs> | null
    /**
     * Filter, which AIPersonalizations to fetch.
     */
    where?: AIPersonalizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIPersonalizations to fetch.
     */
    orderBy?: AIPersonalizationOrderByWithRelationInput | AIPersonalizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIPersonalizations.
     */
    cursor?: AIPersonalizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIPersonalizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIPersonalizations.
     */
    skip?: number
    distinct?: AIPersonalizationScalarFieldEnum | AIPersonalizationScalarFieldEnum[]
  }

  /**
   * AIPersonalization create
   */
  export type AIPersonalizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPersonalization
     */
    select?: AIPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPersonalization
     */
    omit?: AIPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPersonalizationInclude<ExtArgs> | null
    /**
     * The data needed to create a AIPersonalization.
     */
    data: XOR<AIPersonalizationCreateInput, AIPersonalizationUncheckedCreateInput>
  }

  /**
   * AIPersonalization createMany
   */
  export type AIPersonalizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIPersonalizations.
     */
    data: AIPersonalizationCreateManyInput | AIPersonalizationCreateManyInput[]
  }

  /**
   * AIPersonalization createManyAndReturn
   */
  export type AIPersonalizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPersonalization
     */
    select?: AIPersonalizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIPersonalization
     */
    omit?: AIPersonalizationOmit<ExtArgs> | null
    /**
     * The data used to create many AIPersonalizations.
     */
    data: AIPersonalizationCreateManyInput | AIPersonalizationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPersonalizationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIPersonalization update
   */
  export type AIPersonalizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPersonalization
     */
    select?: AIPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPersonalization
     */
    omit?: AIPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPersonalizationInclude<ExtArgs> | null
    /**
     * The data needed to update a AIPersonalization.
     */
    data: XOR<AIPersonalizationUpdateInput, AIPersonalizationUncheckedUpdateInput>
    /**
     * Choose, which AIPersonalization to update.
     */
    where: AIPersonalizationWhereUniqueInput
  }

  /**
   * AIPersonalization updateMany
   */
  export type AIPersonalizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIPersonalizations.
     */
    data: XOR<AIPersonalizationUpdateManyMutationInput, AIPersonalizationUncheckedUpdateManyInput>
    /**
     * Filter which AIPersonalizations to update
     */
    where?: AIPersonalizationWhereInput
    /**
     * Limit how many AIPersonalizations to update.
     */
    limit?: number
  }

  /**
   * AIPersonalization updateManyAndReturn
   */
  export type AIPersonalizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPersonalization
     */
    select?: AIPersonalizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIPersonalization
     */
    omit?: AIPersonalizationOmit<ExtArgs> | null
    /**
     * The data used to update AIPersonalizations.
     */
    data: XOR<AIPersonalizationUpdateManyMutationInput, AIPersonalizationUncheckedUpdateManyInput>
    /**
     * Filter which AIPersonalizations to update
     */
    where?: AIPersonalizationWhereInput
    /**
     * Limit how many AIPersonalizations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPersonalizationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIPersonalization upsert
   */
  export type AIPersonalizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPersonalization
     */
    select?: AIPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPersonalization
     */
    omit?: AIPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPersonalizationInclude<ExtArgs> | null
    /**
     * The filter to search for the AIPersonalization to update in case it exists.
     */
    where: AIPersonalizationWhereUniqueInput
    /**
     * In case the AIPersonalization found by the `where` argument doesn't exist, create a new AIPersonalization with this data.
     */
    create: XOR<AIPersonalizationCreateInput, AIPersonalizationUncheckedCreateInput>
    /**
     * In case the AIPersonalization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIPersonalizationUpdateInput, AIPersonalizationUncheckedUpdateInput>
  }

  /**
   * AIPersonalization delete
   */
  export type AIPersonalizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPersonalization
     */
    select?: AIPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPersonalization
     */
    omit?: AIPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPersonalizationInclude<ExtArgs> | null
    /**
     * Filter which AIPersonalization to delete.
     */
    where: AIPersonalizationWhereUniqueInput
  }

  /**
   * AIPersonalization deleteMany
   */
  export type AIPersonalizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIPersonalizations to delete
     */
    where?: AIPersonalizationWhereInput
    /**
     * Limit how many AIPersonalizations to delete.
     */
    limit?: number
  }

  /**
   * AIPersonalization.therapist
   */
  export type AIPersonalization$therapistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapist
     */
    select?: AITherapistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapist
     */
    omit?: AITherapistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapistInclude<ExtArgs> | null
    where?: AITherapistWhereInput
  }

  /**
   * AIPersonalization without action
   */
  export type AIPersonalizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPersonalization
     */
    select?: AIPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPersonalization
     */
    omit?: AIPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPersonalizationInclude<ExtArgs> | null
  }


  /**
   * Model AIExerciseSession
   */

  export type AggregateAIExerciseSession = {
    _count: AIExerciseSessionCountAggregateOutputType | null
    _avg: AIExerciseSessionAvgAggregateOutputType | null
    _sum: AIExerciseSessionSumAggregateOutputType | null
    _min: AIExerciseSessionMinAggregateOutputType | null
    _max: AIExerciseSessionMaxAggregateOutputType | null
  }

  export type AIExerciseSessionAvgAggregateOutputType = {
    duration: number | null
    progress: number | null
    improvement: number | null
    moodBefore: number | null
    moodAfter: number | null
  }

  export type AIExerciseSessionSumAggregateOutputType = {
    duration: number | null
    progress: number | null
    improvement: number | null
    moodBefore: number | null
    moodAfter: number | null
  }

  export type AIExerciseSessionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    exerciseType: $Enums.AIExerciseType | null
    exerciseName: string | null
    category: string | null
    difficulty: string | null
    duration: number | null
    startedAt: Date | null
    completedAt: Date | null
    completed: boolean | null
    progress: number | null
    results: string | null
    feedback: string | null
    improvement: number | null
    moodBefore: number | null
    moodAfter: number | null
  }

  export type AIExerciseSessionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    exerciseType: $Enums.AIExerciseType | null
    exerciseName: string | null
    category: string | null
    difficulty: string | null
    duration: number | null
    startedAt: Date | null
    completedAt: Date | null
    completed: boolean | null
    progress: number | null
    results: string | null
    feedback: string | null
    improvement: number | null
    moodBefore: number | null
    moodAfter: number | null
  }

  export type AIExerciseSessionCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    exerciseType: number
    exerciseName: number
    category: number
    difficulty: number
    duration: number
    startedAt: number
    completedAt: number
    completed: number
    progress: number
    results: number
    feedback: number
    improvement: number
    moodBefore: number
    moodAfter: number
    _all: number
  }


  export type AIExerciseSessionAvgAggregateInputType = {
    duration?: true
    progress?: true
    improvement?: true
    moodBefore?: true
    moodAfter?: true
  }

  export type AIExerciseSessionSumAggregateInputType = {
    duration?: true
    progress?: true
    improvement?: true
    moodBefore?: true
    moodAfter?: true
  }

  export type AIExerciseSessionMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    exerciseType?: true
    exerciseName?: true
    category?: true
    difficulty?: true
    duration?: true
    startedAt?: true
    completedAt?: true
    completed?: true
    progress?: true
    results?: true
    feedback?: true
    improvement?: true
    moodBefore?: true
    moodAfter?: true
  }

  export type AIExerciseSessionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    exerciseType?: true
    exerciseName?: true
    category?: true
    difficulty?: true
    duration?: true
    startedAt?: true
    completedAt?: true
    completed?: true
    progress?: true
    results?: true
    feedback?: true
    improvement?: true
    moodBefore?: true
    moodAfter?: true
  }

  export type AIExerciseSessionCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    exerciseType?: true
    exerciseName?: true
    category?: true
    difficulty?: true
    duration?: true
    startedAt?: true
    completedAt?: true
    completed?: true
    progress?: true
    results?: true
    feedback?: true
    improvement?: true
    moodBefore?: true
    moodAfter?: true
    _all?: true
  }

  export type AIExerciseSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIExerciseSession to aggregate.
     */
    where?: AIExerciseSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIExerciseSessions to fetch.
     */
    orderBy?: AIExerciseSessionOrderByWithRelationInput | AIExerciseSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIExerciseSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIExerciseSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIExerciseSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIExerciseSessions
    **/
    _count?: true | AIExerciseSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIExerciseSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIExerciseSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIExerciseSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIExerciseSessionMaxAggregateInputType
  }

  export type GetAIExerciseSessionAggregateType<T extends AIExerciseSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAIExerciseSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIExerciseSession[P]>
      : GetScalarType<T[P], AggregateAIExerciseSession[P]>
  }




  export type AIExerciseSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIExerciseSessionWhereInput
    orderBy?: AIExerciseSessionOrderByWithAggregationInput | AIExerciseSessionOrderByWithAggregationInput[]
    by: AIExerciseSessionScalarFieldEnum[] | AIExerciseSessionScalarFieldEnum
    having?: AIExerciseSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIExerciseSessionCountAggregateInputType | true
    _avg?: AIExerciseSessionAvgAggregateInputType
    _sum?: AIExerciseSessionSumAggregateInputType
    _min?: AIExerciseSessionMinAggregateInputType
    _max?: AIExerciseSessionMaxAggregateInputType
  }

  export type AIExerciseSessionGroupByOutputType = {
    id: string
    sessionId: string | null
    userId: string
    exerciseType: $Enums.AIExerciseType
    exerciseName: string
    category: string
    difficulty: string
    duration: number
    startedAt: Date
    completedAt: Date | null
    completed: boolean
    progress: number
    results: string | null
    feedback: string | null
    improvement: number | null
    moodBefore: number | null
    moodAfter: number | null
    _count: AIExerciseSessionCountAggregateOutputType | null
    _avg: AIExerciseSessionAvgAggregateOutputType | null
    _sum: AIExerciseSessionSumAggregateOutputType | null
    _min: AIExerciseSessionMinAggregateOutputType | null
    _max: AIExerciseSessionMaxAggregateOutputType | null
  }

  type GetAIExerciseSessionGroupByPayload<T extends AIExerciseSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIExerciseSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIExerciseSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIExerciseSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AIExerciseSessionGroupByOutputType[P]>
        }
      >
    >


  export type AIExerciseSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    exerciseType?: boolean
    exerciseName?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    startedAt?: boolean
    completedAt?: boolean
    completed?: boolean
    progress?: boolean
    results?: boolean
    feedback?: boolean
    improvement?: boolean
    moodBefore?: boolean
    moodAfter?: boolean
    session?: boolean | AIExerciseSession$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["aIExerciseSession"]>

  export type AIExerciseSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    exerciseType?: boolean
    exerciseName?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    startedAt?: boolean
    completedAt?: boolean
    completed?: boolean
    progress?: boolean
    results?: boolean
    feedback?: boolean
    improvement?: boolean
    moodBefore?: boolean
    moodAfter?: boolean
    session?: boolean | AIExerciseSession$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["aIExerciseSession"]>

  export type AIExerciseSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    exerciseType?: boolean
    exerciseName?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    startedAt?: boolean
    completedAt?: boolean
    completed?: boolean
    progress?: boolean
    results?: boolean
    feedback?: boolean
    improvement?: boolean
    moodBefore?: boolean
    moodAfter?: boolean
    session?: boolean | AIExerciseSession$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["aIExerciseSession"]>

  export type AIExerciseSessionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    exerciseType?: boolean
    exerciseName?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    startedAt?: boolean
    completedAt?: boolean
    completed?: boolean
    progress?: boolean
    results?: boolean
    feedback?: boolean
    improvement?: boolean
    moodBefore?: boolean
    moodAfter?: boolean
  }

  export type AIExerciseSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "userId" | "exerciseType" | "exerciseName" | "category" | "difficulty" | "duration" | "startedAt" | "completedAt" | "completed" | "progress" | "results" | "feedback" | "improvement" | "moodBefore" | "moodAfter", ExtArgs["result"]["aIExerciseSession"]>
  export type AIExerciseSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AIExerciseSession$sessionArgs<ExtArgs>
  }
  export type AIExerciseSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AIExerciseSession$sessionArgs<ExtArgs>
  }
  export type AIExerciseSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AIExerciseSession$sessionArgs<ExtArgs>
  }

  export type $AIExerciseSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIExerciseSession"
    objects: {
      session: Prisma.$AITherapySessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string | null
      userId: string
      exerciseType: $Enums.AIExerciseType
      exerciseName: string
      category: string
      difficulty: string
      duration: number
      startedAt: Date
      completedAt: Date | null
      completed: boolean
      progress: number
      results: string | null
      feedback: string | null
      improvement: number | null
      moodBefore: number | null
      moodAfter: number | null
    }, ExtArgs["result"]["aIExerciseSession"]>
    composites: {}
  }

  type AIExerciseSessionGetPayload<S extends boolean | null | undefined | AIExerciseSessionDefaultArgs> = $Result.GetResult<Prisma.$AIExerciseSessionPayload, S>

  type AIExerciseSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIExerciseSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AIExerciseSessionCountAggregateInputType | true
    }

  export interface AIExerciseSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIExerciseSession'], meta: { name: 'AIExerciseSession' } }
    /**
     * Find zero or one AIExerciseSession that matches the filter.
     * @param {AIExerciseSessionFindUniqueArgs} args - Arguments to find a AIExerciseSession
     * @example
     * // Get one AIExerciseSession
     * const aIExerciseSession = await prisma.aIExerciseSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIExerciseSessionFindUniqueArgs>(args: SelectSubset<T, AIExerciseSessionFindUniqueArgs<ExtArgs>>): Prisma__AIExerciseSessionClient<$Result.GetResult<Prisma.$AIExerciseSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIExerciseSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIExerciseSessionFindUniqueOrThrowArgs} args - Arguments to find a AIExerciseSession
     * @example
     * // Get one AIExerciseSession
     * const aIExerciseSession = await prisma.aIExerciseSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIExerciseSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AIExerciseSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIExerciseSessionClient<$Result.GetResult<Prisma.$AIExerciseSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIExerciseSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIExerciseSessionFindFirstArgs} args - Arguments to find a AIExerciseSession
     * @example
     * // Get one AIExerciseSession
     * const aIExerciseSession = await prisma.aIExerciseSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIExerciseSessionFindFirstArgs>(args?: SelectSubset<T, AIExerciseSessionFindFirstArgs<ExtArgs>>): Prisma__AIExerciseSessionClient<$Result.GetResult<Prisma.$AIExerciseSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIExerciseSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIExerciseSessionFindFirstOrThrowArgs} args - Arguments to find a AIExerciseSession
     * @example
     * // Get one AIExerciseSession
     * const aIExerciseSession = await prisma.aIExerciseSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIExerciseSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AIExerciseSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIExerciseSessionClient<$Result.GetResult<Prisma.$AIExerciseSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIExerciseSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIExerciseSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIExerciseSessions
     * const aIExerciseSessions = await prisma.aIExerciseSession.findMany()
     * 
     * // Get first 10 AIExerciseSessions
     * const aIExerciseSessions = await prisma.aIExerciseSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIExerciseSessionWithIdOnly = await prisma.aIExerciseSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIExerciseSessionFindManyArgs>(args?: SelectSubset<T, AIExerciseSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIExerciseSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIExerciseSession.
     * @param {AIExerciseSessionCreateArgs} args - Arguments to create a AIExerciseSession.
     * @example
     * // Create one AIExerciseSession
     * const AIExerciseSession = await prisma.aIExerciseSession.create({
     *   data: {
     *     // ... data to create a AIExerciseSession
     *   }
     * })
     * 
     */
    create<T extends AIExerciseSessionCreateArgs>(args: SelectSubset<T, AIExerciseSessionCreateArgs<ExtArgs>>): Prisma__AIExerciseSessionClient<$Result.GetResult<Prisma.$AIExerciseSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIExerciseSessions.
     * @param {AIExerciseSessionCreateManyArgs} args - Arguments to create many AIExerciseSessions.
     * @example
     * // Create many AIExerciseSessions
     * const aIExerciseSession = await prisma.aIExerciseSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIExerciseSessionCreateManyArgs>(args?: SelectSubset<T, AIExerciseSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIExerciseSessions and returns the data saved in the database.
     * @param {AIExerciseSessionCreateManyAndReturnArgs} args - Arguments to create many AIExerciseSessions.
     * @example
     * // Create many AIExerciseSessions
     * const aIExerciseSession = await prisma.aIExerciseSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIExerciseSessions and only return the `id`
     * const aIExerciseSessionWithIdOnly = await prisma.aIExerciseSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIExerciseSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AIExerciseSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIExerciseSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIExerciseSession.
     * @param {AIExerciseSessionDeleteArgs} args - Arguments to delete one AIExerciseSession.
     * @example
     * // Delete one AIExerciseSession
     * const AIExerciseSession = await prisma.aIExerciseSession.delete({
     *   where: {
     *     // ... filter to delete one AIExerciseSession
     *   }
     * })
     * 
     */
    delete<T extends AIExerciseSessionDeleteArgs>(args: SelectSubset<T, AIExerciseSessionDeleteArgs<ExtArgs>>): Prisma__AIExerciseSessionClient<$Result.GetResult<Prisma.$AIExerciseSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIExerciseSession.
     * @param {AIExerciseSessionUpdateArgs} args - Arguments to update one AIExerciseSession.
     * @example
     * // Update one AIExerciseSession
     * const aIExerciseSession = await prisma.aIExerciseSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIExerciseSessionUpdateArgs>(args: SelectSubset<T, AIExerciseSessionUpdateArgs<ExtArgs>>): Prisma__AIExerciseSessionClient<$Result.GetResult<Prisma.$AIExerciseSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIExerciseSessions.
     * @param {AIExerciseSessionDeleteManyArgs} args - Arguments to filter AIExerciseSessions to delete.
     * @example
     * // Delete a few AIExerciseSessions
     * const { count } = await prisma.aIExerciseSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIExerciseSessionDeleteManyArgs>(args?: SelectSubset<T, AIExerciseSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIExerciseSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIExerciseSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIExerciseSessions
     * const aIExerciseSession = await prisma.aIExerciseSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIExerciseSessionUpdateManyArgs>(args: SelectSubset<T, AIExerciseSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIExerciseSessions and returns the data updated in the database.
     * @param {AIExerciseSessionUpdateManyAndReturnArgs} args - Arguments to update many AIExerciseSessions.
     * @example
     * // Update many AIExerciseSessions
     * const aIExerciseSession = await prisma.aIExerciseSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIExerciseSessions and only return the `id`
     * const aIExerciseSessionWithIdOnly = await prisma.aIExerciseSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIExerciseSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, AIExerciseSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIExerciseSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIExerciseSession.
     * @param {AIExerciseSessionUpsertArgs} args - Arguments to update or create a AIExerciseSession.
     * @example
     * // Update or create a AIExerciseSession
     * const aIExerciseSession = await prisma.aIExerciseSession.upsert({
     *   create: {
     *     // ... data to create a AIExerciseSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIExerciseSession we want to update
     *   }
     * })
     */
    upsert<T extends AIExerciseSessionUpsertArgs>(args: SelectSubset<T, AIExerciseSessionUpsertArgs<ExtArgs>>): Prisma__AIExerciseSessionClient<$Result.GetResult<Prisma.$AIExerciseSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIExerciseSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIExerciseSessionCountArgs} args - Arguments to filter AIExerciseSessions to count.
     * @example
     * // Count the number of AIExerciseSessions
     * const count = await prisma.aIExerciseSession.count({
     *   where: {
     *     // ... the filter for the AIExerciseSessions we want to count
     *   }
     * })
    **/
    count<T extends AIExerciseSessionCountArgs>(
      args?: Subset<T, AIExerciseSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIExerciseSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIExerciseSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIExerciseSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIExerciseSessionAggregateArgs>(args: Subset<T, AIExerciseSessionAggregateArgs>): Prisma.PrismaPromise<GetAIExerciseSessionAggregateType<T>>

    /**
     * Group by AIExerciseSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIExerciseSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIExerciseSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIExerciseSessionGroupByArgs['orderBy'] }
        : { orderBy?: AIExerciseSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIExerciseSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIExerciseSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIExerciseSession model
   */
  readonly fields: AIExerciseSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIExerciseSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIExerciseSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends AIExerciseSession$sessionArgs<ExtArgs> = {}>(args?: Subset<T, AIExerciseSession$sessionArgs<ExtArgs>>): Prisma__AITherapySessionClient<$Result.GetResult<Prisma.$AITherapySessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIExerciseSession model
   */
  interface AIExerciseSessionFieldRefs {
    readonly id: FieldRef<"AIExerciseSession", 'String'>
    readonly sessionId: FieldRef<"AIExerciseSession", 'String'>
    readonly userId: FieldRef<"AIExerciseSession", 'String'>
    readonly exerciseType: FieldRef<"AIExerciseSession", 'AIExerciseType'>
    readonly exerciseName: FieldRef<"AIExerciseSession", 'String'>
    readonly category: FieldRef<"AIExerciseSession", 'String'>
    readonly difficulty: FieldRef<"AIExerciseSession", 'String'>
    readonly duration: FieldRef<"AIExerciseSession", 'Int'>
    readonly startedAt: FieldRef<"AIExerciseSession", 'DateTime'>
    readonly completedAt: FieldRef<"AIExerciseSession", 'DateTime'>
    readonly completed: FieldRef<"AIExerciseSession", 'Boolean'>
    readonly progress: FieldRef<"AIExerciseSession", 'Int'>
    readonly results: FieldRef<"AIExerciseSession", 'String'>
    readonly feedback: FieldRef<"AIExerciseSession", 'String'>
    readonly improvement: FieldRef<"AIExerciseSession", 'Float'>
    readonly moodBefore: FieldRef<"AIExerciseSession", 'Int'>
    readonly moodAfter: FieldRef<"AIExerciseSession", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AIExerciseSession findUnique
   */
  export type AIExerciseSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIExerciseSession
     */
    select?: AIExerciseSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIExerciseSession
     */
    omit?: AIExerciseSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIExerciseSessionInclude<ExtArgs> | null
    /**
     * Filter, which AIExerciseSession to fetch.
     */
    where: AIExerciseSessionWhereUniqueInput
  }

  /**
   * AIExerciseSession findUniqueOrThrow
   */
  export type AIExerciseSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIExerciseSession
     */
    select?: AIExerciseSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIExerciseSession
     */
    omit?: AIExerciseSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIExerciseSessionInclude<ExtArgs> | null
    /**
     * Filter, which AIExerciseSession to fetch.
     */
    where: AIExerciseSessionWhereUniqueInput
  }

  /**
   * AIExerciseSession findFirst
   */
  export type AIExerciseSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIExerciseSession
     */
    select?: AIExerciseSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIExerciseSession
     */
    omit?: AIExerciseSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIExerciseSessionInclude<ExtArgs> | null
    /**
     * Filter, which AIExerciseSession to fetch.
     */
    where?: AIExerciseSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIExerciseSessions to fetch.
     */
    orderBy?: AIExerciseSessionOrderByWithRelationInput | AIExerciseSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIExerciseSessions.
     */
    cursor?: AIExerciseSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIExerciseSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIExerciseSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIExerciseSessions.
     */
    distinct?: AIExerciseSessionScalarFieldEnum | AIExerciseSessionScalarFieldEnum[]
  }

  /**
   * AIExerciseSession findFirstOrThrow
   */
  export type AIExerciseSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIExerciseSession
     */
    select?: AIExerciseSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIExerciseSession
     */
    omit?: AIExerciseSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIExerciseSessionInclude<ExtArgs> | null
    /**
     * Filter, which AIExerciseSession to fetch.
     */
    where?: AIExerciseSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIExerciseSessions to fetch.
     */
    orderBy?: AIExerciseSessionOrderByWithRelationInput | AIExerciseSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIExerciseSessions.
     */
    cursor?: AIExerciseSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIExerciseSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIExerciseSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIExerciseSessions.
     */
    distinct?: AIExerciseSessionScalarFieldEnum | AIExerciseSessionScalarFieldEnum[]
  }

  /**
   * AIExerciseSession findMany
   */
  export type AIExerciseSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIExerciseSession
     */
    select?: AIExerciseSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIExerciseSession
     */
    omit?: AIExerciseSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIExerciseSessionInclude<ExtArgs> | null
    /**
     * Filter, which AIExerciseSessions to fetch.
     */
    where?: AIExerciseSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIExerciseSessions to fetch.
     */
    orderBy?: AIExerciseSessionOrderByWithRelationInput | AIExerciseSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIExerciseSessions.
     */
    cursor?: AIExerciseSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIExerciseSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIExerciseSessions.
     */
    skip?: number
    distinct?: AIExerciseSessionScalarFieldEnum | AIExerciseSessionScalarFieldEnum[]
  }

  /**
   * AIExerciseSession create
   */
  export type AIExerciseSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIExerciseSession
     */
    select?: AIExerciseSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIExerciseSession
     */
    omit?: AIExerciseSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIExerciseSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AIExerciseSession.
     */
    data: XOR<AIExerciseSessionCreateInput, AIExerciseSessionUncheckedCreateInput>
  }

  /**
   * AIExerciseSession createMany
   */
  export type AIExerciseSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIExerciseSessions.
     */
    data: AIExerciseSessionCreateManyInput | AIExerciseSessionCreateManyInput[]
  }

  /**
   * AIExerciseSession createManyAndReturn
   */
  export type AIExerciseSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIExerciseSession
     */
    select?: AIExerciseSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIExerciseSession
     */
    omit?: AIExerciseSessionOmit<ExtArgs> | null
    /**
     * The data used to create many AIExerciseSessions.
     */
    data: AIExerciseSessionCreateManyInput | AIExerciseSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIExerciseSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIExerciseSession update
   */
  export type AIExerciseSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIExerciseSession
     */
    select?: AIExerciseSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIExerciseSession
     */
    omit?: AIExerciseSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIExerciseSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AIExerciseSession.
     */
    data: XOR<AIExerciseSessionUpdateInput, AIExerciseSessionUncheckedUpdateInput>
    /**
     * Choose, which AIExerciseSession to update.
     */
    where: AIExerciseSessionWhereUniqueInput
  }

  /**
   * AIExerciseSession updateMany
   */
  export type AIExerciseSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIExerciseSessions.
     */
    data: XOR<AIExerciseSessionUpdateManyMutationInput, AIExerciseSessionUncheckedUpdateManyInput>
    /**
     * Filter which AIExerciseSessions to update
     */
    where?: AIExerciseSessionWhereInput
    /**
     * Limit how many AIExerciseSessions to update.
     */
    limit?: number
  }

  /**
   * AIExerciseSession updateManyAndReturn
   */
  export type AIExerciseSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIExerciseSession
     */
    select?: AIExerciseSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIExerciseSession
     */
    omit?: AIExerciseSessionOmit<ExtArgs> | null
    /**
     * The data used to update AIExerciseSessions.
     */
    data: XOR<AIExerciseSessionUpdateManyMutationInput, AIExerciseSessionUncheckedUpdateManyInput>
    /**
     * Filter which AIExerciseSessions to update
     */
    where?: AIExerciseSessionWhereInput
    /**
     * Limit how many AIExerciseSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIExerciseSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIExerciseSession upsert
   */
  export type AIExerciseSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIExerciseSession
     */
    select?: AIExerciseSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIExerciseSession
     */
    omit?: AIExerciseSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIExerciseSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AIExerciseSession to update in case it exists.
     */
    where: AIExerciseSessionWhereUniqueInput
    /**
     * In case the AIExerciseSession found by the `where` argument doesn't exist, create a new AIExerciseSession with this data.
     */
    create: XOR<AIExerciseSessionCreateInput, AIExerciseSessionUncheckedCreateInput>
    /**
     * In case the AIExerciseSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIExerciseSessionUpdateInput, AIExerciseSessionUncheckedUpdateInput>
  }

  /**
   * AIExerciseSession delete
   */
  export type AIExerciseSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIExerciseSession
     */
    select?: AIExerciseSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIExerciseSession
     */
    omit?: AIExerciseSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIExerciseSessionInclude<ExtArgs> | null
    /**
     * Filter which AIExerciseSession to delete.
     */
    where: AIExerciseSessionWhereUniqueInput
  }

  /**
   * AIExerciseSession deleteMany
   */
  export type AIExerciseSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIExerciseSessions to delete
     */
    where?: AIExerciseSessionWhereInput
    /**
     * Limit how many AIExerciseSessions to delete.
     */
    limit?: number
  }

  /**
   * AIExerciseSession.session
   */
  export type AIExerciseSession$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapySession
     */
    select?: AITherapySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapySession
     */
    omit?: AITherapySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AITherapySessionInclude<ExtArgs> | null
    where?: AITherapySessionWhereInput
  }

  /**
   * AIExerciseSession without action
   */
  export type AIExerciseSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIExerciseSession
     */
    select?: AIExerciseSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIExerciseSession
     */
    omit?: AIExerciseSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIExerciseSessionInclude<ExtArgs> | null
  }


  /**
   * Model AITherapyInsight
   */

  export type AggregateAITherapyInsight = {
    _count: AITherapyInsightCountAggregateOutputType | null
    _min: AITherapyInsightMinAggregateOutputType | null
    _max: AITherapyInsightMaxAggregateOutputType | null
  }

  export type AITherapyInsightMinAggregateOutputType = {
    id: string | null
    userId: string | null
    insightType: $Enums.AIInsightType | null
    title: string | null
    description: string | null
    significance: string | null
    dataPoints: string | null
    patterns: string | null
    trends: string | null
    recommendations: string | null
    actions: string | null
    periodStart: Date | null
    periodEnd: Date | null
    generatedAt: Date | null
    viewed: boolean | null
    viewedAt: Date | null
    helpful: boolean | null
    dismissed: boolean | null
  }

  export type AITherapyInsightMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    insightType: $Enums.AIInsightType | null
    title: string | null
    description: string | null
    significance: string | null
    dataPoints: string | null
    patterns: string | null
    trends: string | null
    recommendations: string | null
    actions: string | null
    periodStart: Date | null
    periodEnd: Date | null
    generatedAt: Date | null
    viewed: boolean | null
    viewedAt: Date | null
    helpful: boolean | null
    dismissed: boolean | null
  }

  export type AITherapyInsightCountAggregateOutputType = {
    id: number
    userId: number
    insightType: number
    title: number
    description: number
    significance: number
    dataPoints: number
    patterns: number
    trends: number
    recommendations: number
    actions: number
    periodStart: number
    periodEnd: number
    generatedAt: number
    viewed: number
    viewedAt: number
    helpful: number
    dismissed: number
    _all: number
  }


  export type AITherapyInsightMinAggregateInputType = {
    id?: true
    userId?: true
    insightType?: true
    title?: true
    description?: true
    significance?: true
    dataPoints?: true
    patterns?: true
    trends?: true
    recommendations?: true
    actions?: true
    periodStart?: true
    periodEnd?: true
    generatedAt?: true
    viewed?: true
    viewedAt?: true
    helpful?: true
    dismissed?: true
  }

  export type AITherapyInsightMaxAggregateInputType = {
    id?: true
    userId?: true
    insightType?: true
    title?: true
    description?: true
    significance?: true
    dataPoints?: true
    patterns?: true
    trends?: true
    recommendations?: true
    actions?: true
    periodStart?: true
    periodEnd?: true
    generatedAt?: true
    viewed?: true
    viewedAt?: true
    helpful?: true
    dismissed?: true
  }

  export type AITherapyInsightCountAggregateInputType = {
    id?: true
    userId?: true
    insightType?: true
    title?: true
    description?: true
    significance?: true
    dataPoints?: true
    patterns?: true
    trends?: true
    recommendations?: true
    actions?: true
    periodStart?: true
    periodEnd?: true
    generatedAt?: true
    viewed?: true
    viewedAt?: true
    helpful?: true
    dismissed?: true
    _all?: true
  }

  export type AITherapyInsightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AITherapyInsight to aggregate.
     */
    where?: AITherapyInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapyInsights to fetch.
     */
    orderBy?: AITherapyInsightOrderByWithRelationInput | AITherapyInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AITherapyInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapyInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapyInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AITherapyInsights
    **/
    _count?: true | AITherapyInsightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AITherapyInsightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AITherapyInsightMaxAggregateInputType
  }

  export type GetAITherapyInsightAggregateType<T extends AITherapyInsightAggregateArgs> = {
        [P in keyof T & keyof AggregateAITherapyInsight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAITherapyInsight[P]>
      : GetScalarType<T[P], AggregateAITherapyInsight[P]>
  }




  export type AITherapyInsightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AITherapyInsightWhereInput
    orderBy?: AITherapyInsightOrderByWithAggregationInput | AITherapyInsightOrderByWithAggregationInput[]
    by: AITherapyInsightScalarFieldEnum[] | AITherapyInsightScalarFieldEnum
    having?: AITherapyInsightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AITherapyInsightCountAggregateInputType | true
    _min?: AITherapyInsightMinAggregateInputType
    _max?: AITherapyInsightMaxAggregateInputType
  }

  export type AITherapyInsightGroupByOutputType = {
    id: string
    userId: string
    insightType: $Enums.AIInsightType
    title: string
    description: string
    significance: string
    dataPoints: string
    patterns: string | null
    trends: string | null
    recommendations: string | null
    actions: string | null
    periodStart: Date
    periodEnd: Date
    generatedAt: Date
    viewed: boolean
    viewedAt: Date | null
    helpful: boolean | null
    dismissed: boolean
    _count: AITherapyInsightCountAggregateOutputType | null
    _min: AITherapyInsightMinAggregateOutputType | null
    _max: AITherapyInsightMaxAggregateOutputType | null
  }

  type GetAITherapyInsightGroupByPayload<T extends AITherapyInsightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AITherapyInsightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AITherapyInsightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AITherapyInsightGroupByOutputType[P]>
            : GetScalarType<T[P], AITherapyInsightGroupByOutputType[P]>
        }
      >
    >


  export type AITherapyInsightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    insightType?: boolean
    title?: boolean
    description?: boolean
    significance?: boolean
    dataPoints?: boolean
    patterns?: boolean
    trends?: boolean
    recommendations?: boolean
    actions?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    generatedAt?: boolean
    viewed?: boolean
    viewedAt?: boolean
    helpful?: boolean
    dismissed?: boolean
  }, ExtArgs["result"]["aITherapyInsight"]>

  export type AITherapyInsightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    insightType?: boolean
    title?: boolean
    description?: boolean
    significance?: boolean
    dataPoints?: boolean
    patterns?: boolean
    trends?: boolean
    recommendations?: boolean
    actions?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    generatedAt?: boolean
    viewed?: boolean
    viewedAt?: boolean
    helpful?: boolean
    dismissed?: boolean
  }, ExtArgs["result"]["aITherapyInsight"]>

  export type AITherapyInsightSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    insightType?: boolean
    title?: boolean
    description?: boolean
    significance?: boolean
    dataPoints?: boolean
    patterns?: boolean
    trends?: boolean
    recommendations?: boolean
    actions?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    generatedAt?: boolean
    viewed?: boolean
    viewedAt?: boolean
    helpful?: boolean
    dismissed?: boolean
  }, ExtArgs["result"]["aITherapyInsight"]>

  export type AITherapyInsightSelectScalar = {
    id?: boolean
    userId?: boolean
    insightType?: boolean
    title?: boolean
    description?: boolean
    significance?: boolean
    dataPoints?: boolean
    patterns?: boolean
    trends?: boolean
    recommendations?: boolean
    actions?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    generatedAt?: boolean
    viewed?: boolean
    viewedAt?: boolean
    helpful?: boolean
    dismissed?: boolean
  }

  export type AITherapyInsightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "insightType" | "title" | "description" | "significance" | "dataPoints" | "patterns" | "trends" | "recommendations" | "actions" | "periodStart" | "periodEnd" | "generatedAt" | "viewed" | "viewedAt" | "helpful" | "dismissed", ExtArgs["result"]["aITherapyInsight"]>

  export type $AITherapyInsightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AITherapyInsight"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      insightType: $Enums.AIInsightType
      title: string
      description: string
      significance: string
      dataPoints: string
      patterns: string | null
      trends: string | null
      recommendations: string | null
      actions: string | null
      periodStart: Date
      periodEnd: Date
      generatedAt: Date
      viewed: boolean
      viewedAt: Date | null
      helpful: boolean | null
      dismissed: boolean
    }, ExtArgs["result"]["aITherapyInsight"]>
    composites: {}
  }

  type AITherapyInsightGetPayload<S extends boolean | null | undefined | AITherapyInsightDefaultArgs> = $Result.GetResult<Prisma.$AITherapyInsightPayload, S>

  type AITherapyInsightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AITherapyInsightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AITherapyInsightCountAggregateInputType | true
    }

  export interface AITherapyInsightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AITherapyInsight'], meta: { name: 'AITherapyInsight' } }
    /**
     * Find zero or one AITherapyInsight that matches the filter.
     * @param {AITherapyInsightFindUniqueArgs} args - Arguments to find a AITherapyInsight
     * @example
     * // Get one AITherapyInsight
     * const aITherapyInsight = await prisma.aITherapyInsight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AITherapyInsightFindUniqueArgs>(args: SelectSubset<T, AITherapyInsightFindUniqueArgs<ExtArgs>>): Prisma__AITherapyInsightClient<$Result.GetResult<Prisma.$AITherapyInsightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AITherapyInsight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AITherapyInsightFindUniqueOrThrowArgs} args - Arguments to find a AITherapyInsight
     * @example
     * // Get one AITherapyInsight
     * const aITherapyInsight = await prisma.aITherapyInsight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AITherapyInsightFindUniqueOrThrowArgs>(args: SelectSubset<T, AITherapyInsightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AITherapyInsightClient<$Result.GetResult<Prisma.$AITherapyInsightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AITherapyInsight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyInsightFindFirstArgs} args - Arguments to find a AITherapyInsight
     * @example
     * // Get one AITherapyInsight
     * const aITherapyInsight = await prisma.aITherapyInsight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AITherapyInsightFindFirstArgs>(args?: SelectSubset<T, AITherapyInsightFindFirstArgs<ExtArgs>>): Prisma__AITherapyInsightClient<$Result.GetResult<Prisma.$AITherapyInsightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AITherapyInsight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyInsightFindFirstOrThrowArgs} args - Arguments to find a AITherapyInsight
     * @example
     * // Get one AITherapyInsight
     * const aITherapyInsight = await prisma.aITherapyInsight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AITherapyInsightFindFirstOrThrowArgs>(args?: SelectSubset<T, AITherapyInsightFindFirstOrThrowArgs<ExtArgs>>): Prisma__AITherapyInsightClient<$Result.GetResult<Prisma.$AITherapyInsightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AITherapyInsights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyInsightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AITherapyInsights
     * const aITherapyInsights = await prisma.aITherapyInsight.findMany()
     * 
     * // Get first 10 AITherapyInsights
     * const aITherapyInsights = await prisma.aITherapyInsight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aITherapyInsightWithIdOnly = await prisma.aITherapyInsight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AITherapyInsightFindManyArgs>(args?: SelectSubset<T, AITherapyInsightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITherapyInsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AITherapyInsight.
     * @param {AITherapyInsightCreateArgs} args - Arguments to create a AITherapyInsight.
     * @example
     * // Create one AITherapyInsight
     * const AITherapyInsight = await prisma.aITherapyInsight.create({
     *   data: {
     *     // ... data to create a AITherapyInsight
     *   }
     * })
     * 
     */
    create<T extends AITherapyInsightCreateArgs>(args: SelectSubset<T, AITherapyInsightCreateArgs<ExtArgs>>): Prisma__AITherapyInsightClient<$Result.GetResult<Prisma.$AITherapyInsightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AITherapyInsights.
     * @param {AITherapyInsightCreateManyArgs} args - Arguments to create many AITherapyInsights.
     * @example
     * // Create many AITherapyInsights
     * const aITherapyInsight = await prisma.aITherapyInsight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AITherapyInsightCreateManyArgs>(args?: SelectSubset<T, AITherapyInsightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AITherapyInsights and returns the data saved in the database.
     * @param {AITherapyInsightCreateManyAndReturnArgs} args - Arguments to create many AITherapyInsights.
     * @example
     * // Create many AITherapyInsights
     * const aITherapyInsight = await prisma.aITherapyInsight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AITherapyInsights and only return the `id`
     * const aITherapyInsightWithIdOnly = await prisma.aITherapyInsight.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AITherapyInsightCreateManyAndReturnArgs>(args?: SelectSubset<T, AITherapyInsightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITherapyInsightPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AITherapyInsight.
     * @param {AITherapyInsightDeleteArgs} args - Arguments to delete one AITherapyInsight.
     * @example
     * // Delete one AITherapyInsight
     * const AITherapyInsight = await prisma.aITherapyInsight.delete({
     *   where: {
     *     // ... filter to delete one AITherapyInsight
     *   }
     * })
     * 
     */
    delete<T extends AITherapyInsightDeleteArgs>(args: SelectSubset<T, AITherapyInsightDeleteArgs<ExtArgs>>): Prisma__AITherapyInsightClient<$Result.GetResult<Prisma.$AITherapyInsightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AITherapyInsight.
     * @param {AITherapyInsightUpdateArgs} args - Arguments to update one AITherapyInsight.
     * @example
     * // Update one AITherapyInsight
     * const aITherapyInsight = await prisma.aITherapyInsight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AITherapyInsightUpdateArgs>(args: SelectSubset<T, AITherapyInsightUpdateArgs<ExtArgs>>): Prisma__AITherapyInsightClient<$Result.GetResult<Prisma.$AITherapyInsightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AITherapyInsights.
     * @param {AITherapyInsightDeleteManyArgs} args - Arguments to filter AITherapyInsights to delete.
     * @example
     * // Delete a few AITherapyInsights
     * const { count } = await prisma.aITherapyInsight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AITherapyInsightDeleteManyArgs>(args?: SelectSubset<T, AITherapyInsightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AITherapyInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyInsightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AITherapyInsights
     * const aITherapyInsight = await prisma.aITherapyInsight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AITherapyInsightUpdateManyArgs>(args: SelectSubset<T, AITherapyInsightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AITherapyInsights and returns the data updated in the database.
     * @param {AITherapyInsightUpdateManyAndReturnArgs} args - Arguments to update many AITherapyInsights.
     * @example
     * // Update many AITherapyInsights
     * const aITherapyInsight = await prisma.aITherapyInsight.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AITherapyInsights and only return the `id`
     * const aITherapyInsightWithIdOnly = await prisma.aITherapyInsight.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AITherapyInsightUpdateManyAndReturnArgs>(args: SelectSubset<T, AITherapyInsightUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITherapyInsightPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AITherapyInsight.
     * @param {AITherapyInsightUpsertArgs} args - Arguments to update or create a AITherapyInsight.
     * @example
     * // Update or create a AITherapyInsight
     * const aITherapyInsight = await prisma.aITherapyInsight.upsert({
     *   create: {
     *     // ... data to create a AITherapyInsight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AITherapyInsight we want to update
     *   }
     * })
     */
    upsert<T extends AITherapyInsightUpsertArgs>(args: SelectSubset<T, AITherapyInsightUpsertArgs<ExtArgs>>): Prisma__AITherapyInsightClient<$Result.GetResult<Prisma.$AITherapyInsightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AITherapyInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyInsightCountArgs} args - Arguments to filter AITherapyInsights to count.
     * @example
     * // Count the number of AITherapyInsights
     * const count = await prisma.aITherapyInsight.count({
     *   where: {
     *     // ... the filter for the AITherapyInsights we want to count
     *   }
     * })
    **/
    count<T extends AITherapyInsightCountArgs>(
      args?: Subset<T, AITherapyInsightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AITherapyInsightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AITherapyInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyInsightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AITherapyInsightAggregateArgs>(args: Subset<T, AITherapyInsightAggregateArgs>): Prisma.PrismaPromise<GetAITherapyInsightAggregateType<T>>

    /**
     * Group by AITherapyInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyInsightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AITherapyInsightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AITherapyInsightGroupByArgs['orderBy'] }
        : { orderBy?: AITherapyInsightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AITherapyInsightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAITherapyInsightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AITherapyInsight model
   */
  readonly fields: AITherapyInsightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AITherapyInsight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AITherapyInsightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AITherapyInsight model
   */
  interface AITherapyInsightFieldRefs {
    readonly id: FieldRef<"AITherapyInsight", 'String'>
    readonly userId: FieldRef<"AITherapyInsight", 'String'>
    readonly insightType: FieldRef<"AITherapyInsight", 'AIInsightType'>
    readonly title: FieldRef<"AITherapyInsight", 'String'>
    readonly description: FieldRef<"AITherapyInsight", 'String'>
    readonly significance: FieldRef<"AITherapyInsight", 'String'>
    readonly dataPoints: FieldRef<"AITherapyInsight", 'String'>
    readonly patterns: FieldRef<"AITherapyInsight", 'String'>
    readonly trends: FieldRef<"AITherapyInsight", 'String'>
    readonly recommendations: FieldRef<"AITherapyInsight", 'String'>
    readonly actions: FieldRef<"AITherapyInsight", 'String'>
    readonly periodStart: FieldRef<"AITherapyInsight", 'DateTime'>
    readonly periodEnd: FieldRef<"AITherapyInsight", 'DateTime'>
    readonly generatedAt: FieldRef<"AITherapyInsight", 'DateTime'>
    readonly viewed: FieldRef<"AITherapyInsight", 'Boolean'>
    readonly viewedAt: FieldRef<"AITherapyInsight", 'DateTime'>
    readonly helpful: FieldRef<"AITherapyInsight", 'Boolean'>
    readonly dismissed: FieldRef<"AITherapyInsight", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AITherapyInsight findUnique
   */
  export type AITherapyInsightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyInsight
     */
    select?: AITherapyInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyInsight
     */
    omit?: AITherapyInsightOmit<ExtArgs> | null
    /**
     * Filter, which AITherapyInsight to fetch.
     */
    where: AITherapyInsightWhereUniqueInput
  }

  /**
   * AITherapyInsight findUniqueOrThrow
   */
  export type AITherapyInsightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyInsight
     */
    select?: AITherapyInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyInsight
     */
    omit?: AITherapyInsightOmit<ExtArgs> | null
    /**
     * Filter, which AITherapyInsight to fetch.
     */
    where: AITherapyInsightWhereUniqueInput
  }

  /**
   * AITherapyInsight findFirst
   */
  export type AITherapyInsightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyInsight
     */
    select?: AITherapyInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyInsight
     */
    omit?: AITherapyInsightOmit<ExtArgs> | null
    /**
     * Filter, which AITherapyInsight to fetch.
     */
    where?: AITherapyInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapyInsights to fetch.
     */
    orderBy?: AITherapyInsightOrderByWithRelationInput | AITherapyInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AITherapyInsights.
     */
    cursor?: AITherapyInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapyInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapyInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AITherapyInsights.
     */
    distinct?: AITherapyInsightScalarFieldEnum | AITherapyInsightScalarFieldEnum[]
  }

  /**
   * AITherapyInsight findFirstOrThrow
   */
  export type AITherapyInsightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyInsight
     */
    select?: AITherapyInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyInsight
     */
    omit?: AITherapyInsightOmit<ExtArgs> | null
    /**
     * Filter, which AITherapyInsight to fetch.
     */
    where?: AITherapyInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapyInsights to fetch.
     */
    orderBy?: AITherapyInsightOrderByWithRelationInput | AITherapyInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AITherapyInsights.
     */
    cursor?: AITherapyInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapyInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapyInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AITherapyInsights.
     */
    distinct?: AITherapyInsightScalarFieldEnum | AITherapyInsightScalarFieldEnum[]
  }

  /**
   * AITherapyInsight findMany
   */
  export type AITherapyInsightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyInsight
     */
    select?: AITherapyInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyInsight
     */
    omit?: AITherapyInsightOmit<ExtArgs> | null
    /**
     * Filter, which AITherapyInsights to fetch.
     */
    where?: AITherapyInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapyInsights to fetch.
     */
    orderBy?: AITherapyInsightOrderByWithRelationInput | AITherapyInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AITherapyInsights.
     */
    cursor?: AITherapyInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapyInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapyInsights.
     */
    skip?: number
    distinct?: AITherapyInsightScalarFieldEnum | AITherapyInsightScalarFieldEnum[]
  }

  /**
   * AITherapyInsight create
   */
  export type AITherapyInsightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyInsight
     */
    select?: AITherapyInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyInsight
     */
    omit?: AITherapyInsightOmit<ExtArgs> | null
    /**
     * The data needed to create a AITherapyInsight.
     */
    data: XOR<AITherapyInsightCreateInput, AITherapyInsightUncheckedCreateInput>
  }

  /**
   * AITherapyInsight createMany
   */
  export type AITherapyInsightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AITherapyInsights.
     */
    data: AITherapyInsightCreateManyInput | AITherapyInsightCreateManyInput[]
  }

  /**
   * AITherapyInsight createManyAndReturn
   */
  export type AITherapyInsightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyInsight
     */
    select?: AITherapyInsightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyInsight
     */
    omit?: AITherapyInsightOmit<ExtArgs> | null
    /**
     * The data used to create many AITherapyInsights.
     */
    data: AITherapyInsightCreateManyInput | AITherapyInsightCreateManyInput[]
  }

  /**
   * AITherapyInsight update
   */
  export type AITherapyInsightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyInsight
     */
    select?: AITherapyInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyInsight
     */
    omit?: AITherapyInsightOmit<ExtArgs> | null
    /**
     * The data needed to update a AITherapyInsight.
     */
    data: XOR<AITherapyInsightUpdateInput, AITherapyInsightUncheckedUpdateInput>
    /**
     * Choose, which AITherapyInsight to update.
     */
    where: AITherapyInsightWhereUniqueInput
  }

  /**
   * AITherapyInsight updateMany
   */
  export type AITherapyInsightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AITherapyInsights.
     */
    data: XOR<AITherapyInsightUpdateManyMutationInput, AITherapyInsightUncheckedUpdateManyInput>
    /**
     * Filter which AITherapyInsights to update
     */
    where?: AITherapyInsightWhereInput
    /**
     * Limit how many AITherapyInsights to update.
     */
    limit?: number
  }

  /**
   * AITherapyInsight updateManyAndReturn
   */
  export type AITherapyInsightUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyInsight
     */
    select?: AITherapyInsightSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyInsight
     */
    omit?: AITherapyInsightOmit<ExtArgs> | null
    /**
     * The data used to update AITherapyInsights.
     */
    data: XOR<AITherapyInsightUpdateManyMutationInput, AITherapyInsightUncheckedUpdateManyInput>
    /**
     * Filter which AITherapyInsights to update
     */
    where?: AITherapyInsightWhereInput
    /**
     * Limit how many AITherapyInsights to update.
     */
    limit?: number
  }

  /**
   * AITherapyInsight upsert
   */
  export type AITherapyInsightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyInsight
     */
    select?: AITherapyInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyInsight
     */
    omit?: AITherapyInsightOmit<ExtArgs> | null
    /**
     * The filter to search for the AITherapyInsight to update in case it exists.
     */
    where: AITherapyInsightWhereUniqueInput
    /**
     * In case the AITherapyInsight found by the `where` argument doesn't exist, create a new AITherapyInsight with this data.
     */
    create: XOR<AITherapyInsightCreateInput, AITherapyInsightUncheckedCreateInput>
    /**
     * In case the AITherapyInsight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AITherapyInsightUpdateInput, AITherapyInsightUncheckedUpdateInput>
  }

  /**
   * AITherapyInsight delete
   */
  export type AITherapyInsightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyInsight
     */
    select?: AITherapyInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyInsight
     */
    omit?: AITherapyInsightOmit<ExtArgs> | null
    /**
     * Filter which AITherapyInsight to delete.
     */
    where: AITherapyInsightWhereUniqueInput
  }

  /**
   * AITherapyInsight deleteMany
   */
  export type AITherapyInsightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AITherapyInsights to delete
     */
    where?: AITherapyInsightWhereInput
    /**
     * Limit how many AITherapyInsights to delete.
     */
    limit?: number
  }

  /**
   * AITherapyInsight without action
   */
  export type AITherapyInsightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyInsight
     */
    select?: AITherapyInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyInsight
     */
    omit?: AITherapyInsightOmit<ExtArgs> | null
  }


  /**
   * Model AITherapyGoal
   */

  export type AggregateAITherapyGoal = {
    _count: AITherapyGoalCountAggregateOutputType | null
    _avg: AITherapyGoalAvgAggregateOutputType | null
    _sum: AITherapyGoalSumAggregateOutputType | null
    _min: AITherapyGoalMinAggregateOutputType | null
    _max: AITherapyGoalMaxAggregateOutputType | null
  }

  export type AITherapyGoalAvgAggregateOutputType = {
    progress: number | null
  }

  export type AITherapyGoalSumAggregateOutputType = {
    progress: number | null
  }

  export type AITherapyGoalMinAggregateOutputType = {
    id: string | null
    userId: string | null
    goalType: string | null
    title: string | null
    description: string | null
    category: string | null
    priority: string | null
    specific: string | null
    measurable: string | null
    achievable: string | null
    relevant: string | null
    timebound: Date | null
    status: $Enums.AIGoalStatus | null
    progress: number | null
    milestones: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type AITherapyGoalMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    goalType: string | null
    title: string | null
    description: string | null
    category: string | null
    priority: string | null
    specific: string | null
    measurable: string | null
    achievable: string | null
    relevant: string | null
    timebound: Date | null
    status: $Enums.AIGoalStatus | null
    progress: number | null
    milestones: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type AITherapyGoalCountAggregateOutputType = {
    id: number
    userId: number
    goalType: number
    title: number
    description: number
    category: number
    priority: number
    specific: number
    measurable: number
    achievable: number
    relevant: number
    timebound: number
    status: number
    progress: number
    milestones: number
    createdAt: number
    updatedAt: number
    completedAt: number
    _all: number
  }


  export type AITherapyGoalAvgAggregateInputType = {
    progress?: true
  }

  export type AITherapyGoalSumAggregateInputType = {
    progress?: true
  }

  export type AITherapyGoalMinAggregateInputType = {
    id?: true
    userId?: true
    goalType?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    specific?: true
    measurable?: true
    achievable?: true
    relevant?: true
    timebound?: true
    status?: true
    progress?: true
    milestones?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type AITherapyGoalMaxAggregateInputType = {
    id?: true
    userId?: true
    goalType?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    specific?: true
    measurable?: true
    achievable?: true
    relevant?: true
    timebound?: true
    status?: true
    progress?: true
    milestones?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type AITherapyGoalCountAggregateInputType = {
    id?: true
    userId?: true
    goalType?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    specific?: true
    measurable?: true
    achievable?: true
    relevant?: true
    timebound?: true
    status?: true
    progress?: true
    milestones?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    _all?: true
  }

  export type AITherapyGoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AITherapyGoal to aggregate.
     */
    where?: AITherapyGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapyGoals to fetch.
     */
    orderBy?: AITherapyGoalOrderByWithRelationInput | AITherapyGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AITherapyGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapyGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapyGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AITherapyGoals
    **/
    _count?: true | AITherapyGoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AITherapyGoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AITherapyGoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AITherapyGoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AITherapyGoalMaxAggregateInputType
  }

  export type GetAITherapyGoalAggregateType<T extends AITherapyGoalAggregateArgs> = {
        [P in keyof T & keyof AggregateAITherapyGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAITherapyGoal[P]>
      : GetScalarType<T[P], AggregateAITherapyGoal[P]>
  }




  export type AITherapyGoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AITherapyGoalWhereInput
    orderBy?: AITherapyGoalOrderByWithAggregationInput | AITherapyGoalOrderByWithAggregationInput[]
    by: AITherapyGoalScalarFieldEnum[] | AITherapyGoalScalarFieldEnum
    having?: AITherapyGoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AITherapyGoalCountAggregateInputType | true
    _avg?: AITherapyGoalAvgAggregateInputType
    _sum?: AITherapyGoalSumAggregateInputType
    _min?: AITherapyGoalMinAggregateInputType
    _max?: AITherapyGoalMaxAggregateInputType
  }

  export type AITherapyGoalGroupByOutputType = {
    id: string
    userId: string
    goalType: string
    title: string
    description: string
    category: string
    priority: string
    specific: string
    measurable: string
    achievable: string
    relevant: string
    timebound: Date
    status: $Enums.AIGoalStatus
    progress: number
    milestones: string | null
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    _count: AITherapyGoalCountAggregateOutputType | null
    _avg: AITherapyGoalAvgAggregateOutputType | null
    _sum: AITherapyGoalSumAggregateOutputType | null
    _min: AITherapyGoalMinAggregateOutputType | null
    _max: AITherapyGoalMaxAggregateOutputType | null
  }

  type GetAITherapyGoalGroupByPayload<T extends AITherapyGoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AITherapyGoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AITherapyGoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AITherapyGoalGroupByOutputType[P]>
            : GetScalarType<T[P], AITherapyGoalGroupByOutputType[P]>
        }
      >
    >


  export type AITherapyGoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    goalType?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    specific?: boolean
    measurable?: boolean
    achievable?: boolean
    relevant?: boolean
    timebound?: boolean
    status?: boolean
    progress?: boolean
    milestones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["aITherapyGoal"]>

  export type AITherapyGoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    goalType?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    specific?: boolean
    measurable?: boolean
    achievable?: boolean
    relevant?: boolean
    timebound?: boolean
    status?: boolean
    progress?: boolean
    milestones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["aITherapyGoal"]>

  export type AITherapyGoalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    goalType?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    specific?: boolean
    measurable?: boolean
    achievable?: boolean
    relevant?: boolean
    timebound?: boolean
    status?: boolean
    progress?: boolean
    milestones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["aITherapyGoal"]>

  export type AITherapyGoalSelectScalar = {
    id?: boolean
    userId?: boolean
    goalType?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    specific?: boolean
    measurable?: boolean
    achievable?: boolean
    relevant?: boolean
    timebound?: boolean
    status?: boolean
    progress?: boolean
    milestones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }

  export type AITherapyGoalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "goalType" | "title" | "description" | "category" | "priority" | "specific" | "measurable" | "achievable" | "relevant" | "timebound" | "status" | "progress" | "milestones" | "createdAt" | "updatedAt" | "completedAt", ExtArgs["result"]["aITherapyGoal"]>

  export type $AITherapyGoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AITherapyGoal"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      goalType: string
      title: string
      description: string
      category: string
      priority: string
      specific: string
      measurable: string
      achievable: string
      relevant: string
      timebound: Date
      status: $Enums.AIGoalStatus
      progress: number
      milestones: string | null
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["aITherapyGoal"]>
    composites: {}
  }

  type AITherapyGoalGetPayload<S extends boolean | null | undefined | AITherapyGoalDefaultArgs> = $Result.GetResult<Prisma.$AITherapyGoalPayload, S>

  type AITherapyGoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AITherapyGoalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AITherapyGoalCountAggregateInputType | true
    }

  export interface AITherapyGoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AITherapyGoal'], meta: { name: 'AITherapyGoal' } }
    /**
     * Find zero or one AITherapyGoal that matches the filter.
     * @param {AITherapyGoalFindUniqueArgs} args - Arguments to find a AITherapyGoal
     * @example
     * // Get one AITherapyGoal
     * const aITherapyGoal = await prisma.aITherapyGoal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AITherapyGoalFindUniqueArgs>(args: SelectSubset<T, AITherapyGoalFindUniqueArgs<ExtArgs>>): Prisma__AITherapyGoalClient<$Result.GetResult<Prisma.$AITherapyGoalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AITherapyGoal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AITherapyGoalFindUniqueOrThrowArgs} args - Arguments to find a AITherapyGoal
     * @example
     * // Get one AITherapyGoal
     * const aITherapyGoal = await prisma.aITherapyGoal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AITherapyGoalFindUniqueOrThrowArgs>(args: SelectSubset<T, AITherapyGoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AITherapyGoalClient<$Result.GetResult<Prisma.$AITherapyGoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AITherapyGoal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyGoalFindFirstArgs} args - Arguments to find a AITherapyGoal
     * @example
     * // Get one AITherapyGoal
     * const aITherapyGoal = await prisma.aITherapyGoal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AITherapyGoalFindFirstArgs>(args?: SelectSubset<T, AITherapyGoalFindFirstArgs<ExtArgs>>): Prisma__AITherapyGoalClient<$Result.GetResult<Prisma.$AITherapyGoalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AITherapyGoal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyGoalFindFirstOrThrowArgs} args - Arguments to find a AITherapyGoal
     * @example
     * // Get one AITherapyGoal
     * const aITherapyGoal = await prisma.aITherapyGoal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AITherapyGoalFindFirstOrThrowArgs>(args?: SelectSubset<T, AITherapyGoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__AITherapyGoalClient<$Result.GetResult<Prisma.$AITherapyGoalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AITherapyGoals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyGoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AITherapyGoals
     * const aITherapyGoals = await prisma.aITherapyGoal.findMany()
     * 
     * // Get first 10 AITherapyGoals
     * const aITherapyGoals = await prisma.aITherapyGoal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aITherapyGoalWithIdOnly = await prisma.aITherapyGoal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AITherapyGoalFindManyArgs>(args?: SelectSubset<T, AITherapyGoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITherapyGoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AITherapyGoal.
     * @param {AITherapyGoalCreateArgs} args - Arguments to create a AITherapyGoal.
     * @example
     * // Create one AITherapyGoal
     * const AITherapyGoal = await prisma.aITherapyGoal.create({
     *   data: {
     *     // ... data to create a AITherapyGoal
     *   }
     * })
     * 
     */
    create<T extends AITherapyGoalCreateArgs>(args: SelectSubset<T, AITherapyGoalCreateArgs<ExtArgs>>): Prisma__AITherapyGoalClient<$Result.GetResult<Prisma.$AITherapyGoalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AITherapyGoals.
     * @param {AITherapyGoalCreateManyArgs} args - Arguments to create many AITherapyGoals.
     * @example
     * // Create many AITherapyGoals
     * const aITherapyGoal = await prisma.aITherapyGoal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AITherapyGoalCreateManyArgs>(args?: SelectSubset<T, AITherapyGoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AITherapyGoals and returns the data saved in the database.
     * @param {AITherapyGoalCreateManyAndReturnArgs} args - Arguments to create many AITherapyGoals.
     * @example
     * // Create many AITherapyGoals
     * const aITherapyGoal = await prisma.aITherapyGoal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AITherapyGoals and only return the `id`
     * const aITherapyGoalWithIdOnly = await prisma.aITherapyGoal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AITherapyGoalCreateManyAndReturnArgs>(args?: SelectSubset<T, AITherapyGoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITherapyGoalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AITherapyGoal.
     * @param {AITherapyGoalDeleteArgs} args - Arguments to delete one AITherapyGoal.
     * @example
     * // Delete one AITherapyGoal
     * const AITherapyGoal = await prisma.aITherapyGoal.delete({
     *   where: {
     *     // ... filter to delete one AITherapyGoal
     *   }
     * })
     * 
     */
    delete<T extends AITherapyGoalDeleteArgs>(args: SelectSubset<T, AITherapyGoalDeleteArgs<ExtArgs>>): Prisma__AITherapyGoalClient<$Result.GetResult<Prisma.$AITherapyGoalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AITherapyGoal.
     * @param {AITherapyGoalUpdateArgs} args - Arguments to update one AITherapyGoal.
     * @example
     * // Update one AITherapyGoal
     * const aITherapyGoal = await prisma.aITherapyGoal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AITherapyGoalUpdateArgs>(args: SelectSubset<T, AITherapyGoalUpdateArgs<ExtArgs>>): Prisma__AITherapyGoalClient<$Result.GetResult<Prisma.$AITherapyGoalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AITherapyGoals.
     * @param {AITherapyGoalDeleteManyArgs} args - Arguments to filter AITherapyGoals to delete.
     * @example
     * // Delete a few AITherapyGoals
     * const { count } = await prisma.aITherapyGoal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AITherapyGoalDeleteManyArgs>(args?: SelectSubset<T, AITherapyGoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AITherapyGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyGoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AITherapyGoals
     * const aITherapyGoal = await prisma.aITherapyGoal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AITherapyGoalUpdateManyArgs>(args: SelectSubset<T, AITherapyGoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AITherapyGoals and returns the data updated in the database.
     * @param {AITherapyGoalUpdateManyAndReturnArgs} args - Arguments to update many AITherapyGoals.
     * @example
     * // Update many AITherapyGoals
     * const aITherapyGoal = await prisma.aITherapyGoal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AITherapyGoals and only return the `id`
     * const aITherapyGoalWithIdOnly = await prisma.aITherapyGoal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AITherapyGoalUpdateManyAndReturnArgs>(args: SelectSubset<T, AITherapyGoalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITherapyGoalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AITherapyGoal.
     * @param {AITherapyGoalUpsertArgs} args - Arguments to update or create a AITherapyGoal.
     * @example
     * // Update or create a AITherapyGoal
     * const aITherapyGoal = await prisma.aITherapyGoal.upsert({
     *   create: {
     *     // ... data to create a AITherapyGoal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AITherapyGoal we want to update
     *   }
     * })
     */
    upsert<T extends AITherapyGoalUpsertArgs>(args: SelectSubset<T, AITherapyGoalUpsertArgs<ExtArgs>>): Prisma__AITherapyGoalClient<$Result.GetResult<Prisma.$AITherapyGoalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AITherapyGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyGoalCountArgs} args - Arguments to filter AITherapyGoals to count.
     * @example
     * // Count the number of AITherapyGoals
     * const count = await prisma.aITherapyGoal.count({
     *   where: {
     *     // ... the filter for the AITherapyGoals we want to count
     *   }
     * })
    **/
    count<T extends AITherapyGoalCountArgs>(
      args?: Subset<T, AITherapyGoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AITherapyGoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AITherapyGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyGoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AITherapyGoalAggregateArgs>(args: Subset<T, AITherapyGoalAggregateArgs>): Prisma.PrismaPromise<GetAITherapyGoalAggregateType<T>>

    /**
     * Group by AITherapyGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITherapyGoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AITherapyGoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AITherapyGoalGroupByArgs['orderBy'] }
        : { orderBy?: AITherapyGoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AITherapyGoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAITherapyGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AITherapyGoal model
   */
  readonly fields: AITherapyGoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AITherapyGoal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AITherapyGoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AITherapyGoal model
   */
  interface AITherapyGoalFieldRefs {
    readonly id: FieldRef<"AITherapyGoal", 'String'>
    readonly userId: FieldRef<"AITherapyGoal", 'String'>
    readonly goalType: FieldRef<"AITherapyGoal", 'String'>
    readonly title: FieldRef<"AITherapyGoal", 'String'>
    readonly description: FieldRef<"AITherapyGoal", 'String'>
    readonly category: FieldRef<"AITherapyGoal", 'String'>
    readonly priority: FieldRef<"AITherapyGoal", 'String'>
    readonly specific: FieldRef<"AITherapyGoal", 'String'>
    readonly measurable: FieldRef<"AITherapyGoal", 'String'>
    readonly achievable: FieldRef<"AITherapyGoal", 'String'>
    readonly relevant: FieldRef<"AITherapyGoal", 'String'>
    readonly timebound: FieldRef<"AITherapyGoal", 'DateTime'>
    readonly status: FieldRef<"AITherapyGoal", 'AIGoalStatus'>
    readonly progress: FieldRef<"AITherapyGoal", 'Int'>
    readonly milestones: FieldRef<"AITherapyGoal", 'String'>
    readonly createdAt: FieldRef<"AITherapyGoal", 'DateTime'>
    readonly updatedAt: FieldRef<"AITherapyGoal", 'DateTime'>
    readonly completedAt: FieldRef<"AITherapyGoal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AITherapyGoal findUnique
   */
  export type AITherapyGoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyGoal
     */
    select?: AITherapyGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyGoal
     */
    omit?: AITherapyGoalOmit<ExtArgs> | null
    /**
     * Filter, which AITherapyGoal to fetch.
     */
    where: AITherapyGoalWhereUniqueInput
  }

  /**
   * AITherapyGoal findUniqueOrThrow
   */
  export type AITherapyGoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyGoal
     */
    select?: AITherapyGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyGoal
     */
    omit?: AITherapyGoalOmit<ExtArgs> | null
    /**
     * Filter, which AITherapyGoal to fetch.
     */
    where: AITherapyGoalWhereUniqueInput
  }

  /**
   * AITherapyGoal findFirst
   */
  export type AITherapyGoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyGoal
     */
    select?: AITherapyGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyGoal
     */
    omit?: AITherapyGoalOmit<ExtArgs> | null
    /**
     * Filter, which AITherapyGoal to fetch.
     */
    where?: AITherapyGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapyGoals to fetch.
     */
    orderBy?: AITherapyGoalOrderByWithRelationInput | AITherapyGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AITherapyGoals.
     */
    cursor?: AITherapyGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapyGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapyGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AITherapyGoals.
     */
    distinct?: AITherapyGoalScalarFieldEnum | AITherapyGoalScalarFieldEnum[]
  }

  /**
   * AITherapyGoal findFirstOrThrow
   */
  export type AITherapyGoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyGoal
     */
    select?: AITherapyGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyGoal
     */
    omit?: AITherapyGoalOmit<ExtArgs> | null
    /**
     * Filter, which AITherapyGoal to fetch.
     */
    where?: AITherapyGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapyGoals to fetch.
     */
    orderBy?: AITherapyGoalOrderByWithRelationInput | AITherapyGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AITherapyGoals.
     */
    cursor?: AITherapyGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapyGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapyGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AITherapyGoals.
     */
    distinct?: AITherapyGoalScalarFieldEnum | AITherapyGoalScalarFieldEnum[]
  }

  /**
   * AITherapyGoal findMany
   */
  export type AITherapyGoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyGoal
     */
    select?: AITherapyGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyGoal
     */
    omit?: AITherapyGoalOmit<ExtArgs> | null
    /**
     * Filter, which AITherapyGoals to fetch.
     */
    where?: AITherapyGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITherapyGoals to fetch.
     */
    orderBy?: AITherapyGoalOrderByWithRelationInput | AITherapyGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AITherapyGoals.
     */
    cursor?: AITherapyGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITherapyGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITherapyGoals.
     */
    skip?: number
    distinct?: AITherapyGoalScalarFieldEnum | AITherapyGoalScalarFieldEnum[]
  }

  /**
   * AITherapyGoal create
   */
  export type AITherapyGoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyGoal
     */
    select?: AITherapyGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyGoal
     */
    omit?: AITherapyGoalOmit<ExtArgs> | null
    /**
     * The data needed to create a AITherapyGoal.
     */
    data: XOR<AITherapyGoalCreateInput, AITherapyGoalUncheckedCreateInput>
  }

  /**
   * AITherapyGoal createMany
   */
  export type AITherapyGoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AITherapyGoals.
     */
    data: AITherapyGoalCreateManyInput | AITherapyGoalCreateManyInput[]
  }

  /**
   * AITherapyGoal createManyAndReturn
   */
  export type AITherapyGoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyGoal
     */
    select?: AITherapyGoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyGoal
     */
    omit?: AITherapyGoalOmit<ExtArgs> | null
    /**
     * The data used to create many AITherapyGoals.
     */
    data: AITherapyGoalCreateManyInput | AITherapyGoalCreateManyInput[]
  }

  /**
   * AITherapyGoal update
   */
  export type AITherapyGoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyGoal
     */
    select?: AITherapyGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyGoal
     */
    omit?: AITherapyGoalOmit<ExtArgs> | null
    /**
     * The data needed to update a AITherapyGoal.
     */
    data: XOR<AITherapyGoalUpdateInput, AITherapyGoalUncheckedUpdateInput>
    /**
     * Choose, which AITherapyGoal to update.
     */
    where: AITherapyGoalWhereUniqueInput
  }

  /**
   * AITherapyGoal updateMany
   */
  export type AITherapyGoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AITherapyGoals.
     */
    data: XOR<AITherapyGoalUpdateManyMutationInput, AITherapyGoalUncheckedUpdateManyInput>
    /**
     * Filter which AITherapyGoals to update
     */
    where?: AITherapyGoalWhereInput
    /**
     * Limit how many AITherapyGoals to update.
     */
    limit?: number
  }

  /**
   * AITherapyGoal updateManyAndReturn
   */
  export type AITherapyGoalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyGoal
     */
    select?: AITherapyGoalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyGoal
     */
    omit?: AITherapyGoalOmit<ExtArgs> | null
    /**
     * The data used to update AITherapyGoals.
     */
    data: XOR<AITherapyGoalUpdateManyMutationInput, AITherapyGoalUncheckedUpdateManyInput>
    /**
     * Filter which AITherapyGoals to update
     */
    where?: AITherapyGoalWhereInput
    /**
     * Limit how many AITherapyGoals to update.
     */
    limit?: number
  }

  /**
   * AITherapyGoal upsert
   */
  export type AITherapyGoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyGoal
     */
    select?: AITherapyGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyGoal
     */
    omit?: AITherapyGoalOmit<ExtArgs> | null
    /**
     * The filter to search for the AITherapyGoal to update in case it exists.
     */
    where: AITherapyGoalWhereUniqueInput
    /**
     * In case the AITherapyGoal found by the `where` argument doesn't exist, create a new AITherapyGoal with this data.
     */
    create: XOR<AITherapyGoalCreateInput, AITherapyGoalUncheckedCreateInput>
    /**
     * In case the AITherapyGoal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AITherapyGoalUpdateInput, AITherapyGoalUncheckedUpdateInput>
  }

  /**
   * AITherapyGoal delete
   */
  export type AITherapyGoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyGoal
     */
    select?: AITherapyGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyGoal
     */
    omit?: AITherapyGoalOmit<ExtArgs> | null
    /**
     * Filter which AITherapyGoal to delete.
     */
    where: AITherapyGoalWhereUniqueInput
  }

  /**
   * AITherapyGoal deleteMany
   */
  export type AITherapyGoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AITherapyGoals to delete
     */
    where?: AITherapyGoalWhereInput
    /**
     * Limit how many AITherapyGoals to delete.
     */
    limit?: number
  }

  /**
   * AITherapyGoal without action
   */
  export type AITherapyGoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITherapyGoal
     */
    select?: AITherapyGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITherapyGoal
     */
    omit?: AITherapyGoalOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CrisisSessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    anonymousId: 'anonymousId',
    severity: 'severity',
    status: 'status',
    responderId: 'responderId',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    responseTimeMs: 'responseTimeMs',
    outcome: 'outcome',
    encryptedData: 'encryptedData',
    keyDerivationSalt: 'keyDerivationSalt',
    handoffTime: 'handoffTime',
    resolutionTime: 'resolutionTime',
    emergencyTriggered: 'emergencyTriggered',
    escalatedAt: 'escalatedAt',
    escalationType: 'escalationType'
  };

  export type CrisisSessionScalarFieldEnum = (typeof CrisisSessionScalarFieldEnum)[keyof typeof CrisisSessionScalarFieldEnum]


  export const CrisisMessageScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    senderType: 'senderType',
    senderId: 'senderId',
    encryptedContent: 'encryptedContent',
    messageHash: 'messageHash',
    timestamp: 'timestamp',
    messageType: 'messageType',
    priority: 'priority',
    sentimentScore: 'sentimentScore',
    riskScore: 'riskScore',
    riskLevel: 'riskLevel',
    keywordsDetected: 'keywordsDetected'
  };

  export type CrisisMessageScalarFieldEnum = (typeof CrisisMessageScalarFieldEnum)[keyof typeof CrisisMessageScalarFieldEnum]


  export const CrisisEscalationScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    triggeredBy: 'triggeredBy',
    severity: 'severity',
    reason: 'reason',
    actionsTaken: 'actionsTaken',
    emergencyContacted: 'emergencyContacted',
    lifeline988Called: 'lifeline988Called',
    triggeredAt: 'triggeredAt',
    resolvedAt: 'resolvedAt',
    responseTime: 'responseTime',
    handledBy: 'handledBy',
    outcome: 'outcome'
  };

  export type CrisisEscalationScalarFieldEnum = (typeof CrisisEscalationScalarFieldEnum)[keyof typeof CrisisEscalationScalarFieldEnum]


  export const TetherLinkScalarFieldEnum: {
    id: 'id',
    seekerId: 'seekerId',
    supporterId: 'supporterId',
    strength: 'strength',
    trustScore: 'trustScore',
    established: 'established',
    lastActivity: 'lastActivity',
    pulseInterval: 'pulseInterval',
    lastPulse: 'lastPulse',
    missedPulses: 'missedPulses',
    emergencyActive: 'emergencyActive',
    emergencyType: 'emergencyType',
    lastEmergency: 'lastEmergency',
    matchingScore: 'matchingScore',
    specialties: 'specialties',
    languages: 'languages',
    timezone: 'timezone',
    dataSharing: 'dataSharing',
    locationSharing: 'locationSharing',
    emergencyContact: 'emergencyContact',
    encryptedMeta: 'encryptedMeta'
  };

  export type TetherLinkScalarFieldEnum = (typeof TetherLinkScalarFieldEnum)[keyof typeof TetherLinkScalarFieldEnum]


  export const TetherPulseScalarFieldEnum: {
    id: 'id',
    tetherId: 'tetherId',
    pulseType: 'pulseType',
    strength: 'strength',
    mood: 'mood',
    status: 'status',
    message: 'message',
    emergencySignal: 'emergencySignal',
    urgencyLevel: 'urgencyLevel',
    timestamp: 'timestamp',
    acknowledged: 'acknowledged',
    acknowledgedAt: 'acknowledgedAt'
  };

  export type TetherPulseScalarFieldEnum = (typeof TetherPulseScalarFieldEnum)[keyof typeof TetherPulseScalarFieldEnum]


  export const TetherEmergencyScalarFieldEnum: {
    id: 'id',
    tetherId: 'tetherId',
    triggerUserId: 'triggerUserId',
    emergencyType: 'emergencyType',
    severity: 'severity',
    description: 'description',
    location: 'location',
    triggeredAt: 'triggeredAt',
    acknowledgedAt: 'acknowledgedAt',
    respondedAt: 'respondedAt',
    resolvedAt: 'resolvedAt',
    responseTime: 'responseTime',
    actionsTaken: 'actionsTaken',
    outcome: 'outcome',
    helpersNotified: 'helpersNotified',
    emergencyContacts: 'emergencyContacts'
  };

  export type TetherEmergencyScalarFieldEnum = (typeof TetherEmergencyScalarFieldEnum)[keyof typeof TetherEmergencyScalarFieldEnum]


  export const VolunteerScalarFieldEnum: {
    id: 'id',
    anonymousId: 'anonymousId',
    status: 'status',
    trainingHours: 'trainingHours',
    certifications: 'certifications',
    specializations: 'specializations',
    languages: 'languages',
    backgroundCheck: 'backgroundCheck',
    sessionsCount: 'sessionsCount',
    hoursVolunteered: 'hoursVolunteered',
    averageRating: 'averageRating',
    responseRate: 'responseRate',
    isActive: 'isActive',
    currentLoad: 'currentLoad',
    maxConcurrent: 'maxConcurrent',
    schedule: 'schedule',
    timezone: 'timezone',
    lastActive: 'lastActive',
    burnoutScore: 'burnoutScore',
    needsSupport: 'needsSupport',
    emergencyResponder: 'emergencyResponder',
    emergencyAvailable: 'emergencyAvailable'
  };

  export type VolunteerScalarFieldEnum = (typeof VolunteerScalarFieldEnum)[keyof typeof VolunteerScalarFieldEnum]


  export const VolunteerTrainingScalarFieldEnum: {
    id: 'id',
    volunteerId: 'volunteerId',
    moduleId: 'moduleId',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    score: 'score',
    passingScore: 'passingScore',
    attempts: 'attempts',
    moduleTitle: 'moduleTitle',
    moduleType: 'moduleType',
    duration: 'duration',
    content: 'content'
  };

  export type VolunteerTrainingScalarFieldEnum = (typeof VolunteerTrainingScalarFieldEnum)[keyof typeof VolunteerTrainingScalarFieldEnum]


  export const VolunteerSessionScalarFieldEnum: {
    id: 'id',
    volunteerId: 'volunteerId',
    sessionType: 'sessionType',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    duration: 'duration',
    crisisSessionId: 'crisisSessionId',
    responseTime: 'responseTime',
    userSatisfaction: 'userSatisfaction',
    outcome: 'outcome'
  };

  export type VolunteerSessionScalarFieldEnum = (typeof VolunteerSessionScalarFieldEnum)[keyof typeof VolunteerSessionScalarFieldEnum]


  export const VolunteerFeedbackScalarFieldEnum: {
    id: 'id',
    volunteerId: 'volunteerId',
    sessionId: 'sessionId',
    feedbackType: 'feedbackType',
    rating: 'rating',
    comment: 'comment',
    submittedBy: 'submittedBy',
    sourceType: 'sourceType',
    submittedAt: 'submittedAt',
    isAnonymous: 'isAnonymous',
    isApproved: 'isApproved',
    moderatedAt: 'moderatedAt',
    moderatedBy: 'moderatedBy'
  };

  export type VolunteerFeedbackScalarFieldEnum = (typeof VolunteerFeedbackScalarFieldEnum)[keyof typeof VolunteerFeedbackScalarFieldEnum]


  export const CrisisResourceUsageScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    resourceId: 'resourceId',
    accessedAt: 'accessedAt',
    timeSpent: 'timeSpent',
    wasHelpful: 'wasHelpful',
    helpfulRating: 'helpfulRating',
    resourceTitle: 'resourceTitle',
    resourceType: 'resourceType'
  };

  export type CrisisResourceUsageScalarFieldEnum = (typeof CrisisResourceUsageScalarFieldEnum)[keyof typeof CrisisResourceUsageScalarFieldEnum]


  export const SafetyReportScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    messageId: 'messageId',
    reportType: 'reportType',
    severity: 'severity',
    status: 'status',
    content: 'content',
    reason: 'reason',
    confidence: 'confidence',
    aiAnalysis: 'aiAnalysis',
    keywordsMatched: 'keywordsMatched',
    riskScore: 'riskScore',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    reviewNotes: 'reviewNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SafetyReportScalarFieldEnum = (typeof SafetyReportScalarFieldEnum)[keyof typeof SafetyReportScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    success: 'success',
    errorMessage: 'errorMessage',
    timestamp: 'timestamp',
    sessionId: 'sessionId'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const AnalyticsEventScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType',
    eventName: 'eventName',
    userHash: 'userHash',
    sessionId: 'sessionId',
    properties: 'properties',
    timestamp: 'timestamp',
    responseTime: 'responseTime',
    success: 'success',
    errorCode: 'errorCode'
  };

  export type AnalyticsEventScalarFieldEnum = (typeof AnalyticsEventScalarFieldEnum)[keyof typeof AnalyticsEventScalarFieldEnum]


  export const PerformanceMetricScalarFieldEnum: {
    id: 'id',
    metricType: 'metricType',
    value: 'value',
    unit: 'unit',
    endpoint: 'endpoint',
    region: 'region',
    timestamp: 'timestamp',
    target: 'target',
    threshold: 'threshold',
    status: 'status'
  };

  export type PerformanceMetricScalarFieldEnum = (typeof PerformanceMetricScalarFieldEnum)[keyof typeof PerformanceMetricScalarFieldEnum]


  export const SystemHealthScalarFieldEnum: {
    id: 'id',
    component: 'component',
    status: 'status',
    responseTime: 'responseTime',
    uptime: 'uptime',
    errorRate: 'errorRate',
    lastError: 'lastError',
    errorMessage: 'errorMessage',
    cpuUsage: 'cpuUsage',
    memoryUsage: 'memoryUsage',
    diskUsage: 'diskUsage',
    timestamp: 'timestamp'
  };

  export type SystemHealthScalarFieldEnum = (typeof SystemHealthScalarFieldEnum)[keyof typeof SystemHealthScalarFieldEnum]


  export const CrisisResourceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    phoneNumber: 'phoneNumber',
    url: 'url',
    email: 'email',
    textNumber: 'textNumber',
    content: 'content',
    instructions: 'instructions',
    available24_7: 'available24_7',
    languages: 'languages',
    countries: 'countries',
    regions: 'regions',
    priority: 'priority',
    isEmergency: 'isEmergency',
    severityMin: 'severityMin',
    tags: 'tags',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CrisisResourceScalarFieldEnum = (typeof CrisisResourceScalarFieldEnum)[keyof typeof CrisisResourceScalarFieldEnum]


  export const PublicMetricsScalarFieldEnum: {
    id: 'id',
    metricName: 'metricName',
    value: 'value',
    displayValue: 'displayValue',
    description: 'description',
    isPublic: 'isPublic',
    displayOrder: 'displayOrder',
    icon: 'icon',
    color: 'color',
    lastUpdated: 'lastUpdated',
    updateFrequency: 'updateFrequency'
  };

  export type PublicMetricsScalarFieldEnum = (typeof PublicMetricsScalarFieldEnum)[keyof typeof PublicMetricsScalarFieldEnum]


  export const EmergencyContactScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    encryptedName: 'encryptedName',
    encryptedPhone: 'encryptedPhone',
    encryptedEmail: 'encryptedEmail',
    relationship: 'relationship',
    priority: 'priority',
    contactMethod: 'contactMethod',
    timezone: 'timezone',
    availableHours: 'availableHours',
    preferredMethod: 'preferredMethod',
    autoNotify: 'autoNotify',
    crisisOnly: 'crisisOnly',
    hasConsent: 'hasConsent',
    consentDate: 'consentDate',
    keyDerivationSalt: 'keyDerivationSalt',
    isVerified: 'isVerified',
    verifiedAt: 'verifiedAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastContacted: 'lastContacted'
  };

  export type EmergencyContactScalarFieldEnum = (typeof EmergencyContactScalarFieldEnum)[keyof typeof EmergencyContactScalarFieldEnum]


  export const EmergencyNotificationScalarFieldEnum: {
    id: 'id',
    emergencyContactId: 'emergencyContactId',
    sessionId: 'sessionId',
    tetherEmergencyId: 'tetherEmergencyId',
    notificationType: 'notificationType',
    severity: 'severity',
    message: 'message',
    sentAt: 'sentAt',
    deliveredAt: 'deliveredAt',
    acknowledgedAt: 'acknowledgedAt',
    responseReceived: 'responseReceived',
    responseTime: 'responseTime',
    method: 'method',
    status: 'status',
    attempts: 'attempts',
    maxAttempts: 'maxAttempts',
    errorMessage: 'errorMessage',
    nextRetryAt: 'nextRetryAt'
  };

  export type EmergencyNotificationScalarFieldEnum = (typeof EmergencyNotificationScalarFieldEnum)[keyof typeof EmergencyNotificationScalarFieldEnum]


  export const WebSocketConnectionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userType: 'userType',
    userId: 'userId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    lastActivity: 'lastActivity',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type WebSocketConnectionScalarFieldEnum = (typeof WebSocketConnectionScalarFieldEnum)[keyof typeof WebSocketConnectionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    anonymousId: 'anonymousId',
    email: 'email',
    username: 'username',
    isAnonymous: 'isAnonymous',
    lastLogin: 'lastLogin',
    dataSharing: 'dataSharing',
    allowAnalytics: 'allowAnalytics',
    dataRetentionDays: 'dataRetentionDays',
    verificationStatus: 'verificationStatus',
    professionalType: 'professionalType',
    licenseNumber: 'licenseNumber',
    verifiedAt: 'verifiedAt',
    encryptedProfile: 'encryptedProfile',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MoodEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mood: 'mood',
    emotions: 'emotions',
    triggers: 'triggers',
    activities: 'activities',
    sleepHours: 'sleepHours',
    notes: 'notes',
    weather: 'weather',
    medication: 'medication',
    socialInteraction: 'socialInteraction',
    timestamp: 'timestamp'
  };

  export type MoodEntryScalarFieldEnum = (typeof MoodEntryScalarFieldEnum)[keyof typeof MoodEntryScalarFieldEnum]


  export const SafetyPlanScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    version: 'version',
    isActive: 'isActive',
    encryptedContent: 'encryptedContent',
    contentHash: 'contentHash',
    sharedWith: 'sharedWith',
    emergencyShare: 'emergencyShare',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SafetyPlanScalarFieldEnum = (typeof SafetyPlanScalarFieldEnum)[keyof typeof SafetyPlanScalarFieldEnum]


  export const SafetyPlanVersionScalarFieldEnum: {
    id: 'id',
    safetyPlanId: 'safetyPlanId',
    version: 'version',
    changeLog: 'changeLog',
    encryptedContent: 'encryptedContent',
    contentHash: 'contentHash',
    createdAt: 'createdAt',
    createdBy: 'createdBy'
  };

  export type SafetyPlanVersionScalarFieldEnum = (typeof SafetyPlanVersionScalarFieldEnum)[keyof typeof SafetyPlanVersionScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    displayName: 'displayName',
    level: 'level',
    totalXP: 'totalXP',
    preferences: 'preferences',
    stats: 'stats',
    joinDate: 'joinDate',
    lastActiveDate: 'lastActiveDate'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    rarity: 'rarity',
    requirements: 'requirements',
    xpReward: 'xpReward',
    pointReward: 'pointReward',
    icon: 'icon',
    color: 'color',
    isActive: 'isActive'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const UserAchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    achievementId: 'achievementId',
    progress: 'progress',
    isUnlocked: 'isUnlocked',
    unlockedAt: 'unlockedAt',
    createdAt: 'createdAt'
  };

  export type UserAchievementScalarFieldEnum = (typeof UserAchievementScalarFieldEnum)[keyof typeof UserAchievementScalarFieldEnum]


  export const ChallengeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    difficulty: 'difficulty',
    requirements: 'requirements',
    duration: 'duration',
    xpReward: 'xpReward',
    pointReward: 'pointReward',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive'
  };

  export type ChallengeScalarFieldEnum = (typeof ChallengeScalarFieldEnum)[keyof typeof ChallengeScalarFieldEnum]


  export const UserChallengeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    challengeId: 'challengeId',
    progress: 'progress',
    isCompleted: 'isCompleted',
    completedAt: 'completedAt',
    startedAt: 'startedAt',
    data: 'data'
  };

  export type UserChallengeScalarFieldEnum = (typeof UserChallengeScalarFieldEnum)[keyof typeof UserChallengeScalarFieldEnum]


  export const UserActivityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    description: 'description',
    xpEarned: 'xpEarned',
    pointsEarned: 'pointsEarned',
    metadata: 'metadata',
    timestamp: 'timestamp'
  };

  export type UserActivityScalarFieldEnum = (typeof UserActivityScalarFieldEnum)[keyof typeof UserActivityScalarFieldEnum]


  export const JournalEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    promptId: 'promptId',
    promptText: 'promptText',
    entryType: 'entryType',
    encryptedContent: 'encryptedContent',
    contentHash: 'contentHash',
    keyDerivationSalt: 'keyDerivationSalt',
    mood: 'mood',
    sentimentScore: 'sentimentScore',
    emotions: 'emotions',
    tags: 'tags',
    isPrivate: 'isPrivate',
    shareWithTherapist: 'shareWithTherapist',
    wordCount: 'wordCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JournalEntryScalarFieldEnum = (typeof JournalEntryScalarFieldEnum)[keyof typeof JournalEntryScalarFieldEnum]


  export const BreathingExerciseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    technique: 'technique',
    difficulty: 'difficulty',
    inhaleSeconds: 'inhaleSeconds',
    holdSeconds: 'holdSeconds',
    exhaleSeconds: 'exhaleSeconds',
    pauseSeconds: 'pauseSeconds',
    cyclesRecommended: 'cyclesRecommended',
    instructions: 'instructions',
    visualGuideUrl: 'visualGuideUrl',
    audioGuideUrl: 'audioGuideUrl',
    benefits: 'benefits',
    bestFor: 'bestFor',
    contraindications: 'contraindications',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type BreathingExerciseScalarFieldEnum = (typeof BreathingExerciseScalarFieldEnum)[keyof typeof BreathingExerciseScalarFieldEnum]


  export const BreathingSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    exerciseId: 'exerciseId',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    duration: 'duration',
    cyclesCompleted: 'cyclesCompleted',
    moodBefore: 'moodBefore',
    moodAfter: 'moodAfter',
    anxietyBefore: 'anxietyBefore',
    anxietyAfter: 'anxietyAfter',
    averageBreathRate: 'averageBreathRate',
    heartRateBefore: 'heartRateBefore',
    heartRateAfter: 'heartRateAfter',
    wasHelpful: 'wasHelpful',
    rating: 'rating',
    notes: 'notes'
  };

  export type BreathingSessionScalarFieldEnum = (typeof BreathingSessionScalarFieldEnum)[keyof typeof BreathingSessionScalarFieldEnum]


  export const GroundingTechniqueScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    category: 'category',
    instructions: 'instructions',
    duration: 'duration',
    materials: 'materials',
    audioGuideUrl: 'audioGuideUrl',
    videoGuideUrl: 'videoGuideUrl',
    imageGuides: 'imageGuides',
    evidenceLevel: 'evidenceLevel',
    bestFor: 'bestFor',
    contraindications: 'contraindications',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type GroundingTechniqueScalarFieldEnum = (typeof GroundingTechniqueScalarFieldEnum)[keyof typeof GroundingTechniqueScalarFieldEnum]


  export const GroundingSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    techniqueId: 'techniqueId',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    duration: 'duration',
    triggerType: 'triggerType',
    severityBefore: 'severityBefore',
    severityAfter: 'severityAfter',
    panicBefore: 'panicBefore',
    panicAfter: 'panicAfter',
    dissociationBefore: 'dissociationBefore',
    dissociationAfter: 'dissociationAfter',
    stepsCompleted: 'stepsCompleted',
    completionRate: 'completionRate',
    wasHelpful: 'wasHelpful',
    rating: 'rating',
    notes: 'notes',
    wouldUseAgain: 'wouldUseAgain'
  };

  export type GroundingSessionScalarFieldEnum = (typeof GroundingSessionScalarFieldEnum)[keyof typeof GroundingSessionScalarFieldEnum]


  export const SelfHelpResourceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    type: 'type',
    content: 'content',
    url: 'url',
    mediaUrl: 'mediaUrl',
    thumbnailUrl: 'thumbnailUrl',
    duration: 'duration',
    difficulty: 'difficulty',
    evidenceLevel: 'evidenceLevel',
    tags: 'tags',
    conditions: 'conditions',
    symptoms: 'symptoms',
    viewCount: 'viewCount',
    helpfulCount: 'helpfulCount',
    averageRating: 'averageRating',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SelfHelpResourceScalarFieldEnum = (typeof SelfHelpResourceScalarFieldEnum)[keyof typeof SelfHelpResourceScalarFieldEnum]


  export const SelfHelpInteractionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resourceId: 'resourceId',
    interactionType: 'interactionType',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    duration: 'duration',
    wasHelpful: 'wasHelpful',
    rating: 'rating',
    notes: 'notes',
    moodBefore: 'moodBefore',
    moodAfter: 'moodAfter'
  };

  export type SelfHelpInteractionScalarFieldEnum = (typeof SelfHelpInteractionScalarFieldEnum)[keyof typeof SelfHelpInteractionScalarFieldEnum]


  export const AITherapistScalarFieldEnum: {
    id: 'id',
    therapistId: 'therapistId',
    name: 'name',
    avatar: 'avatar',
    personality: 'personality',
    description: 'description',
    specialties: 'specialties',
    approaches: 'approaches',
    bestFor: 'bestFor',
    features: 'features',
    availability: 'availability',
    sessionsCompleted: 'sessionsCompleted',
    userRating: 'userRating',
    responseTime: 'responseTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AITherapistScalarFieldEnum = (typeof AITherapistScalarFieldEnum)[keyof typeof AITherapistScalarFieldEnum]


  export const AITherapySessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    therapistId: 'therapistId',
    sessionType: 'sessionType',
    status: 'status',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    duration: 'duration',
    pausedAt: 'pausedAt',
    pausedDuration: 'pausedDuration',
    moodBefore: 'moodBefore',
    moodAfter: 'moodAfter',
    anxietyBefore: 'anxietyBefore',
    anxietyAfter: 'anxietyAfter',
    energyBefore: 'energyBefore',
    energyAfter: 'energyAfter',
    encryptedNotes: 'encryptedNotes',
    encryptedInsights: 'encryptedInsights',
    encryptedHomework: 'encryptedHomework',
    encryptedGoals: 'encryptedGoals',
    topics: 'topics',
    techniques: 'techniques',
    interventions: 'interventions',
    breakthroughs: 'breakthroughs',
    crisisDetected: 'crisisDetected',
    crisisLevel: 'crisisLevel',
    crisisInterventions: 'crisisInterventions'
  };

  export type AITherapySessionScalarFieldEnum = (typeof AITherapySessionScalarFieldEnum)[keyof typeof AITherapySessionScalarFieldEnum]


  export const AITherapyMessageScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    messageType: 'messageType',
    sender: 'sender',
    encryptedContent: 'encryptedContent',
    messageHash: 'messageHash',
    timestamp: 'timestamp',
    edited: 'edited',
    editedAt: 'editedAt',
    sentiment: 'sentiment',
    emotion: 'emotion',
    riskScore: 'riskScore',
    techniques: 'techniques',
    hasAudio: 'hasAudio',
    audioDuration: 'audioDuration',
    audioUrl: 'audioUrl'
  };

  export type AITherapyMessageScalarFieldEnum = (typeof AITherapyMessageScalarFieldEnum)[keyof typeof AITherapyMessageScalarFieldEnum]


  export const AIPersonalizationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    therapistId: 'therapistId',
    preferredStyle: 'preferredStyle',
    preferredTechniques: 'preferredTechniques',
    preferredTopics: 'preferredTopics',
    avoidTopics: 'avoidTopics',
    responseLength: 'responseLength',
    responseComplexity: 'responseComplexity',
    empathyLevel: 'empathyLevel',
    directness: 'directness',
    culturalBackground: 'culturalBackground',
    languagePreference: 'languagePreference',
    timezone: 'timezone',
    pronouns: 'pronouns',
    learnedPatterns: 'learnedPatterns',
    effectiveTechniques: 'effectiveTechniques',
    triggerPatterns: 'triggerPatterns',
    copingStrategies: 'copingStrategies',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIPersonalizationScalarFieldEnum = (typeof AIPersonalizationScalarFieldEnum)[keyof typeof AIPersonalizationScalarFieldEnum]


  export const AIExerciseSessionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    exerciseType: 'exerciseType',
    exerciseName: 'exerciseName',
    category: 'category',
    difficulty: 'difficulty',
    duration: 'duration',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    completed: 'completed',
    progress: 'progress',
    results: 'results',
    feedback: 'feedback',
    improvement: 'improvement',
    moodBefore: 'moodBefore',
    moodAfter: 'moodAfter'
  };

  export type AIExerciseSessionScalarFieldEnum = (typeof AIExerciseSessionScalarFieldEnum)[keyof typeof AIExerciseSessionScalarFieldEnum]


  export const AITherapyInsightScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    insightType: 'insightType',
    title: 'title',
    description: 'description',
    significance: 'significance',
    dataPoints: 'dataPoints',
    patterns: 'patterns',
    trends: 'trends',
    recommendations: 'recommendations',
    actions: 'actions',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    generatedAt: 'generatedAt',
    viewed: 'viewed',
    viewedAt: 'viewedAt',
    helpful: 'helpful',
    dismissed: 'dismissed'
  };

  export type AITherapyInsightScalarFieldEnum = (typeof AITherapyInsightScalarFieldEnum)[keyof typeof AITherapyInsightScalarFieldEnum]


  export const AITherapyGoalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    goalType: 'goalType',
    title: 'title',
    description: 'description',
    category: 'category',
    priority: 'priority',
    specific: 'specific',
    measurable: 'measurable',
    achievable: 'achievable',
    relevant: 'relevant',
    timebound: 'timebound',
    status: 'status',
    progress: 'progress',
    milestones: 'milestones',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt'
  };

  export type AITherapyGoalScalarFieldEnum = (typeof AITherapyGoalScalarFieldEnum)[keyof typeof AITherapyGoalScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'CrisisStatus'
   */
  export type EnumCrisisStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CrisisStatus'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'EscalationType'
   */
  export type EnumEscalationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EscalationType'>
    


  /**
   * Reference to a field of type 'MessageSender'
   */
  export type EnumMessageSenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageSender'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessagePriority'
   */
  export type EnumMessagePriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessagePriority'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'EscalationTrigger'
   */
  export type EnumEscalationTriggerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EscalationTrigger'>
    


  /**
   * Reference to a field of type 'EscalationSeverity'
   */
  export type EnumEscalationSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EscalationSeverity'>
    


  /**
   * Reference to a field of type 'EscalationOutcome'
   */
  export type EnumEscalationOutcomeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EscalationOutcome'>
    


  /**
   * Reference to a field of type 'EmergencyType'
   */
  export type EnumEmergencyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmergencyType'>
    


  /**
   * Reference to a field of type 'TetherDataSharing'
   */
  export type EnumTetherDataSharingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TetherDataSharing'>
    


  /**
   * Reference to a field of type 'PulseType'
   */
  export type EnumPulseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PulseType'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UrgencyLevel'
   */
  export type EnumUrgencyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UrgencyLevel'>
    


  /**
   * Reference to a field of type 'EmergencySeverity'
   */
  export type EnumEmergencySeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmergencySeverity'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'EmergencyOutcome'
   */
  export type EnumEmergencyOutcomeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmergencyOutcome'>
    


  /**
   * Reference to a field of type 'VolunteerStatus'
   */
  export type EnumVolunteerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VolunteerStatus'>
    


  /**
   * Reference to a field of type 'VerificationStatus'
   */
  export type EnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus'>
    


  /**
   * Reference to a field of type 'TrainingStatus'
   */
  export type EnumTrainingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingStatus'>
    


  /**
   * Reference to a field of type 'TrainingType'
   */
  export type EnumTrainingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingType'>
    


  /**
   * Reference to a field of type 'VolunteerSessionType'
   */
  export type EnumVolunteerSessionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VolunteerSessionType'>
    


  /**
   * Reference to a field of type 'SessionOutcome'
   */
  export type EnumSessionOutcomeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionOutcome'>
    


  /**
   * Reference to a field of type 'FeedbackType'
   */
  export type EnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType'>
    


  /**
   * Reference to a field of type 'FeedbackSource'
   */
  export type EnumFeedbackSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackSource'>
    


  /**
   * Reference to a field of type 'ResourceCategory'
   */
  export type EnumResourceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceCategory'>
    


  /**
   * Reference to a field of type 'ReportType'
   */
  export type EnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType'>
    


  /**
   * Reference to a field of type 'ReportSeverity'
   */
  export type EnumReportSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportSeverity'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'MetricStatus'
   */
  export type EnumMetricStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetricStatus'>
    


  /**
   * Reference to a field of type 'HealthStatus'
   */
  export type EnumHealthStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HealthStatus'>
    


  /**
   * Reference to a field of type 'EmergencyNotificationType'
   */
  export type EnumEmergencyNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmergencyNotificationType'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'UserDataSharing'
   */
  export type EnumUserDataSharingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserDataSharing'>
    


  /**
   * Reference to a field of type 'AchievementCategory'
   */
  export type EnumAchievementCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementCategory'>
    


  /**
   * Reference to a field of type 'AchievementRarity'
   */
  export type EnumAchievementRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementRarity'>
    


  /**
   * Reference to a field of type 'ChallengeType'
   */
  export type EnumChallengeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeType'>
    


  /**
   * Reference to a field of type 'ChallengeDifficulty'
   */
  export type EnumChallengeDifficultyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeDifficulty'>
    


  /**
   * Reference to a field of type 'ActivityType'
   */
  export type EnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType'>
    


  /**
   * Reference to a field of type 'JournalType'
   */
  export type EnumJournalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JournalType'>
    


  /**
   * Reference to a field of type 'BreathingTechnique'
   */
  export type EnumBreathingTechniqueFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BreathingTechnique'>
    


  /**
   * Reference to a field of type 'ExerciseDifficulty'
   */
  export type EnumExerciseDifficultyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExerciseDifficulty'>
    


  /**
   * Reference to a field of type 'GroundingType'
   */
  export type EnumGroundingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroundingType'>
    


  /**
   * Reference to a field of type 'GroundingCategory'
   */
  export type EnumGroundingCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroundingCategory'>
    


  /**
   * Reference to a field of type 'EvidenceLevel'
   */
  export type EnumEvidenceLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EvidenceLevel'>
    


  /**
   * Reference to a field of type 'SelfHelpCategory'
   */
  export type EnumSelfHelpCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SelfHelpCategory'>
    


  /**
   * Reference to a field of type 'ResourceType'
   */
  export type EnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType'>
    


  /**
   * Reference to a field of type 'InteractionType'
   */
  export type EnumInteractionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteractionType'>
    


  /**
   * Reference to a field of type 'AISessionType'
   */
  export type EnumAISessionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AISessionType'>
    


  /**
   * Reference to a field of type 'AISessionStatus'
   */
  export type EnumAISessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AISessionStatus'>
    


  /**
   * Reference to a field of type 'AIMessageType'
   */
  export type EnumAIMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIMessageType'>
    


  /**
   * Reference to a field of type 'AIMessageSender'
   */
  export type EnumAIMessageSenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIMessageSender'>
    


  /**
   * Reference to a field of type 'AIExerciseType'
   */
  export type EnumAIExerciseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIExerciseType'>
    


  /**
   * Reference to a field of type 'AIInsightType'
   */
  export type EnumAIInsightTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIInsightType'>
    


  /**
   * Reference to a field of type 'AIGoalStatus'
   */
  export type EnumAIGoalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIGoalStatus'>
    
  /**
   * Deep Input Types
   */


  export type CrisisSessionWhereInput = {
    AND?: CrisisSessionWhereInput | CrisisSessionWhereInput[]
    OR?: CrisisSessionWhereInput[]
    NOT?: CrisisSessionWhereInput | CrisisSessionWhereInput[]
    id?: StringFilter<"CrisisSession"> | string
    sessionToken?: StringFilter<"CrisisSession"> | string
    anonymousId?: StringFilter<"CrisisSession"> | string
    severity?: IntFilter<"CrisisSession"> | number
    status?: EnumCrisisStatusFilter<"CrisisSession"> | $Enums.CrisisStatus
    responderId?: StringNullableFilter<"CrisisSession"> | string | null
    startedAt?: DateTimeFilter<"CrisisSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"CrisisSession"> | Date | string | null
    responseTimeMs?: IntNullableFilter<"CrisisSession"> | number | null
    outcome?: StringNullableFilter<"CrisisSession"> | string | null
    encryptedData?: BytesNullableFilter<"CrisisSession"> | Uint8Array | null
    keyDerivationSalt?: BytesNullableFilter<"CrisisSession"> | Uint8Array | null
    handoffTime?: IntNullableFilter<"CrisisSession"> | number | null
    resolutionTime?: IntNullableFilter<"CrisisSession"> | number | null
    emergencyTriggered?: BoolFilter<"CrisisSession"> | boolean
    escalatedAt?: DateTimeNullableFilter<"CrisisSession"> | Date | string | null
    escalationType?: EnumEscalationTypeNullableFilter<"CrisisSession"> | $Enums.EscalationType | null
    messages?: CrisisMessageListRelationFilter
    escalations?: CrisisEscalationListRelationFilter
    resources?: CrisisResourceUsageListRelationFilter
  }

  export type CrisisSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    anonymousId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    responderId?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    responseTimeMs?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    encryptedData?: SortOrderInput | SortOrder
    keyDerivationSalt?: SortOrderInput | SortOrder
    handoffTime?: SortOrderInput | SortOrder
    resolutionTime?: SortOrderInput | SortOrder
    emergencyTriggered?: SortOrder
    escalatedAt?: SortOrderInput | SortOrder
    escalationType?: SortOrderInput | SortOrder
    messages?: CrisisMessageOrderByRelationAggregateInput
    escalations?: CrisisEscalationOrderByRelationAggregateInput
    resources?: CrisisResourceUsageOrderByRelationAggregateInput
  }

  export type CrisisSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    anonymousId?: string
    AND?: CrisisSessionWhereInput | CrisisSessionWhereInput[]
    OR?: CrisisSessionWhereInput[]
    NOT?: CrisisSessionWhereInput | CrisisSessionWhereInput[]
    severity?: IntFilter<"CrisisSession"> | number
    status?: EnumCrisisStatusFilter<"CrisisSession"> | $Enums.CrisisStatus
    responderId?: StringNullableFilter<"CrisisSession"> | string | null
    startedAt?: DateTimeFilter<"CrisisSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"CrisisSession"> | Date | string | null
    responseTimeMs?: IntNullableFilter<"CrisisSession"> | number | null
    outcome?: StringNullableFilter<"CrisisSession"> | string | null
    encryptedData?: BytesNullableFilter<"CrisisSession"> | Uint8Array | null
    keyDerivationSalt?: BytesNullableFilter<"CrisisSession"> | Uint8Array | null
    handoffTime?: IntNullableFilter<"CrisisSession"> | number | null
    resolutionTime?: IntNullableFilter<"CrisisSession"> | number | null
    emergencyTriggered?: BoolFilter<"CrisisSession"> | boolean
    escalatedAt?: DateTimeNullableFilter<"CrisisSession"> | Date | string | null
    escalationType?: EnumEscalationTypeNullableFilter<"CrisisSession"> | $Enums.EscalationType | null
    messages?: CrisisMessageListRelationFilter
    escalations?: CrisisEscalationListRelationFilter
    resources?: CrisisResourceUsageListRelationFilter
  }, "id" | "sessionToken" | "anonymousId">

  export type CrisisSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    anonymousId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    responderId?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    responseTimeMs?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    encryptedData?: SortOrderInput | SortOrder
    keyDerivationSalt?: SortOrderInput | SortOrder
    handoffTime?: SortOrderInput | SortOrder
    resolutionTime?: SortOrderInput | SortOrder
    emergencyTriggered?: SortOrder
    escalatedAt?: SortOrderInput | SortOrder
    escalationType?: SortOrderInput | SortOrder
    _count?: CrisisSessionCountOrderByAggregateInput
    _avg?: CrisisSessionAvgOrderByAggregateInput
    _max?: CrisisSessionMaxOrderByAggregateInput
    _min?: CrisisSessionMinOrderByAggregateInput
    _sum?: CrisisSessionSumOrderByAggregateInput
  }

  export type CrisisSessionScalarWhereWithAggregatesInput = {
    AND?: CrisisSessionScalarWhereWithAggregatesInput | CrisisSessionScalarWhereWithAggregatesInput[]
    OR?: CrisisSessionScalarWhereWithAggregatesInput[]
    NOT?: CrisisSessionScalarWhereWithAggregatesInput | CrisisSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CrisisSession"> | string
    sessionToken?: StringWithAggregatesFilter<"CrisisSession"> | string
    anonymousId?: StringWithAggregatesFilter<"CrisisSession"> | string
    severity?: IntWithAggregatesFilter<"CrisisSession"> | number
    status?: EnumCrisisStatusWithAggregatesFilter<"CrisisSession"> | $Enums.CrisisStatus
    responderId?: StringNullableWithAggregatesFilter<"CrisisSession"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"CrisisSession"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"CrisisSession"> | Date | string | null
    responseTimeMs?: IntNullableWithAggregatesFilter<"CrisisSession"> | number | null
    outcome?: StringNullableWithAggregatesFilter<"CrisisSession"> | string | null
    encryptedData?: BytesNullableWithAggregatesFilter<"CrisisSession"> | Uint8Array | null
    keyDerivationSalt?: BytesNullableWithAggregatesFilter<"CrisisSession"> | Uint8Array | null
    handoffTime?: IntNullableWithAggregatesFilter<"CrisisSession"> | number | null
    resolutionTime?: IntNullableWithAggregatesFilter<"CrisisSession"> | number | null
    emergencyTriggered?: BoolWithAggregatesFilter<"CrisisSession"> | boolean
    escalatedAt?: DateTimeNullableWithAggregatesFilter<"CrisisSession"> | Date | string | null
    escalationType?: EnumEscalationTypeNullableWithAggregatesFilter<"CrisisSession"> | $Enums.EscalationType | null
  }

  export type CrisisMessageWhereInput = {
    AND?: CrisisMessageWhereInput | CrisisMessageWhereInput[]
    OR?: CrisisMessageWhereInput[]
    NOT?: CrisisMessageWhereInput | CrisisMessageWhereInput[]
    id?: StringFilter<"CrisisMessage"> | string
    sessionId?: StringFilter<"CrisisMessage"> | string
    senderType?: EnumMessageSenderFilter<"CrisisMessage"> | $Enums.MessageSender
    senderId?: StringFilter<"CrisisMessage"> | string
    encryptedContent?: BytesFilter<"CrisisMessage"> | Uint8Array
    messageHash?: StringFilter<"CrisisMessage"> | string
    timestamp?: DateTimeFilter<"CrisisMessage"> | Date | string
    messageType?: EnumMessageTypeFilter<"CrisisMessage"> | $Enums.MessageType
    priority?: EnumMessagePriorityFilter<"CrisisMessage"> | $Enums.MessagePriority
    sentimentScore?: FloatNullableFilter<"CrisisMessage"> | number | null
    riskScore?: IntNullableFilter<"CrisisMessage"> | number | null
    riskLevel?: StringNullableFilter<"CrisisMessage"> | string | null
    keywordsDetected?: StringNullableFilter<"CrisisMessage"> | string | null
    session?: XOR<CrisisSessionScalarRelationFilter, CrisisSessionWhereInput>
  }

  export type CrisisMessageOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    senderType?: SortOrder
    senderId?: SortOrder
    encryptedContent?: SortOrder
    messageHash?: SortOrder
    timestamp?: SortOrder
    messageType?: SortOrder
    priority?: SortOrder
    sentimentScore?: SortOrderInput | SortOrder
    riskScore?: SortOrderInput | SortOrder
    riskLevel?: SortOrderInput | SortOrder
    keywordsDetected?: SortOrderInput | SortOrder
    session?: CrisisSessionOrderByWithRelationInput
  }

  export type CrisisMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrisisMessageWhereInput | CrisisMessageWhereInput[]
    OR?: CrisisMessageWhereInput[]
    NOT?: CrisisMessageWhereInput | CrisisMessageWhereInput[]
    sessionId?: StringFilter<"CrisisMessage"> | string
    senderType?: EnumMessageSenderFilter<"CrisisMessage"> | $Enums.MessageSender
    senderId?: StringFilter<"CrisisMessage"> | string
    encryptedContent?: BytesFilter<"CrisisMessage"> | Uint8Array
    messageHash?: StringFilter<"CrisisMessage"> | string
    timestamp?: DateTimeFilter<"CrisisMessage"> | Date | string
    messageType?: EnumMessageTypeFilter<"CrisisMessage"> | $Enums.MessageType
    priority?: EnumMessagePriorityFilter<"CrisisMessage"> | $Enums.MessagePriority
    sentimentScore?: FloatNullableFilter<"CrisisMessage"> | number | null
    riskScore?: IntNullableFilter<"CrisisMessage"> | number | null
    riskLevel?: StringNullableFilter<"CrisisMessage"> | string | null
    keywordsDetected?: StringNullableFilter<"CrisisMessage"> | string | null
    session?: XOR<CrisisSessionScalarRelationFilter, CrisisSessionWhereInput>
  }, "id">

  export type CrisisMessageOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    senderType?: SortOrder
    senderId?: SortOrder
    encryptedContent?: SortOrder
    messageHash?: SortOrder
    timestamp?: SortOrder
    messageType?: SortOrder
    priority?: SortOrder
    sentimentScore?: SortOrderInput | SortOrder
    riskScore?: SortOrderInput | SortOrder
    riskLevel?: SortOrderInput | SortOrder
    keywordsDetected?: SortOrderInput | SortOrder
    _count?: CrisisMessageCountOrderByAggregateInput
    _avg?: CrisisMessageAvgOrderByAggregateInput
    _max?: CrisisMessageMaxOrderByAggregateInput
    _min?: CrisisMessageMinOrderByAggregateInput
    _sum?: CrisisMessageSumOrderByAggregateInput
  }

  export type CrisisMessageScalarWhereWithAggregatesInput = {
    AND?: CrisisMessageScalarWhereWithAggregatesInput | CrisisMessageScalarWhereWithAggregatesInput[]
    OR?: CrisisMessageScalarWhereWithAggregatesInput[]
    NOT?: CrisisMessageScalarWhereWithAggregatesInput | CrisisMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CrisisMessage"> | string
    sessionId?: StringWithAggregatesFilter<"CrisisMessage"> | string
    senderType?: EnumMessageSenderWithAggregatesFilter<"CrisisMessage"> | $Enums.MessageSender
    senderId?: StringWithAggregatesFilter<"CrisisMessage"> | string
    encryptedContent?: BytesWithAggregatesFilter<"CrisisMessage"> | Uint8Array
    messageHash?: StringWithAggregatesFilter<"CrisisMessage"> | string
    timestamp?: DateTimeWithAggregatesFilter<"CrisisMessage"> | Date | string
    messageType?: EnumMessageTypeWithAggregatesFilter<"CrisisMessage"> | $Enums.MessageType
    priority?: EnumMessagePriorityWithAggregatesFilter<"CrisisMessage"> | $Enums.MessagePriority
    sentimentScore?: FloatNullableWithAggregatesFilter<"CrisisMessage"> | number | null
    riskScore?: IntNullableWithAggregatesFilter<"CrisisMessage"> | number | null
    riskLevel?: StringNullableWithAggregatesFilter<"CrisisMessage"> | string | null
    keywordsDetected?: StringNullableWithAggregatesFilter<"CrisisMessage"> | string | null
  }

  export type CrisisEscalationWhereInput = {
    AND?: CrisisEscalationWhereInput | CrisisEscalationWhereInput[]
    OR?: CrisisEscalationWhereInput[]
    NOT?: CrisisEscalationWhereInput | CrisisEscalationWhereInput[]
    id?: StringFilter<"CrisisEscalation"> | string
    sessionId?: StringFilter<"CrisisEscalation"> | string
    triggeredBy?: EnumEscalationTriggerFilter<"CrisisEscalation"> | $Enums.EscalationTrigger
    severity?: EnumEscalationSeverityFilter<"CrisisEscalation"> | $Enums.EscalationSeverity
    reason?: StringFilter<"CrisisEscalation"> | string
    actionsTaken?: StringNullableFilter<"CrisisEscalation"> | string | null
    emergencyContacted?: BoolFilter<"CrisisEscalation"> | boolean
    lifeline988Called?: BoolFilter<"CrisisEscalation"> | boolean
    triggeredAt?: DateTimeFilter<"CrisisEscalation"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"CrisisEscalation"> | Date | string | null
    responseTime?: IntNullableFilter<"CrisisEscalation"> | number | null
    handledBy?: StringNullableFilter<"CrisisEscalation"> | string | null
    outcome?: EnumEscalationOutcomeNullableFilter<"CrisisEscalation"> | $Enums.EscalationOutcome | null
    session?: XOR<CrisisSessionScalarRelationFilter, CrisisSessionWhereInput>
  }

  export type CrisisEscalationOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    triggeredBy?: SortOrder
    severity?: SortOrder
    reason?: SortOrder
    actionsTaken?: SortOrderInput | SortOrder
    emergencyContacted?: SortOrder
    lifeline988Called?: SortOrder
    triggeredAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    handledBy?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    session?: CrisisSessionOrderByWithRelationInput
  }

  export type CrisisEscalationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrisisEscalationWhereInput | CrisisEscalationWhereInput[]
    OR?: CrisisEscalationWhereInput[]
    NOT?: CrisisEscalationWhereInput | CrisisEscalationWhereInput[]
    sessionId?: StringFilter<"CrisisEscalation"> | string
    triggeredBy?: EnumEscalationTriggerFilter<"CrisisEscalation"> | $Enums.EscalationTrigger
    severity?: EnumEscalationSeverityFilter<"CrisisEscalation"> | $Enums.EscalationSeverity
    reason?: StringFilter<"CrisisEscalation"> | string
    actionsTaken?: StringNullableFilter<"CrisisEscalation"> | string | null
    emergencyContacted?: BoolFilter<"CrisisEscalation"> | boolean
    lifeline988Called?: BoolFilter<"CrisisEscalation"> | boolean
    triggeredAt?: DateTimeFilter<"CrisisEscalation"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"CrisisEscalation"> | Date | string | null
    responseTime?: IntNullableFilter<"CrisisEscalation"> | number | null
    handledBy?: StringNullableFilter<"CrisisEscalation"> | string | null
    outcome?: EnumEscalationOutcomeNullableFilter<"CrisisEscalation"> | $Enums.EscalationOutcome | null
    session?: XOR<CrisisSessionScalarRelationFilter, CrisisSessionWhereInput>
  }, "id">

  export type CrisisEscalationOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    triggeredBy?: SortOrder
    severity?: SortOrder
    reason?: SortOrder
    actionsTaken?: SortOrderInput | SortOrder
    emergencyContacted?: SortOrder
    lifeline988Called?: SortOrder
    triggeredAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    handledBy?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    _count?: CrisisEscalationCountOrderByAggregateInput
    _avg?: CrisisEscalationAvgOrderByAggregateInput
    _max?: CrisisEscalationMaxOrderByAggregateInput
    _min?: CrisisEscalationMinOrderByAggregateInput
    _sum?: CrisisEscalationSumOrderByAggregateInput
  }

  export type CrisisEscalationScalarWhereWithAggregatesInput = {
    AND?: CrisisEscalationScalarWhereWithAggregatesInput | CrisisEscalationScalarWhereWithAggregatesInput[]
    OR?: CrisisEscalationScalarWhereWithAggregatesInput[]
    NOT?: CrisisEscalationScalarWhereWithAggregatesInput | CrisisEscalationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CrisisEscalation"> | string
    sessionId?: StringWithAggregatesFilter<"CrisisEscalation"> | string
    triggeredBy?: EnumEscalationTriggerWithAggregatesFilter<"CrisisEscalation"> | $Enums.EscalationTrigger
    severity?: EnumEscalationSeverityWithAggregatesFilter<"CrisisEscalation"> | $Enums.EscalationSeverity
    reason?: StringWithAggregatesFilter<"CrisisEscalation"> | string
    actionsTaken?: StringNullableWithAggregatesFilter<"CrisisEscalation"> | string | null
    emergencyContacted?: BoolWithAggregatesFilter<"CrisisEscalation"> | boolean
    lifeline988Called?: BoolWithAggregatesFilter<"CrisisEscalation"> | boolean
    triggeredAt?: DateTimeWithAggregatesFilter<"CrisisEscalation"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"CrisisEscalation"> | Date | string | null
    responseTime?: IntNullableWithAggregatesFilter<"CrisisEscalation"> | number | null
    handledBy?: StringNullableWithAggregatesFilter<"CrisisEscalation"> | string | null
    outcome?: EnumEscalationOutcomeNullableWithAggregatesFilter<"CrisisEscalation"> | $Enums.EscalationOutcome | null
  }

  export type TetherLinkWhereInput = {
    AND?: TetherLinkWhereInput | TetherLinkWhereInput[]
    OR?: TetherLinkWhereInput[]
    NOT?: TetherLinkWhereInput | TetherLinkWhereInput[]
    id?: StringFilter<"TetherLink"> | string
    seekerId?: StringFilter<"TetherLink"> | string
    supporterId?: StringFilter<"TetherLink"> | string
    strength?: FloatFilter<"TetherLink"> | number
    trustScore?: FloatFilter<"TetherLink"> | number
    established?: DateTimeFilter<"TetherLink"> | Date | string
    lastActivity?: DateTimeFilter<"TetherLink"> | Date | string
    pulseInterval?: IntFilter<"TetherLink"> | number
    lastPulse?: DateTimeFilter<"TetherLink"> | Date | string
    missedPulses?: IntFilter<"TetherLink"> | number
    emergencyActive?: BoolFilter<"TetherLink"> | boolean
    emergencyType?: EnumEmergencyTypeNullableFilter<"TetherLink"> | $Enums.EmergencyType | null
    lastEmergency?: DateTimeNullableFilter<"TetherLink"> | Date | string | null
    matchingScore?: FloatNullableFilter<"TetherLink"> | number | null
    specialties?: StringNullableFilter<"TetherLink"> | string | null
    languages?: StringNullableFilter<"TetherLink"> | string | null
    timezone?: StringNullableFilter<"TetherLink"> | string | null
    dataSharing?: EnumTetherDataSharingFilter<"TetherLink"> | $Enums.TetherDataSharing
    locationSharing?: BoolFilter<"TetherLink"> | boolean
    emergencyContact?: BoolFilter<"TetherLink"> | boolean
    encryptedMeta?: BytesNullableFilter<"TetherLink"> | Uint8Array | null
    pulses?: TetherPulseListRelationFilter
    emergencies?: TetherEmergencyListRelationFilter
  }

  export type TetherLinkOrderByWithRelationInput = {
    id?: SortOrder
    seekerId?: SortOrder
    supporterId?: SortOrder
    strength?: SortOrder
    trustScore?: SortOrder
    established?: SortOrder
    lastActivity?: SortOrder
    pulseInterval?: SortOrder
    lastPulse?: SortOrder
    missedPulses?: SortOrder
    emergencyActive?: SortOrder
    emergencyType?: SortOrderInput | SortOrder
    lastEmergency?: SortOrderInput | SortOrder
    matchingScore?: SortOrderInput | SortOrder
    specialties?: SortOrderInput | SortOrder
    languages?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    dataSharing?: SortOrder
    locationSharing?: SortOrder
    emergencyContact?: SortOrder
    encryptedMeta?: SortOrderInput | SortOrder
    pulses?: TetherPulseOrderByRelationAggregateInput
    emergencies?: TetherEmergencyOrderByRelationAggregateInput
  }

  export type TetherLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seekerId_supporterId?: TetherLinkSeekerIdSupporterIdCompoundUniqueInput
    AND?: TetherLinkWhereInput | TetherLinkWhereInput[]
    OR?: TetherLinkWhereInput[]
    NOT?: TetherLinkWhereInput | TetherLinkWhereInput[]
    seekerId?: StringFilter<"TetherLink"> | string
    supporterId?: StringFilter<"TetherLink"> | string
    strength?: FloatFilter<"TetherLink"> | number
    trustScore?: FloatFilter<"TetherLink"> | number
    established?: DateTimeFilter<"TetherLink"> | Date | string
    lastActivity?: DateTimeFilter<"TetherLink"> | Date | string
    pulseInterval?: IntFilter<"TetherLink"> | number
    lastPulse?: DateTimeFilter<"TetherLink"> | Date | string
    missedPulses?: IntFilter<"TetherLink"> | number
    emergencyActive?: BoolFilter<"TetherLink"> | boolean
    emergencyType?: EnumEmergencyTypeNullableFilter<"TetherLink"> | $Enums.EmergencyType | null
    lastEmergency?: DateTimeNullableFilter<"TetherLink"> | Date | string | null
    matchingScore?: FloatNullableFilter<"TetherLink"> | number | null
    specialties?: StringNullableFilter<"TetherLink"> | string | null
    languages?: StringNullableFilter<"TetherLink"> | string | null
    timezone?: StringNullableFilter<"TetherLink"> | string | null
    dataSharing?: EnumTetherDataSharingFilter<"TetherLink"> | $Enums.TetherDataSharing
    locationSharing?: BoolFilter<"TetherLink"> | boolean
    emergencyContact?: BoolFilter<"TetherLink"> | boolean
    encryptedMeta?: BytesNullableFilter<"TetherLink"> | Uint8Array | null
    pulses?: TetherPulseListRelationFilter
    emergencies?: TetherEmergencyListRelationFilter
  }, "id" | "seekerId_supporterId">

  export type TetherLinkOrderByWithAggregationInput = {
    id?: SortOrder
    seekerId?: SortOrder
    supporterId?: SortOrder
    strength?: SortOrder
    trustScore?: SortOrder
    established?: SortOrder
    lastActivity?: SortOrder
    pulseInterval?: SortOrder
    lastPulse?: SortOrder
    missedPulses?: SortOrder
    emergencyActive?: SortOrder
    emergencyType?: SortOrderInput | SortOrder
    lastEmergency?: SortOrderInput | SortOrder
    matchingScore?: SortOrderInput | SortOrder
    specialties?: SortOrderInput | SortOrder
    languages?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    dataSharing?: SortOrder
    locationSharing?: SortOrder
    emergencyContact?: SortOrder
    encryptedMeta?: SortOrderInput | SortOrder
    _count?: TetherLinkCountOrderByAggregateInput
    _avg?: TetherLinkAvgOrderByAggregateInput
    _max?: TetherLinkMaxOrderByAggregateInput
    _min?: TetherLinkMinOrderByAggregateInput
    _sum?: TetherLinkSumOrderByAggregateInput
  }

  export type TetherLinkScalarWhereWithAggregatesInput = {
    AND?: TetherLinkScalarWhereWithAggregatesInput | TetherLinkScalarWhereWithAggregatesInput[]
    OR?: TetherLinkScalarWhereWithAggregatesInput[]
    NOT?: TetherLinkScalarWhereWithAggregatesInput | TetherLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TetherLink"> | string
    seekerId?: StringWithAggregatesFilter<"TetherLink"> | string
    supporterId?: StringWithAggregatesFilter<"TetherLink"> | string
    strength?: FloatWithAggregatesFilter<"TetherLink"> | number
    trustScore?: FloatWithAggregatesFilter<"TetherLink"> | number
    established?: DateTimeWithAggregatesFilter<"TetherLink"> | Date | string
    lastActivity?: DateTimeWithAggregatesFilter<"TetherLink"> | Date | string
    pulseInterval?: IntWithAggregatesFilter<"TetherLink"> | number
    lastPulse?: DateTimeWithAggregatesFilter<"TetherLink"> | Date | string
    missedPulses?: IntWithAggregatesFilter<"TetherLink"> | number
    emergencyActive?: BoolWithAggregatesFilter<"TetherLink"> | boolean
    emergencyType?: EnumEmergencyTypeNullableWithAggregatesFilter<"TetherLink"> | $Enums.EmergencyType | null
    lastEmergency?: DateTimeNullableWithAggregatesFilter<"TetherLink"> | Date | string | null
    matchingScore?: FloatNullableWithAggregatesFilter<"TetherLink"> | number | null
    specialties?: StringNullableWithAggregatesFilter<"TetherLink"> | string | null
    languages?: StringNullableWithAggregatesFilter<"TetherLink"> | string | null
    timezone?: StringNullableWithAggregatesFilter<"TetherLink"> | string | null
    dataSharing?: EnumTetherDataSharingWithAggregatesFilter<"TetherLink"> | $Enums.TetherDataSharing
    locationSharing?: BoolWithAggregatesFilter<"TetherLink"> | boolean
    emergencyContact?: BoolWithAggregatesFilter<"TetherLink"> | boolean
    encryptedMeta?: BytesNullableWithAggregatesFilter<"TetherLink"> | Uint8Array | null
  }

  export type TetherPulseWhereInput = {
    AND?: TetherPulseWhereInput | TetherPulseWhereInput[]
    OR?: TetherPulseWhereInput[]
    NOT?: TetherPulseWhereInput | TetherPulseWhereInput[]
    id?: StringFilter<"TetherPulse"> | string
    tetherId?: StringFilter<"TetherPulse"> | string
    pulseType?: EnumPulseTypeFilter<"TetherPulse"> | $Enums.PulseType
    strength?: FloatFilter<"TetherPulse"> | number
    mood?: IntNullableFilter<"TetherPulse"> | number | null
    status?: EnumUserStatusFilter<"TetherPulse"> | $Enums.UserStatus
    message?: StringNullableFilter<"TetherPulse"> | string | null
    emergencySignal?: BoolFilter<"TetherPulse"> | boolean
    urgencyLevel?: EnumUrgencyLevelFilter<"TetherPulse"> | $Enums.UrgencyLevel
    timestamp?: DateTimeFilter<"TetherPulse"> | Date | string
    acknowledged?: BoolFilter<"TetherPulse"> | boolean
    acknowledgedAt?: DateTimeNullableFilter<"TetherPulse"> | Date | string | null
    tether?: XOR<TetherLinkScalarRelationFilter, TetherLinkWhereInput>
  }

  export type TetherPulseOrderByWithRelationInput = {
    id?: SortOrder
    tetherId?: SortOrder
    pulseType?: SortOrder
    strength?: SortOrder
    mood?: SortOrderInput | SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    emergencySignal?: SortOrder
    urgencyLevel?: SortOrder
    timestamp?: SortOrder
    acknowledged?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    tether?: TetherLinkOrderByWithRelationInput
  }

  export type TetherPulseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TetherPulseWhereInput | TetherPulseWhereInput[]
    OR?: TetherPulseWhereInput[]
    NOT?: TetherPulseWhereInput | TetherPulseWhereInput[]
    tetherId?: StringFilter<"TetherPulse"> | string
    pulseType?: EnumPulseTypeFilter<"TetherPulse"> | $Enums.PulseType
    strength?: FloatFilter<"TetherPulse"> | number
    mood?: IntNullableFilter<"TetherPulse"> | number | null
    status?: EnumUserStatusFilter<"TetherPulse"> | $Enums.UserStatus
    message?: StringNullableFilter<"TetherPulse"> | string | null
    emergencySignal?: BoolFilter<"TetherPulse"> | boolean
    urgencyLevel?: EnumUrgencyLevelFilter<"TetherPulse"> | $Enums.UrgencyLevel
    timestamp?: DateTimeFilter<"TetherPulse"> | Date | string
    acknowledged?: BoolFilter<"TetherPulse"> | boolean
    acknowledgedAt?: DateTimeNullableFilter<"TetherPulse"> | Date | string | null
    tether?: XOR<TetherLinkScalarRelationFilter, TetherLinkWhereInput>
  }, "id">

  export type TetherPulseOrderByWithAggregationInput = {
    id?: SortOrder
    tetherId?: SortOrder
    pulseType?: SortOrder
    strength?: SortOrder
    mood?: SortOrderInput | SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    emergencySignal?: SortOrder
    urgencyLevel?: SortOrder
    timestamp?: SortOrder
    acknowledged?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    _count?: TetherPulseCountOrderByAggregateInput
    _avg?: TetherPulseAvgOrderByAggregateInput
    _max?: TetherPulseMaxOrderByAggregateInput
    _min?: TetherPulseMinOrderByAggregateInput
    _sum?: TetherPulseSumOrderByAggregateInput
  }

  export type TetherPulseScalarWhereWithAggregatesInput = {
    AND?: TetherPulseScalarWhereWithAggregatesInput | TetherPulseScalarWhereWithAggregatesInput[]
    OR?: TetherPulseScalarWhereWithAggregatesInput[]
    NOT?: TetherPulseScalarWhereWithAggregatesInput | TetherPulseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TetherPulse"> | string
    tetherId?: StringWithAggregatesFilter<"TetherPulse"> | string
    pulseType?: EnumPulseTypeWithAggregatesFilter<"TetherPulse"> | $Enums.PulseType
    strength?: FloatWithAggregatesFilter<"TetherPulse"> | number
    mood?: IntNullableWithAggregatesFilter<"TetherPulse"> | number | null
    status?: EnumUserStatusWithAggregatesFilter<"TetherPulse"> | $Enums.UserStatus
    message?: StringNullableWithAggregatesFilter<"TetherPulse"> | string | null
    emergencySignal?: BoolWithAggregatesFilter<"TetherPulse"> | boolean
    urgencyLevel?: EnumUrgencyLevelWithAggregatesFilter<"TetherPulse"> | $Enums.UrgencyLevel
    timestamp?: DateTimeWithAggregatesFilter<"TetherPulse"> | Date | string
    acknowledged?: BoolWithAggregatesFilter<"TetherPulse"> | boolean
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"TetherPulse"> | Date | string | null
  }

  export type TetherEmergencyWhereInput = {
    AND?: TetherEmergencyWhereInput | TetherEmergencyWhereInput[]
    OR?: TetherEmergencyWhereInput[]
    NOT?: TetherEmergencyWhereInput | TetherEmergencyWhereInput[]
    id?: StringFilter<"TetherEmergency"> | string
    tetherId?: StringFilter<"TetherEmergency"> | string
    triggerUserId?: StringFilter<"TetherEmergency"> | string
    emergencyType?: EnumEmergencyTypeFilter<"TetherEmergency"> | $Enums.EmergencyType
    severity?: EnumEmergencySeverityFilter<"TetherEmergency"> | $Enums.EmergencySeverity
    description?: StringFilter<"TetherEmergency"> | string
    location?: JsonNullableFilter<"TetherEmergency">
    triggeredAt?: DateTimeFilter<"TetherEmergency"> | Date | string
    acknowledgedAt?: DateTimeNullableFilter<"TetherEmergency"> | Date | string | null
    respondedAt?: DateTimeNullableFilter<"TetherEmergency"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"TetherEmergency"> | Date | string | null
    responseTime?: IntNullableFilter<"TetherEmergency"> | number | null
    actionsTaken?: StringNullableFilter<"TetherEmergency"> | string | null
    outcome?: EnumEmergencyOutcomeNullableFilter<"TetherEmergency"> | $Enums.EmergencyOutcome | null
    helpersNotified?: StringNullableFilter<"TetherEmergency"> | string | null
    emergencyContacts?: StringNullableFilter<"TetherEmergency"> | string | null
    tether?: XOR<TetherLinkScalarRelationFilter, TetherLinkWhereInput>
  }

  export type TetherEmergencyOrderByWithRelationInput = {
    id?: SortOrder
    tetherId?: SortOrder
    triggerUserId?: SortOrder
    emergencyType?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    location?: SortOrderInput | SortOrder
    triggeredAt?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    actionsTaken?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    helpersNotified?: SortOrderInput | SortOrder
    emergencyContacts?: SortOrderInput | SortOrder
    tether?: TetherLinkOrderByWithRelationInput
  }

  export type TetherEmergencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TetherEmergencyWhereInput | TetherEmergencyWhereInput[]
    OR?: TetherEmergencyWhereInput[]
    NOT?: TetherEmergencyWhereInput | TetherEmergencyWhereInput[]
    tetherId?: StringFilter<"TetherEmergency"> | string
    triggerUserId?: StringFilter<"TetherEmergency"> | string
    emergencyType?: EnumEmergencyTypeFilter<"TetherEmergency"> | $Enums.EmergencyType
    severity?: EnumEmergencySeverityFilter<"TetherEmergency"> | $Enums.EmergencySeverity
    description?: StringFilter<"TetherEmergency"> | string
    location?: JsonNullableFilter<"TetherEmergency">
    triggeredAt?: DateTimeFilter<"TetherEmergency"> | Date | string
    acknowledgedAt?: DateTimeNullableFilter<"TetherEmergency"> | Date | string | null
    respondedAt?: DateTimeNullableFilter<"TetherEmergency"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"TetherEmergency"> | Date | string | null
    responseTime?: IntNullableFilter<"TetherEmergency"> | number | null
    actionsTaken?: StringNullableFilter<"TetherEmergency"> | string | null
    outcome?: EnumEmergencyOutcomeNullableFilter<"TetherEmergency"> | $Enums.EmergencyOutcome | null
    helpersNotified?: StringNullableFilter<"TetherEmergency"> | string | null
    emergencyContacts?: StringNullableFilter<"TetherEmergency"> | string | null
    tether?: XOR<TetherLinkScalarRelationFilter, TetherLinkWhereInput>
  }, "id">

  export type TetherEmergencyOrderByWithAggregationInput = {
    id?: SortOrder
    tetherId?: SortOrder
    triggerUserId?: SortOrder
    emergencyType?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    location?: SortOrderInput | SortOrder
    triggeredAt?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    actionsTaken?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    helpersNotified?: SortOrderInput | SortOrder
    emergencyContacts?: SortOrderInput | SortOrder
    _count?: TetherEmergencyCountOrderByAggregateInput
    _avg?: TetherEmergencyAvgOrderByAggregateInput
    _max?: TetherEmergencyMaxOrderByAggregateInput
    _min?: TetherEmergencyMinOrderByAggregateInput
    _sum?: TetherEmergencySumOrderByAggregateInput
  }

  export type TetherEmergencyScalarWhereWithAggregatesInput = {
    AND?: TetherEmergencyScalarWhereWithAggregatesInput | TetherEmergencyScalarWhereWithAggregatesInput[]
    OR?: TetherEmergencyScalarWhereWithAggregatesInput[]
    NOT?: TetherEmergencyScalarWhereWithAggregatesInput | TetherEmergencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TetherEmergency"> | string
    tetherId?: StringWithAggregatesFilter<"TetherEmergency"> | string
    triggerUserId?: StringWithAggregatesFilter<"TetherEmergency"> | string
    emergencyType?: EnumEmergencyTypeWithAggregatesFilter<"TetherEmergency"> | $Enums.EmergencyType
    severity?: EnumEmergencySeverityWithAggregatesFilter<"TetherEmergency"> | $Enums.EmergencySeverity
    description?: StringWithAggregatesFilter<"TetherEmergency"> | string
    location?: JsonNullableWithAggregatesFilter<"TetherEmergency">
    triggeredAt?: DateTimeWithAggregatesFilter<"TetherEmergency"> | Date | string
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"TetherEmergency"> | Date | string | null
    respondedAt?: DateTimeNullableWithAggregatesFilter<"TetherEmergency"> | Date | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"TetherEmergency"> | Date | string | null
    responseTime?: IntNullableWithAggregatesFilter<"TetherEmergency"> | number | null
    actionsTaken?: StringNullableWithAggregatesFilter<"TetherEmergency"> | string | null
    outcome?: EnumEmergencyOutcomeNullableWithAggregatesFilter<"TetherEmergency"> | $Enums.EmergencyOutcome | null
    helpersNotified?: StringNullableWithAggregatesFilter<"TetherEmergency"> | string | null
    emergencyContacts?: StringNullableWithAggregatesFilter<"TetherEmergency"> | string | null
  }

  export type VolunteerWhereInput = {
    AND?: VolunteerWhereInput | VolunteerWhereInput[]
    OR?: VolunteerWhereInput[]
    NOT?: VolunteerWhereInput | VolunteerWhereInput[]
    id?: StringFilter<"Volunteer"> | string
    anonymousId?: StringFilter<"Volunteer"> | string
    status?: EnumVolunteerStatusFilter<"Volunteer"> | $Enums.VolunteerStatus
    trainingHours?: FloatFilter<"Volunteer"> | number
    certifications?: StringNullableFilter<"Volunteer"> | string | null
    specializations?: StringNullableFilter<"Volunteer"> | string | null
    languages?: StringNullableFilter<"Volunteer"> | string | null
    backgroundCheck?: EnumVerificationStatusFilter<"Volunteer"> | $Enums.VerificationStatus
    sessionsCount?: IntFilter<"Volunteer"> | number
    hoursVolunteered?: FloatFilter<"Volunteer"> | number
    averageRating?: FloatNullableFilter<"Volunteer"> | number | null
    responseRate?: FloatFilter<"Volunteer"> | number
    isActive?: BoolFilter<"Volunteer"> | boolean
    currentLoad?: IntFilter<"Volunteer"> | number
    maxConcurrent?: IntFilter<"Volunteer"> | number
    schedule?: JsonNullableFilter<"Volunteer">
    timezone?: StringNullableFilter<"Volunteer"> | string | null
    lastActive?: DateTimeFilter<"Volunteer"> | Date | string
    burnoutScore?: FloatFilter<"Volunteer"> | number
    needsSupport?: BoolFilter<"Volunteer"> | boolean
    emergencyResponder?: BoolFilter<"Volunteer"> | boolean
    emergencyAvailable?: BoolFilter<"Volunteer"> | boolean
    training?: VolunteerTrainingListRelationFilter
    sessions?: VolunteerSessionListRelationFilter
    feedback?: VolunteerFeedbackListRelationFilter
  }

  export type VolunteerOrderByWithRelationInput = {
    id?: SortOrder
    anonymousId?: SortOrder
    status?: SortOrder
    trainingHours?: SortOrder
    certifications?: SortOrderInput | SortOrder
    specializations?: SortOrderInput | SortOrder
    languages?: SortOrderInput | SortOrder
    backgroundCheck?: SortOrder
    sessionsCount?: SortOrder
    hoursVolunteered?: SortOrder
    averageRating?: SortOrderInput | SortOrder
    responseRate?: SortOrder
    isActive?: SortOrder
    currentLoad?: SortOrder
    maxConcurrent?: SortOrder
    schedule?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    lastActive?: SortOrder
    burnoutScore?: SortOrder
    needsSupport?: SortOrder
    emergencyResponder?: SortOrder
    emergencyAvailable?: SortOrder
    training?: VolunteerTrainingOrderByRelationAggregateInput
    sessions?: VolunteerSessionOrderByRelationAggregateInput
    feedback?: VolunteerFeedbackOrderByRelationAggregateInput
  }

  export type VolunteerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    anonymousId?: string
    AND?: VolunteerWhereInput | VolunteerWhereInput[]
    OR?: VolunteerWhereInput[]
    NOT?: VolunteerWhereInput | VolunteerWhereInput[]
    status?: EnumVolunteerStatusFilter<"Volunteer"> | $Enums.VolunteerStatus
    trainingHours?: FloatFilter<"Volunteer"> | number
    certifications?: StringNullableFilter<"Volunteer"> | string | null
    specializations?: StringNullableFilter<"Volunteer"> | string | null
    languages?: StringNullableFilter<"Volunteer"> | string | null
    backgroundCheck?: EnumVerificationStatusFilter<"Volunteer"> | $Enums.VerificationStatus
    sessionsCount?: IntFilter<"Volunteer"> | number
    hoursVolunteered?: FloatFilter<"Volunteer"> | number
    averageRating?: FloatNullableFilter<"Volunteer"> | number | null
    responseRate?: FloatFilter<"Volunteer"> | number
    isActive?: BoolFilter<"Volunteer"> | boolean
    currentLoad?: IntFilter<"Volunteer"> | number
    maxConcurrent?: IntFilter<"Volunteer"> | number
    schedule?: JsonNullableFilter<"Volunteer">
    timezone?: StringNullableFilter<"Volunteer"> | string | null
    lastActive?: DateTimeFilter<"Volunteer"> | Date | string
    burnoutScore?: FloatFilter<"Volunteer"> | number
    needsSupport?: BoolFilter<"Volunteer"> | boolean
    emergencyResponder?: BoolFilter<"Volunteer"> | boolean
    emergencyAvailable?: BoolFilter<"Volunteer"> | boolean
    training?: VolunteerTrainingListRelationFilter
    sessions?: VolunteerSessionListRelationFilter
    feedback?: VolunteerFeedbackListRelationFilter
  }, "id" | "anonymousId">

  export type VolunteerOrderByWithAggregationInput = {
    id?: SortOrder
    anonymousId?: SortOrder
    status?: SortOrder
    trainingHours?: SortOrder
    certifications?: SortOrderInput | SortOrder
    specializations?: SortOrderInput | SortOrder
    languages?: SortOrderInput | SortOrder
    backgroundCheck?: SortOrder
    sessionsCount?: SortOrder
    hoursVolunteered?: SortOrder
    averageRating?: SortOrderInput | SortOrder
    responseRate?: SortOrder
    isActive?: SortOrder
    currentLoad?: SortOrder
    maxConcurrent?: SortOrder
    schedule?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    lastActive?: SortOrder
    burnoutScore?: SortOrder
    needsSupport?: SortOrder
    emergencyResponder?: SortOrder
    emergencyAvailable?: SortOrder
    _count?: VolunteerCountOrderByAggregateInput
    _avg?: VolunteerAvgOrderByAggregateInput
    _max?: VolunteerMaxOrderByAggregateInput
    _min?: VolunteerMinOrderByAggregateInput
    _sum?: VolunteerSumOrderByAggregateInput
  }

  export type VolunteerScalarWhereWithAggregatesInput = {
    AND?: VolunteerScalarWhereWithAggregatesInput | VolunteerScalarWhereWithAggregatesInput[]
    OR?: VolunteerScalarWhereWithAggregatesInput[]
    NOT?: VolunteerScalarWhereWithAggregatesInput | VolunteerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Volunteer"> | string
    anonymousId?: StringWithAggregatesFilter<"Volunteer"> | string
    status?: EnumVolunteerStatusWithAggregatesFilter<"Volunteer"> | $Enums.VolunteerStatus
    trainingHours?: FloatWithAggregatesFilter<"Volunteer"> | number
    certifications?: StringNullableWithAggregatesFilter<"Volunteer"> | string | null
    specializations?: StringNullableWithAggregatesFilter<"Volunteer"> | string | null
    languages?: StringNullableWithAggregatesFilter<"Volunteer"> | string | null
    backgroundCheck?: EnumVerificationStatusWithAggregatesFilter<"Volunteer"> | $Enums.VerificationStatus
    sessionsCount?: IntWithAggregatesFilter<"Volunteer"> | number
    hoursVolunteered?: FloatWithAggregatesFilter<"Volunteer"> | number
    averageRating?: FloatNullableWithAggregatesFilter<"Volunteer"> | number | null
    responseRate?: FloatWithAggregatesFilter<"Volunteer"> | number
    isActive?: BoolWithAggregatesFilter<"Volunteer"> | boolean
    currentLoad?: IntWithAggregatesFilter<"Volunteer"> | number
    maxConcurrent?: IntWithAggregatesFilter<"Volunteer"> | number
    schedule?: JsonNullableWithAggregatesFilter<"Volunteer">
    timezone?: StringNullableWithAggregatesFilter<"Volunteer"> | string | null
    lastActive?: DateTimeWithAggregatesFilter<"Volunteer"> | Date | string
    burnoutScore?: FloatWithAggregatesFilter<"Volunteer"> | number
    needsSupport?: BoolWithAggregatesFilter<"Volunteer"> | boolean
    emergencyResponder?: BoolWithAggregatesFilter<"Volunteer"> | boolean
    emergencyAvailable?: BoolWithAggregatesFilter<"Volunteer"> | boolean
  }

  export type VolunteerTrainingWhereInput = {
    AND?: VolunteerTrainingWhereInput | VolunteerTrainingWhereInput[]
    OR?: VolunteerTrainingWhereInput[]
    NOT?: VolunteerTrainingWhereInput | VolunteerTrainingWhereInput[]
    id?: StringFilter<"VolunteerTraining"> | string
    volunteerId?: StringFilter<"VolunteerTraining"> | string
    moduleId?: StringFilter<"VolunteerTraining"> | string
    status?: EnumTrainingStatusFilter<"VolunteerTraining"> | $Enums.TrainingStatus
    startedAt?: DateTimeNullableFilter<"VolunteerTraining"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"VolunteerTraining"> | Date | string | null
    score?: FloatNullableFilter<"VolunteerTraining"> | number | null
    passingScore?: FloatFilter<"VolunteerTraining"> | number
    attempts?: IntFilter<"VolunteerTraining"> | number
    moduleTitle?: StringFilter<"VolunteerTraining"> | string
    moduleType?: EnumTrainingTypeFilter<"VolunteerTraining"> | $Enums.TrainingType
    duration?: IntFilter<"VolunteerTraining"> | number
    content?: JsonFilter<"VolunteerTraining">
    volunteer?: XOR<VolunteerScalarRelationFilter, VolunteerWhereInput>
  }

  export type VolunteerTrainingOrderByWithRelationInput = {
    id?: SortOrder
    volunteerId?: SortOrder
    moduleId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    passingScore?: SortOrder
    attempts?: SortOrder
    moduleTitle?: SortOrder
    moduleType?: SortOrder
    duration?: SortOrder
    content?: SortOrder
    volunteer?: VolunteerOrderByWithRelationInput
  }

  export type VolunteerTrainingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    volunteerId_moduleId?: VolunteerTrainingVolunteerIdModuleIdCompoundUniqueInput
    AND?: VolunteerTrainingWhereInput | VolunteerTrainingWhereInput[]
    OR?: VolunteerTrainingWhereInput[]
    NOT?: VolunteerTrainingWhereInput | VolunteerTrainingWhereInput[]
    volunteerId?: StringFilter<"VolunteerTraining"> | string
    moduleId?: StringFilter<"VolunteerTraining"> | string
    status?: EnumTrainingStatusFilter<"VolunteerTraining"> | $Enums.TrainingStatus
    startedAt?: DateTimeNullableFilter<"VolunteerTraining"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"VolunteerTraining"> | Date | string | null
    score?: FloatNullableFilter<"VolunteerTraining"> | number | null
    passingScore?: FloatFilter<"VolunteerTraining"> | number
    attempts?: IntFilter<"VolunteerTraining"> | number
    moduleTitle?: StringFilter<"VolunteerTraining"> | string
    moduleType?: EnumTrainingTypeFilter<"VolunteerTraining"> | $Enums.TrainingType
    duration?: IntFilter<"VolunteerTraining"> | number
    content?: JsonFilter<"VolunteerTraining">
    volunteer?: XOR<VolunteerScalarRelationFilter, VolunteerWhereInput>
  }, "id" | "volunteerId_moduleId">

  export type VolunteerTrainingOrderByWithAggregationInput = {
    id?: SortOrder
    volunteerId?: SortOrder
    moduleId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    passingScore?: SortOrder
    attempts?: SortOrder
    moduleTitle?: SortOrder
    moduleType?: SortOrder
    duration?: SortOrder
    content?: SortOrder
    _count?: VolunteerTrainingCountOrderByAggregateInput
    _avg?: VolunteerTrainingAvgOrderByAggregateInput
    _max?: VolunteerTrainingMaxOrderByAggregateInput
    _min?: VolunteerTrainingMinOrderByAggregateInput
    _sum?: VolunteerTrainingSumOrderByAggregateInput
  }

  export type VolunteerTrainingScalarWhereWithAggregatesInput = {
    AND?: VolunteerTrainingScalarWhereWithAggregatesInput | VolunteerTrainingScalarWhereWithAggregatesInput[]
    OR?: VolunteerTrainingScalarWhereWithAggregatesInput[]
    NOT?: VolunteerTrainingScalarWhereWithAggregatesInput | VolunteerTrainingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VolunteerTraining"> | string
    volunteerId?: StringWithAggregatesFilter<"VolunteerTraining"> | string
    moduleId?: StringWithAggregatesFilter<"VolunteerTraining"> | string
    status?: EnumTrainingStatusWithAggregatesFilter<"VolunteerTraining"> | $Enums.TrainingStatus
    startedAt?: DateTimeNullableWithAggregatesFilter<"VolunteerTraining"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"VolunteerTraining"> | Date | string | null
    score?: FloatNullableWithAggregatesFilter<"VolunteerTraining"> | number | null
    passingScore?: FloatWithAggregatesFilter<"VolunteerTraining"> | number
    attempts?: IntWithAggregatesFilter<"VolunteerTraining"> | number
    moduleTitle?: StringWithAggregatesFilter<"VolunteerTraining"> | string
    moduleType?: EnumTrainingTypeWithAggregatesFilter<"VolunteerTraining"> | $Enums.TrainingType
    duration?: IntWithAggregatesFilter<"VolunteerTraining"> | number
    content?: JsonWithAggregatesFilter<"VolunteerTraining">
  }

  export type VolunteerSessionWhereInput = {
    AND?: VolunteerSessionWhereInput | VolunteerSessionWhereInput[]
    OR?: VolunteerSessionWhereInput[]
    NOT?: VolunteerSessionWhereInput | VolunteerSessionWhereInput[]
    id?: StringFilter<"VolunteerSession"> | string
    volunteerId?: StringFilter<"VolunteerSession"> | string
    sessionType?: EnumVolunteerSessionTypeFilter<"VolunteerSession"> | $Enums.VolunteerSessionType
    startedAt?: DateTimeFilter<"VolunteerSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"VolunteerSession"> | Date | string | null
    duration?: IntNullableFilter<"VolunteerSession"> | number | null
    crisisSessionId?: StringNullableFilter<"VolunteerSession"> | string | null
    responseTime?: IntNullableFilter<"VolunteerSession"> | number | null
    userSatisfaction?: FloatNullableFilter<"VolunteerSession"> | number | null
    outcome?: EnumSessionOutcomeNullableFilter<"VolunteerSession"> | $Enums.SessionOutcome | null
    volunteer?: XOR<VolunteerScalarRelationFilter, VolunteerWhereInput>
  }

  export type VolunteerSessionOrderByWithRelationInput = {
    id?: SortOrder
    volunteerId?: SortOrder
    sessionType?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    crisisSessionId?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    userSatisfaction?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    volunteer?: VolunteerOrderByWithRelationInput
  }

  export type VolunteerSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VolunteerSessionWhereInput | VolunteerSessionWhereInput[]
    OR?: VolunteerSessionWhereInput[]
    NOT?: VolunteerSessionWhereInput | VolunteerSessionWhereInput[]
    volunteerId?: StringFilter<"VolunteerSession"> | string
    sessionType?: EnumVolunteerSessionTypeFilter<"VolunteerSession"> | $Enums.VolunteerSessionType
    startedAt?: DateTimeFilter<"VolunteerSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"VolunteerSession"> | Date | string | null
    duration?: IntNullableFilter<"VolunteerSession"> | number | null
    crisisSessionId?: StringNullableFilter<"VolunteerSession"> | string | null
    responseTime?: IntNullableFilter<"VolunteerSession"> | number | null
    userSatisfaction?: FloatNullableFilter<"VolunteerSession"> | number | null
    outcome?: EnumSessionOutcomeNullableFilter<"VolunteerSession"> | $Enums.SessionOutcome | null
    volunteer?: XOR<VolunteerScalarRelationFilter, VolunteerWhereInput>
  }, "id">

  export type VolunteerSessionOrderByWithAggregationInput = {
    id?: SortOrder
    volunteerId?: SortOrder
    sessionType?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    crisisSessionId?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    userSatisfaction?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    _count?: VolunteerSessionCountOrderByAggregateInput
    _avg?: VolunteerSessionAvgOrderByAggregateInput
    _max?: VolunteerSessionMaxOrderByAggregateInput
    _min?: VolunteerSessionMinOrderByAggregateInput
    _sum?: VolunteerSessionSumOrderByAggregateInput
  }

  export type VolunteerSessionScalarWhereWithAggregatesInput = {
    AND?: VolunteerSessionScalarWhereWithAggregatesInput | VolunteerSessionScalarWhereWithAggregatesInput[]
    OR?: VolunteerSessionScalarWhereWithAggregatesInput[]
    NOT?: VolunteerSessionScalarWhereWithAggregatesInput | VolunteerSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VolunteerSession"> | string
    volunteerId?: StringWithAggregatesFilter<"VolunteerSession"> | string
    sessionType?: EnumVolunteerSessionTypeWithAggregatesFilter<"VolunteerSession"> | $Enums.VolunteerSessionType
    startedAt?: DateTimeWithAggregatesFilter<"VolunteerSession"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"VolunteerSession"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"VolunteerSession"> | number | null
    crisisSessionId?: StringNullableWithAggregatesFilter<"VolunteerSession"> | string | null
    responseTime?: IntNullableWithAggregatesFilter<"VolunteerSession"> | number | null
    userSatisfaction?: FloatNullableWithAggregatesFilter<"VolunteerSession"> | number | null
    outcome?: EnumSessionOutcomeNullableWithAggregatesFilter<"VolunteerSession"> | $Enums.SessionOutcome | null
  }

  export type VolunteerFeedbackWhereInput = {
    AND?: VolunteerFeedbackWhereInput | VolunteerFeedbackWhereInput[]
    OR?: VolunteerFeedbackWhereInput[]
    NOT?: VolunteerFeedbackWhereInput | VolunteerFeedbackWhereInput[]
    id?: StringFilter<"VolunteerFeedback"> | string
    volunteerId?: StringFilter<"VolunteerFeedback"> | string
    sessionId?: StringNullableFilter<"VolunteerFeedback"> | string | null
    feedbackType?: EnumFeedbackTypeFilter<"VolunteerFeedback"> | $Enums.FeedbackType
    rating?: IntFilter<"VolunteerFeedback"> | number
    comment?: StringNullableFilter<"VolunteerFeedback"> | string | null
    submittedBy?: StringNullableFilter<"VolunteerFeedback"> | string | null
    sourceType?: EnumFeedbackSourceFilter<"VolunteerFeedback"> | $Enums.FeedbackSource
    submittedAt?: DateTimeFilter<"VolunteerFeedback"> | Date | string
    isAnonymous?: BoolFilter<"VolunteerFeedback"> | boolean
    isApproved?: BoolFilter<"VolunteerFeedback"> | boolean
    moderatedAt?: DateTimeNullableFilter<"VolunteerFeedback"> | Date | string | null
    moderatedBy?: StringNullableFilter<"VolunteerFeedback"> | string | null
    volunteer?: XOR<VolunteerScalarRelationFilter, VolunteerWhereInput>
  }

  export type VolunteerFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    volunteerId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    feedbackType?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    submittedBy?: SortOrderInput | SortOrder
    sourceType?: SortOrder
    submittedAt?: SortOrder
    isAnonymous?: SortOrder
    isApproved?: SortOrder
    moderatedAt?: SortOrderInput | SortOrder
    moderatedBy?: SortOrderInput | SortOrder
    volunteer?: VolunteerOrderByWithRelationInput
  }

  export type VolunteerFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VolunteerFeedbackWhereInput | VolunteerFeedbackWhereInput[]
    OR?: VolunteerFeedbackWhereInput[]
    NOT?: VolunteerFeedbackWhereInput | VolunteerFeedbackWhereInput[]
    volunteerId?: StringFilter<"VolunteerFeedback"> | string
    sessionId?: StringNullableFilter<"VolunteerFeedback"> | string | null
    feedbackType?: EnumFeedbackTypeFilter<"VolunteerFeedback"> | $Enums.FeedbackType
    rating?: IntFilter<"VolunteerFeedback"> | number
    comment?: StringNullableFilter<"VolunteerFeedback"> | string | null
    submittedBy?: StringNullableFilter<"VolunteerFeedback"> | string | null
    sourceType?: EnumFeedbackSourceFilter<"VolunteerFeedback"> | $Enums.FeedbackSource
    submittedAt?: DateTimeFilter<"VolunteerFeedback"> | Date | string
    isAnonymous?: BoolFilter<"VolunteerFeedback"> | boolean
    isApproved?: BoolFilter<"VolunteerFeedback"> | boolean
    moderatedAt?: DateTimeNullableFilter<"VolunteerFeedback"> | Date | string | null
    moderatedBy?: StringNullableFilter<"VolunteerFeedback"> | string | null
    volunteer?: XOR<VolunteerScalarRelationFilter, VolunteerWhereInput>
  }, "id">

  export type VolunteerFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    volunteerId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    feedbackType?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    submittedBy?: SortOrderInput | SortOrder
    sourceType?: SortOrder
    submittedAt?: SortOrder
    isAnonymous?: SortOrder
    isApproved?: SortOrder
    moderatedAt?: SortOrderInput | SortOrder
    moderatedBy?: SortOrderInput | SortOrder
    _count?: VolunteerFeedbackCountOrderByAggregateInput
    _avg?: VolunteerFeedbackAvgOrderByAggregateInput
    _max?: VolunteerFeedbackMaxOrderByAggregateInput
    _min?: VolunteerFeedbackMinOrderByAggregateInput
    _sum?: VolunteerFeedbackSumOrderByAggregateInput
  }

  export type VolunteerFeedbackScalarWhereWithAggregatesInput = {
    AND?: VolunteerFeedbackScalarWhereWithAggregatesInput | VolunteerFeedbackScalarWhereWithAggregatesInput[]
    OR?: VolunteerFeedbackScalarWhereWithAggregatesInput[]
    NOT?: VolunteerFeedbackScalarWhereWithAggregatesInput | VolunteerFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VolunteerFeedback"> | string
    volunteerId?: StringWithAggregatesFilter<"VolunteerFeedback"> | string
    sessionId?: StringNullableWithAggregatesFilter<"VolunteerFeedback"> | string | null
    feedbackType?: EnumFeedbackTypeWithAggregatesFilter<"VolunteerFeedback"> | $Enums.FeedbackType
    rating?: IntWithAggregatesFilter<"VolunteerFeedback"> | number
    comment?: StringNullableWithAggregatesFilter<"VolunteerFeedback"> | string | null
    submittedBy?: StringNullableWithAggregatesFilter<"VolunteerFeedback"> | string | null
    sourceType?: EnumFeedbackSourceWithAggregatesFilter<"VolunteerFeedback"> | $Enums.FeedbackSource
    submittedAt?: DateTimeWithAggregatesFilter<"VolunteerFeedback"> | Date | string
    isAnonymous?: BoolWithAggregatesFilter<"VolunteerFeedback"> | boolean
    isApproved?: BoolWithAggregatesFilter<"VolunteerFeedback"> | boolean
    moderatedAt?: DateTimeNullableWithAggregatesFilter<"VolunteerFeedback"> | Date | string | null
    moderatedBy?: StringNullableWithAggregatesFilter<"VolunteerFeedback"> | string | null
  }

  export type CrisisResourceUsageWhereInput = {
    AND?: CrisisResourceUsageWhereInput | CrisisResourceUsageWhereInput[]
    OR?: CrisisResourceUsageWhereInput[]
    NOT?: CrisisResourceUsageWhereInput | CrisisResourceUsageWhereInput[]
    id?: StringFilter<"CrisisResourceUsage"> | string
    sessionId?: StringFilter<"CrisisResourceUsage"> | string
    resourceId?: StringFilter<"CrisisResourceUsage"> | string
    accessedAt?: DateTimeFilter<"CrisisResourceUsage"> | Date | string
    timeSpent?: IntNullableFilter<"CrisisResourceUsage"> | number | null
    wasHelpful?: BoolNullableFilter<"CrisisResourceUsage"> | boolean | null
    helpfulRating?: IntNullableFilter<"CrisisResourceUsage"> | number | null
    resourceTitle?: StringFilter<"CrisisResourceUsage"> | string
    resourceType?: EnumResourceCategoryFilter<"CrisisResourceUsage"> | $Enums.ResourceCategory
    session?: XOR<CrisisSessionScalarRelationFilter, CrisisSessionWhereInput>
  }

  export type CrisisResourceUsageOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    resourceId?: SortOrder
    accessedAt?: SortOrder
    timeSpent?: SortOrderInput | SortOrder
    wasHelpful?: SortOrderInput | SortOrder
    helpfulRating?: SortOrderInput | SortOrder
    resourceTitle?: SortOrder
    resourceType?: SortOrder
    session?: CrisisSessionOrderByWithRelationInput
  }

  export type CrisisResourceUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrisisResourceUsageWhereInput | CrisisResourceUsageWhereInput[]
    OR?: CrisisResourceUsageWhereInput[]
    NOT?: CrisisResourceUsageWhereInput | CrisisResourceUsageWhereInput[]
    sessionId?: StringFilter<"CrisisResourceUsage"> | string
    resourceId?: StringFilter<"CrisisResourceUsage"> | string
    accessedAt?: DateTimeFilter<"CrisisResourceUsage"> | Date | string
    timeSpent?: IntNullableFilter<"CrisisResourceUsage"> | number | null
    wasHelpful?: BoolNullableFilter<"CrisisResourceUsage"> | boolean | null
    helpfulRating?: IntNullableFilter<"CrisisResourceUsage"> | number | null
    resourceTitle?: StringFilter<"CrisisResourceUsage"> | string
    resourceType?: EnumResourceCategoryFilter<"CrisisResourceUsage"> | $Enums.ResourceCategory
    session?: XOR<CrisisSessionScalarRelationFilter, CrisisSessionWhereInput>
  }, "id">

  export type CrisisResourceUsageOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    resourceId?: SortOrder
    accessedAt?: SortOrder
    timeSpent?: SortOrderInput | SortOrder
    wasHelpful?: SortOrderInput | SortOrder
    helpfulRating?: SortOrderInput | SortOrder
    resourceTitle?: SortOrder
    resourceType?: SortOrder
    _count?: CrisisResourceUsageCountOrderByAggregateInput
    _avg?: CrisisResourceUsageAvgOrderByAggregateInput
    _max?: CrisisResourceUsageMaxOrderByAggregateInput
    _min?: CrisisResourceUsageMinOrderByAggregateInput
    _sum?: CrisisResourceUsageSumOrderByAggregateInput
  }

  export type CrisisResourceUsageScalarWhereWithAggregatesInput = {
    AND?: CrisisResourceUsageScalarWhereWithAggregatesInput | CrisisResourceUsageScalarWhereWithAggregatesInput[]
    OR?: CrisisResourceUsageScalarWhereWithAggregatesInput[]
    NOT?: CrisisResourceUsageScalarWhereWithAggregatesInput | CrisisResourceUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CrisisResourceUsage"> | string
    sessionId?: StringWithAggregatesFilter<"CrisisResourceUsage"> | string
    resourceId?: StringWithAggregatesFilter<"CrisisResourceUsage"> | string
    accessedAt?: DateTimeWithAggregatesFilter<"CrisisResourceUsage"> | Date | string
    timeSpent?: IntNullableWithAggregatesFilter<"CrisisResourceUsage"> | number | null
    wasHelpful?: BoolNullableWithAggregatesFilter<"CrisisResourceUsage"> | boolean | null
    helpfulRating?: IntNullableWithAggregatesFilter<"CrisisResourceUsage"> | number | null
    resourceTitle?: StringWithAggregatesFilter<"CrisisResourceUsage"> | string
    resourceType?: EnumResourceCategoryWithAggregatesFilter<"CrisisResourceUsage"> | $Enums.ResourceCategory
  }

  export type SafetyReportWhereInput = {
    AND?: SafetyReportWhereInput | SafetyReportWhereInput[]
    OR?: SafetyReportWhereInput[]
    NOT?: SafetyReportWhereInput | SafetyReportWhereInput[]
    id?: StringFilter<"SafetyReport"> | string
    sessionId?: StringNullableFilter<"SafetyReport"> | string | null
    messageId?: StringNullableFilter<"SafetyReport"> | string | null
    reportType?: EnumReportTypeFilter<"SafetyReport"> | $Enums.ReportType
    severity?: EnumReportSeverityFilter<"SafetyReport"> | $Enums.ReportSeverity
    status?: EnumReportStatusFilter<"SafetyReport"> | $Enums.ReportStatus
    content?: StringNullableFilter<"SafetyReport"> | string | null
    reason?: StringFilter<"SafetyReport"> | string
    confidence?: FloatFilter<"SafetyReport"> | number
    aiAnalysis?: JsonNullableFilter<"SafetyReport">
    keywordsMatched?: StringNullableFilter<"SafetyReport"> | string | null
    riskScore?: IntFilter<"SafetyReport"> | number
    reviewedBy?: StringNullableFilter<"SafetyReport"> | string | null
    reviewedAt?: DateTimeNullableFilter<"SafetyReport"> | Date | string | null
    reviewNotes?: StringNullableFilter<"SafetyReport"> | string | null
    createdAt?: DateTimeFilter<"SafetyReport"> | Date | string
    updatedAt?: DateTimeFilter<"SafetyReport"> | Date | string
  }

  export type SafetyReportOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    reportType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    content?: SortOrderInput | SortOrder
    reason?: SortOrder
    confidence?: SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    keywordsMatched?: SortOrderInput | SortOrder
    riskScore?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SafetyReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SafetyReportWhereInput | SafetyReportWhereInput[]
    OR?: SafetyReportWhereInput[]
    NOT?: SafetyReportWhereInput | SafetyReportWhereInput[]
    sessionId?: StringNullableFilter<"SafetyReport"> | string | null
    messageId?: StringNullableFilter<"SafetyReport"> | string | null
    reportType?: EnumReportTypeFilter<"SafetyReport"> | $Enums.ReportType
    severity?: EnumReportSeverityFilter<"SafetyReport"> | $Enums.ReportSeverity
    status?: EnumReportStatusFilter<"SafetyReport"> | $Enums.ReportStatus
    content?: StringNullableFilter<"SafetyReport"> | string | null
    reason?: StringFilter<"SafetyReport"> | string
    confidence?: FloatFilter<"SafetyReport"> | number
    aiAnalysis?: JsonNullableFilter<"SafetyReport">
    keywordsMatched?: StringNullableFilter<"SafetyReport"> | string | null
    riskScore?: IntFilter<"SafetyReport"> | number
    reviewedBy?: StringNullableFilter<"SafetyReport"> | string | null
    reviewedAt?: DateTimeNullableFilter<"SafetyReport"> | Date | string | null
    reviewNotes?: StringNullableFilter<"SafetyReport"> | string | null
    createdAt?: DateTimeFilter<"SafetyReport"> | Date | string
    updatedAt?: DateTimeFilter<"SafetyReport"> | Date | string
  }, "id">

  export type SafetyReportOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    reportType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    content?: SortOrderInput | SortOrder
    reason?: SortOrder
    confidence?: SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    keywordsMatched?: SortOrderInput | SortOrder
    riskScore?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SafetyReportCountOrderByAggregateInput
    _avg?: SafetyReportAvgOrderByAggregateInput
    _max?: SafetyReportMaxOrderByAggregateInput
    _min?: SafetyReportMinOrderByAggregateInput
    _sum?: SafetyReportSumOrderByAggregateInput
  }

  export type SafetyReportScalarWhereWithAggregatesInput = {
    AND?: SafetyReportScalarWhereWithAggregatesInput | SafetyReportScalarWhereWithAggregatesInput[]
    OR?: SafetyReportScalarWhereWithAggregatesInput[]
    NOT?: SafetyReportScalarWhereWithAggregatesInput | SafetyReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SafetyReport"> | string
    sessionId?: StringNullableWithAggregatesFilter<"SafetyReport"> | string | null
    messageId?: StringNullableWithAggregatesFilter<"SafetyReport"> | string | null
    reportType?: EnumReportTypeWithAggregatesFilter<"SafetyReport"> | $Enums.ReportType
    severity?: EnumReportSeverityWithAggregatesFilter<"SafetyReport"> | $Enums.ReportSeverity
    status?: EnumReportStatusWithAggregatesFilter<"SafetyReport"> | $Enums.ReportStatus
    content?: StringNullableWithAggregatesFilter<"SafetyReport"> | string | null
    reason?: StringWithAggregatesFilter<"SafetyReport"> | string
    confidence?: FloatWithAggregatesFilter<"SafetyReport"> | number
    aiAnalysis?: JsonNullableWithAggregatesFilter<"SafetyReport">
    keywordsMatched?: StringNullableWithAggregatesFilter<"SafetyReport"> | string | null
    riskScore?: IntWithAggregatesFilter<"SafetyReport"> | number
    reviewedBy?: StringNullableWithAggregatesFilter<"SafetyReport"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"SafetyReport"> | Date | string | null
    reviewNotes?: StringNullableWithAggregatesFilter<"SafetyReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SafetyReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SafetyReport"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    success?: BoolFilter<"AuditLog"> | boolean
    errorMessage?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    sessionId?: StringNullableFilter<"AuditLog"> | string | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    sessionId?: SortOrderInput | SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    success?: BoolFilter<"AuditLog"> | boolean
    errorMessage?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    sessionId?: StringNullableFilter<"AuditLog"> | string | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    success?: BoolWithAggregatesFilter<"AuditLog"> | boolean
    errorMessage?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    sessionId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
  }

  export type AnalyticsEventWhereInput = {
    AND?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    OR?: AnalyticsEventWhereInput[]
    NOT?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    id?: StringFilter<"AnalyticsEvent"> | string
    eventType?: StringFilter<"AnalyticsEvent"> | string
    eventName?: StringFilter<"AnalyticsEvent"> | string
    userHash?: StringNullableFilter<"AnalyticsEvent"> | string | null
    sessionId?: StringNullableFilter<"AnalyticsEvent"> | string | null
    properties?: JsonNullableFilter<"AnalyticsEvent">
    timestamp?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    responseTime?: IntNullableFilter<"AnalyticsEvent"> | number | null
    success?: BoolFilter<"AnalyticsEvent"> | boolean
    errorCode?: StringNullableFilter<"AnalyticsEvent"> | string | null
  }

  export type AnalyticsEventOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    eventName?: SortOrder
    userHash?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    properties?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    success?: SortOrder
    errorCode?: SortOrderInput | SortOrder
  }

  export type AnalyticsEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    OR?: AnalyticsEventWhereInput[]
    NOT?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    eventType?: StringFilter<"AnalyticsEvent"> | string
    eventName?: StringFilter<"AnalyticsEvent"> | string
    userHash?: StringNullableFilter<"AnalyticsEvent"> | string | null
    sessionId?: StringNullableFilter<"AnalyticsEvent"> | string | null
    properties?: JsonNullableFilter<"AnalyticsEvent">
    timestamp?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    responseTime?: IntNullableFilter<"AnalyticsEvent"> | number | null
    success?: BoolFilter<"AnalyticsEvent"> | boolean
    errorCode?: StringNullableFilter<"AnalyticsEvent"> | string | null
  }, "id">

  export type AnalyticsEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    eventName?: SortOrder
    userHash?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    properties?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    success?: SortOrder
    errorCode?: SortOrderInput | SortOrder
    _count?: AnalyticsEventCountOrderByAggregateInput
    _avg?: AnalyticsEventAvgOrderByAggregateInput
    _max?: AnalyticsEventMaxOrderByAggregateInput
    _min?: AnalyticsEventMinOrderByAggregateInput
    _sum?: AnalyticsEventSumOrderByAggregateInput
  }

  export type AnalyticsEventScalarWhereWithAggregatesInput = {
    AND?: AnalyticsEventScalarWhereWithAggregatesInput | AnalyticsEventScalarWhereWithAggregatesInput[]
    OR?: AnalyticsEventScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsEventScalarWhereWithAggregatesInput | AnalyticsEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    eventType?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    eventName?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    userHash?: StringNullableWithAggregatesFilter<"AnalyticsEvent"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"AnalyticsEvent"> | string | null
    properties?: JsonNullableWithAggregatesFilter<"AnalyticsEvent">
    timestamp?: DateTimeWithAggregatesFilter<"AnalyticsEvent"> | Date | string
    responseTime?: IntNullableWithAggregatesFilter<"AnalyticsEvent"> | number | null
    success?: BoolWithAggregatesFilter<"AnalyticsEvent"> | boolean
    errorCode?: StringNullableWithAggregatesFilter<"AnalyticsEvent"> | string | null
  }

  export type PerformanceMetricWhereInput = {
    AND?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    OR?: PerformanceMetricWhereInput[]
    NOT?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    id?: StringFilter<"PerformanceMetric"> | string
    metricType?: StringFilter<"PerformanceMetric"> | string
    value?: FloatFilter<"PerformanceMetric"> | number
    unit?: StringFilter<"PerformanceMetric"> | string
    endpoint?: StringNullableFilter<"PerformanceMetric"> | string | null
    region?: StringNullableFilter<"PerformanceMetric"> | string | null
    timestamp?: DateTimeFilter<"PerformanceMetric"> | Date | string
    target?: FloatNullableFilter<"PerformanceMetric"> | number | null
    threshold?: FloatNullableFilter<"PerformanceMetric"> | number | null
    status?: EnumMetricStatusFilter<"PerformanceMetric"> | $Enums.MetricStatus
  }

  export type PerformanceMetricOrderByWithRelationInput = {
    id?: SortOrder
    metricType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    endpoint?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    target?: SortOrderInput | SortOrder
    threshold?: SortOrderInput | SortOrder
    status?: SortOrder
  }

  export type PerformanceMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    OR?: PerformanceMetricWhereInput[]
    NOT?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    metricType?: StringFilter<"PerformanceMetric"> | string
    value?: FloatFilter<"PerformanceMetric"> | number
    unit?: StringFilter<"PerformanceMetric"> | string
    endpoint?: StringNullableFilter<"PerformanceMetric"> | string | null
    region?: StringNullableFilter<"PerformanceMetric"> | string | null
    timestamp?: DateTimeFilter<"PerformanceMetric"> | Date | string
    target?: FloatNullableFilter<"PerformanceMetric"> | number | null
    threshold?: FloatNullableFilter<"PerformanceMetric"> | number | null
    status?: EnumMetricStatusFilter<"PerformanceMetric"> | $Enums.MetricStatus
  }, "id">

  export type PerformanceMetricOrderByWithAggregationInput = {
    id?: SortOrder
    metricType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    endpoint?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    target?: SortOrderInput | SortOrder
    threshold?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: PerformanceMetricCountOrderByAggregateInput
    _avg?: PerformanceMetricAvgOrderByAggregateInput
    _max?: PerformanceMetricMaxOrderByAggregateInput
    _min?: PerformanceMetricMinOrderByAggregateInput
    _sum?: PerformanceMetricSumOrderByAggregateInput
  }

  export type PerformanceMetricScalarWhereWithAggregatesInput = {
    AND?: PerformanceMetricScalarWhereWithAggregatesInput | PerformanceMetricScalarWhereWithAggregatesInput[]
    OR?: PerformanceMetricScalarWhereWithAggregatesInput[]
    NOT?: PerformanceMetricScalarWhereWithAggregatesInput | PerformanceMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerformanceMetric"> | string
    metricType?: StringWithAggregatesFilter<"PerformanceMetric"> | string
    value?: FloatWithAggregatesFilter<"PerformanceMetric"> | number
    unit?: StringWithAggregatesFilter<"PerformanceMetric"> | string
    endpoint?: StringNullableWithAggregatesFilter<"PerformanceMetric"> | string | null
    region?: StringNullableWithAggregatesFilter<"PerformanceMetric"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"PerformanceMetric"> | Date | string
    target?: FloatNullableWithAggregatesFilter<"PerformanceMetric"> | number | null
    threshold?: FloatNullableWithAggregatesFilter<"PerformanceMetric"> | number | null
    status?: EnumMetricStatusWithAggregatesFilter<"PerformanceMetric"> | $Enums.MetricStatus
  }

  export type SystemHealthWhereInput = {
    AND?: SystemHealthWhereInput | SystemHealthWhereInput[]
    OR?: SystemHealthWhereInput[]
    NOT?: SystemHealthWhereInput | SystemHealthWhereInput[]
    id?: StringFilter<"SystemHealth"> | string
    component?: StringFilter<"SystemHealth"> | string
    status?: EnumHealthStatusFilter<"SystemHealth"> | $Enums.HealthStatus
    responseTime?: FloatNullableFilter<"SystemHealth"> | number | null
    uptime?: FloatNullableFilter<"SystemHealth"> | number | null
    errorRate?: FloatNullableFilter<"SystemHealth"> | number | null
    lastError?: DateTimeNullableFilter<"SystemHealth"> | Date | string | null
    errorMessage?: StringNullableFilter<"SystemHealth"> | string | null
    cpuUsage?: FloatNullableFilter<"SystemHealth"> | number | null
    memoryUsage?: FloatNullableFilter<"SystemHealth"> | number | null
    diskUsage?: FloatNullableFilter<"SystemHealth"> | number | null
    timestamp?: DateTimeFilter<"SystemHealth"> | Date | string
  }

  export type SystemHealthOrderByWithRelationInput = {
    id?: SortOrder
    component?: SortOrder
    status?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    uptime?: SortOrderInput | SortOrder
    errorRate?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    cpuUsage?: SortOrderInput | SortOrder
    memoryUsage?: SortOrderInput | SortOrder
    diskUsage?: SortOrderInput | SortOrder
    timestamp?: SortOrder
  }

  export type SystemHealthWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemHealthWhereInput | SystemHealthWhereInput[]
    OR?: SystemHealthWhereInput[]
    NOT?: SystemHealthWhereInput | SystemHealthWhereInput[]
    component?: StringFilter<"SystemHealth"> | string
    status?: EnumHealthStatusFilter<"SystemHealth"> | $Enums.HealthStatus
    responseTime?: FloatNullableFilter<"SystemHealth"> | number | null
    uptime?: FloatNullableFilter<"SystemHealth"> | number | null
    errorRate?: FloatNullableFilter<"SystemHealth"> | number | null
    lastError?: DateTimeNullableFilter<"SystemHealth"> | Date | string | null
    errorMessage?: StringNullableFilter<"SystemHealth"> | string | null
    cpuUsage?: FloatNullableFilter<"SystemHealth"> | number | null
    memoryUsage?: FloatNullableFilter<"SystemHealth"> | number | null
    diskUsage?: FloatNullableFilter<"SystemHealth"> | number | null
    timestamp?: DateTimeFilter<"SystemHealth"> | Date | string
  }, "id">

  export type SystemHealthOrderByWithAggregationInput = {
    id?: SortOrder
    component?: SortOrder
    status?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    uptime?: SortOrderInput | SortOrder
    errorRate?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    cpuUsage?: SortOrderInput | SortOrder
    memoryUsage?: SortOrderInput | SortOrder
    diskUsage?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: SystemHealthCountOrderByAggregateInput
    _avg?: SystemHealthAvgOrderByAggregateInput
    _max?: SystemHealthMaxOrderByAggregateInput
    _min?: SystemHealthMinOrderByAggregateInput
    _sum?: SystemHealthSumOrderByAggregateInput
  }

  export type SystemHealthScalarWhereWithAggregatesInput = {
    AND?: SystemHealthScalarWhereWithAggregatesInput | SystemHealthScalarWhereWithAggregatesInput[]
    OR?: SystemHealthScalarWhereWithAggregatesInput[]
    NOT?: SystemHealthScalarWhereWithAggregatesInput | SystemHealthScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemHealth"> | string
    component?: StringWithAggregatesFilter<"SystemHealth"> | string
    status?: EnumHealthStatusWithAggregatesFilter<"SystemHealth"> | $Enums.HealthStatus
    responseTime?: FloatNullableWithAggregatesFilter<"SystemHealth"> | number | null
    uptime?: FloatNullableWithAggregatesFilter<"SystemHealth"> | number | null
    errorRate?: FloatNullableWithAggregatesFilter<"SystemHealth"> | number | null
    lastError?: DateTimeNullableWithAggregatesFilter<"SystemHealth"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"SystemHealth"> | string | null
    cpuUsage?: FloatNullableWithAggregatesFilter<"SystemHealth"> | number | null
    memoryUsage?: FloatNullableWithAggregatesFilter<"SystemHealth"> | number | null
    diskUsage?: FloatNullableWithAggregatesFilter<"SystemHealth"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"SystemHealth"> | Date | string
  }

  export type CrisisResourceWhereInput = {
    AND?: CrisisResourceWhereInput | CrisisResourceWhereInput[]
    OR?: CrisisResourceWhereInput[]
    NOT?: CrisisResourceWhereInput | CrisisResourceWhereInput[]
    id?: StringFilter<"CrisisResource"> | string
    title?: StringFilter<"CrisisResource"> | string
    description?: StringFilter<"CrisisResource"> | string
    category?: EnumResourceCategoryFilter<"CrisisResource"> | $Enums.ResourceCategory
    phoneNumber?: StringNullableFilter<"CrisisResource"> | string | null
    url?: StringNullableFilter<"CrisisResource"> | string | null
    email?: StringNullableFilter<"CrisisResource"> | string | null
    textNumber?: StringNullableFilter<"CrisisResource"> | string | null
    content?: StringNullableFilter<"CrisisResource"> | string | null
    instructions?: StringNullableFilter<"CrisisResource"> | string | null
    available24_7?: BoolFilter<"CrisisResource"> | boolean
    languages?: StringNullableFilter<"CrisisResource"> | string | null
    countries?: StringNullableFilter<"CrisisResource"> | string | null
    regions?: StringNullableFilter<"CrisisResource"> | string | null
    priority?: IntFilter<"CrisisResource"> | number
    isEmergency?: BoolFilter<"CrisisResource"> | boolean
    severityMin?: IntFilter<"CrisisResource"> | number
    tags?: StringNullableFilter<"CrisisResource"> | string | null
    isActive?: BoolFilter<"CrisisResource"> | boolean
    createdAt?: DateTimeFilter<"CrisisResource"> | Date | string
    updatedAt?: DateTimeFilter<"CrisisResource"> | Date | string
  }

  export type CrisisResourceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    textNumber?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    available24_7?: SortOrder
    languages?: SortOrderInput | SortOrder
    countries?: SortOrderInput | SortOrder
    regions?: SortOrderInput | SortOrder
    priority?: SortOrder
    isEmergency?: SortOrder
    severityMin?: SortOrder
    tags?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrisisResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrisisResourceWhereInput | CrisisResourceWhereInput[]
    OR?: CrisisResourceWhereInput[]
    NOT?: CrisisResourceWhereInput | CrisisResourceWhereInput[]
    title?: StringFilter<"CrisisResource"> | string
    description?: StringFilter<"CrisisResource"> | string
    category?: EnumResourceCategoryFilter<"CrisisResource"> | $Enums.ResourceCategory
    phoneNumber?: StringNullableFilter<"CrisisResource"> | string | null
    url?: StringNullableFilter<"CrisisResource"> | string | null
    email?: StringNullableFilter<"CrisisResource"> | string | null
    textNumber?: StringNullableFilter<"CrisisResource"> | string | null
    content?: StringNullableFilter<"CrisisResource"> | string | null
    instructions?: StringNullableFilter<"CrisisResource"> | string | null
    available24_7?: BoolFilter<"CrisisResource"> | boolean
    languages?: StringNullableFilter<"CrisisResource"> | string | null
    countries?: StringNullableFilter<"CrisisResource"> | string | null
    regions?: StringNullableFilter<"CrisisResource"> | string | null
    priority?: IntFilter<"CrisisResource"> | number
    isEmergency?: BoolFilter<"CrisisResource"> | boolean
    severityMin?: IntFilter<"CrisisResource"> | number
    tags?: StringNullableFilter<"CrisisResource"> | string | null
    isActive?: BoolFilter<"CrisisResource"> | boolean
    createdAt?: DateTimeFilter<"CrisisResource"> | Date | string
    updatedAt?: DateTimeFilter<"CrisisResource"> | Date | string
  }, "id">

  export type CrisisResourceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    textNumber?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    available24_7?: SortOrder
    languages?: SortOrderInput | SortOrder
    countries?: SortOrderInput | SortOrder
    regions?: SortOrderInput | SortOrder
    priority?: SortOrder
    isEmergency?: SortOrder
    severityMin?: SortOrder
    tags?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CrisisResourceCountOrderByAggregateInput
    _avg?: CrisisResourceAvgOrderByAggregateInput
    _max?: CrisisResourceMaxOrderByAggregateInput
    _min?: CrisisResourceMinOrderByAggregateInput
    _sum?: CrisisResourceSumOrderByAggregateInput
  }

  export type CrisisResourceScalarWhereWithAggregatesInput = {
    AND?: CrisisResourceScalarWhereWithAggregatesInput | CrisisResourceScalarWhereWithAggregatesInput[]
    OR?: CrisisResourceScalarWhereWithAggregatesInput[]
    NOT?: CrisisResourceScalarWhereWithAggregatesInput | CrisisResourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CrisisResource"> | string
    title?: StringWithAggregatesFilter<"CrisisResource"> | string
    description?: StringWithAggregatesFilter<"CrisisResource"> | string
    category?: EnumResourceCategoryWithAggregatesFilter<"CrisisResource"> | $Enums.ResourceCategory
    phoneNumber?: StringNullableWithAggregatesFilter<"CrisisResource"> | string | null
    url?: StringNullableWithAggregatesFilter<"CrisisResource"> | string | null
    email?: StringNullableWithAggregatesFilter<"CrisisResource"> | string | null
    textNumber?: StringNullableWithAggregatesFilter<"CrisisResource"> | string | null
    content?: StringNullableWithAggregatesFilter<"CrisisResource"> | string | null
    instructions?: StringNullableWithAggregatesFilter<"CrisisResource"> | string | null
    available24_7?: BoolWithAggregatesFilter<"CrisisResource"> | boolean
    languages?: StringNullableWithAggregatesFilter<"CrisisResource"> | string | null
    countries?: StringNullableWithAggregatesFilter<"CrisisResource"> | string | null
    regions?: StringNullableWithAggregatesFilter<"CrisisResource"> | string | null
    priority?: IntWithAggregatesFilter<"CrisisResource"> | number
    isEmergency?: BoolWithAggregatesFilter<"CrisisResource"> | boolean
    severityMin?: IntWithAggregatesFilter<"CrisisResource"> | number
    tags?: StringNullableWithAggregatesFilter<"CrisisResource"> | string | null
    isActive?: BoolWithAggregatesFilter<"CrisisResource"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CrisisResource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CrisisResource"> | Date | string
  }

  export type PublicMetricsWhereInput = {
    AND?: PublicMetricsWhereInput | PublicMetricsWhereInput[]
    OR?: PublicMetricsWhereInput[]
    NOT?: PublicMetricsWhereInput | PublicMetricsWhereInput[]
    id?: StringFilter<"PublicMetrics"> | string
    metricName?: StringFilter<"PublicMetrics"> | string
    value?: FloatFilter<"PublicMetrics"> | number
    displayValue?: StringFilter<"PublicMetrics"> | string
    description?: StringFilter<"PublicMetrics"> | string
    isPublic?: BoolFilter<"PublicMetrics"> | boolean
    displayOrder?: IntFilter<"PublicMetrics"> | number
    icon?: StringNullableFilter<"PublicMetrics"> | string | null
    color?: StringNullableFilter<"PublicMetrics"> | string | null
    lastUpdated?: DateTimeFilter<"PublicMetrics"> | Date | string
    updateFrequency?: StringFilter<"PublicMetrics"> | string
  }

  export type PublicMetricsOrderByWithRelationInput = {
    id?: SortOrder
    metricName?: SortOrder
    value?: SortOrder
    displayValue?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    displayOrder?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
    updateFrequency?: SortOrder
  }

  export type PublicMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    metricName?: string
    AND?: PublicMetricsWhereInput | PublicMetricsWhereInput[]
    OR?: PublicMetricsWhereInput[]
    NOT?: PublicMetricsWhereInput | PublicMetricsWhereInput[]
    value?: FloatFilter<"PublicMetrics"> | number
    displayValue?: StringFilter<"PublicMetrics"> | string
    description?: StringFilter<"PublicMetrics"> | string
    isPublic?: BoolFilter<"PublicMetrics"> | boolean
    displayOrder?: IntFilter<"PublicMetrics"> | number
    icon?: StringNullableFilter<"PublicMetrics"> | string | null
    color?: StringNullableFilter<"PublicMetrics"> | string | null
    lastUpdated?: DateTimeFilter<"PublicMetrics"> | Date | string
    updateFrequency?: StringFilter<"PublicMetrics"> | string
  }, "id" | "metricName">

  export type PublicMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    metricName?: SortOrder
    value?: SortOrder
    displayValue?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    displayOrder?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
    updateFrequency?: SortOrder
    _count?: PublicMetricsCountOrderByAggregateInput
    _avg?: PublicMetricsAvgOrderByAggregateInput
    _max?: PublicMetricsMaxOrderByAggregateInput
    _min?: PublicMetricsMinOrderByAggregateInput
    _sum?: PublicMetricsSumOrderByAggregateInput
  }

  export type PublicMetricsScalarWhereWithAggregatesInput = {
    AND?: PublicMetricsScalarWhereWithAggregatesInput | PublicMetricsScalarWhereWithAggregatesInput[]
    OR?: PublicMetricsScalarWhereWithAggregatesInput[]
    NOT?: PublicMetricsScalarWhereWithAggregatesInput | PublicMetricsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PublicMetrics"> | string
    metricName?: StringWithAggregatesFilter<"PublicMetrics"> | string
    value?: FloatWithAggregatesFilter<"PublicMetrics"> | number
    displayValue?: StringWithAggregatesFilter<"PublicMetrics"> | string
    description?: StringWithAggregatesFilter<"PublicMetrics"> | string
    isPublic?: BoolWithAggregatesFilter<"PublicMetrics"> | boolean
    displayOrder?: IntWithAggregatesFilter<"PublicMetrics"> | number
    icon?: StringNullableWithAggregatesFilter<"PublicMetrics"> | string | null
    color?: StringNullableWithAggregatesFilter<"PublicMetrics"> | string | null
    lastUpdated?: DateTimeWithAggregatesFilter<"PublicMetrics"> | Date | string
    updateFrequency?: StringWithAggregatesFilter<"PublicMetrics"> | string
  }

  export type EmergencyContactWhereInput = {
    AND?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    OR?: EmergencyContactWhereInput[]
    NOT?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    id?: StringFilter<"EmergencyContact"> | string
    userId?: StringFilter<"EmergencyContact"> | string
    encryptedName?: BytesFilter<"EmergencyContact"> | Uint8Array
    encryptedPhone?: BytesFilter<"EmergencyContact"> | Uint8Array
    encryptedEmail?: BytesNullableFilter<"EmergencyContact"> | Uint8Array | null
    relationship?: StringFilter<"EmergencyContact"> | string
    priority?: IntFilter<"EmergencyContact"> | number
    contactMethod?: StringFilter<"EmergencyContact"> | string
    timezone?: StringNullableFilter<"EmergencyContact"> | string | null
    availableHours?: JsonNullableFilter<"EmergencyContact">
    preferredMethod?: StringNullableFilter<"EmergencyContact"> | string | null
    autoNotify?: BoolFilter<"EmergencyContact"> | boolean
    crisisOnly?: BoolFilter<"EmergencyContact"> | boolean
    hasConsent?: BoolFilter<"EmergencyContact"> | boolean
    consentDate?: DateTimeNullableFilter<"EmergencyContact"> | Date | string | null
    keyDerivationSalt?: BytesFilter<"EmergencyContact"> | Uint8Array
    isVerified?: BoolFilter<"EmergencyContact"> | boolean
    verifiedAt?: DateTimeNullableFilter<"EmergencyContact"> | Date | string | null
    isActive?: BoolFilter<"EmergencyContact"> | boolean
    createdAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    lastContacted?: DateTimeNullableFilter<"EmergencyContact"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    notifications?: EmergencyNotificationListRelationFilter
  }

  export type EmergencyContactOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    encryptedName?: SortOrder
    encryptedPhone?: SortOrder
    encryptedEmail?: SortOrderInput | SortOrder
    relationship?: SortOrder
    priority?: SortOrder
    contactMethod?: SortOrder
    timezone?: SortOrderInput | SortOrder
    availableHours?: SortOrderInput | SortOrder
    preferredMethod?: SortOrderInput | SortOrder
    autoNotify?: SortOrder
    crisisOnly?: SortOrder
    hasConsent?: SortOrder
    consentDate?: SortOrderInput | SortOrder
    keyDerivationSalt?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastContacted?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    notifications?: EmergencyNotificationOrderByRelationAggregateInput
  }

  export type EmergencyContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    OR?: EmergencyContactWhereInput[]
    NOT?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    userId?: StringFilter<"EmergencyContact"> | string
    encryptedName?: BytesFilter<"EmergencyContact"> | Uint8Array
    encryptedPhone?: BytesFilter<"EmergencyContact"> | Uint8Array
    encryptedEmail?: BytesNullableFilter<"EmergencyContact"> | Uint8Array | null
    relationship?: StringFilter<"EmergencyContact"> | string
    priority?: IntFilter<"EmergencyContact"> | number
    contactMethod?: StringFilter<"EmergencyContact"> | string
    timezone?: StringNullableFilter<"EmergencyContact"> | string | null
    availableHours?: JsonNullableFilter<"EmergencyContact">
    preferredMethod?: StringNullableFilter<"EmergencyContact"> | string | null
    autoNotify?: BoolFilter<"EmergencyContact"> | boolean
    crisisOnly?: BoolFilter<"EmergencyContact"> | boolean
    hasConsent?: BoolFilter<"EmergencyContact"> | boolean
    consentDate?: DateTimeNullableFilter<"EmergencyContact"> | Date | string | null
    keyDerivationSalt?: BytesFilter<"EmergencyContact"> | Uint8Array
    isVerified?: BoolFilter<"EmergencyContact"> | boolean
    verifiedAt?: DateTimeNullableFilter<"EmergencyContact"> | Date | string | null
    isActive?: BoolFilter<"EmergencyContact"> | boolean
    createdAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    lastContacted?: DateTimeNullableFilter<"EmergencyContact"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    notifications?: EmergencyNotificationListRelationFilter
  }, "id">

  export type EmergencyContactOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    encryptedName?: SortOrder
    encryptedPhone?: SortOrder
    encryptedEmail?: SortOrderInput | SortOrder
    relationship?: SortOrder
    priority?: SortOrder
    contactMethod?: SortOrder
    timezone?: SortOrderInput | SortOrder
    availableHours?: SortOrderInput | SortOrder
    preferredMethod?: SortOrderInput | SortOrder
    autoNotify?: SortOrder
    crisisOnly?: SortOrder
    hasConsent?: SortOrder
    consentDate?: SortOrderInput | SortOrder
    keyDerivationSalt?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastContacted?: SortOrderInput | SortOrder
    _count?: EmergencyContactCountOrderByAggregateInput
    _avg?: EmergencyContactAvgOrderByAggregateInput
    _max?: EmergencyContactMaxOrderByAggregateInput
    _min?: EmergencyContactMinOrderByAggregateInput
    _sum?: EmergencyContactSumOrderByAggregateInput
  }

  export type EmergencyContactScalarWhereWithAggregatesInput = {
    AND?: EmergencyContactScalarWhereWithAggregatesInput | EmergencyContactScalarWhereWithAggregatesInput[]
    OR?: EmergencyContactScalarWhereWithAggregatesInput[]
    NOT?: EmergencyContactScalarWhereWithAggregatesInput | EmergencyContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmergencyContact"> | string
    userId?: StringWithAggregatesFilter<"EmergencyContact"> | string
    encryptedName?: BytesWithAggregatesFilter<"EmergencyContact"> | Uint8Array
    encryptedPhone?: BytesWithAggregatesFilter<"EmergencyContact"> | Uint8Array
    encryptedEmail?: BytesNullableWithAggregatesFilter<"EmergencyContact"> | Uint8Array | null
    relationship?: StringWithAggregatesFilter<"EmergencyContact"> | string
    priority?: IntWithAggregatesFilter<"EmergencyContact"> | number
    contactMethod?: StringWithAggregatesFilter<"EmergencyContact"> | string
    timezone?: StringNullableWithAggregatesFilter<"EmergencyContact"> | string | null
    availableHours?: JsonNullableWithAggregatesFilter<"EmergencyContact">
    preferredMethod?: StringNullableWithAggregatesFilter<"EmergencyContact"> | string | null
    autoNotify?: BoolWithAggregatesFilter<"EmergencyContact"> | boolean
    crisisOnly?: BoolWithAggregatesFilter<"EmergencyContact"> | boolean
    hasConsent?: BoolWithAggregatesFilter<"EmergencyContact"> | boolean
    consentDate?: DateTimeNullableWithAggregatesFilter<"EmergencyContact"> | Date | string | null
    keyDerivationSalt?: BytesWithAggregatesFilter<"EmergencyContact"> | Uint8Array
    isVerified?: BoolWithAggregatesFilter<"EmergencyContact"> | boolean
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"EmergencyContact"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"EmergencyContact"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EmergencyContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmergencyContact"> | Date | string
    lastContacted?: DateTimeNullableWithAggregatesFilter<"EmergencyContact"> | Date | string | null
  }

  export type EmergencyNotificationWhereInput = {
    AND?: EmergencyNotificationWhereInput | EmergencyNotificationWhereInput[]
    OR?: EmergencyNotificationWhereInput[]
    NOT?: EmergencyNotificationWhereInput | EmergencyNotificationWhereInput[]
    id?: StringFilter<"EmergencyNotification"> | string
    emergencyContactId?: StringFilter<"EmergencyNotification"> | string
    sessionId?: StringNullableFilter<"EmergencyNotification"> | string | null
    tetherEmergencyId?: StringNullableFilter<"EmergencyNotification"> | string | null
    notificationType?: EnumEmergencyNotificationTypeFilter<"EmergencyNotification"> | $Enums.EmergencyNotificationType
    severity?: EnumEmergencySeverityFilter<"EmergencyNotification"> | $Enums.EmergencySeverity
    message?: StringFilter<"EmergencyNotification"> | string
    sentAt?: DateTimeFilter<"EmergencyNotification"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"EmergencyNotification"> | Date | string | null
    acknowledgedAt?: DateTimeNullableFilter<"EmergencyNotification"> | Date | string | null
    responseReceived?: BoolFilter<"EmergencyNotification"> | boolean
    responseTime?: IntNullableFilter<"EmergencyNotification"> | number | null
    method?: StringFilter<"EmergencyNotification"> | string
    status?: EnumNotificationStatusFilter<"EmergencyNotification"> | $Enums.NotificationStatus
    attempts?: IntFilter<"EmergencyNotification"> | number
    maxAttempts?: IntFilter<"EmergencyNotification"> | number
    errorMessage?: StringNullableFilter<"EmergencyNotification"> | string | null
    nextRetryAt?: DateTimeNullableFilter<"EmergencyNotification"> | Date | string | null
    emergencyContact?: XOR<EmergencyContactScalarRelationFilter, EmergencyContactWhereInput>
  }

  export type EmergencyNotificationOrderByWithRelationInput = {
    id?: SortOrder
    emergencyContactId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    tetherEmergencyId?: SortOrderInput | SortOrder
    notificationType?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    responseReceived?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    method?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    emergencyContact?: EmergencyContactOrderByWithRelationInput
  }

  export type EmergencyNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmergencyNotificationWhereInput | EmergencyNotificationWhereInput[]
    OR?: EmergencyNotificationWhereInput[]
    NOT?: EmergencyNotificationWhereInput | EmergencyNotificationWhereInput[]
    emergencyContactId?: StringFilter<"EmergencyNotification"> | string
    sessionId?: StringNullableFilter<"EmergencyNotification"> | string | null
    tetherEmergencyId?: StringNullableFilter<"EmergencyNotification"> | string | null
    notificationType?: EnumEmergencyNotificationTypeFilter<"EmergencyNotification"> | $Enums.EmergencyNotificationType
    severity?: EnumEmergencySeverityFilter<"EmergencyNotification"> | $Enums.EmergencySeverity
    message?: StringFilter<"EmergencyNotification"> | string
    sentAt?: DateTimeFilter<"EmergencyNotification"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"EmergencyNotification"> | Date | string | null
    acknowledgedAt?: DateTimeNullableFilter<"EmergencyNotification"> | Date | string | null
    responseReceived?: BoolFilter<"EmergencyNotification"> | boolean
    responseTime?: IntNullableFilter<"EmergencyNotification"> | number | null
    method?: StringFilter<"EmergencyNotification"> | string
    status?: EnumNotificationStatusFilter<"EmergencyNotification"> | $Enums.NotificationStatus
    attempts?: IntFilter<"EmergencyNotification"> | number
    maxAttempts?: IntFilter<"EmergencyNotification"> | number
    errorMessage?: StringNullableFilter<"EmergencyNotification"> | string | null
    nextRetryAt?: DateTimeNullableFilter<"EmergencyNotification"> | Date | string | null
    emergencyContact?: XOR<EmergencyContactScalarRelationFilter, EmergencyContactWhereInput>
  }, "id">

  export type EmergencyNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    emergencyContactId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    tetherEmergencyId?: SortOrderInput | SortOrder
    notificationType?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    responseReceived?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    method?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    _count?: EmergencyNotificationCountOrderByAggregateInput
    _avg?: EmergencyNotificationAvgOrderByAggregateInput
    _max?: EmergencyNotificationMaxOrderByAggregateInput
    _min?: EmergencyNotificationMinOrderByAggregateInput
    _sum?: EmergencyNotificationSumOrderByAggregateInput
  }

  export type EmergencyNotificationScalarWhereWithAggregatesInput = {
    AND?: EmergencyNotificationScalarWhereWithAggregatesInput | EmergencyNotificationScalarWhereWithAggregatesInput[]
    OR?: EmergencyNotificationScalarWhereWithAggregatesInput[]
    NOT?: EmergencyNotificationScalarWhereWithAggregatesInput | EmergencyNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmergencyNotification"> | string
    emergencyContactId?: StringWithAggregatesFilter<"EmergencyNotification"> | string
    sessionId?: StringNullableWithAggregatesFilter<"EmergencyNotification"> | string | null
    tetherEmergencyId?: StringNullableWithAggregatesFilter<"EmergencyNotification"> | string | null
    notificationType?: EnumEmergencyNotificationTypeWithAggregatesFilter<"EmergencyNotification"> | $Enums.EmergencyNotificationType
    severity?: EnumEmergencySeverityWithAggregatesFilter<"EmergencyNotification"> | $Enums.EmergencySeverity
    message?: StringWithAggregatesFilter<"EmergencyNotification"> | string
    sentAt?: DateTimeWithAggregatesFilter<"EmergencyNotification"> | Date | string
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"EmergencyNotification"> | Date | string | null
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"EmergencyNotification"> | Date | string | null
    responseReceived?: BoolWithAggregatesFilter<"EmergencyNotification"> | boolean
    responseTime?: IntNullableWithAggregatesFilter<"EmergencyNotification"> | number | null
    method?: StringWithAggregatesFilter<"EmergencyNotification"> | string
    status?: EnumNotificationStatusWithAggregatesFilter<"EmergencyNotification"> | $Enums.NotificationStatus
    attempts?: IntWithAggregatesFilter<"EmergencyNotification"> | number
    maxAttempts?: IntWithAggregatesFilter<"EmergencyNotification"> | number
    errorMessage?: StringNullableWithAggregatesFilter<"EmergencyNotification"> | string | null
    nextRetryAt?: DateTimeNullableWithAggregatesFilter<"EmergencyNotification"> | Date | string | null
  }

  export type WebSocketConnectionWhereInput = {
    AND?: WebSocketConnectionWhereInput | WebSocketConnectionWhereInput[]
    OR?: WebSocketConnectionWhereInput[]
    NOT?: WebSocketConnectionWhereInput | WebSocketConnectionWhereInput[]
    id?: StringFilter<"WebSocketConnection"> | string
    sessionId?: StringFilter<"WebSocketConnection"> | string
    userType?: StringFilter<"WebSocketConnection"> | string
    userId?: StringNullableFilter<"WebSocketConnection"> | string | null
    isActive?: BoolFilter<"WebSocketConnection"> | boolean
    createdAt?: DateTimeFilter<"WebSocketConnection"> | Date | string
    lastActivity?: DateTimeFilter<"WebSocketConnection"> | Date | string
    expiresAt?: DateTimeFilter<"WebSocketConnection"> | Date | string
    ipAddress?: StringNullableFilter<"WebSocketConnection"> | string | null
    userAgent?: StringNullableFilter<"WebSocketConnection"> | string | null
  }

  export type WebSocketConnectionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userType?: SortOrder
    userId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    lastActivity?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
  }

  export type WebSocketConnectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebSocketConnectionWhereInput | WebSocketConnectionWhereInput[]
    OR?: WebSocketConnectionWhereInput[]
    NOT?: WebSocketConnectionWhereInput | WebSocketConnectionWhereInput[]
    sessionId?: StringFilter<"WebSocketConnection"> | string
    userType?: StringFilter<"WebSocketConnection"> | string
    userId?: StringNullableFilter<"WebSocketConnection"> | string | null
    isActive?: BoolFilter<"WebSocketConnection"> | boolean
    createdAt?: DateTimeFilter<"WebSocketConnection"> | Date | string
    lastActivity?: DateTimeFilter<"WebSocketConnection"> | Date | string
    expiresAt?: DateTimeFilter<"WebSocketConnection"> | Date | string
    ipAddress?: StringNullableFilter<"WebSocketConnection"> | string | null
    userAgent?: StringNullableFilter<"WebSocketConnection"> | string | null
  }, "id">

  export type WebSocketConnectionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userType?: SortOrder
    userId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    lastActivity?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    _count?: WebSocketConnectionCountOrderByAggregateInput
    _max?: WebSocketConnectionMaxOrderByAggregateInput
    _min?: WebSocketConnectionMinOrderByAggregateInput
  }

  export type WebSocketConnectionScalarWhereWithAggregatesInput = {
    AND?: WebSocketConnectionScalarWhereWithAggregatesInput | WebSocketConnectionScalarWhereWithAggregatesInput[]
    OR?: WebSocketConnectionScalarWhereWithAggregatesInput[]
    NOT?: WebSocketConnectionScalarWhereWithAggregatesInput | WebSocketConnectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebSocketConnection"> | string
    sessionId?: StringWithAggregatesFilter<"WebSocketConnection"> | string
    userType?: StringWithAggregatesFilter<"WebSocketConnection"> | string
    userId?: StringNullableWithAggregatesFilter<"WebSocketConnection"> | string | null
    isActive?: BoolWithAggregatesFilter<"WebSocketConnection"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"WebSocketConnection"> | Date | string
    lastActivity?: DateTimeWithAggregatesFilter<"WebSocketConnection"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"WebSocketConnection"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"WebSocketConnection"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"WebSocketConnection"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    anonymousId?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    isAnonymous?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    dataSharing?: EnumUserDataSharingFilter<"User"> | $Enums.UserDataSharing
    allowAnalytics?: BoolFilter<"User"> | boolean
    dataRetentionDays?: IntNullableFilter<"User"> | number | null
    verificationStatus?: EnumVerificationStatusFilter<"User"> | $Enums.VerificationStatus
    professionalType?: StringNullableFilter<"User"> | string | null
    licenseNumber?: StringNullableFilter<"User"> | string | null
    verifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    encryptedProfile?: BytesNullableFilter<"User"> | Uint8Array | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    moodEntries?: MoodEntryListRelationFilter
    safetyPlans?: SafetyPlanListRelationFilter
    userProfile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    achievements?: UserAchievementListRelationFilter
    challenges?: UserChallengeListRelationFilter
    activities?: UserActivityListRelationFilter
    emergencyContacts?: EmergencyContactListRelationFilter
    journalEntries?: JournalEntryListRelationFilter
    breathingSessions?: BreathingSessionListRelationFilter
    groundingSessions?: GroundingSessionListRelationFilter
    selfHelpInteractions?: SelfHelpInteractionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    anonymousId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    isAnonymous?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    dataSharing?: SortOrder
    allowAnalytics?: SortOrder
    dataRetentionDays?: SortOrderInput | SortOrder
    verificationStatus?: SortOrder
    professionalType?: SortOrderInput | SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    encryptedProfile?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    moodEntries?: MoodEntryOrderByRelationAggregateInput
    safetyPlans?: SafetyPlanOrderByRelationAggregateInput
    userProfile?: UserProfileOrderByWithRelationInput
    achievements?: UserAchievementOrderByRelationAggregateInput
    challenges?: UserChallengeOrderByRelationAggregateInput
    activities?: UserActivityOrderByRelationAggregateInput
    emergencyContacts?: EmergencyContactOrderByRelationAggregateInput
    journalEntries?: JournalEntryOrderByRelationAggregateInput
    breathingSessions?: BreathingSessionOrderByRelationAggregateInput
    groundingSessions?: GroundingSessionOrderByRelationAggregateInput
    selfHelpInteractions?: SelfHelpInteractionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    anonymousId?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    isAnonymous?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    dataSharing?: EnumUserDataSharingFilter<"User"> | $Enums.UserDataSharing
    allowAnalytics?: BoolFilter<"User"> | boolean
    dataRetentionDays?: IntNullableFilter<"User"> | number | null
    verificationStatus?: EnumVerificationStatusFilter<"User"> | $Enums.VerificationStatus
    professionalType?: StringNullableFilter<"User"> | string | null
    licenseNumber?: StringNullableFilter<"User"> | string | null
    verifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    encryptedProfile?: BytesNullableFilter<"User"> | Uint8Array | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    moodEntries?: MoodEntryListRelationFilter
    safetyPlans?: SafetyPlanListRelationFilter
    userProfile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    achievements?: UserAchievementListRelationFilter
    challenges?: UserChallengeListRelationFilter
    activities?: UserActivityListRelationFilter
    emergencyContacts?: EmergencyContactListRelationFilter
    journalEntries?: JournalEntryListRelationFilter
    breathingSessions?: BreathingSessionListRelationFilter
    groundingSessions?: GroundingSessionListRelationFilter
    selfHelpInteractions?: SelfHelpInteractionListRelationFilter
  }, "id" | "anonymousId" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    anonymousId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    isAnonymous?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    dataSharing?: SortOrder
    allowAnalytics?: SortOrder
    dataRetentionDays?: SortOrderInput | SortOrder
    verificationStatus?: SortOrder
    professionalType?: SortOrderInput | SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    encryptedProfile?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    anonymousId?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    isAnonymous?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    dataSharing?: EnumUserDataSharingWithAggregatesFilter<"User"> | $Enums.UserDataSharing
    allowAnalytics?: BoolWithAggregatesFilter<"User"> | boolean
    dataRetentionDays?: IntNullableWithAggregatesFilter<"User"> | number | null
    verificationStatus?: EnumVerificationStatusWithAggregatesFilter<"User"> | $Enums.VerificationStatus
    professionalType?: StringNullableWithAggregatesFilter<"User"> | string | null
    licenseNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    encryptedProfile?: BytesNullableWithAggregatesFilter<"User"> | Uint8Array | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type MoodEntryWhereInput = {
    AND?: MoodEntryWhereInput | MoodEntryWhereInput[]
    OR?: MoodEntryWhereInput[]
    NOT?: MoodEntryWhereInput | MoodEntryWhereInput[]
    id?: StringFilter<"MoodEntry"> | string
    userId?: StringFilter<"MoodEntry"> | string
    mood?: IntFilter<"MoodEntry"> | number
    emotions?: JsonFilter<"MoodEntry">
    triggers?: JsonFilter<"MoodEntry">
    activities?: JsonFilter<"MoodEntry">
    sleepHours?: FloatNullableFilter<"MoodEntry"> | number | null
    notes?: StringNullableFilter<"MoodEntry"> | string | null
    weather?: StringNullableFilter<"MoodEntry"> | string | null
    medication?: BoolNullableFilter<"MoodEntry"> | boolean | null
    socialInteraction?: IntNullableFilter<"MoodEntry"> | number | null
    timestamp?: DateTimeFilter<"MoodEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MoodEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    emotions?: SortOrder
    triggers?: SortOrder
    activities?: SortOrder
    sleepHours?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    weather?: SortOrderInput | SortOrder
    medication?: SortOrderInput | SortOrder
    socialInteraction?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MoodEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MoodEntryWhereInput | MoodEntryWhereInput[]
    OR?: MoodEntryWhereInput[]
    NOT?: MoodEntryWhereInput | MoodEntryWhereInput[]
    userId?: StringFilter<"MoodEntry"> | string
    mood?: IntFilter<"MoodEntry"> | number
    emotions?: JsonFilter<"MoodEntry">
    triggers?: JsonFilter<"MoodEntry">
    activities?: JsonFilter<"MoodEntry">
    sleepHours?: FloatNullableFilter<"MoodEntry"> | number | null
    notes?: StringNullableFilter<"MoodEntry"> | string | null
    weather?: StringNullableFilter<"MoodEntry"> | string | null
    medication?: BoolNullableFilter<"MoodEntry"> | boolean | null
    socialInteraction?: IntNullableFilter<"MoodEntry"> | number | null
    timestamp?: DateTimeFilter<"MoodEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MoodEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    emotions?: SortOrder
    triggers?: SortOrder
    activities?: SortOrder
    sleepHours?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    weather?: SortOrderInput | SortOrder
    medication?: SortOrderInput | SortOrder
    socialInteraction?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: MoodEntryCountOrderByAggregateInput
    _avg?: MoodEntryAvgOrderByAggregateInput
    _max?: MoodEntryMaxOrderByAggregateInput
    _min?: MoodEntryMinOrderByAggregateInput
    _sum?: MoodEntrySumOrderByAggregateInput
  }

  export type MoodEntryScalarWhereWithAggregatesInput = {
    AND?: MoodEntryScalarWhereWithAggregatesInput | MoodEntryScalarWhereWithAggregatesInput[]
    OR?: MoodEntryScalarWhereWithAggregatesInput[]
    NOT?: MoodEntryScalarWhereWithAggregatesInput | MoodEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MoodEntry"> | string
    userId?: StringWithAggregatesFilter<"MoodEntry"> | string
    mood?: IntWithAggregatesFilter<"MoodEntry"> | number
    emotions?: JsonWithAggregatesFilter<"MoodEntry">
    triggers?: JsonWithAggregatesFilter<"MoodEntry">
    activities?: JsonWithAggregatesFilter<"MoodEntry">
    sleepHours?: FloatNullableWithAggregatesFilter<"MoodEntry"> | number | null
    notes?: StringNullableWithAggregatesFilter<"MoodEntry"> | string | null
    weather?: StringNullableWithAggregatesFilter<"MoodEntry"> | string | null
    medication?: BoolNullableWithAggregatesFilter<"MoodEntry"> | boolean | null
    socialInteraction?: IntNullableWithAggregatesFilter<"MoodEntry"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"MoodEntry"> | Date | string
  }

  export type SafetyPlanWhereInput = {
    AND?: SafetyPlanWhereInput | SafetyPlanWhereInput[]
    OR?: SafetyPlanWhereInput[]
    NOT?: SafetyPlanWhereInput | SafetyPlanWhereInput[]
    id?: StringFilter<"SafetyPlan"> | string
    userId?: StringFilter<"SafetyPlan"> | string
    title?: StringFilter<"SafetyPlan"> | string
    version?: IntFilter<"SafetyPlan"> | number
    isActive?: BoolFilter<"SafetyPlan"> | boolean
    encryptedContent?: BytesFilter<"SafetyPlan"> | Uint8Array
    contentHash?: StringFilter<"SafetyPlan"> | string
    sharedWith?: JsonNullableFilter<"SafetyPlan">
    emergencyShare?: BoolFilter<"SafetyPlan"> | boolean
    createdAt?: DateTimeFilter<"SafetyPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SafetyPlan"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    versions?: SafetyPlanVersionListRelationFilter
  }

  export type SafetyPlanOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    encryptedContent?: SortOrder
    contentHash?: SortOrder
    sharedWith?: SortOrderInput | SortOrder
    emergencyShare?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    versions?: SafetyPlanVersionOrderByRelationAggregateInput
  }

  export type SafetyPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SafetyPlanWhereInput | SafetyPlanWhereInput[]
    OR?: SafetyPlanWhereInput[]
    NOT?: SafetyPlanWhereInput | SafetyPlanWhereInput[]
    userId?: StringFilter<"SafetyPlan"> | string
    title?: StringFilter<"SafetyPlan"> | string
    version?: IntFilter<"SafetyPlan"> | number
    isActive?: BoolFilter<"SafetyPlan"> | boolean
    encryptedContent?: BytesFilter<"SafetyPlan"> | Uint8Array
    contentHash?: StringFilter<"SafetyPlan"> | string
    sharedWith?: JsonNullableFilter<"SafetyPlan">
    emergencyShare?: BoolFilter<"SafetyPlan"> | boolean
    createdAt?: DateTimeFilter<"SafetyPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SafetyPlan"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    versions?: SafetyPlanVersionListRelationFilter
  }, "id">

  export type SafetyPlanOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    encryptedContent?: SortOrder
    contentHash?: SortOrder
    sharedWith?: SortOrderInput | SortOrder
    emergencyShare?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SafetyPlanCountOrderByAggregateInput
    _avg?: SafetyPlanAvgOrderByAggregateInput
    _max?: SafetyPlanMaxOrderByAggregateInput
    _min?: SafetyPlanMinOrderByAggregateInput
    _sum?: SafetyPlanSumOrderByAggregateInput
  }

  export type SafetyPlanScalarWhereWithAggregatesInput = {
    AND?: SafetyPlanScalarWhereWithAggregatesInput | SafetyPlanScalarWhereWithAggregatesInput[]
    OR?: SafetyPlanScalarWhereWithAggregatesInput[]
    NOT?: SafetyPlanScalarWhereWithAggregatesInput | SafetyPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SafetyPlan"> | string
    userId?: StringWithAggregatesFilter<"SafetyPlan"> | string
    title?: StringWithAggregatesFilter<"SafetyPlan"> | string
    version?: IntWithAggregatesFilter<"SafetyPlan"> | number
    isActive?: BoolWithAggregatesFilter<"SafetyPlan"> | boolean
    encryptedContent?: BytesWithAggregatesFilter<"SafetyPlan"> | Uint8Array
    contentHash?: StringWithAggregatesFilter<"SafetyPlan"> | string
    sharedWith?: JsonNullableWithAggregatesFilter<"SafetyPlan">
    emergencyShare?: BoolWithAggregatesFilter<"SafetyPlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SafetyPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SafetyPlan"> | Date | string
  }

  export type SafetyPlanVersionWhereInput = {
    AND?: SafetyPlanVersionWhereInput | SafetyPlanVersionWhereInput[]
    OR?: SafetyPlanVersionWhereInput[]
    NOT?: SafetyPlanVersionWhereInput | SafetyPlanVersionWhereInput[]
    id?: StringFilter<"SafetyPlanVersion"> | string
    safetyPlanId?: StringFilter<"SafetyPlanVersion"> | string
    version?: IntFilter<"SafetyPlanVersion"> | number
    changeLog?: StringNullableFilter<"SafetyPlanVersion"> | string | null
    encryptedContent?: BytesFilter<"SafetyPlanVersion"> | Uint8Array
    contentHash?: StringFilter<"SafetyPlanVersion"> | string
    createdAt?: DateTimeFilter<"SafetyPlanVersion"> | Date | string
    createdBy?: StringFilter<"SafetyPlanVersion"> | string
    safetyPlan?: XOR<SafetyPlanScalarRelationFilter, SafetyPlanWhereInput>
  }

  export type SafetyPlanVersionOrderByWithRelationInput = {
    id?: SortOrder
    safetyPlanId?: SortOrder
    version?: SortOrder
    changeLog?: SortOrderInput | SortOrder
    encryptedContent?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    safetyPlan?: SafetyPlanOrderByWithRelationInput
  }

  export type SafetyPlanVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    safetyPlanId_version?: SafetyPlanVersionSafetyPlanIdVersionCompoundUniqueInput
    AND?: SafetyPlanVersionWhereInput | SafetyPlanVersionWhereInput[]
    OR?: SafetyPlanVersionWhereInput[]
    NOT?: SafetyPlanVersionWhereInput | SafetyPlanVersionWhereInput[]
    safetyPlanId?: StringFilter<"SafetyPlanVersion"> | string
    version?: IntFilter<"SafetyPlanVersion"> | number
    changeLog?: StringNullableFilter<"SafetyPlanVersion"> | string | null
    encryptedContent?: BytesFilter<"SafetyPlanVersion"> | Uint8Array
    contentHash?: StringFilter<"SafetyPlanVersion"> | string
    createdAt?: DateTimeFilter<"SafetyPlanVersion"> | Date | string
    createdBy?: StringFilter<"SafetyPlanVersion"> | string
    safetyPlan?: XOR<SafetyPlanScalarRelationFilter, SafetyPlanWhereInput>
  }, "id" | "safetyPlanId_version">

  export type SafetyPlanVersionOrderByWithAggregationInput = {
    id?: SortOrder
    safetyPlanId?: SortOrder
    version?: SortOrder
    changeLog?: SortOrderInput | SortOrder
    encryptedContent?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    _count?: SafetyPlanVersionCountOrderByAggregateInput
    _avg?: SafetyPlanVersionAvgOrderByAggregateInput
    _max?: SafetyPlanVersionMaxOrderByAggregateInput
    _min?: SafetyPlanVersionMinOrderByAggregateInput
    _sum?: SafetyPlanVersionSumOrderByAggregateInput
  }

  export type SafetyPlanVersionScalarWhereWithAggregatesInput = {
    AND?: SafetyPlanVersionScalarWhereWithAggregatesInput | SafetyPlanVersionScalarWhereWithAggregatesInput[]
    OR?: SafetyPlanVersionScalarWhereWithAggregatesInput[]
    NOT?: SafetyPlanVersionScalarWhereWithAggregatesInput | SafetyPlanVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SafetyPlanVersion"> | string
    safetyPlanId?: StringWithAggregatesFilter<"SafetyPlanVersion"> | string
    version?: IntWithAggregatesFilter<"SafetyPlanVersion"> | number
    changeLog?: StringNullableWithAggregatesFilter<"SafetyPlanVersion"> | string | null
    encryptedContent?: BytesWithAggregatesFilter<"SafetyPlanVersion"> | Uint8Array
    contentHash?: StringWithAggregatesFilter<"SafetyPlanVersion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SafetyPlanVersion"> | Date | string
    createdBy?: StringWithAggregatesFilter<"SafetyPlanVersion"> | string
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: StringFilter<"UserProfile"> | string
    userId?: StringFilter<"UserProfile"> | string
    displayName?: StringFilter<"UserProfile"> | string
    level?: IntFilter<"UserProfile"> | number
    totalXP?: IntFilter<"UserProfile"> | number
    preferences?: JsonFilter<"UserProfile">
    stats?: JsonFilter<"UserProfile">
    joinDate?: DateTimeFilter<"UserProfile"> | Date | string
    lastActiveDate?: DateTimeFilter<"UserProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    level?: SortOrder
    totalXP?: SortOrder
    preferences?: SortOrder
    stats?: SortOrder
    joinDate?: SortOrder
    lastActiveDate?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    displayName?: StringFilter<"UserProfile"> | string
    level?: IntFilter<"UserProfile"> | number
    totalXP?: IntFilter<"UserProfile"> | number
    preferences?: JsonFilter<"UserProfile">
    stats?: JsonFilter<"UserProfile">
    joinDate?: DateTimeFilter<"UserProfile"> | Date | string
    lastActiveDate?: DateTimeFilter<"UserProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    level?: SortOrder
    totalXP?: SortOrder
    preferences?: SortOrder
    stats?: SortOrder
    joinDate?: SortOrder
    lastActiveDate?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _avg?: UserProfileAvgOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
    _sum?: UserProfileSumOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProfile"> | string
    userId?: StringWithAggregatesFilter<"UserProfile"> | string
    displayName?: StringWithAggregatesFilter<"UserProfile"> | string
    level?: IntWithAggregatesFilter<"UserProfile"> | number
    totalXP?: IntWithAggregatesFilter<"UserProfile"> | number
    preferences?: JsonWithAggregatesFilter<"UserProfile">
    stats?: JsonWithAggregatesFilter<"UserProfile">
    joinDate?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    lastActiveDate?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    category?: EnumAchievementCategoryFilter<"Achievement"> | $Enums.AchievementCategory
    rarity?: EnumAchievementRarityFilter<"Achievement"> | $Enums.AchievementRarity
    requirements?: JsonFilter<"Achievement">
    xpReward?: IntFilter<"Achievement"> | number
    pointReward?: IntFilter<"Achievement"> | number
    icon?: StringNullableFilter<"Achievement"> | string | null
    color?: StringNullableFilter<"Achievement"> | string | null
    isActive?: BoolFilter<"Achievement"> | boolean
    userAchievements?: UserAchievementListRelationFilter
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    rarity?: SortOrder
    requirements?: SortOrder
    xpReward?: SortOrder
    pointReward?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    userAchievements?: UserAchievementOrderByRelationAggregateInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    category?: EnumAchievementCategoryFilter<"Achievement"> | $Enums.AchievementCategory
    rarity?: EnumAchievementRarityFilter<"Achievement"> | $Enums.AchievementRarity
    requirements?: JsonFilter<"Achievement">
    xpReward?: IntFilter<"Achievement"> | number
    pointReward?: IntFilter<"Achievement"> | number
    icon?: StringNullableFilter<"Achievement"> | string | null
    color?: StringNullableFilter<"Achievement"> | string | null
    isActive?: BoolFilter<"Achievement"> | boolean
    userAchievements?: UserAchievementListRelationFilter
  }, "id">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    rarity?: SortOrder
    requirements?: SortOrder
    xpReward?: SortOrder
    pointReward?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    name?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringWithAggregatesFilter<"Achievement"> | string
    category?: EnumAchievementCategoryWithAggregatesFilter<"Achievement"> | $Enums.AchievementCategory
    rarity?: EnumAchievementRarityWithAggregatesFilter<"Achievement"> | $Enums.AchievementRarity
    requirements?: JsonWithAggregatesFilter<"Achievement">
    xpReward?: IntWithAggregatesFilter<"Achievement"> | number
    pointReward?: IntWithAggregatesFilter<"Achievement"> | number
    icon?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    color?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    isActive?: BoolWithAggregatesFilter<"Achievement"> | boolean
  }

  export type UserAchievementWhereInput = {
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    progress?: FloatFilter<"UserAchievement"> | number
    isUnlocked?: BoolFilter<"UserAchievement"> | boolean
    unlockedAt?: DateTimeNullableFilter<"UserAchievement"> | Date | string | null
    createdAt?: DateTimeFilter<"UserAchievement"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
  }

  export type UserAchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    achievement?: AchievementOrderByWithRelationInput
  }

  export type UserAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_achievementId?: UserAchievementUserIdAchievementIdCompoundUniqueInput
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    progress?: FloatFilter<"UserAchievement"> | number
    isUnlocked?: BoolFilter<"UserAchievement"> | boolean
    unlockedAt?: DateTimeNullableFilter<"UserAchievement"> | Date | string | null
    createdAt?: DateTimeFilter<"UserAchievement"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
  }, "id" | "userId_achievementId">

  export type UserAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserAchievementCountOrderByAggregateInput
    _avg?: UserAchievementAvgOrderByAggregateInput
    _max?: UserAchievementMaxOrderByAggregateInput
    _min?: UserAchievementMinOrderByAggregateInput
    _sum?: UserAchievementSumOrderByAggregateInput
  }

  export type UserAchievementScalarWhereWithAggregatesInput = {
    AND?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    OR?: UserAchievementScalarWhereWithAggregatesInput[]
    NOT?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAchievement"> | string
    userId?: StringWithAggregatesFilter<"UserAchievement"> | string
    achievementId?: StringWithAggregatesFilter<"UserAchievement"> | string
    progress?: FloatWithAggregatesFilter<"UserAchievement"> | number
    isUnlocked?: BoolWithAggregatesFilter<"UserAchievement"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"UserAchievement"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserAchievement"> | Date | string
  }

  export type ChallengeWhereInput = {
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    id?: StringFilter<"Challenge"> | string
    name?: StringFilter<"Challenge"> | string
    description?: StringFilter<"Challenge"> | string
    type?: EnumChallengeTypeFilter<"Challenge"> | $Enums.ChallengeType
    difficulty?: EnumChallengeDifficultyFilter<"Challenge"> | $Enums.ChallengeDifficulty
    requirements?: JsonFilter<"Challenge">
    duration?: IntFilter<"Challenge"> | number
    xpReward?: IntFilter<"Challenge"> | number
    pointReward?: IntFilter<"Challenge"> | number
    startDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    isActive?: BoolFilter<"Challenge"> | boolean
    userChallenges?: UserChallengeListRelationFilter
  }

  export type ChallengeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    requirements?: SortOrder
    duration?: SortOrder
    xpReward?: SortOrder
    pointReward?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    userChallenges?: UserChallengeOrderByRelationAggregateInput
  }

  export type ChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    name?: StringFilter<"Challenge"> | string
    description?: StringFilter<"Challenge"> | string
    type?: EnumChallengeTypeFilter<"Challenge"> | $Enums.ChallengeType
    difficulty?: EnumChallengeDifficultyFilter<"Challenge"> | $Enums.ChallengeDifficulty
    requirements?: JsonFilter<"Challenge">
    duration?: IntFilter<"Challenge"> | number
    xpReward?: IntFilter<"Challenge"> | number
    pointReward?: IntFilter<"Challenge"> | number
    startDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    isActive?: BoolFilter<"Challenge"> | boolean
    userChallenges?: UserChallengeListRelationFilter
  }, "id">

  export type ChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    requirements?: SortOrder
    duration?: SortOrder
    xpReward?: SortOrder
    pointReward?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: ChallengeCountOrderByAggregateInput
    _avg?: ChallengeAvgOrderByAggregateInput
    _max?: ChallengeMaxOrderByAggregateInput
    _min?: ChallengeMinOrderByAggregateInput
    _sum?: ChallengeSumOrderByAggregateInput
  }

  export type ChallengeScalarWhereWithAggregatesInput = {
    AND?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    OR?: ChallengeScalarWhereWithAggregatesInput[]
    NOT?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Challenge"> | string
    name?: StringWithAggregatesFilter<"Challenge"> | string
    description?: StringWithAggregatesFilter<"Challenge"> | string
    type?: EnumChallengeTypeWithAggregatesFilter<"Challenge"> | $Enums.ChallengeType
    difficulty?: EnumChallengeDifficultyWithAggregatesFilter<"Challenge"> | $Enums.ChallengeDifficulty
    requirements?: JsonWithAggregatesFilter<"Challenge">
    duration?: IntWithAggregatesFilter<"Challenge"> | number
    xpReward?: IntWithAggregatesFilter<"Challenge"> | number
    pointReward?: IntWithAggregatesFilter<"Challenge"> | number
    startDate?: DateTimeNullableWithAggregatesFilter<"Challenge"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Challenge"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Challenge"> | boolean
  }

  export type UserChallengeWhereInput = {
    AND?: UserChallengeWhereInput | UserChallengeWhereInput[]
    OR?: UserChallengeWhereInput[]
    NOT?: UserChallengeWhereInput | UserChallengeWhereInput[]
    id?: StringFilter<"UserChallenge"> | string
    userId?: StringFilter<"UserChallenge"> | string
    challengeId?: StringFilter<"UserChallenge"> | string
    progress?: FloatFilter<"UserChallenge"> | number
    isCompleted?: BoolFilter<"UserChallenge"> | boolean
    completedAt?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
    startedAt?: DateTimeFilter<"UserChallenge"> | Date | string
    data?: JsonNullableFilter<"UserChallenge">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type UserChallengeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    progress?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    data?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    challenge?: ChallengeOrderByWithRelationInput
  }

  export type UserChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_challengeId?: UserChallengeUserIdChallengeIdCompoundUniqueInput
    AND?: UserChallengeWhereInput | UserChallengeWhereInput[]
    OR?: UserChallengeWhereInput[]
    NOT?: UserChallengeWhereInput | UserChallengeWhereInput[]
    userId?: StringFilter<"UserChallenge"> | string
    challengeId?: StringFilter<"UserChallenge"> | string
    progress?: FloatFilter<"UserChallenge"> | number
    isCompleted?: BoolFilter<"UserChallenge"> | boolean
    completedAt?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
    startedAt?: DateTimeFilter<"UserChallenge"> | Date | string
    data?: JsonNullableFilter<"UserChallenge">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }, "id" | "userId_challengeId">

  export type UserChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    progress?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    data?: SortOrderInput | SortOrder
    _count?: UserChallengeCountOrderByAggregateInput
    _avg?: UserChallengeAvgOrderByAggregateInput
    _max?: UserChallengeMaxOrderByAggregateInput
    _min?: UserChallengeMinOrderByAggregateInput
    _sum?: UserChallengeSumOrderByAggregateInput
  }

  export type UserChallengeScalarWhereWithAggregatesInput = {
    AND?: UserChallengeScalarWhereWithAggregatesInput | UserChallengeScalarWhereWithAggregatesInput[]
    OR?: UserChallengeScalarWhereWithAggregatesInput[]
    NOT?: UserChallengeScalarWhereWithAggregatesInput | UserChallengeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserChallenge"> | string
    userId?: StringWithAggregatesFilter<"UserChallenge"> | string
    challengeId?: StringWithAggregatesFilter<"UserChallenge"> | string
    progress?: FloatWithAggregatesFilter<"UserChallenge"> | number
    isCompleted?: BoolWithAggregatesFilter<"UserChallenge"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserChallenge"> | Date | string | null
    startedAt?: DateTimeWithAggregatesFilter<"UserChallenge"> | Date | string
    data?: JsonNullableWithAggregatesFilter<"UserChallenge">
  }

  export type UserActivityWhereInput = {
    AND?: UserActivityWhereInput | UserActivityWhereInput[]
    OR?: UserActivityWhereInput[]
    NOT?: UserActivityWhereInput | UserActivityWhereInput[]
    id?: StringFilter<"UserActivity"> | string
    userId?: StringFilter<"UserActivity"> | string
    type?: EnumActivityTypeFilter<"UserActivity"> | $Enums.ActivityType
    description?: StringFilter<"UserActivity"> | string
    xpEarned?: IntFilter<"UserActivity"> | number
    pointsEarned?: IntFilter<"UserActivity"> | number
    metadata?: JsonNullableFilter<"UserActivity">
    timestamp?: DateTimeFilter<"UserActivity"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserActivityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    xpEarned?: SortOrder
    pointsEarned?: SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserActivityWhereInput | UserActivityWhereInput[]
    OR?: UserActivityWhereInput[]
    NOT?: UserActivityWhereInput | UserActivityWhereInput[]
    userId?: StringFilter<"UserActivity"> | string
    type?: EnumActivityTypeFilter<"UserActivity"> | $Enums.ActivityType
    description?: StringFilter<"UserActivity"> | string
    xpEarned?: IntFilter<"UserActivity"> | number
    pointsEarned?: IntFilter<"UserActivity"> | number
    metadata?: JsonNullableFilter<"UserActivity">
    timestamp?: DateTimeFilter<"UserActivity"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserActivityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    xpEarned?: SortOrder
    pointsEarned?: SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: UserActivityCountOrderByAggregateInput
    _avg?: UserActivityAvgOrderByAggregateInput
    _max?: UserActivityMaxOrderByAggregateInput
    _min?: UserActivityMinOrderByAggregateInput
    _sum?: UserActivitySumOrderByAggregateInput
  }

  export type UserActivityScalarWhereWithAggregatesInput = {
    AND?: UserActivityScalarWhereWithAggregatesInput | UserActivityScalarWhereWithAggregatesInput[]
    OR?: UserActivityScalarWhereWithAggregatesInput[]
    NOT?: UserActivityScalarWhereWithAggregatesInput | UserActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserActivity"> | string
    userId?: StringWithAggregatesFilter<"UserActivity"> | string
    type?: EnumActivityTypeWithAggregatesFilter<"UserActivity"> | $Enums.ActivityType
    description?: StringWithAggregatesFilter<"UserActivity"> | string
    xpEarned?: IntWithAggregatesFilter<"UserActivity"> | number
    pointsEarned?: IntWithAggregatesFilter<"UserActivity"> | number
    metadata?: JsonNullableWithAggregatesFilter<"UserActivity">
    timestamp?: DateTimeWithAggregatesFilter<"UserActivity"> | Date | string
  }

  export type JournalEntryWhereInput = {
    AND?: JournalEntryWhereInput | JournalEntryWhereInput[]
    OR?: JournalEntryWhereInput[]
    NOT?: JournalEntryWhereInput | JournalEntryWhereInput[]
    id?: StringFilter<"JournalEntry"> | string
    userId?: StringFilter<"JournalEntry"> | string
    title?: StringNullableFilter<"JournalEntry"> | string | null
    promptId?: StringNullableFilter<"JournalEntry"> | string | null
    promptText?: StringNullableFilter<"JournalEntry"> | string | null
    entryType?: EnumJournalTypeFilter<"JournalEntry"> | $Enums.JournalType
    encryptedContent?: BytesFilter<"JournalEntry"> | Uint8Array
    contentHash?: StringFilter<"JournalEntry"> | string
    keyDerivationSalt?: BytesFilter<"JournalEntry"> | Uint8Array
    mood?: IntNullableFilter<"JournalEntry"> | number | null
    sentimentScore?: FloatNullableFilter<"JournalEntry"> | number | null
    emotions?: JsonNullableFilter<"JournalEntry">
    tags?: JsonNullableFilter<"JournalEntry">
    isPrivate?: BoolFilter<"JournalEntry"> | boolean
    shareWithTherapist?: BoolFilter<"JournalEntry"> | boolean
    wordCount?: IntNullableFilter<"JournalEntry"> | number | null
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"JournalEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type JournalEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    promptId?: SortOrderInput | SortOrder
    promptText?: SortOrderInput | SortOrder
    entryType?: SortOrder
    encryptedContent?: SortOrder
    contentHash?: SortOrder
    keyDerivationSalt?: SortOrder
    mood?: SortOrderInput | SortOrder
    sentimentScore?: SortOrderInput | SortOrder
    emotions?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    isPrivate?: SortOrder
    shareWithTherapist?: SortOrder
    wordCount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type JournalEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalEntryWhereInput | JournalEntryWhereInput[]
    OR?: JournalEntryWhereInput[]
    NOT?: JournalEntryWhereInput | JournalEntryWhereInput[]
    userId?: StringFilter<"JournalEntry"> | string
    title?: StringNullableFilter<"JournalEntry"> | string | null
    promptId?: StringNullableFilter<"JournalEntry"> | string | null
    promptText?: StringNullableFilter<"JournalEntry"> | string | null
    entryType?: EnumJournalTypeFilter<"JournalEntry"> | $Enums.JournalType
    encryptedContent?: BytesFilter<"JournalEntry"> | Uint8Array
    contentHash?: StringFilter<"JournalEntry"> | string
    keyDerivationSalt?: BytesFilter<"JournalEntry"> | Uint8Array
    mood?: IntNullableFilter<"JournalEntry"> | number | null
    sentimentScore?: FloatNullableFilter<"JournalEntry"> | number | null
    emotions?: JsonNullableFilter<"JournalEntry">
    tags?: JsonNullableFilter<"JournalEntry">
    isPrivate?: BoolFilter<"JournalEntry"> | boolean
    shareWithTherapist?: BoolFilter<"JournalEntry"> | boolean
    wordCount?: IntNullableFilter<"JournalEntry"> | number | null
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"JournalEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type JournalEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    promptId?: SortOrderInput | SortOrder
    promptText?: SortOrderInput | SortOrder
    entryType?: SortOrder
    encryptedContent?: SortOrder
    contentHash?: SortOrder
    keyDerivationSalt?: SortOrder
    mood?: SortOrderInput | SortOrder
    sentimentScore?: SortOrderInput | SortOrder
    emotions?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    isPrivate?: SortOrder
    shareWithTherapist?: SortOrder
    wordCount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JournalEntryCountOrderByAggregateInput
    _avg?: JournalEntryAvgOrderByAggregateInput
    _max?: JournalEntryMaxOrderByAggregateInput
    _min?: JournalEntryMinOrderByAggregateInput
    _sum?: JournalEntrySumOrderByAggregateInput
  }

  export type JournalEntryScalarWhereWithAggregatesInput = {
    AND?: JournalEntryScalarWhereWithAggregatesInput | JournalEntryScalarWhereWithAggregatesInput[]
    OR?: JournalEntryScalarWhereWithAggregatesInput[]
    NOT?: JournalEntryScalarWhereWithAggregatesInput | JournalEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalEntry"> | string
    userId?: StringWithAggregatesFilter<"JournalEntry"> | string
    title?: StringNullableWithAggregatesFilter<"JournalEntry"> | string | null
    promptId?: StringNullableWithAggregatesFilter<"JournalEntry"> | string | null
    promptText?: StringNullableWithAggregatesFilter<"JournalEntry"> | string | null
    entryType?: EnumJournalTypeWithAggregatesFilter<"JournalEntry"> | $Enums.JournalType
    encryptedContent?: BytesWithAggregatesFilter<"JournalEntry"> | Uint8Array
    contentHash?: StringWithAggregatesFilter<"JournalEntry"> | string
    keyDerivationSalt?: BytesWithAggregatesFilter<"JournalEntry"> | Uint8Array
    mood?: IntNullableWithAggregatesFilter<"JournalEntry"> | number | null
    sentimentScore?: FloatNullableWithAggregatesFilter<"JournalEntry"> | number | null
    emotions?: JsonNullableWithAggregatesFilter<"JournalEntry">
    tags?: JsonNullableWithAggregatesFilter<"JournalEntry">
    isPrivate?: BoolWithAggregatesFilter<"JournalEntry"> | boolean
    shareWithTherapist?: BoolWithAggregatesFilter<"JournalEntry"> | boolean
    wordCount?: IntNullableWithAggregatesFilter<"JournalEntry"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
  }

  export type BreathingExerciseWhereInput = {
    AND?: BreathingExerciseWhereInput | BreathingExerciseWhereInput[]
    OR?: BreathingExerciseWhereInput[]
    NOT?: BreathingExerciseWhereInput | BreathingExerciseWhereInput[]
    id?: StringFilter<"BreathingExercise"> | string
    name?: StringFilter<"BreathingExercise"> | string
    description?: StringFilter<"BreathingExercise"> | string
    technique?: EnumBreathingTechniqueFilter<"BreathingExercise"> | $Enums.BreathingTechnique
    difficulty?: EnumExerciseDifficultyFilter<"BreathingExercise"> | $Enums.ExerciseDifficulty
    inhaleSeconds?: IntFilter<"BreathingExercise"> | number
    holdSeconds?: IntNullableFilter<"BreathingExercise"> | number | null
    exhaleSeconds?: IntFilter<"BreathingExercise"> | number
    pauseSeconds?: IntNullableFilter<"BreathingExercise"> | number | null
    cyclesRecommended?: IntFilter<"BreathingExercise"> | number
    instructions?: JsonFilter<"BreathingExercise">
    visualGuideUrl?: StringNullableFilter<"BreathingExercise"> | string | null
    audioGuideUrl?: StringNullableFilter<"BreathingExercise"> | string | null
    benefits?: JsonFilter<"BreathingExercise">
    bestFor?: JsonFilter<"BreathingExercise">
    contraindications?: JsonNullableFilter<"BreathingExercise">
    isActive?: BoolFilter<"BreathingExercise"> | boolean
    createdAt?: DateTimeFilter<"BreathingExercise"> | Date | string
    sessions?: BreathingSessionListRelationFilter
  }

  export type BreathingExerciseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    technique?: SortOrder
    difficulty?: SortOrder
    inhaleSeconds?: SortOrder
    holdSeconds?: SortOrderInput | SortOrder
    exhaleSeconds?: SortOrder
    pauseSeconds?: SortOrderInput | SortOrder
    cyclesRecommended?: SortOrder
    instructions?: SortOrder
    visualGuideUrl?: SortOrderInput | SortOrder
    audioGuideUrl?: SortOrderInput | SortOrder
    benefits?: SortOrder
    bestFor?: SortOrder
    contraindications?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    sessions?: BreathingSessionOrderByRelationAggregateInput
  }

  export type BreathingExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: BreathingExerciseWhereInput | BreathingExerciseWhereInput[]
    OR?: BreathingExerciseWhereInput[]
    NOT?: BreathingExerciseWhereInput | BreathingExerciseWhereInput[]
    description?: StringFilter<"BreathingExercise"> | string
    technique?: EnumBreathingTechniqueFilter<"BreathingExercise"> | $Enums.BreathingTechnique
    difficulty?: EnumExerciseDifficultyFilter<"BreathingExercise"> | $Enums.ExerciseDifficulty
    inhaleSeconds?: IntFilter<"BreathingExercise"> | number
    holdSeconds?: IntNullableFilter<"BreathingExercise"> | number | null
    exhaleSeconds?: IntFilter<"BreathingExercise"> | number
    pauseSeconds?: IntNullableFilter<"BreathingExercise"> | number | null
    cyclesRecommended?: IntFilter<"BreathingExercise"> | number
    instructions?: JsonFilter<"BreathingExercise">
    visualGuideUrl?: StringNullableFilter<"BreathingExercise"> | string | null
    audioGuideUrl?: StringNullableFilter<"BreathingExercise"> | string | null
    benefits?: JsonFilter<"BreathingExercise">
    bestFor?: JsonFilter<"BreathingExercise">
    contraindications?: JsonNullableFilter<"BreathingExercise">
    isActive?: BoolFilter<"BreathingExercise"> | boolean
    createdAt?: DateTimeFilter<"BreathingExercise"> | Date | string
    sessions?: BreathingSessionListRelationFilter
  }, "id" | "name">

  export type BreathingExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    technique?: SortOrder
    difficulty?: SortOrder
    inhaleSeconds?: SortOrder
    holdSeconds?: SortOrderInput | SortOrder
    exhaleSeconds?: SortOrder
    pauseSeconds?: SortOrderInput | SortOrder
    cyclesRecommended?: SortOrder
    instructions?: SortOrder
    visualGuideUrl?: SortOrderInput | SortOrder
    audioGuideUrl?: SortOrderInput | SortOrder
    benefits?: SortOrder
    bestFor?: SortOrder
    contraindications?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: BreathingExerciseCountOrderByAggregateInput
    _avg?: BreathingExerciseAvgOrderByAggregateInput
    _max?: BreathingExerciseMaxOrderByAggregateInput
    _min?: BreathingExerciseMinOrderByAggregateInput
    _sum?: BreathingExerciseSumOrderByAggregateInput
  }

  export type BreathingExerciseScalarWhereWithAggregatesInput = {
    AND?: BreathingExerciseScalarWhereWithAggregatesInput | BreathingExerciseScalarWhereWithAggregatesInput[]
    OR?: BreathingExerciseScalarWhereWithAggregatesInput[]
    NOT?: BreathingExerciseScalarWhereWithAggregatesInput | BreathingExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BreathingExercise"> | string
    name?: StringWithAggregatesFilter<"BreathingExercise"> | string
    description?: StringWithAggregatesFilter<"BreathingExercise"> | string
    technique?: EnumBreathingTechniqueWithAggregatesFilter<"BreathingExercise"> | $Enums.BreathingTechnique
    difficulty?: EnumExerciseDifficultyWithAggregatesFilter<"BreathingExercise"> | $Enums.ExerciseDifficulty
    inhaleSeconds?: IntWithAggregatesFilter<"BreathingExercise"> | number
    holdSeconds?: IntNullableWithAggregatesFilter<"BreathingExercise"> | number | null
    exhaleSeconds?: IntWithAggregatesFilter<"BreathingExercise"> | number
    pauseSeconds?: IntNullableWithAggregatesFilter<"BreathingExercise"> | number | null
    cyclesRecommended?: IntWithAggregatesFilter<"BreathingExercise"> | number
    instructions?: JsonWithAggregatesFilter<"BreathingExercise">
    visualGuideUrl?: StringNullableWithAggregatesFilter<"BreathingExercise"> | string | null
    audioGuideUrl?: StringNullableWithAggregatesFilter<"BreathingExercise"> | string | null
    benefits?: JsonWithAggregatesFilter<"BreathingExercise">
    bestFor?: JsonWithAggregatesFilter<"BreathingExercise">
    contraindications?: JsonNullableWithAggregatesFilter<"BreathingExercise">
    isActive?: BoolWithAggregatesFilter<"BreathingExercise"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BreathingExercise"> | Date | string
  }

  export type BreathingSessionWhereInput = {
    AND?: BreathingSessionWhereInput | BreathingSessionWhereInput[]
    OR?: BreathingSessionWhereInput[]
    NOT?: BreathingSessionWhereInput | BreathingSessionWhereInput[]
    id?: StringFilter<"BreathingSession"> | string
    userId?: StringFilter<"BreathingSession"> | string
    exerciseId?: StringFilter<"BreathingSession"> | string
    startedAt?: DateTimeFilter<"BreathingSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"BreathingSession"> | Date | string | null
    duration?: IntNullableFilter<"BreathingSession"> | number | null
    cyclesCompleted?: IntFilter<"BreathingSession"> | number
    moodBefore?: IntNullableFilter<"BreathingSession"> | number | null
    moodAfter?: IntNullableFilter<"BreathingSession"> | number | null
    anxietyBefore?: IntNullableFilter<"BreathingSession"> | number | null
    anxietyAfter?: IntNullableFilter<"BreathingSession"> | number | null
    averageBreathRate?: FloatNullableFilter<"BreathingSession"> | number | null
    heartRateBefore?: IntNullableFilter<"BreathingSession"> | number | null
    heartRateAfter?: IntNullableFilter<"BreathingSession"> | number | null
    wasHelpful?: BoolNullableFilter<"BreathingSession"> | boolean | null
    rating?: IntNullableFilter<"BreathingSession"> | number | null
    notes?: StringNullableFilter<"BreathingSession"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    exercise?: XOR<BreathingExerciseScalarRelationFilter, BreathingExerciseWhereInput>
  }

  export type BreathingSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    cyclesCompleted?: SortOrder
    moodBefore?: SortOrderInput | SortOrder
    moodAfter?: SortOrderInput | SortOrder
    anxietyBefore?: SortOrderInput | SortOrder
    anxietyAfter?: SortOrderInput | SortOrder
    averageBreathRate?: SortOrderInput | SortOrder
    heartRateBefore?: SortOrderInput | SortOrder
    heartRateAfter?: SortOrderInput | SortOrder
    wasHelpful?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    exercise?: BreathingExerciseOrderByWithRelationInput
  }

  export type BreathingSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BreathingSessionWhereInput | BreathingSessionWhereInput[]
    OR?: BreathingSessionWhereInput[]
    NOT?: BreathingSessionWhereInput | BreathingSessionWhereInput[]
    userId?: StringFilter<"BreathingSession"> | string
    exerciseId?: StringFilter<"BreathingSession"> | string
    startedAt?: DateTimeFilter<"BreathingSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"BreathingSession"> | Date | string | null
    duration?: IntNullableFilter<"BreathingSession"> | number | null
    cyclesCompleted?: IntFilter<"BreathingSession"> | number
    moodBefore?: IntNullableFilter<"BreathingSession"> | number | null
    moodAfter?: IntNullableFilter<"BreathingSession"> | number | null
    anxietyBefore?: IntNullableFilter<"BreathingSession"> | number | null
    anxietyAfter?: IntNullableFilter<"BreathingSession"> | number | null
    averageBreathRate?: FloatNullableFilter<"BreathingSession"> | number | null
    heartRateBefore?: IntNullableFilter<"BreathingSession"> | number | null
    heartRateAfter?: IntNullableFilter<"BreathingSession"> | number | null
    wasHelpful?: BoolNullableFilter<"BreathingSession"> | boolean | null
    rating?: IntNullableFilter<"BreathingSession"> | number | null
    notes?: StringNullableFilter<"BreathingSession"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    exercise?: XOR<BreathingExerciseScalarRelationFilter, BreathingExerciseWhereInput>
  }, "id">

  export type BreathingSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    cyclesCompleted?: SortOrder
    moodBefore?: SortOrderInput | SortOrder
    moodAfter?: SortOrderInput | SortOrder
    anxietyBefore?: SortOrderInput | SortOrder
    anxietyAfter?: SortOrderInput | SortOrder
    averageBreathRate?: SortOrderInput | SortOrder
    heartRateBefore?: SortOrderInput | SortOrder
    heartRateAfter?: SortOrderInput | SortOrder
    wasHelpful?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: BreathingSessionCountOrderByAggregateInput
    _avg?: BreathingSessionAvgOrderByAggregateInput
    _max?: BreathingSessionMaxOrderByAggregateInput
    _min?: BreathingSessionMinOrderByAggregateInput
    _sum?: BreathingSessionSumOrderByAggregateInput
  }

  export type BreathingSessionScalarWhereWithAggregatesInput = {
    AND?: BreathingSessionScalarWhereWithAggregatesInput | BreathingSessionScalarWhereWithAggregatesInput[]
    OR?: BreathingSessionScalarWhereWithAggregatesInput[]
    NOT?: BreathingSessionScalarWhereWithAggregatesInput | BreathingSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BreathingSession"> | string
    userId?: StringWithAggregatesFilter<"BreathingSession"> | string
    exerciseId?: StringWithAggregatesFilter<"BreathingSession"> | string
    startedAt?: DateTimeWithAggregatesFilter<"BreathingSession"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"BreathingSession"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"BreathingSession"> | number | null
    cyclesCompleted?: IntWithAggregatesFilter<"BreathingSession"> | number
    moodBefore?: IntNullableWithAggregatesFilter<"BreathingSession"> | number | null
    moodAfter?: IntNullableWithAggregatesFilter<"BreathingSession"> | number | null
    anxietyBefore?: IntNullableWithAggregatesFilter<"BreathingSession"> | number | null
    anxietyAfter?: IntNullableWithAggregatesFilter<"BreathingSession"> | number | null
    averageBreathRate?: FloatNullableWithAggregatesFilter<"BreathingSession"> | number | null
    heartRateBefore?: IntNullableWithAggregatesFilter<"BreathingSession"> | number | null
    heartRateAfter?: IntNullableWithAggregatesFilter<"BreathingSession"> | number | null
    wasHelpful?: BoolNullableWithAggregatesFilter<"BreathingSession"> | boolean | null
    rating?: IntNullableWithAggregatesFilter<"BreathingSession"> | number | null
    notes?: StringNullableWithAggregatesFilter<"BreathingSession"> | string | null
  }

  export type GroundingTechniqueWhereInput = {
    AND?: GroundingTechniqueWhereInput | GroundingTechniqueWhereInput[]
    OR?: GroundingTechniqueWhereInput[]
    NOT?: GroundingTechniqueWhereInput | GroundingTechniqueWhereInput[]
    id?: StringFilter<"GroundingTechnique"> | string
    name?: StringFilter<"GroundingTechnique"> | string
    description?: StringFilter<"GroundingTechnique"> | string
    type?: EnumGroundingTypeFilter<"GroundingTechnique"> | $Enums.GroundingType
    category?: EnumGroundingCategoryFilter<"GroundingTechnique"> | $Enums.GroundingCategory
    instructions?: JsonFilter<"GroundingTechnique">
    duration?: IntFilter<"GroundingTechnique"> | number
    materials?: JsonNullableFilter<"GroundingTechnique">
    audioGuideUrl?: StringNullableFilter<"GroundingTechnique"> | string | null
    videoGuideUrl?: StringNullableFilter<"GroundingTechnique"> | string | null
    imageGuides?: JsonNullableFilter<"GroundingTechnique">
    evidenceLevel?: EnumEvidenceLevelFilter<"GroundingTechnique"> | $Enums.EvidenceLevel
    bestFor?: JsonFilter<"GroundingTechnique">
    contraindications?: JsonNullableFilter<"GroundingTechnique">
    isActive?: BoolFilter<"GroundingTechnique"> | boolean
    createdAt?: DateTimeFilter<"GroundingTechnique"> | Date | string
    sessions?: GroundingSessionListRelationFilter
  }

  export type GroundingTechniqueOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    instructions?: SortOrder
    duration?: SortOrder
    materials?: SortOrderInput | SortOrder
    audioGuideUrl?: SortOrderInput | SortOrder
    videoGuideUrl?: SortOrderInput | SortOrder
    imageGuides?: SortOrderInput | SortOrder
    evidenceLevel?: SortOrder
    bestFor?: SortOrder
    contraindications?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    sessions?: GroundingSessionOrderByRelationAggregateInput
  }

  export type GroundingTechniqueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: GroundingTechniqueWhereInput | GroundingTechniqueWhereInput[]
    OR?: GroundingTechniqueWhereInput[]
    NOT?: GroundingTechniqueWhereInput | GroundingTechniqueWhereInput[]
    description?: StringFilter<"GroundingTechnique"> | string
    type?: EnumGroundingTypeFilter<"GroundingTechnique"> | $Enums.GroundingType
    category?: EnumGroundingCategoryFilter<"GroundingTechnique"> | $Enums.GroundingCategory
    instructions?: JsonFilter<"GroundingTechnique">
    duration?: IntFilter<"GroundingTechnique"> | number
    materials?: JsonNullableFilter<"GroundingTechnique">
    audioGuideUrl?: StringNullableFilter<"GroundingTechnique"> | string | null
    videoGuideUrl?: StringNullableFilter<"GroundingTechnique"> | string | null
    imageGuides?: JsonNullableFilter<"GroundingTechnique">
    evidenceLevel?: EnumEvidenceLevelFilter<"GroundingTechnique"> | $Enums.EvidenceLevel
    bestFor?: JsonFilter<"GroundingTechnique">
    contraindications?: JsonNullableFilter<"GroundingTechnique">
    isActive?: BoolFilter<"GroundingTechnique"> | boolean
    createdAt?: DateTimeFilter<"GroundingTechnique"> | Date | string
    sessions?: GroundingSessionListRelationFilter
  }, "id" | "name">

  export type GroundingTechniqueOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    instructions?: SortOrder
    duration?: SortOrder
    materials?: SortOrderInput | SortOrder
    audioGuideUrl?: SortOrderInput | SortOrder
    videoGuideUrl?: SortOrderInput | SortOrder
    imageGuides?: SortOrderInput | SortOrder
    evidenceLevel?: SortOrder
    bestFor?: SortOrder
    contraindications?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: GroundingTechniqueCountOrderByAggregateInput
    _avg?: GroundingTechniqueAvgOrderByAggregateInput
    _max?: GroundingTechniqueMaxOrderByAggregateInput
    _min?: GroundingTechniqueMinOrderByAggregateInput
    _sum?: GroundingTechniqueSumOrderByAggregateInput
  }

  export type GroundingTechniqueScalarWhereWithAggregatesInput = {
    AND?: GroundingTechniqueScalarWhereWithAggregatesInput | GroundingTechniqueScalarWhereWithAggregatesInput[]
    OR?: GroundingTechniqueScalarWhereWithAggregatesInput[]
    NOT?: GroundingTechniqueScalarWhereWithAggregatesInput | GroundingTechniqueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroundingTechnique"> | string
    name?: StringWithAggregatesFilter<"GroundingTechnique"> | string
    description?: StringWithAggregatesFilter<"GroundingTechnique"> | string
    type?: EnumGroundingTypeWithAggregatesFilter<"GroundingTechnique"> | $Enums.GroundingType
    category?: EnumGroundingCategoryWithAggregatesFilter<"GroundingTechnique"> | $Enums.GroundingCategory
    instructions?: JsonWithAggregatesFilter<"GroundingTechnique">
    duration?: IntWithAggregatesFilter<"GroundingTechnique"> | number
    materials?: JsonNullableWithAggregatesFilter<"GroundingTechnique">
    audioGuideUrl?: StringNullableWithAggregatesFilter<"GroundingTechnique"> | string | null
    videoGuideUrl?: StringNullableWithAggregatesFilter<"GroundingTechnique"> | string | null
    imageGuides?: JsonNullableWithAggregatesFilter<"GroundingTechnique">
    evidenceLevel?: EnumEvidenceLevelWithAggregatesFilter<"GroundingTechnique"> | $Enums.EvidenceLevel
    bestFor?: JsonWithAggregatesFilter<"GroundingTechnique">
    contraindications?: JsonNullableWithAggregatesFilter<"GroundingTechnique">
    isActive?: BoolWithAggregatesFilter<"GroundingTechnique"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GroundingTechnique"> | Date | string
  }

  export type GroundingSessionWhereInput = {
    AND?: GroundingSessionWhereInput | GroundingSessionWhereInput[]
    OR?: GroundingSessionWhereInput[]
    NOT?: GroundingSessionWhereInput | GroundingSessionWhereInput[]
    id?: StringFilter<"GroundingSession"> | string
    userId?: StringFilter<"GroundingSession"> | string
    techniqueId?: StringFilter<"GroundingSession"> | string
    startedAt?: DateTimeFilter<"GroundingSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"GroundingSession"> | Date | string | null
    duration?: IntNullableFilter<"GroundingSession"> | number | null
    triggerType?: StringNullableFilter<"GroundingSession"> | string | null
    severityBefore?: IntNullableFilter<"GroundingSession"> | number | null
    severityAfter?: IntNullableFilter<"GroundingSession"> | number | null
    panicBefore?: IntNullableFilter<"GroundingSession"> | number | null
    panicAfter?: IntNullableFilter<"GroundingSession"> | number | null
    dissociationBefore?: IntNullableFilter<"GroundingSession"> | number | null
    dissociationAfter?: IntNullableFilter<"GroundingSession"> | number | null
    stepsCompleted?: JsonNullableFilter<"GroundingSession">
    completionRate?: FloatNullableFilter<"GroundingSession"> | number | null
    wasHelpful?: BoolNullableFilter<"GroundingSession"> | boolean | null
    rating?: IntNullableFilter<"GroundingSession"> | number | null
    notes?: StringNullableFilter<"GroundingSession"> | string | null
    wouldUseAgain?: BoolNullableFilter<"GroundingSession"> | boolean | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    technique?: XOR<GroundingTechniqueScalarRelationFilter, GroundingTechniqueWhereInput>
  }

  export type GroundingSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    techniqueId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    triggerType?: SortOrderInput | SortOrder
    severityBefore?: SortOrderInput | SortOrder
    severityAfter?: SortOrderInput | SortOrder
    panicBefore?: SortOrderInput | SortOrder
    panicAfter?: SortOrderInput | SortOrder
    dissociationBefore?: SortOrderInput | SortOrder
    dissociationAfter?: SortOrderInput | SortOrder
    stepsCompleted?: SortOrderInput | SortOrder
    completionRate?: SortOrderInput | SortOrder
    wasHelpful?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    wouldUseAgain?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    technique?: GroundingTechniqueOrderByWithRelationInput
  }

  export type GroundingSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroundingSessionWhereInput | GroundingSessionWhereInput[]
    OR?: GroundingSessionWhereInput[]
    NOT?: GroundingSessionWhereInput | GroundingSessionWhereInput[]
    userId?: StringFilter<"GroundingSession"> | string
    techniqueId?: StringFilter<"GroundingSession"> | string
    startedAt?: DateTimeFilter<"GroundingSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"GroundingSession"> | Date | string | null
    duration?: IntNullableFilter<"GroundingSession"> | number | null
    triggerType?: StringNullableFilter<"GroundingSession"> | string | null
    severityBefore?: IntNullableFilter<"GroundingSession"> | number | null
    severityAfter?: IntNullableFilter<"GroundingSession"> | number | null
    panicBefore?: IntNullableFilter<"GroundingSession"> | number | null
    panicAfter?: IntNullableFilter<"GroundingSession"> | number | null
    dissociationBefore?: IntNullableFilter<"GroundingSession"> | number | null
    dissociationAfter?: IntNullableFilter<"GroundingSession"> | number | null
    stepsCompleted?: JsonNullableFilter<"GroundingSession">
    completionRate?: FloatNullableFilter<"GroundingSession"> | number | null
    wasHelpful?: BoolNullableFilter<"GroundingSession"> | boolean | null
    rating?: IntNullableFilter<"GroundingSession"> | number | null
    notes?: StringNullableFilter<"GroundingSession"> | string | null
    wouldUseAgain?: BoolNullableFilter<"GroundingSession"> | boolean | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    technique?: XOR<GroundingTechniqueScalarRelationFilter, GroundingTechniqueWhereInput>
  }, "id">

  export type GroundingSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    techniqueId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    triggerType?: SortOrderInput | SortOrder
    severityBefore?: SortOrderInput | SortOrder
    severityAfter?: SortOrderInput | SortOrder
    panicBefore?: SortOrderInput | SortOrder
    panicAfter?: SortOrderInput | SortOrder
    dissociationBefore?: SortOrderInput | SortOrder
    dissociationAfter?: SortOrderInput | SortOrder
    stepsCompleted?: SortOrderInput | SortOrder
    completionRate?: SortOrderInput | SortOrder
    wasHelpful?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    wouldUseAgain?: SortOrderInput | SortOrder
    _count?: GroundingSessionCountOrderByAggregateInput
    _avg?: GroundingSessionAvgOrderByAggregateInput
    _max?: GroundingSessionMaxOrderByAggregateInput
    _min?: GroundingSessionMinOrderByAggregateInput
    _sum?: GroundingSessionSumOrderByAggregateInput
  }

  export type GroundingSessionScalarWhereWithAggregatesInput = {
    AND?: GroundingSessionScalarWhereWithAggregatesInput | GroundingSessionScalarWhereWithAggregatesInput[]
    OR?: GroundingSessionScalarWhereWithAggregatesInput[]
    NOT?: GroundingSessionScalarWhereWithAggregatesInput | GroundingSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroundingSession"> | string
    userId?: StringWithAggregatesFilter<"GroundingSession"> | string
    techniqueId?: StringWithAggregatesFilter<"GroundingSession"> | string
    startedAt?: DateTimeWithAggregatesFilter<"GroundingSession"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"GroundingSession"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"GroundingSession"> | number | null
    triggerType?: StringNullableWithAggregatesFilter<"GroundingSession"> | string | null
    severityBefore?: IntNullableWithAggregatesFilter<"GroundingSession"> | number | null
    severityAfter?: IntNullableWithAggregatesFilter<"GroundingSession"> | number | null
    panicBefore?: IntNullableWithAggregatesFilter<"GroundingSession"> | number | null
    panicAfter?: IntNullableWithAggregatesFilter<"GroundingSession"> | number | null
    dissociationBefore?: IntNullableWithAggregatesFilter<"GroundingSession"> | number | null
    dissociationAfter?: IntNullableWithAggregatesFilter<"GroundingSession"> | number | null
    stepsCompleted?: JsonNullableWithAggregatesFilter<"GroundingSession">
    completionRate?: FloatNullableWithAggregatesFilter<"GroundingSession"> | number | null
    wasHelpful?: BoolNullableWithAggregatesFilter<"GroundingSession"> | boolean | null
    rating?: IntNullableWithAggregatesFilter<"GroundingSession"> | number | null
    notes?: StringNullableWithAggregatesFilter<"GroundingSession"> | string | null
    wouldUseAgain?: BoolNullableWithAggregatesFilter<"GroundingSession"> | boolean | null
  }

  export type SelfHelpResourceWhereInput = {
    AND?: SelfHelpResourceWhereInput | SelfHelpResourceWhereInput[]
    OR?: SelfHelpResourceWhereInput[]
    NOT?: SelfHelpResourceWhereInput | SelfHelpResourceWhereInput[]
    id?: StringFilter<"SelfHelpResource"> | string
    title?: StringFilter<"SelfHelpResource"> | string
    description?: StringFilter<"SelfHelpResource"> | string
    category?: EnumSelfHelpCategoryFilter<"SelfHelpResource"> | $Enums.SelfHelpCategory
    type?: EnumResourceTypeFilter<"SelfHelpResource"> | $Enums.ResourceType
    content?: StringNullableFilter<"SelfHelpResource"> | string | null
    url?: StringNullableFilter<"SelfHelpResource"> | string | null
    mediaUrl?: StringNullableFilter<"SelfHelpResource"> | string | null
    thumbnailUrl?: StringNullableFilter<"SelfHelpResource"> | string | null
    duration?: IntNullableFilter<"SelfHelpResource"> | number | null
    difficulty?: EnumExerciseDifficultyFilter<"SelfHelpResource"> | $Enums.ExerciseDifficulty
    evidenceLevel?: EnumEvidenceLevelFilter<"SelfHelpResource"> | $Enums.EvidenceLevel
    tags?: JsonFilter<"SelfHelpResource">
    conditions?: JsonNullableFilter<"SelfHelpResource">
    symptoms?: JsonNullableFilter<"SelfHelpResource">
    viewCount?: IntFilter<"SelfHelpResource"> | number
    helpfulCount?: IntFilter<"SelfHelpResource"> | number
    averageRating?: FloatNullableFilter<"SelfHelpResource"> | number | null
    isActive?: BoolFilter<"SelfHelpResource"> | boolean
    createdAt?: DateTimeFilter<"SelfHelpResource"> | Date | string
    updatedAt?: DateTimeFilter<"SelfHelpResource"> | Date | string
    interactions?: SelfHelpInteractionListRelationFilter
  }

  export type SelfHelpResourceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    content?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    evidenceLevel?: SortOrder
    tags?: SortOrder
    conditions?: SortOrderInput | SortOrder
    symptoms?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    helpfulCount?: SortOrder
    averageRating?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    interactions?: SelfHelpInteractionOrderByRelationAggregateInput
  }

  export type SelfHelpResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SelfHelpResourceWhereInput | SelfHelpResourceWhereInput[]
    OR?: SelfHelpResourceWhereInput[]
    NOT?: SelfHelpResourceWhereInput | SelfHelpResourceWhereInput[]
    title?: StringFilter<"SelfHelpResource"> | string
    description?: StringFilter<"SelfHelpResource"> | string
    category?: EnumSelfHelpCategoryFilter<"SelfHelpResource"> | $Enums.SelfHelpCategory
    type?: EnumResourceTypeFilter<"SelfHelpResource"> | $Enums.ResourceType
    content?: StringNullableFilter<"SelfHelpResource"> | string | null
    url?: StringNullableFilter<"SelfHelpResource"> | string | null
    mediaUrl?: StringNullableFilter<"SelfHelpResource"> | string | null
    thumbnailUrl?: StringNullableFilter<"SelfHelpResource"> | string | null
    duration?: IntNullableFilter<"SelfHelpResource"> | number | null
    difficulty?: EnumExerciseDifficultyFilter<"SelfHelpResource"> | $Enums.ExerciseDifficulty
    evidenceLevel?: EnumEvidenceLevelFilter<"SelfHelpResource"> | $Enums.EvidenceLevel
    tags?: JsonFilter<"SelfHelpResource">
    conditions?: JsonNullableFilter<"SelfHelpResource">
    symptoms?: JsonNullableFilter<"SelfHelpResource">
    viewCount?: IntFilter<"SelfHelpResource"> | number
    helpfulCount?: IntFilter<"SelfHelpResource"> | number
    averageRating?: FloatNullableFilter<"SelfHelpResource"> | number | null
    isActive?: BoolFilter<"SelfHelpResource"> | boolean
    createdAt?: DateTimeFilter<"SelfHelpResource"> | Date | string
    updatedAt?: DateTimeFilter<"SelfHelpResource"> | Date | string
    interactions?: SelfHelpInteractionListRelationFilter
  }, "id">

  export type SelfHelpResourceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    content?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    evidenceLevel?: SortOrder
    tags?: SortOrder
    conditions?: SortOrderInput | SortOrder
    symptoms?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    helpfulCount?: SortOrder
    averageRating?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SelfHelpResourceCountOrderByAggregateInput
    _avg?: SelfHelpResourceAvgOrderByAggregateInput
    _max?: SelfHelpResourceMaxOrderByAggregateInput
    _min?: SelfHelpResourceMinOrderByAggregateInput
    _sum?: SelfHelpResourceSumOrderByAggregateInput
  }

  export type SelfHelpResourceScalarWhereWithAggregatesInput = {
    AND?: SelfHelpResourceScalarWhereWithAggregatesInput | SelfHelpResourceScalarWhereWithAggregatesInput[]
    OR?: SelfHelpResourceScalarWhereWithAggregatesInput[]
    NOT?: SelfHelpResourceScalarWhereWithAggregatesInput | SelfHelpResourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SelfHelpResource"> | string
    title?: StringWithAggregatesFilter<"SelfHelpResource"> | string
    description?: StringWithAggregatesFilter<"SelfHelpResource"> | string
    category?: EnumSelfHelpCategoryWithAggregatesFilter<"SelfHelpResource"> | $Enums.SelfHelpCategory
    type?: EnumResourceTypeWithAggregatesFilter<"SelfHelpResource"> | $Enums.ResourceType
    content?: StringNullableWithAggregatesFilter<"SelfHelpResource"> | string | null
    url?: StringNullableWithAggregatesFilter<"SelfHelpResource"> | string | null
    mediaUrl?: StringNullableWithAggregatesFilter<"SelfHelpResource"> | string | null
    thumbnailUrl?: StringNullableWithAggregatesFilter<"SelfHelpResource"> | string | null
    duration?: IntNullableWithAggregatesFilter<"SelfHelpResource"> | number | null
    difficulty?: EnumExerciseDifficultyWithAggregatesFilter<"SelfHelpResource"> | $Enums.ExerciseDifficulty
    evidenceLevel?: EnumEvidenceLevelWithAggregatesFilter<"SelfHelpResource"> | $Enums.EvidenceLevel
    tags?: JsonWithAggregatesFilter<"SelfHelpResource">
    conditions?: JsonNullableWithAggregatesFilter<"SelfHelpResource">
    symptoms?: JsonNullableWithAggregatesFilter<"SelfHelpResource">
    viewCount?: IntWithAggregatesFilter<"SelfHelpResource"> | number
    helpfulCount?: IntWithAggregatesFilter<"SelfHelpResource"> | number
    averageRating?: FloatNullableWithAggregatesFilter<"SelfHelpResource"> | number | null
    isActive?: BoolWithAggregatesFilter<"SelfHelpResource"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SelfHelpResource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SelfHelpResource"> | Date | string
  }

  export type SelfHelpInteractionWhereInput = {
    AND?: SelfHelpInteractionWhereInput | SelfHelpInteractionWhereInput[]
    OR?: SelfHelpInteractionWhereInput[]
    NOT?: SelfHelpInteractionWhereInput | SelfHelpInteractionWhereInput[]
    id?: StringFilter<"SelfHelpInteraction"> | string
    userId?: StringFilter<"SelfHelpInteraction"> | string
    resourceId?: StringFilter<"SelfHelpInteraction"> | string
    interactionType?: EnumInteractionTypeFilter<"SelfHelpInteraction"> | $Enums.InteractionType
    startedAt?: DateTimeFilter<"SelfHelpInteraction"> | Date | string
    completedAt?: DateTimeNullableFilter<"SelfHelpInteraction"> | Date | string | null
    duration?: IntNullableFilter<"SelfHelpInteraction"> | number | null
    wasHelpful?: BoolNullableFilter<"SelfHelpInteraction"> | boolean | null
    rating?: IntNullableFilter<"SelfHelpInteraction"> | number | null
    notes?: StringNullableFilter<"SelfHelpInteraction"> | string | null
    moodBefore?: IntNullableFilter<"SelfHelpInteraction"> | number | null
    moodAfter?: IntNullableFilter<"SelfHelpInteraction"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resource?: XOR<SelfHelpResourceScalarRelationFilter, SelfHelpResourceWhereInput>
  }

  export type SelfHelpInteractionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    resourceId?: SortOrder
    interactionType?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    wasHelpful?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    moodBefore?: SortOrderInput | SortOrder
    moodAfter?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    resource?: SelfHelpResourceOrderByWithRelationInput
  }

  export type SelfHelpInteractionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SelfHelpInteractionWhereInput | SelfHelpInteractionWhereInput[]
    OR?: SelfHelpInteractionWhereInput[]
    NOT?: SelfHelpInteractionWhereInput | SelfHelpInteractionWhereInput[]
    userId?: StringFilter<"SelfHelpInteraction"> | string
    resourceId?: StringFilter<"SelfHelpInteraction"> | string
    interactionType?: EnumInteractionTypeFilter<"SelfHelpInteraction"> | $Enums.InteractionType
    startedAt?: DateTimeFilter<"SelfHelpInteraction"> | Date | string
    completedAt?: DateTimeNullableFilter<"SelfHelpInteraction"> | Date | string | null
    duration?: IntNullableFilter<"SelfHelpInteraction"> | number | null
    wasHelpful?: BoolNullableFilter<"SelfHelpInteraction"> | boolean | null
    rating?: IntNullableFilter<"SelfHelpInteraction"> | number | null
    notes?: StringNullableFilter<"SelfHelpInteraction"> | string | null
    moodBefore?: IntNullableFilter<"SelfHelpInteraction"> | number | null
    moodAfter?: IntNullableFilter<"SelfHelpInteraction"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resource?: XOR<SelfHelpResourceScalarRelationFilter, SelfHelpResourceWhereInput>
  }, "id">

  export type SelfHelpInteractionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    resourceId?: SortOrder
    interactionType?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    wasHelpful?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    moodBefore?: SortOrderInput | SortOrder
    moodAfter?: SortOrderInput | SortOrder
    _count?: SelfHelpInteractionCountOrderByAggregateInput
    _avg?: SelfHelpInteractionAvgOrderByAggregateInput
    _max?: SelfHelpInteractionMaxOrderByAggregateInput
    _min?: SelfHelpInteractionMinOrderByAggregateInput
    _sum?: SelfHelpInteractionSumOrderByAggregateInput
  }

  export type SelfHelpInteractionScalarWhereWithAggregatesInput = {
    AND?: SelfHelpInteractionScalarWhereWithAggregatesInput | SelfHelpInteractionScalarWhereWithAggregatesInput[]
    OR?: SelfHelpInteractionScalarWhereWithAggregatesInput[]
    NOT?: SelfHelpInteractionScalarWhereWithAggregatesInput | SelfHelpInteractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SelfHelpInteraction"> | string
    userId?: StringWithAggregatesFilter<"SelfHelpInteraction"> | string
    resourceId?: StringWithAggregatesFilter<"SelfHelpInteraction"> | string
    interactionType?: EnumInteractionTypeWithAggregatesFilter<"SelfHelpInteraction"> | $Enums.InteractionType
    startedAt?: DateTimeWithAggregatesFilter<"SelfHelpInteraction"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"SelfHelpInteraction"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"SelfHelpInteraction"> | number | null
    wasHelpful?: BoolNullableWithAggregatesFilter<"SelfHelpInteraction"> | boolean | null
    rating?: IntNullableWithAggregatesFilter<"SelfHelpInteraction"> | number | null
    notes?: StringNullableWithAggregatesFilter<"SelfHelpInteraction"> | string | null
    moodBefore?: IntNullableWithAggregatesFilter<"SelfHelpInteraction"> | number | null
    moodAfter?: IntNullableWithAggregatesFilter<"SelfHelpInteraction"> | number | null
  }

  export type AITherapistWhereInput = {
    AND?: AITherapistWhereInput | AITherapistWhereInput[]
    OR?: AITherapistWhereInput[]
    NOT?: AITherapistWhereInput | AITherapistWhereInput[]
    id?: StringFilter<"AITherapist"> | string
    therapistId?: StringFilter<"AITherapist"> | string
    name?: StringFilter<"AITherapist"> | string
    avatar?: StringFilter<"AITherapist"> | string
    personality?: StringFilter<"AITherapist"> | string
    description?: StringFilter<"AITherapist"> | string
    specialties?: StringFilter<"AITherapist"> | string
    approaches?: StringFilter<"AITherapist"> | string
    bestFor?: StringFilter<"AITherapist"> | string
    features?: StringFilter<"AITherapist"> | string
    availability?: StringFilter<"AITherapist"> | string
    sessionsCompleted?: IntFilter<"AITherapist"> | number
    userRating?: FloatFilter<"AITherapist"> | number
    responseTime?: FloatFilter<"AITherapist"> | number
    createdAt?: DateTimeFilter<"AITherapist"> | Date | string
    updatedAt?: DateTimeFilter<"AITherapist"> | Date | string
    sessions?: AITherapySessionListRelationFilter
    personalizations?: AIPersonalizationListRelationFilter
  }

  export type AITherapistOrderByWithRelationInput = {
    id?: SortOrder
    therapistId?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    personality?: SortOrder
    description?: SortOrder
    specialties?: SortOrder
    approaches?: SortOrder
    bestFor?: SortOrder
    features?: SortOrder
    availability?: SortOrder
    sessionsCompleted?: SortOrder
    userRating?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: AITherapySessionOrderByRelationAggregateInput
    personalizations?: AIPersonalizationOrderByRelationAggregateInput
  }

  export type AITherapistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    therapistId?: string
    AND?: AITherapistWhereInput | AITherapistWhereInput[]
    OR?: AITherapistWhereInput[]
    NOT?: AITherapistWhereInput | AITherapistWhereInput[]
    name?: StringFilter<"AITherapist"> | string
    avatar?: StringFilter<"AITherapist"> | string
    personality?: StringFilter<"AITherapist"> | string
    description?: StringFilter<"AITherapist"> | string
    specialties?: StringFilter<"AITherapist"> | string
    approaches?: StringFilter<"AITherapist"> | string
    bestFor?: StringFilter<"AITherapist"> | string
    features?: StringFilter<"AITherapist"> | string
    availability?: StringFilter<"AITherapist"> | string
    sessionsCompleted?: IntFilter<"AITherapist"> | number
    userRating?: FloatFilter<"AITherapist"> | number
    responseTime?: FloatFilter<"AITherapist"> | number
    createdAt?: DateTimeFilter<"AITherapist"> | Date | string
    updatedAt?: DateTimeFilter<"AITherapist"> | Date | string
    sessions?: AITherapySessionListRelationFilter
    personalizations?: AIPersonalizationListRelationFilter
  }, "id" | "therapistId">

  export type AITherapistOrderByWithAggregationInput = {
    id?: SortOrder
    therapistId?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    personality?: SortOrder
    description?: SortOrder
    specialties?: SortOrder
    approaches?: SortOrder
    bestFor?: SortOrder
    features?: SortOrder
    availability?: SortOrder
    sessionsCompleted?: SortOrder
    userRating?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AITherapistCountOrderByAggregateInput
    _avg?: AITherapistAvgOrderByAggregateInput
    _max?: AITherapistMaxOrderByAggregateInput
    _min?: AITherapistMinOrderByAggregateInput
    _sum?: AITherapistSumOrderByAggregateInput
  }

  export type AITherapistScalarWhereWithAggregatesInput = {
    AND?: AITherapistScalarWhereWithAggregatesInput | AITherapistScalarWhereWithAggregatesInput[]
    OR?: AITherapistScalarWhereWithAggregatesInput[]
    NOT?: AITherapistScalarWhereWithAggregatesInput | AITherapistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AITherapist"> | string
    therapistId?: StringWithAggregatesFilter<"AITherapist"> | string
    name?: StringWithAggregatesFilter<"AITherapist"> | string
    avatar?: StringWithAggregatesFilter<"AITherapist"> | string
    personality?: StringWithAggregatesFilter<"AITherapist"> | string
    description?: StringWithAggregatesFilter<"AITherapist"> | string
    specialties?: StringWithAggregatesFilter<"AITherapist"> | string
    approaches?: StringWithAggregatesFilter<"AITherapist"> | string
    bestFor?: StringWithAggregatesFilter<"AITherapist"> | string
    features?: StringWithAggregatesFilter<"AITherapist"> | string
    availability?: StringWithAggregatesFilter<"AITherapist"> | string
    sessionsCompleted?: IntWithAggregatesFilter<"AITherapist"> | number
    userRating?: FloatWithAggregatesFilter<"AITherapist"> | number
    responseTime?: FloatWithAggregatesFilter<"AITherapist"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AITherapist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AITherapist"> | Date | string
  }

  export type AITherapySessionWhereInput = {
    AND?: AITherapySessionWhereInput | AITherapySessionWhereInput[]
    OR?: AITherapySessionWhereInput[]
    NOT?: AITherapySessionWhereInput | AITherapySessionWhereInput[]
    id?: StringFilter<"AITherapySession"> | string
    sessionToken?: StringFilter<"AITherapySession"> | string
    userId?: StringFilter<"AITherapySession"> | string
    therapistId?: StringFilter<"AITherapySession"> | string
    sessionType?: EnumAISessionTypeFilter<"AITherapySession"> | $Enums.AISessionType
    status?: EnumAISessionStatusFilter<"AITherapySession"> | $Enums.AISessionStatus
    startedAt?: DateTimeFilter<"AITherapySession"> | Date | string
    endedAt?: DateTimeNullableFilter<"AITherapySession"> | Date | string | null
    duration?: IntNullableFilter<"AITherapySession"> | number | null
    pausedAt?: DateTimeNullableFilter<"AITherapySession"> | Date | string | null
    pausedDuration?: IntFilter<"AITherapySession"> | number
    moodBefore?: IntNullableFilter<"AITherapySession"> | number | null
    moodAfter?: IntNullableFilter<"AITherapySession"> | number | null
    anxietyBefore?: IntNullableFilter<"AITherapySession"> | number | null
    anxietyAfter?: IntNullableFilter<"AITherapySession"> | number | null
    energyBefore?: IntNullableFilter<"AITherapySession"> | number | null
    energyAfter?: IntNullableFilter<"AITherapySession"> | number | null
    encryptedNotes?: BytesNullableFilter<"AITherapySession"> | Uint8Array | null
    encryptedInsights?: BytesNullableFilter<"AITherapySession"> | Uint8Array | null
    encryptedHomework?: BytesNullableFilter<"AITherapySession"> | Uint8Array | null
    encryptedGoals?: BytesNullableFilter<"AITherapySession"> | Uint8Array | null
    topics?: StringNullableFilter<"AITherapySession"> | string | null
    techniques?: StringNullableFilter<"AITherapySession"> | string | null
    interventions?: StringNullableFilter<"AITherapySession"> | string | null
    breakthroughs?: StringNullableFilter<"AITherapySession"> | string | null
    crisisDetected?: BoolFilter<"AITherapySession"> | boolean
    crisisLevel?: IntNullableFilter<"AITherapySession"> | number | null
    crisisInterventions?: StringNullableFilter<"AITherapySession"> | string | null
    therapist?: XOR<AITherapistScalarRelationFilter, AITherapistWhereInput>
    messages?: AITherapyMessageListRelationFilter
    exercises?: AIExerciseSessionListRelationFilter
  }

  export type AITherapySessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    therapistId?: SortOrder
    sessionType?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    pausedAt?: SortOrderInput | SortOrder
    pausedDuration?: SortOrder
    moodBefore?: SortOrderInput | SortOrder
    moodAfter?: SortOrderInput | SortOrder
    anxietyBefore?: SortOrderInput | SortOrder
    anxietyAfter?: SortOrderInput | SortOrder
    energyBefore?: SortOrderInput | SortOrder
    energyAfter?: SortOrderInput | SortOrder
    encryptedNotes?: SortOrderInput | SortOrder
    encryptedInsights?: SortOrderInput | SortOrder
    encryptedHomework?: SortOrderInput | SortOrder
    encryptedGoals?: SortOrderInput | SortOrder
    topics?: SortOrderInput | SortOrder
    techniques?: SortOrderInput | SortOrder
    interventions?: SortOrderInput | SortOrder
    breakthroughs?: SortOrderInput | SortOrder
    crisisDetected?: SortOrder
    crisisLevel?: SortOrderInput | SortOrder
    crisisInterventions?: SortOrderInput | SortOrder
    therapist?: AITherapistOrderByWithRelationInput
    messages?: AITherapyMessageOrderByRelationAggregateInput
    exercises?: AIExerciseSessionOrderByRelationAggregateInput
  }

  export type AITherapySessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: AITherapySessionWhereInput | AITherapySessionWhereInput[]
    OR?: AITherapySessionWhereInput[]
    NOT?: AITherapySessionWhereInput | AITherapySessionWhereInput[]
    userId?: StringFilter<"AITherapySession"> | string
    therapistId?: StringFilter<"AITherapySession"> | string
    sessionType?: EnumAISessionTypeFilter<"AITherapySession"> | $Enums.AISessionType
    status?: EnumAISessionStatusFilter<"AITherapySession"> | $Enums.AISessionStatus
    startedAt?: DateTimeFilter<"AITherapySession"> | Date | string
    endedAt?: DateTimeNullableFilter<"AITherapySession"> | Date | string | null
    duration?: IntNullableFilter<"AITherapySession"> | number | null
    pausedAt?: DateTimeNullableFilter<"AITherapySession"> | Date | string | null
    pausedDuration?: IntFilter<"AITherapySession"> | number
    moodBefore?: IntNullableFilter<"AITherapySession"> | number | null
    moodAfter?: IntNullableFilter<"AITherapySession"> | number | null
    anxietyBefore?: IntNullableFilter<"AITherapySession"> | number | null
    anxietyAfter?: IntNullableFilter<"AITherapySession"> | number | null
    energyBefore?: IntNullableFilter<"AITherapySession"> | number | null
    energyAfter?: IntNullableFilter<"AITherapySession"> | number | null
    encryptedNotes?: BytesNullableFilter<"AITherapySession"> | Uint8Array | null
    encryptedInsights?: BytesNullableFilter<"AITherapySession"> | Uint8Array | null
    encryptedHomework?: BytesNullableFilter<"AITherapySession"> | Uint8Array | null
    encryptedGoals?: BytesNullableFilter<"AITherapySession"> | Uint8Array | null
    topics?: StringNullableFilter<"AITherapySession"> | string | null
    techniques?: StringNullableFilter<"AITherapySession"> | string | null
    interventions?: StringNullableFilter<"AITherapySession"> | string | null
    breakthroughs?: StringNullableFilter<"AITherapySession"> | string | null
    crisisDetected?: BoolFilter<"AITherapySession"> | boolean
    crisisLevel?: IntNullableFilter<"AITherapySession"> | number | null
    crisisInterventions?: StringNullableFilter<"AITherapySession"> | string | null
    therapist?: XOR<AITherapistScalarRelationFilter, AITherapistWhereInput>
    messages?: AITherapyMessageListRelationFilter
    exercises?: AIExerciseSessionListRelationFilter
  }, "id" | "sessionToken">

  export type AITherapySessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    therapistId?: SortOrder
    sessionType?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    pausedAt?: SortOrderInput | SortOrder
    pausedDuration?: SortOrder
    moodBefore?: SortOrderInput | SortOrder
    moodAfter?: SortOrderInput | SortOrder
    anxietyBefore?: SortOrderInput | SortOrder
    anxietyAfter?: SortOrderInput | SortOrder
    energyBefore?: SortOrderInput | SortOrder
    energyAfter?: SortOrderInput | SortOrder
    encryptedNotes?: SortOrderInput | SortOrder
    encryptedInsights?: SortOrderInput | SortOrder
    encryptedHomework?: SortOrderInput | SortOrder
    encryptedGoals?: SortOrderInput | SortOrder
    topics?: SortOrderInput | SortOrder
    techniques?: SortOrderInput | SortOrder
    interventions?: SortOrderInput | SortOrder
    breakthroughs?: SortOrderInput | SortOrder
    crisisDetected?: SortOrder
    crisisLevel?: SortOrderInput | SortOrder
    crisisInterventions?: SortOrderInput | SortOrder
    _count?: AITherapySessionCountOrderByAggregateInput
    _avg?: AITherapySessionAvgOrderByAggregateInput
    _max?: AITherapySessionMaxOrderByAggregateInput
    _min?: AITherapySessionMinOrderByAggregateInput
    _sum?: AITherapySessionSumOrderByAggregateInput
  }

  export type AITherapySessionScalarWhereWithAggregatesInput = {
    AND?: AITherapySessionScalarWhereWithAggregatesInput | AITherapySessionScalarWhereWithAggregatesInput[]
    OR?: AITherapySessionScalarWhereWithAggregatesInput[]
    NOT?: AITherapySessionScalarWhereWithAggregatesInput | AITherapySessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AITherapySession"> | string
    sessionToken?: StringWithAggregatesFilter<"AITherapySession"> | string
    userId?: StringWithAggregatesFilter<"AITherapySession"> | string
    therapistId?: StringWithAggregatesFilter<"AITherapySession"> | string
    sessionType?: EnumAISessionTypeWithAggregatesFilter<"AITherapySession"> | $Enums.AISessionType
    status?: EnumAISessionStatusWithAggregatesFilter<"AITherapySession"> | $Enums.AISessionStatus
    startedAt?: DateTimeWithAggregatesFilter<"AITherapySession"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"AITherapySession"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"AITherapySession"> | number | null
    pausedAt?: DateTimeNullableWithAggregatesFilter<"AITherapySession"> | Date | string | null
    pausedDuration?: IntWithAggregatesFilter<"AITherapySession"> | number
    moodBefore?: IntNullableWithAggregatesFilter<"AITherapySession"> | number | null
    moodAfter?: IntNullableWithAggregatesFilter<"AITherapySession"> | number | null
    anxietyBefore?: IntNullableWithAggregatesFilter<"AITherapySession"> | number | null
    anxietyAfter?: IntNullableWithAggregatesFilter<"AITherapySession"> | number | null
    energyBefore?: IntNullableWithAggregatesFilter<"AITherapySession"> | number | null
    energyAfter?: IntNullableWithAggregatesFilter<"AITherapySession"> | number | null
    encryptedNotes?: BytesNullableWithAggregatesFilter<"AITherapySession"> | Uint8Array | null
    encryptedInsights?: BytesNullableWithAggregatesFilter<"AITherapySession"> | Uint8Array | null
    encryptedHomework?: BytesNullableWithAggregatesFilter<"AITherapySession"> | Uint8Array | null
    encryptedGoals?: BytesNullableWithAggregatesFilter<"AITherapySession"> | Uint8Array | null
    topics?: StringNullableWithAggregatesFilter<"AITherapySession"> | string | null
    techniques?: StringNullableWithAggregatesFilter<"AITherapySession"> | string | null
    interventions?: StringNullableWithAggregatesFilter<"AITherapySession"> | string | null
    breakthroughs?: StringNullableWithAggregatesFilter<"AITherapySession"> | string | null
    crisisDetected?: BoolWithAggregatesFilter<"AITherapySession"> | boolean
    crisisLevel?: IntNullableWithAggregatesFilter<"AITherapySession"> | number | null
    crisisInterventions?: StringNullableWithAggregatesFilter<"AITherapySession"> | string | null
  }

  export type AITherapyMessageWhereInput = {
    AND?: AITherapyMessageWhereInput | AITherapyMessageWhereInput[]
    OR?: AITherapyMessageWhereInput[]
    NOT?: AITherapyMessageWhereInput | AITherapyMessageWhereInput[]
    id?: StringFilter<"AITherapyMessage"> | string
    sessionId?: StringFilter<"AITherapyMessage"> | string
    messageType?: EnumAIMessageTypeFilter<"AITherapyMessage"> | $Enums.AIMessageType
    sender?: EnumAIMessageSenderFilter<"AITherapyMessage"> | $Enums.AIMessageSender
    encryptedContent?: BytesFilter<"AITherapyMessage"> | Uint8Array
    messageHash?: StringFilter<"AITherapyMessage"> | string
    timestamp?: DateTimeFilter<"AITherapyMessage"> | Date | string
    edited?: BoolFilter<"AITherapyMessage"> | boolean
    editedAt?: DateTimeNullableFilter<"AITherapyMessage"> | Date | string | null
    sentiment?: FloatNullableFilter<"AITherapyMessage"> | number | null
    emotion?: StringNullableFilter<"AITherapyMessage"> | string | null
    riskScore?: IntNullableFilter<"AITherapyMessage"> | number | null
    techniques?: StringNullableFilter<"AITherapyMessage"> | string | null
    hasAudio?: BoolFilter<"AITherapyMessage"> | boolean
    audioDuration?: IntNullableFilter<"AITherapyMessage"> | number | null
    audioUrl?: StringNullableFilter<"AITherapyMessage"> | string | null
    session?: XOR<AITherapySessionScalarRelationFilter, AITherapySessionWhereInput>
  }

  export type AITherapyMessageOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    messageType?: SortOrder
    sender?: SortOrder
    encryptedContent?: SortOrder
    messageHash?: SortOrder
    timestamp?: SortOrder
    edited?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    emotion?: SortOrderInput | SortOrder
    riskScore?: SortOrderInput | SortOrder
    techniques?: SortOrderInput | SortOrder
    hasAudio?: SortOrder
    audioDuration?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    session?: AITherapySessionOrderByWithRelationInput
  }

  export type AITherapyMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AITherapyMessageWhereInput | AITherapyMessageWhereInput[]
    OR?: AITherapyMessageWhereInput[]
    NOT?: AITherapyMessageWhereInput | AITherapyMessageWhereInput[]
    sessionId?: StringFilter<"AITherapyMessage"> | string
    messageType?: EnumAIMessageTypeFilter<"AITherapyMessage"> | $Enums.AIMessageType
    sender?: EnumAIMessageSenderFilter<"AITherapyMessage"> | $Enums.AIMessageSender
    encryptedContent?: BytesFilter<"AITherapyMessage"> | Uint8Array
    messageHash?: StringFilter<"AITherapyMessage"> | string
    timestamp?: DateTimeFilter<"AITherapyMessage"> | Date | string
    edited?: BoolFilter<"AITherapyMessage"> | boolean
    editedAt?: DateTimeNullableFilter<"AITherapyMessage"> | Date | string | null
    sentiment?: FloatNullableFilter<"AITherapyMessage"> | number | null
    emotion?: StringNullableFilter<"AITherapyMessage"> | string | null
    riskScore?: IntNullableFilter<"AITherapyMessage"> | number | null
    techniques?: StringNullableFilter<"AITherapyMessage"> | string | null
    hasAudio?: BoolFilter<"AITherapyMessage"> | boolean
    audioDuration?: IntNullableFilter<"AITherapyMessage"> | number | null
    audioUrl?: StringNullableFilter<"AITherapyMessage"> | string | null
    session?: XOR<AITherapySessionScalarRelationFilter, AITherapySessionWhereInput>
  }, "id">

  export type AITherapyMessageOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    messageType?: SortOrder
    sender?: SortOrder
    encryptedContent?: SortOrder
    messageHash?: SortOrder
    timestamp?: SortOrder
    edited?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    emotion?: SortOrderInput | SortOrder
    riskScore?: SortOrderInput | SortOrder
    techniques?: SortOrderInput | SortOrder
    hasAudio?: SortOrder
    audioDuration?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    _count?: AITherapyMessageCountOrderByAggregateInput
    _avg?: AITherapyMessageAvgOrderByAggregateInput
    _max?: AITherapyMessageMaxOrderByAggregateInput
    _min?: AITherapyMessageMinOrderByAggregateInput
    _sum?: AITherapyMessageSumOrderByAggregateInput
  }

  export type AITherapyMessageScalarWhereWithAggregatesInput = {
    AND?: AITherapyMessageScalarWhereWithAggregatesInput | AITherapyMessageScalarWhereWithAggregatesInput[]
    OR?: AITherapyMessageScalarWhereWithAggregatesInput[]
    NOT?: AITherapyMessageScalarWhereWithAggregatesInput | AITherapyMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AITherapyMessage"> | string
    sessionId?: StringWithAggregatesFilter<"AITherapyMessage"> | string
    messageType?: EnumAIMessageTypeWithAggregatesFilter<"AITherapyMessage"> | $Enums.AIMessageType
    sender?: EnumAIMessageSenderWithAggregatesFilter<"AITherapyMessage"> | $Enums.AIMessageSender
    encryptedContent?: BytesWithAggregatesFilter<"AITherapyMessage"> | Uint8Array
    messageHash?: StringWithAggregatesFilter<"AITherapyMessage"> | string
    timestamp?: DateTimeWithAggregatesFilter<"AITherapyMessage"> | Date | string
    edited?: BoolWithAggregatesFilter<"AITherapyMessage"> | boolean
    editedAt?: DateTimeNullableWithAggregatesFilter<"AITherapyMessage"> | Date | string | null
    sentiment?: FloatNullableWithAggregatesFilter<"AITherapyMessage"> | number | null
    emotion?: StringNullableWithAggregatesFilter<"AITherapyMessage"> | string | null
    riskScore?: IntNullableWithAggregatesFilter<"AITherapyMessage"> | number | null
    techniques?: StringNullableWithAggregatesFilter<"AITherapyMessage"> | string | null
    hasAudio?: BoolWithAggregatesFilter<"AITherapyMessage"> | boolean
    audioDuration?: IntNullableWithAggregatesFilter<"AITherapyMessage"> | number | null
    audioUrl?: StringNullableWithAggregatesFilter<"AITherapyMessage"> | string | null
  }

  export type AIPersonalizationWhereInput = {
    AND?: AIPersonalizationWhereInput | AIPersonalizationWhereInput[]
    OR?: AIPersonalizationWhereInput[]
    NOT?: AIPersonalizationWhereInput | AIPersonalizationWhereInput[]
    id?: StringFilter<"AIPersonalization"> | string
    userId?: StringFilter<"AIPersonalization"> | string
    therapistId?: StringNullableFilter<"AIPersonalization"> | string | null
    preferredStyle?: StringNullableFilter<"AIPersonalization"> | string | null
    preferredTechniques?: StringNullableFilter<"AIPersonalization"> | string | null
    preferredTopics?: StringNullableFilter<"AIPersonalization"> | string | null
    avoidTopics?: StringNullableFilter<"AIPersonalization"> | string | null
    responseLength?: StringFilter<"AIPersonalization"> | string
    responseComplexity?: StringFilter<"AIPersonalization"> | string
    empathyLevel?: StringFilter<"AIPersonalization"> | string
    directness?: StringFilter<"AIPersonalization"> | string
    culturalBackground?: StringNullableFilter<"AIPersonalization"> | string | null
    languagePreference?: StringFilter<"AIPersonalization"> | string
    timezone?: StringFilter<"AIPersonalization"> | string
    pronouns?: StringNullableFilter<"AIPersonalization"> | string | null
    learnedPatterns?: StringNullableFilter<"AIPersonalization"> | string | null
    effectiveTechniques?: StringNullableFilter<"AIPersonalization"> | string | null
    triggerPatterns?: StringNullableFilter<"AIPersonalization"> | string | null
    copingStrategies?: StringNullableFilter<"AIPersonalization"> | string | null
    createdAt?: DateTimeFilter<"AIPersonalization"> | Date | string
    updatedAt?: DateTimeFilter<"AIPersonalization"> | Date | string
    therapist?: XOR<AITherapistNullableScalarRelationFilter, AITherapistWhereInput> | null
  }

  export type AIPersonalizationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    therapistId?: SortOrderInput | SortOrder
    preferredStyle?: SortOrderInput | SortOrder
    preferredTechniques?: SortOrderInput | SortOrder
    preferredTopics?: SortOrderInput | SortOrder
    avoidTopics?: SortOrderInput | SortOrder
    responseLength?: SortOrder
    responseComplexity?: SortOrder
    empathyLevel?: SortOrder
    directness?: SortOrder
    culturalBackground?: SortOrderInput | SortOrder
    languagePreference?: SortOrder
    timezone?: SortOrder
    pronouns?: SortOrderInput | SortOrder
    learnedPatterns?: SortOrderInput | SortOrder
    effectiveTechniques?: SortOrderInput | SortOrder
    triggerPatterns?: SortOrderInput | SortOrder
    copingStrategies?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    therapist?: AITherapistOrderByWithRelationInput
  }

  export type AIPersonalizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AIPersonalizationWhereInput | AIPersonalizationWhereInput[]
    OR?: AIPersonalizationWhereInput[]
    NOT?: AIPersonalizationWhereInput | AIPersonalizationWhereInput[]
    therapistId?: StringNullableFilter<"AIPersonalization"> | string | null
    preferredStyle?: StringNullableFilter<"AIPersonalization"> | string | null
    preferredTechniques?: StringNullableFilter<"AIPersonalization"> | string | null
    preferredTopics?: StringNullableFilter<"AIPersonalization"> | string | null
    avoidTopics?: StringNullableFilter<"AIPersonalization"> | string | null
    responseLength?: StringFilter<"AIPersonalization"> | string
    responseComplexity?: StringFilter<"AIPersonalization"> | string
    empathyLevel?: StringFilter<"AIPersonalization"> | string
    directness?: StringFilter<"AIPersonalization"> | string
    culturalBackground?: StringNullableFilter<"AIPersonalization"> | string | null
    languagePreference?: StringFilter<"AIPersonalization"> | string
    timezone?: StringFilter<"AIPersonalization"> | string
    pronouns?: StringNullableFilter<"AIPersonalization"> | string | null
    learnedPatterns?: StringNullableFilter<"AIPersonalization"> | string | null
    effectiveTechniques?: StringNullableFilter<"AIPersonalization"> | string | null
    triggerPatterns?: StringNullableFilter<"AIPersonalization"> | string | null
    copingStrategies?: StringNullableFilter<"AIPersonalization"> | string | null
    createdAt?: DateTimeFilter<"AIPersonalization"> | Date | string
    updatedAt?: DateTimeFilter<"AIPersonalization"> | Date | string
    therapist?: XOR<AITherapistNullableScalarRelationFilter, AITherapistWhereInput> | null
  }, "id" | "userId">

  export type AIPersonalizationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    therapistId?: SortOrderInput | SortOrder
    preferredStyle?: SortOrderInput | SortOrder
    preferredTechniques?: SortOrderInput | SortOrder
    preferredTopics?: SortOrderInput | SortOrder
    avoidTopics?: SortOrderInput | SortOrder
    responseLength?: SortOrder
    responseComplexity?: SortOrder
    empathyLevel?: SortOrder
    directness?: SortOrder
    culturalBackground?: SortOrderInput | SortOrder
    languagePreference?: SortOrder
    timezone?: SortOrder
    pronouns?: SortOrderInput | SortOrder
    learnedPatterns?: SortOrderInput | SortOrder
    effectiveTechniques?: SortOrderInput | SortOrder
    triggerPatterns?: SortOrderInput | SortOrder
    copingStrategies?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIPersonalizationCountOrderByAggregateInput
    _max?: AIPersonalizationMaxOrderByAggregateInput
    _min?: AIPersonalizationMinOrderByAggregateInput
  }

  export type AIPersonalizationScalarWhereWithAggregatesInput = {
    AND?: AIPersonalizationScalarWhereWithAggregatesInput | AIPersonalizationScalarWhereWithAggregatesInput[]
    OR?: AIPersonalizationScalarWhereWithAggregatesInput[]
    NOT?: AIPersonalizationScalarWhereWithAggregatesInput | AIPersonalizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIPersonalization"> | string
    userId?: StringWithAggregatesFilter<"AIPersonalization"> | string
    therapistId?: StringNullableWithAggregatesFilter<"AIPersonalization"> | string | null
    preferredStyle?: StringNullableWithAggregatesFilter<"AIPersonalization"> | string | null
    preferredTechniques?: StringNullableWithAggregatesFilter<"AIPersonalization"> | string | null
    preferredTopics?: StringNullableWithAggregatesFilter<"AIPersonalization"> | string | null
    avoidTopics?: StringNullableWithAggregatesFilter<"AIPersonalization"> | string | null
    responseLength?: StringWithAggregatesFilter<"AIPersonalization"> | string
    responseComplexity?: StringWithAggregatesFilter<"AIPersonalization"> | string
    empathyLevel?: StringWithAggregatesFilter<"AIPersonalization"> | string
    directness?: StringWithAggregatesFilter<"AIPersonalization"> | string
    culturalBackground?: StringNullableWithAggregatesFilter<"AIPersonalization"> | string | null
    languagePreference?: StringWithAggregatesFilter<"AIPersonalization"> | string
    timezone?: StringWithAggregatesFilter<"AIPersonalization"> | string
    pronouns?: StringNullableWithAggregatesFilter<"AIPersonalization"> | string | null
    learnedPatterns?: StringNullableWithAggregatesFilter<"AIPersonalization"> | string | null
    effectiveTechniques?: StringNullableWithAggregatesFilter<"AIPersonalization"> | string | null
    triggerPatterns?: StringNullableWithAggregatesFilter<"AIPersonalization"> | string | null
    copingStrategies?: StringNullableWithAggregatesFilter<"AIPersonalization"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIPersonalization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIPersonalization"> | Date | string
  }

  export type AIExerciseSessionWhereInput = {
    AND?: AIExerciseSessionWhereInput | AIExerciseSessionWhereInput[]
    OR?: AIExerciseSessionWhereInput[]
    NOT?: AIExerciseSessionWhereInput | AIExerciseSessionWhereInput[]
    id?: StringFilter<"AIExerciseSession"> | string
    sessionId?: StringNullableFilter<"AIExerciseSession"> | string | null
    userId?: StringFilter<"AIExerciseSession"> | string
    exerciseType?: EnumAIExerciseTypeFilter<"AIExerciseSession"> | $Enums.AIExerciseType
    exerciseName?: StringFilter<"AIExerciseSession"> | string
    category?: StringFilter<"AIExerciseSession"> | string
    difficulty?: StringFilter<"AIExerciseSession"> | string
    duration?: IntFilter<"AIExerciseSession"> | number
    startedAt?: DateTimeFilter<"AIExerciseSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"AIExerciseSession"> | Date | string | null
    completed?: BoolFilter<"AIExerciseSession"> | boolean
    progress?: IntFilter<"AIExerciseSession"> | number
    results?: StringNullableFilter<"AIExerciseSession"> | string | null
    feedback?: StringNullableFilter<"AIExerciseSession"> | string | null
    improvement?: FloatNullableFilter<"AIExerciseSession"> | number | null
    moodBefore?: IntNullableFilter<"AIExerciseSession"> | number | null
    moodAfter?: IntNullableFilter<"AIExerciseSession"> | number | null
    session?: XOR<AITherapySessionNullableScalarRelationFilter, AITherapySessionWhereInput> | null
  }

  export type AIExerciseSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    userId?: SortOrder
    exerciseType?: SortOrder
    exerciseName?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    completed?: SortOrder
    progress?: SortOrder
    results?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    improvement?: SortOrderInput | SortOrder
    moodBefore?: SortOrderInput | SortOrder
    moodAfter?: SortOrderInput | SortOrder
    session?: AITherapySessionOrderByWithRelationInput
  }

  export type AIExerciseSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIExerciseSessionWhereInput | AIExerciseSessionWhereInput[]
    OR?: AIExerciseSessionWhereInput[]
    NOT?: AIExerciseSessionWhereInput | AIExerciseSessionWhereInput[]
    sessionId?: StringNullableFilter<"AIExerciseSession"> | string | null
    userId?: StringFilter<"AIExerciseSession"> | string
    exerciseType?: EnumAIExerciseTypeFilter<"AIExerciseSession"> | $Enums.AIExerciseType
    exerciseName?: StringFilter<"AIExerciseSession"> | string
    category?: StringFilter<"AIExerciseSession"> | string
    difficulty?: StringFilter<"AIExerciseSession"> | string
    duration?: IntFilter<"AIExerciseSession"> | number
    startedAt?: DateTimeFilter<"AIExerciseSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"AIExerciseSession"> | Date | string | null
    completed?: BoolFilter<"AIExerciseSession"> | boolean
    progress?: IntFilter<"AIExerciseSession"> | number
    results?: StringNullableFilter<"AIExerciseSession"> | string | null
    feedback?: StringNullableFilter<"AIExerciseSession"> | string | null
    improvement?: FloatNullableFilter<"AIExerciseSession"> | number | null
    moodBefore?: IntNullableFilter<"AIExerciseSession"> | number | null
    moodAfter?: IntNullableFilter<"AIExerciseSession"> | number | null
    session?: XOR<AITherapySessionNullableScalarRelationFilter, AITherapySessionWhereInput> | null
  }, "id">

  export type AIExerciseSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    userId?: SortOrder
    exerciseType?: SortOrder
    exerciseName?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    completed?: SortOrder
    progress?: SortOrder
    results?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    improvement?: SortOrderInput | SortOrder
    moodBefore?: SortOrderInput | SortOrder
    moodAfter?: SortOrderInput | SortOrder
    _count?: AIExerciseSessionCountOrderByAggregateInput
    _avg?: AIExerciseSessionAvgOrderByAggregateInput
    _max?: AIExerciseSessionMaxOrderByAggregateInput
    _min?: AIExerciseSessionMinOrderByAggregateInput
    _sum?: AIExerciseSessionSumOrderByAggregateInput
  }

  export type AIExerciseSessionScalarWhereWithAggregatesInput = {
    AND?: AIExerciseSessionScalarWhereWithAggregatesInput | AIExerciseSessionScalarWhereWithAggregatesInput[]
    OR?: AIExerciseSessionScalarWhereWithAggregatesInput[]
    NOT?: AIExerciseSessionScalarWhereWithAggregatesInput | AIExerciseSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIExerciseSession"> | string
    sessionId?: StringNullableWithAggregatesFilter<"AIExerciseSession"> | string | null
    userId?: StringWithAggregatesFilter<"AIExerciseSession"> | string
    exerciseType?: EnumAIExerciseTypeWithAggregatesFilter<"AIExerciseSession"> | $Enums.AIExerciseType
    exerciseName?: StringWithAggregatesFilter<"AIExerciseSession"> | string
    category?: StringWithAggregatesFilter<"AIExerciseSession"> | string
    difficulty?: StringWithAggregatesFilter<"AIExerciseSession"> | string
    duration?: IntWithAggregatesFilter<"AIExerciseSession"> | number
    startedAt?: DateTimeWithAggregatesFilter<"AIExerciseSession"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"AIExerciseSession"> | Date | string | null
    completed?: BoolWithAggregatesFilter<"AIExerciseSession"> | boolean
    progress?: IntWithAggregatesFilter<"AIExerciseSession"> | number
    results?: StringNullableWithAggregatesFilter<"AIExerciseSession"> | string | null
    feedback?: StringNullableWithAggregatesFilter<"AIExerciseSession"> | string | null
    improvement?: FloatNullableWithAggregatesFilter<"AIExerciseSession"> | number | null
    moodBefore?: IntNullableWithAggregatesFilter<"AIExerciseSession"> | number | null
    moodAfter?: IntNullableWithAggregatesFilter<"AIExerciseSession"> | number | null
  }

  export type AITherapyInsightWhereInput = {
    AND?: AITherapyInsightWhereInput | AITherapyInsightWhereInput[]
    OR?: AITherapyInsightWhereInput[]
    NOT?: AITherapyInsightWhereInput | AITherapyInsightWhereInput[]
    id?: StringFilter<"AITherapyInsight"> | string
    userId?: StringFilter<"AITherapyInsight"> | string
    insightType?: EnumAIInsightTypeFilter<"AITherapyInsight"> | $Enums.AIInsightType
    title?: StringFilter<"AITherapyInsight"> | string
    description?: StringFilter<"AITherapyInsight"> | string
    significance?: StringFilter<"AITherapyInsight"> | string
    dataPoints?: StringFilter<"AITherapyInsight"> | string
    patterns?: StringNullableFilter<"AITherapyInsight"> | string | null
    trends?: StringNullableFilter<"AITherapyInsight"> | string | null
    recommendations?: StringNullableFilter<"AITherapyInsight"> | string | null
    actions?: StringNullableFilter<"AITherapyInsight"> | string | null
    periodStart?: DateTimeFilter<"AITherapyInsight"> | Date | string
    periodEnd?: DateTimeFilter<"AITherapyInsight"> | Date | string
    generatedAt?: DateTimeFilter<"AITherapyInsight"> | Date | string
    viewed?: BoolFilter<"AITherapyInsight"> | boolean
    viewedAt?: DateTimeNullableFilter<"AITherapyInsight"> | Date | string | null
    helpful?: BoolNullableFilter<"AITherapyInsight"> | boolean | null
    dismissed?: BoolFilter<"AITherapyInsight"> | boolean
  }

  export type AITherapyInsightOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    significance?: SortOrder
    dataPoints?: SortOrder
    patterns?: SortOrderInput | SortOrder
    trends?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    actions?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    generatedAt?: SortOrder
    viewed?: SortOrder
    viewedAt?: SortOrderInput | SortOrder
    helpful?: SortOrderInput | SortOrder
    dismissed?: SortOrder
  }

  export type AITherapyInsightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AITherapyInsightWhereInput | AITherapyInsightWhereInput[]
    OR?: AITherapyInsightWhereInput[]
    NOT?: AITherapyInsightWhereInput | AITherapyInsightWhereInput[]
    userId?: StringFilter<"AITherapyInsight"> | string
    insightType?: EnumAIInsightTypeFilter<"AITherapyInsight"> | $Enums.AIInsightType
    title?: StringFilter<"AITherapyInsight"> | string
    description?: StringFilter<"AITherapyInsight"> | string
    significance?: StringFilter<"AITherapyInsight"> | string
    dataPoints?: StringFilter<"AITherapyInsight"> | string
    patterns?: StringNullableFilter<"AITherapyInsight"> | string | null
    trends?: StringNullableFilter<"AITherapyInsight"> | string | null
    recommendations?: StringNullableFilter<"AITherapyInsight"> | string | null
    actions?: StringNullableFilter<"AITherapyInsight"> | string | null
    periodStart?: DateTimeFilter<"AITherapyInsight"> | Date | string
    periodEnd?: DateTimeFilter<"AITherapyInsight"> | Date | string
    generatedAt?: DateTimeFilter<"AITherapyInsight"> | Date | string
    viewed?: BoolFilter<"AITherapyInsight"> | boolean
    viewedAt?: DateTimeNullableFilter<"AITherapyInsight"> | Date | string | null
    helpful?: BoolNullableFilter<"AITherapyInsight"> | boolean | null
    dismissed?: BoolFilter<"AITherapyInsight"> | boolean
  }, "id">

  export type AITherapyInsightOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    significance?: SortOrder
    dataPoints?: SortOrder
    patterns?: SortOrderInput | SortOrder
    trends?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    actions?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    generatedAt?: SortOrder
    viewed?: SortOrder
    viewedAt?: SortOrderInput | SortOrder
    helpful?: SortOrderInput | SortOrder
    dismissed?: SortOrder
    _count?: AITherapyInsightCountOrderByAggregateInput
    _max?: AITherapyInsightMaxOrderByAggregateInput
    _min?: AITherapyInsightMinOrderByAggregateInput
  }

  export type AITherapyInsightScalarWhereWithAggregatesInput = {
    AND?: AITherapyInsightScalarWhereWithAggregatesInput | AITherapyInsightScalarWhereWithAggregatesInput[]
    OR?: AITherapyInsightScalarWhereWithAggregatesInput[]
    NOT?: AITherapyInsightScalarWhereWithAggregatesInput | AITherapyInsightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AITherapyInsight"> | string
    userId?: StringWithAggregatesFilter<"AITherapyInsight"> | string
    insightType?: EnumAIInsightTypeWithAggregatesFilter<"AITherapyInsight"> | $Enums.AIInsightType
    title?: StringWithAggregatesFilter<"AITherapyInsight"> | string
    description?: StringWithAggregatesFilter<"AITherapyInsight"> | string
    significance?: StringWithAggregatesFilter<"AITherapyInsight"> | string
    dataPoints?: StringWithAggregatesFilter<"AITherapyInsight"> | string
    patterns?: StringNullableWithAggregatesFilter<"AITherapyInsight"> | string | null
    trends?: StringNullableWithAggregatesFilter<"AITherapyInsight"> | string | null
    recommendations?: StringNullableWithAggregatesFilter<"AITherapyInsight"> | string | null
    actions?: StringNullableWithAggregatesFilter<"AITherapyInsight"> | string | null
    periodStart?: DateTimeWithAggregatesFilter<"AITherapyInsight"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"AITherapyInsight"> | Date | string
    generatedAt?: DateTimeWithAggregatesFilter<"AITherapyInsight"> | Date | string
    viewed?: BoolWithAggregatesFilter<"AITherapyInsight"> | boolean
    viewedAt?: DateTimeNullableWithAggregatesFilter<"AITherapyInsight"> | Date | string | null
    helpful?: BoolNullableWithAggregatesFilter<"AITherapyInsight"> | boolean | null
    dismissed?: BoolWithAggregatesFilter<"AITherapyInsight"> | boolean
  }

  export type AITherapyGoalWhereInput = {
    AND?: AITherapyGoalWhereInput | AITherapyGoalWhereInput[]
    OR?: AITherapyGoalWhereInput[]
    NOT?: AITherapyGoalWhereInput | AITherapyGoalWhereInput[]
    id?: StringFilter<"AITherapyGoal"> | string
    userId?: StringFilter<"AITherapyGoal"> | string
    goalType?: StringFilter<"AITherapyGoal"> | string
    title?: StringFilter<"AITherapyGoal"> | string
    description?: StringFilter<"AITherapyGoal"> | string
    category?: StringFilter<"AITherapyGoal"> | string
    priority?: StringFilter<"AITherapyGoal"> | string
    specific?: StringFilter<"AITherapyGoal"> | string
    measurable?: StringFilter<"AITherapyGoal"> | string
    achievable?: StringFilter<"AITherapyGoal"> | string
    relevant?: StringFilter<"AITherapyGoal"> | string
    timebound?: DateTimeFilter<"AITherapyGoal"> | Date | string
    status?: EnumAIGoalStatusFilter<"AITherapyGoal"> | $Enums.AIGoalStatus
    progress?: IntFilter<"AITherapyGoal"> | number
    milestones?: StringNullableFilter<"AITherapyGoal"> | string | null
    createdAt?: DateTimeFilter<"AITherapyGoal"> | Date | string
    updatedAt?: DateTimeFilter<"AITherapyGoal"> | Date | string
    completedAt?: DateTimeNullableFilter<"AITherapyGoal"> | Date | string | null
  }

  export type AITherapyGoalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    goalType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    specific?: SortOrder
    measurable?: SortOrder
    achievable?: SortOrder
    relevant?: SortOrder
    timebound?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    milestones?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
  }

  export type AITherapyGoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AITherapyGoalWhereInput | AITherapyGoalWhereInput[]
    OR?: AITherapyGoalWhereInput[]
    NOT?: AITherapyGoalWhereInput | AITherapyGoalWhereInput[]
    userId?: StringFilter<"AITherapyGoal"> | string
    goalType?: StringFilter<"AITherapyGoal"> | string
    title?: StringFilter<"AITherapyGoal"> | string
    description?: StringFilter<"AITherapyGoal"> | string
    category?: StringFilter<"AITherapyGoal"> | string
    priority?: StringFilter<"AITherapyGoal"> | string
    specific?: StringFilter<"AITherapyGoal"> | string
    measurable?: StringFilter<"AITherapyGoal"> | string
    achievable?: StringFilter<"AITherapyGoal"> | string
    relevant?: StringFilter<"AITherapyGoal"> | string
    timebound?: DateTimeFilter<"AITherapyGoal"> | Date | string
    status?: EnumAIGoalStatusFilter<"AITherapyGoal"> | $Enums.AIGoalStatus
    progress?: IntFilter<"AITherapyGoal"> | number
    milestones?: StringNullableFilter<"AITherapyGoal"> | string | null
    createdAt?: DateTimeFilter<"AITherapyGoal"> | Date | string
    updatedAt?: DateTimeFilter<"AITherapyGoal"> | Date | string
    completedAt?: DateTimeNullableFilter<"AITherapyGoal"> | Date | string | null
  }, "id">

  export type AITherapyGoalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    goalType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    specific?: SortOrder
    measurable?: SortOrder
    achievable?: SortOrder
    relevant?: SortOrder
    timebound?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    milestones?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: AITherapyGoalCountOrderByAggregateInput
    _avg?: AITherapyGoalAvgOrderByAggregateInput
    _max?: AITherapyGoalMaxOrderByAggregateInput
    _min?: AITherapyGoalMinOrderByAggregateInput
    _sum?: AITherapyGoalSumOrderByAggregateInput
  }

  export type AITherapyGoalScalarWhereWithAggregatesInput = {
    AND?: AITherapyGoalScalarWhereWithAggregatesInput | AITherapyGoalScalarWhereWithAggregatesInput[]
    OR?: AITherapyGoalScalarWhereWithAggregatesInput[]
    NOT?: AITherapyGoalScalarWhereWithAggregatesInput | AITherapyGoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AITherapyGoal"> | string
    userId?: StringWithAggregatesFilter<"AITherapyGoal"> | string
    goalType?: StringWithAggregatesFilter<"AITherapyGoal"> | string
    title?: StringWithAggregatesFilter<"AITherapyGoal"> | string
    description?: StringWithAggregatesFilter<"AITherapyGoal"> | string
    category?: StringWithAggregatesFilter<"AITherapyGoal"> | string
    priority?: StringWithAggregatesFilter<"AITherapyGoal"> | string
    specific?: StringWithAggregatesFilter<"AITherapyGoal"> | string
    measurable?: StringWithAggregatesFilter<"AITherapyGoal"> | string
    achievable?: StringWithAggregatesFilter<"AITherapyGoal"> | string
    relevant?: StringWithAggregatesFilter<"AITherapyGoal"> | string
    timebound?: DateTimeWithAggregatesFilter<"AITherapyGoal"> | Date | string
    status?: EnumAIGoalStatusWithAggregatesFilter<"AITherapyGoal"> | $Enums.AIGoalStatus
    progress?: IntWithAggregatesFilter<"AITherapyGoal"> | number
    milestones?: StringNullableWithAggregatesFilter<"AITherapyGoal"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AITherapyGoal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AITherapyGoal"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"AITherapyGoal"> | Date | string | null
  }

  export type CrisisSessionCreateInput = {
    id?: string
    sessionToken: string
    anonymousId: string
    severity: number
    status?: $Enums.CrisisStatus
    responderId?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    responseTimeMs?: number | null
    outcome?: string | null
    encryptedData?: Uint8Array | null
    keyDerivationSalt?: Uint8Array | null
    handoffTime?: number | null
    resolutionTime?: number | null
    emergencyTriggered?: boolean
    escalatedAt?: Date | string | null
    escalationType?: $Enums.EscalationType | null
    messages?: CrisisMessageCreateNestedManyWithoutSessionInput
    escalations?: CrisisEscalationCreateNestedManyWithoutSessionInput
    resources?: CrisisResourceUsageCreateNestedManyWithoutSessionInput
  }

  export type CrisisSessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    anonymousId: string
    severity: number
    status?: $Enums.CrisisStatus
    responderId?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    responseTimeMs?: number | null
    outcome?: string | null
    encryptedData?: Uint8Array | null
    keyDerivationSalt?: Uint8Array | null
    handoffTime?: number | null
    resolutionTime?: number | null
    emergencyTriggered?: boolean
    escalatedAt?: Date | string | null
    escalationType?: $Enums.EscalationType | null
    messages?: CrisisMessageUncheckedCreateNestedManyWithoutSessionInput
    escalations?: CrisisEscalationUncheckedCreateNestedManyWithoutSessionInput
    resources?: CrisisResourceUsageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type CrisisSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    status?: EnumCrisisStatusFieldUpdateOperationsInput | $Enums.CrisisStatus
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedData?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    keyDerivationSalt?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    handoffTime?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionTime?: NullableIntFieldUpdateOperationsInput | number | null
    emergencyTriggered?: BoolFieldUpdateOperationsInput | boolean
    escalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationType?: NullableEnumEscalationTypeFieldUpdateOperationsInput | $Enums.EscalationType | null
    messages?: CrisisMessageUpdateManyWithoutSessionNestedInput
    escalations?: CrisisEscalationUpdateManyWithoutSessionNestedInput
    resources?: CrisisResourceUsageUpdateManyWithoutSessionNestedInput
  }

  export type CrisisSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    status?: EnumCrisisStatusFieldUpdateOperationsInput | $Enums.CrisisStatus
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedData?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    keyDerivationSalt?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    handoffTime?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionTime?: NullableIntFieldUpdateOperationsInput | number | null
    emergencyTriggered?: BoolFieldUpdateOperationsInput | boolean
    escalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationType?: NullableEnumEscalationTypeFieldUpdateOperationsInput | $Enums.EscalationType | null
    messages?: CrisisMessageUncheckedUpdateManyWithoutSessionNestedInput
    escalations?: CrisisEscalationUncheckedUpdateManyWithoutSessionNestedInput
    resources?: CrisisResourceUsageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CrisisSessionCreateManyInput = {
    id?: string
    sessionToken: string
    anonymousId: string
    severity: number
    status?: $Enums.CrisisStatus
    responderId?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    responseTimeMs?: number | null
    outcome?: string | null
    encryptedData?: Uint8Array | null
    keyDerivationSalt?: Uint8Array | null
    handoffTime?: number | null
    resolutionTime?: number | null
    emergencyTriggered?: boolean
    escalatedAt?: Date | string | null
    escalationType?: $Enums.EscalationType | null
  }

  export type CrisisSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    status?: EnumCrisisStatusFieldUpdateOperationsInput | $Enums.CrisisStatus
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedData?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    keyDerivationSalt?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    handoffTime?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionTime?: NullableIntFieldUpdateOperationsInput | number | null
    emergencyTriggered?: BoolFieldUpdateOperationsInput | boolean
    escalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationType?: NullableEnumEscalationTypeFieldUpdateOperationsInput | $Enums.EscalationType | null
  }

  export type CrisisSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    status?: EnumCrisisStatusFieldUpdateOperationsInput | $Enums.CrisisStatus
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedData?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    keyDerivationSalt?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    handoffTime?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionTime?: NullableIntFieldUpdateOperationsInput | number | null
    emergencyTriggered?: BoolFieldUpdateOperationsInput | boolean
    escalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationType?: NullableEnumEscalationTypeFieldUpdateOperationsInput | $Enums.EscalationType | null
  }

  export type CrisisMessageCreateInput = {
    id?: string
    senderType: $Enums.MessageSender
    senderId: string
    encryptedContent: Uint8Array
    messageHash: string
    timestamp?: Date | string
    messageType?: $Enums.MessageType
    priority?: $Enums.MessagePriority
    sentimentScore?: number | null
    riskScore?: number | null
    riskLevel?: string | null
    keywordsDetected?: string | null
    session: CrisisSessionCreateNestedOneWithoutMessagesInput
  }

  export type CrisisMessageUncheckedCreateInput = {
    id?: string
    sessionId: string
    senderType: $Enums.MessageSender
    senderId: string
    encryptedContent: Uint8Array
    messageHash: string
    timestamp?: Date | string
    messageType?: $Enums.MessageType
    priority?: $Enums.MessagePriority
    sentimentScore?: number | null
    riskScore?: number | null
    riskLevel?: string | null
    keywordsDetected?: string | null
  }

  export type CrisisMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderType?: EnumMessageSenderFieldUpdateOperationsInput | $Enums.MessageSender
    senderId?: StringFieldUpdateOperationsInput | string
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    messageHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    keywordsDetected?: NullableStringFieldUpdateOperationsInput | string | null
    session?: CrisisSessionUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type CrisisMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    senderType?: EnumMessageSenderFieldUpdateOperationsInput | $Enums.MessageSender
    senderId?: StringFieldUpdateOperationsInput | string
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    messageHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    keywordsDetected?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CrisisMessageCreateManyInput = {
    id?: string
    sessionId: string
    senderType: $Enums.MessageSender
    senderId: string
    encryptedContent: Uint8Array
    messageHash: string
    timestamp?: Date | string
    messageType?: $Enums.MessageType
    priority?: $Enums.MessagePriority
    sentimentScore?: number | null
    riskScore?: number | null
    riskLevel?: string | null
    keywordsDetected?: string | null
  }

  export type CrisisMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderType?: EnumMessageSenderFieldUpdateOperationsInput | $Enums.MessageSender
    senderId?: StringFieldUpdateOperationsInput | string
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    messageHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    keywordsDetected?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CrisisMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    senderType?: EnumMessageSenderFieldUpdateOperationsInput | $Enums.MessageSender
    senderId?: StringFieldUpdateOperationsInput | string
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    messageHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    keywordsDetected?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CrisisEscalationCreateInput = {
    id?: string
    triggeredBy: $Enums.EscalationTrigger
    severity: $Enums.EscalationSeverity
    reason: string
    actionsTaken?: string | null
    emergencyContacted?: boolean
    lifeline988Called?: boolean
    triggeredAt?: Date | string
    resolvedAt?: Date | string | null
    responseTime?: number | null
    handledBy?: string | null
    outcome?: $Enums.EscalationOutcome | null
    session: CrisisSessionCreateNestedOneWithoutEscalationsInput
  }

  export type CrisisEscalationUncheckedCreateInput = {
    id?: string
    sessionId: string
    triggeredBy: $Enums.EscalationTrigger
    severity: $Enums.EscalationSeverity
    reason: string
    actionsTaken?: string | null
    emergencyContacted?: boolean
    lifeline988Called?: boolean
    triggeredAt?: Date | string
    resolvedAt?: Date | string | null
    responseTime?: number | null
    handledBy?: string | null
    outcome?: $Enums.EscalationOutcome | null
  }

  export type CrisisEscalationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggeredBy?: EnumEscalationTriggerFieldUpdateOperationsInput | $Enums.EscalationTrigger
    severity?: EnumEscalationSeverityFieldUpdateOperationsInput | $Enums.EscalationSeverity
    reason?: StringFieldUpdateOperationsInput | string
    actionsTaken?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacted?: BoolFieldUpdateOperationsInput | boolean
    lifeline988Called?: BoolFieldUpdateOperationsInput | boolean
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableEnumEscalationOutcomeFieldUpdateOperationsInput | $Enums.EscalationOutcome | null
    session?: CrisisSessionUpdateOneRequiredWithoutEscalationsNestedInput
  }

  export type CrisisEscalationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    triggeredBy?: EnumEscalationTriggerFieldUpdateOperationsInput | $Enums.EscalationTrigger
    severity?: EnumEscalationSeverityFieldUpdateOperationsInput | $Enums.EscalationSeverity
    reason?: StringFieldUpdateOperationsInput | string
    actionsTaken?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacted?: BoolFieldUpdateOperationsInput | boolean
    lifeline988Called?: BoolFieldUpdateOperationsInput | boolean
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableEnumEscalationOutcomeFieldUpdateOperationsInput | $Enums.EscalationOutcome | null
  }

  export type CrisisEscalationCreateManyInput = {
    id?: string
    sessionId: string
    triggeredBy: $Enums.EscalationTrigger
    severity: $Enums.EscalationSeverity
    reason: string
    actionsTaken?: string | null
    emergencyContacted?: boolean
    lifeline988Called?: boolean
    triggeredAt?: Date | string
    resolvedAt?: Date | string | null
    responseTime?: number | null
    handledBy?: string | null
    outcome?: $Enums.EscalationOutcome | null
  }

  export type CrisisEscalationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggeredBy?: EnumEscalationTriggerFieldUpdateOperationsInput | $Enums.EscalationTrigger
    severity?: EnumEscalationSeverityFieldUpdateOperationsInput | $Enums.EscalationSeverity
    reason?: StringFieldUpdateOperationsInput | string
    actionsTaken?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacted?: BoolFieldUpdateOperationsInput | boolean
    lifeline988Called?: BoolFieldUpdateOperationsInput | boolean
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableEnumEscalationOutcomeFieldUpdateOperationsInput | $Enums.EscalationOutcome | null
  }

  export type CrisisEscalationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    triggeredBy?: EnumEscalationTriggerFieldUpdateOperationsInput | $Enums.EscalationTrigger
    severity?: EnumEscalationSeverityFieldUpdateOperationsInput | $Enums.EscalationSeverity
    reason?: StringFieldUpdateOperationsInput | string
    actionsTaken?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacted?: BoolFieldUpdateOperationsInput | boolean
    lifeline988Called?: BoolFieldUpdateOperationsInput | boolean
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableEnumEscalationOutcomeFieldUpdateOperationsInput | $Enums.EscalationOutcome | null
  }

  export type TetherLinkCreateInput = {
    id?: string
    seekerId: string
    supporterId: string
    strength?: number
    trustScore?: number
    established?: Date | string
    lastActivity?: Date | string
    pulseInterval?: number
    lastPulse?: Date | string
    missedPulses?: number
    emergencyActive?: boolean
    emergencyType?: $Enums.EmergencyType | null
    lastEmergency?: Date | string | null
    matchingScore?: number | null
    specialties?: string | null
    languages?: string | null
    timezone?: string | null
    dataSharing?: $Enums.TetherDataSharing
    locationSharing?: boolean
    emergencyContact?: boolean
    encryptedMeta?: Uint8Array | null
    pulses?: TetherPulseCreateNestedManyWithoutTetherInput
    emergencies?: TetherEmergencyCreateNestedManyWithoutTetherInput
  }

  export type TetherLinkUncheckedCreateInput = {
    id?: string
    seekerId: string
    supporterId: string
    strength?: number
    trustScore?: number
    established?: Date | string
    lastActivity?: Date | string
    pulseInterval?: number
    lastPulse?: Date | string
    missedPulses?: number
    emergencyActive?: boolean
    emergencyType?: $Enums.EmergencyType | null
    lastEmergency?: Date | string | null
    matchingScore?: number | null
    specialties?: string | null
    languages?: string | null
    timezone?: string | null
    dataSharing?: $Enums.TetherDataSharing
    locationSharing?: boolean
    emergencyContact?: boolean
    encryptedMeta?: Uint8Array | null
    pulses?: TetherPulseUncheckedCreateNestedManyWithoutTetherInput
    emergencies?: TetherEmergencyUncheckedCreateNestedManyWithoutTetherInput
  }

  export type TetherLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seekerId?: StringFieldUpdateOperationsInput | string
    supporterId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    trustScore?: FloatFieldUpdateOperationsInput | number
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    pulseInterval?: IntFieldUpdateOperationsInput | number
    lastPulse?: DateTimeFieldUpdateOperationsInput | Date | string
    missedPulses?: IntFieldUpdateOperationsInput | number
    emergencyActive?: BoolFieldUpdateOperationsInput | boolean
    emergencyType?: NullableEnumEmergencyTypeFieldUpdateOperationsInput | $Enums.EmergencyType | null
    lastEmergency?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    matchingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    specialties?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dataSharing?: EnumTetherDataSharingFieldUpdateOperationsInput | $Enums.TetherDataSharing
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    emergencyContact?: BoolFieldUpdateOperationsInput | boolean
    encryptedMeta?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    pulses?: TetherPulseUpdateManyWithoutTetherNestedInput
    emergencies?: TetherEmergencyUpdateManyWithoutTetherNestedInput
  }

  export type TetherLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seekerId?: StringFieldUpdateOperationsInput | string
    supporterId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    trustScore?: FloatFieldUpdateOperationsInput | number
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    pulseInterval?: IntFieldUpdateOperationsInput | number
    lastPulse?: DateTimeFieldUpdateOperationsInput | Date | string
    missedPulses?: IntFieldUpdateOperationsInput | number
    emergencyActive?: BoolFieldUpdateOperationsInput | boolean
    emergencyType?: NullableEnumEmergencyTypeFieldUpdateOperationsInput | $Enums.EmergencyType | null
    lastEmergency?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    matchingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    specialties?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dataSharing?: EnumTetherDataSharingFieldUpdateOperationsInput | $Enums.TetherDataSharing
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    emergencyContact?: BoolFieldUpdateOperationsInput | boolean
    encryptedMeta?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    pulses?: TetherPulseUncheckedUpdateManyWithoutTetherNestedInput
    emergencies?: TetherEmergencyUncheckedUpdateManyWithoutTetherNestedInput
  }

  export type TetherLinkCreateManyInput = {
    id?: string
    seekerId: string
    supporterId: string
    strength?: number
    trustScore?: number
    established?: Date | string
    lastActivity?: Date | string
    pulseInterval?: number
    lastPulse?: Date | string
    missedPulses?: number
    emergencyActive?: boolean
    emergencyType?: $Enums.EmergencyType | null
    lastEmergency?: Date | string | null
    matchingScore?: number | null
    specialties?: string | null
    languages?: string | null
    timezone?: string | null
    dataSharing?: $Enums.TetherDataSharing
    locationSharing?: boolean
    emergencyContact?: boolean
    encryptedMeta?: Uint8Array | null
  }

  export type TetherLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    seekerId?: StringFieldUpdateOperationsInput | string
    supporterId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    trustScore?: FloatFieldUpdateOperationsInput | number
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    pulseInterval?: IntFieldUpdateOperationsInput | number
    lastPulse?: DateTimeFieldUpdateOperationsInput | Date | string
    missedPulses?: IntFieldUpdateOperationsInput | number
    emergencyActive?: BoolFieldUpdateOperationsInput | boolean
    emergencyType?: NullableEnumEmergencyTypeFieldUpdateOperationsInput | $Enums.EmergencyType | null
    lastEmergency?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    matchingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    specialties?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dataSharing?: EnumTetherDataSharingFieldUpdateOperationsInput | $Enums.TetherDataSharing
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    emergencyContact?: BoolFieldUpdateOperationsInput | boolean
    encryptedMeta?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type TetherLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seekerId?: StringFieldUpdateOperationsInput | string
    supporterId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    trustScore?: FloatFieldUpdateOperationsInput | number
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    pulseInterval?: IntFieldUpdateOperationsInput | number
    lastPulse?: DateTimeFieldUpdateOperationsInput | Date | string
    missedPulses?: IntFieldUpdateOperationsInput | number
    emergencyActive?: BoolFieldUpdateOperationsInput | boolean
    emergencyType?: NullableEnumEmergencyTypeFieldUpdateOperationsInput | $Enums.EmergencyType | null
    lastEmergency?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    matchingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    specialties?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dataSharing?: EnumTetherDataSharingFieldUpdateOperationsInput | $Enums.TetherDataSharing
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    emergencyContact?: BoolFieldUpdateOperationsInput | boolean
    encryptedMeta?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type TetherPulseCreateInput = {
    id?: string
    pulseType?: $Enums.PulseType
    strength: number
    mood?: number | null
    status?: $Enums.UserStatus
    message?: string | null
    emergencySignal?: boolean
    urgencyLevel?: $Enums.UrgencyLevel
    timestamp?: Date | string
    acknowledged?: boolean
    acknowledgedAt?: Date | string | null
    tether: TetherLinkCreateNestedOneWithoutPulsesInput
  }

  export type TetherPulseUncheckedCreateInput = {
    id?: string
    tetherId: string
    pulseType?: $Enums.PulseType
    strength: number
    mood?: number | null
    status?: $Enums.UserStatus
    message?: string | null
    emergencySignal?: boolean
    urgencyLevel?: $Enums.UrgencyLevel
    timestamp?: Date | string
    acknowledged?: boolean
    acknowledgedAt?: Date | string | null
  }

  export type TetherPulseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pulseType?: EnumPulseTypeFieldUpdateOperationsInput | $Enums.PulseType
    strength?: FloatFieldUpdateOperationsInput | number
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    emergencySignal?: BoolFieldUpdateOperationsInput | boolean
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tether?: TetherLinkUpdateOneRequiredWithoutPulsesNestedInput
  }

  export type TetherPulseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tetherId?: StringFieldUpdateOperationsInput | string
    pulseType?: EnumPulseTypeFieldUpdateOperationsInput | $Enums.PulseType
    strength?: FloatFieldUpdateOperationsInput | number
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    emergencySignal?: BoolFieldUpdateOperationsInput | boolean
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TetherPulseCreateManyInput = {
    id?: string
    tetherId: string
    pulseType?: $Enums.PulseType
    strength: number
    mood?: number | null
    status?: $Enums.UserStatus
    message?: string | null
    emergencySignal?: boolean
    urgencyLevel?: $Enums.UrgencyLevel
    timestamp?: Date | string
    acknowledged?: boolean
    acknowledgedAt?: Date | string | null
  }

  export type TetherPulseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pulseType?: EnumPulseTypeFieldUpdateOperationsInput | $Enums.PulseType
    strength?: FloatFieldUpdateOperationsInput | number
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    emergencySignal?: BoolFieldUpdateOperationsInput | boolean
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TetherPulseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tetherId?: StringFieldUpdateOperationsInput | string
    pulseType?: EnumPulseTypeFieldUpdateOperationsInput | $Enums.PulseType
    strength?: FloatFieldUpdateOperationsInput | number
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    emergencySignal?: BoolFieldUpdateOperationsInput | boolean
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TetherEmergencyCreateInput = {
    id?: string
    triggerUserId: string
    emergencyType: $Enums.EmergencyType
    severity: $Enums.EmergencySeverity
    description: string
    location?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: Date | string
    acknowledgedAt?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    responseTime?: number | null
    actionsTaken?: string | null
    outcome?: $Enums.EmergencyOutcome | null
    helpersNotified?: string | null
    emergencyContacts?: string | null
    tether: TetherLinkCreateNestedOneWithoutEmergenciesInput
  }

  export type TetherEmergencyUncheckedCreateInput = {
    id?: string
    tetherId: string
    triggerUserId: string
    emergencyType: $Enums.EmergencyType
    severity: $Enums.EmergencySeverity
    description: string
    location?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: Date | string
    acknowledgedAt?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    responseTime?: number | null
    actionsTaken?: string | null
    outcome?: $Enums.EmergencyOutcome | null
    helpersNotified?: string | null
    emergencyContacts?: string | null
  }

  export type TetherEmergencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggerUserId?: StringFieldUpdateOperationsInput | string
    emergencyType?: EnumEmergencyTypeFieldUpdateOperationsInput | $Enums.EmergencyType
    severity?: EnumEmergencySeverityFieldUpdateOperationsInput | $Enums.EmergencySeverity
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    actionsTaken?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableEnumEmergencyOutcomeFieldUpdateOperationsInput | $Enums.EmergencyOutcome | null
    helpersNotified?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    tether?: TetherLinkUpdateOneRequiredWithoutEmergenciesNestedInput
  }

  export type TetherEmergencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tetherId?: StringFieldUpdateOperationsInput | string
    triggerUserId?: StringFieldUpdateOperationsInput | string
    emergencyType?: EnumEmergencyTypeFieldUpdateOperationsInput | $Enums.EmergencyType
    severity?: EnumEmergencySeverityFieldUpdateOperationsInput | $Enums.EmergencySeverity
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    actionsTaken?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableEnumEmergencyOutcomeFieldUpdateOperationsInput | $Enums.EmergencyOutcome | null
    helpersNotified?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TetherEmergencyCreateManyInput = {
    id?: string
    tetherId: string
    triggerUserId: string
    emergencyType: $Enums.EmergencyType
    severity: $Enums.EmergencySeverity
    description: string
    location?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: Date | string
    acknowledgedAt?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    responseTime?: number | null
    actionsTaken?: string | null
    outcome?: $Enums.EmergencyOutcome | null
    helpersNotified?: string | null
    emergencyContacts?: string | null
  }

  export type TetherEmergencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggerUserId?: StringFieldUpdateOperationsInput | string
    emergencyType?: EnumEmergencyTypeFieldUpdateOperationsInput | $Enums.EmergencyType
    severity?: EnumEmergencySeverityFieldUpdateOperationsInput | $Enums.EmergencySeverity
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    actionsTaken?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableEnumEmergencyOutcomeFieldUpdateOperationsInput | $Enums.EmergencyOutcome | null
    helpersNotified?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TetherEmergencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tetherId?: StringFieldUpdateOperationsInput | string
    triggerUserId?: StringFieldUpdateOperationsInput | string
    emergencyType?: EnumEmergencyTypeFieldUpdateOperationsInput | $Enums.EmergencyType
    severity?: EnumEmergencySeverityFieldUpdateOperationsInput | $Enums.EmergencySeverity
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    actionsTaken?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableEnumEmergencyOutcomeFieldUpdateOperationsInput | $Enums.EmergencyOutcome | null
    helpersNotified?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VolunteerCreateInput = {
    id?: string
    anonymousId: string
    status?: $Enums.VolunteerStatus
    trainingHours?: number
    certifications?: string | null
    specializations?: string | null
    languages?: string | null
    backgroundCheck?: $Enums.VerificationStatus
    sessionsCount?: number
    hoursVolunteered?: number
    averageRating?: number | null
    responseRate?: number
    isActive?: boolean
    currentLoad?: number
    maxConcurrent?: number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    lastActive?: Date | string
    burnoutScore?: number
    needsSupport?: boolean
    emergencyResponder?: boolean
    emergencyAvailable?: boolean
    training?: VolunteerTrainingCreateNestedManyWithoutVolunteerInput
    sessions?: VolunteerSessionCreateNestedManyWithoutVolunteerInput
    feedback?: VolunteerFeedbackCreateNestedManyWithoutVolunteerInput
  }

  export type VolunteerUncheckedCreateInput = {
    id?: string
    anonymousId: string
    status?: $Enums.VolunteerStatus
    trainingHours?: number
    certifications?: string | null
    specializations?: string | null
    languages?: string | null
    backgroundCheck?: $Enums.VerificationStatus
    sessionsCount?: number
    hoursVolunteered?: number
    averageRating?: number | null
    responseRate?: number
    isActive?: boolean
    currentLoad?: number
    maxConcurrent?: number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    lastActive?: Date | string
    burnoutScore?: number
    needsSupport?: boolean
    emergencyResponder?: boolean
    emergencyAvailable?: boolean
    training?: VolunteerTrainingUncheckedCreateNestedManyWithoutVolunteerInput
    sessions?: VolunteerSessionUncheckedCreateNestedManyWithoutVolunteerInput
    feedback?: VolunteerFeedbackUncheckedCreateNestedManyWithoutVolunteerInput
  }

  export type VolunteerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    status?: EnumVolunteerStatusFieldUpdateOperationsInput | $Enums.VolunteerStatus
    trainingHours?: FloatFieldUpdateOperationsInput | number
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    sessionsCount?: IntFieldUpdateOperationsInput | number
    hoursVolunteered?: FloatFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentLoad?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    burnoutScore?: FloatFieldUpdateOperationsInput | number
    needsSupport?: BoolFieldUpdateOperationsInput | boolean
    emergencyResponder?: BoolFieldUpdateOperationsInput | boolean
    emergencyAvailable?: BoolFieldUpdateOperationsInput | boolean
    training?: VolunteerTrainingUpdateManyWithoutVolunteerNestedInput
    sessions?: VolunteerSessionUpdateManyWithoutVolunteerNestedInput
    feedback?: VolunteerFeedbackUpdateManyWithoutVolunteerNestedInput
  }

  export type VolunteerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    status?: EnumVolunteerStatusFieldUpdateOperationsInput | $Enums.VolunteerStatus
    trainingHours?: FloatFieldUpdateOperationsInput | number
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    sessionsCount?: IntFieldUpdateOperationsInput | number
    hoursVolunteered?: FloatFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentLoad?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    burnoutScore?: FloatFieldUpdateOperationsInput | number
    needsSupport?: BoolFieldUpdateOperationsInput | boolean
    emergencyResponder?: BoolFieldUpdateOperationsInput | boolean
    emergencyAvailable?: BoolFieldUpdateOperationsInput | boolean
    training?: VolunteerTrainingUncheckedUpdateManyWithoutVolunteerNestedInput
    sessions?: VolunteerSessionUncheckedUpdateManyWithoutVolunteerNestedInput
    feedback?: VolunteerFeedbackUncheckedUpdateManyWithoutVolunteerNestedInput
  }

  export type VolunteerCreateManyInput = {
    id?: string
    anonymousId: string
    status?: $Enums.VolunteerStatus
    trainingHours?: number
    certifications?: string | null
    specializations?: string | null
    languages?: string | null
    backgroundCheck?: $Enums.VerificationStatus
    sessionsCount?: number
    hoursVolunteered?: number
    averageRating?: number | null
    responseRate?: number
    isActive?: boolean
    currentLoad?: number
    maxConcurrent?: number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    lastActive?: Date | string
    burnoutScore?: number
    needsSupport?: boolean
    emergencyResponder?: boolean
    emergencyAvailable?: boolean
  }

  export type VolunteerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    status?: EnumVolunteerStatusFieldUpdateOperationsInput | $Enums.VolunteerStatus
    trainingHours?: FloatFieldUpdateOperationsInput | number
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    sessionsCount?: IntFieldUpdateOperationsInput | number
    hoursVolunteered?: FloatFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentLoad?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    burnoutScore?: FloatFieldUpdateOperationsInput | number
    needsSupport?: BoolFieldUpdateOperationsInput | boolean
    emergencyResponder?: BoolFieldUpdateOperationsInput | boolean
    emergencyAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VolunteerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    status?: EnumVolunteerStatusFieldUpdateOperationsInput | $Enums.VolunteerStatus
    trainingHours?: FloatFieldUpdateOperationsInput | number
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    sessionsCount?: IntFieldUpdateOperationsInput | number
    hoursVolunteered?: FloatFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentLoad?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    burnoutScore?: FloatFieldUpdateOperationsInput | number
    needsSupport?: BoolFieldUpdateOperationsInput | boolean
    emergencyResponder?: BoolFieldUpdateOperationsInput | boolean
    emergencyAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VolunteerTrainingCreateInput = {
    id?: string
    moduleId: string
    status?: $Enums.TrainingStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    score?: number | null
    passingScore?: number
    attempts?: number
    moduleTitle: string
    moduleType: $Enums.TrainingType
    duration: number
    content: JsonNullValueInput | InputJsonValue
    volunteer: VolunteerCreateNestedOneWithoutTrainingInput
  }

  export type VolunteerTrainingUncheckedCreateInput = {
    id?: string
    volunteerId: string
    moduleId: string
    status?: $Enums.TrainingStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    score?: number | null
    passingScore?: number
    attempts?: number
    moduleTitle: string
    moduleType: $Enums.TrainingType
    duration: number
    content: JsonNullValueInput | InputJsonValue
  }

  export type VolunteerTrainingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passingScore?: FloatFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    moduleTitle?: StringFieldUpdateOperationsInput | string
    moduleType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    duration?: IntFieldUpdateOperationsInput | number
    content?: JsonNullValueInput | InputJsonValue
    volunteer?: VolunteerUpdateOneRequiredWithoutTrainingNestedInput
  }

  export type VolunteerTrainingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    volunteerId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passingScore?: FloatFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    moduleTitle?: StringFieldUpdateOperationsInput | string
    moduleType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    duration?: IntFieldUpdateOperationsInput | number
    content?: JsonNullValueInput | InputJsonValue
  }

  export type VolunteerTrainingCreateManyInput = {
    id?: string
    volunteerId: string
    moduleId: string
    status?: $Enums.TrainingStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    score?: number | null
    passingScore?: number
    attempts?: number
    moduleTitle: string
    moduleType: $Enums.TrainingType
    duration: number
    content: JsonNullValueInput | InputJsonValue
  }

  export type VolunteerTrainingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passingScore?: FloatFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    moduleTitle?: StringFieldUpdateOperationsInput | string
    moduleType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    duration?: IntFieldUpdateOperationsInput | number
    content?: JsonNullValueInput | InputJsonValue
  }

  export type VolunteerTrainingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    volunteerId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passingScore?: FloatFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    moduleTitle?: StringFieldUpdateOperationsInput | string
    moduleType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    duration?: IntFieldUpdateOperationsInput | number
    content?: JsonNullValueInput | InputJsonValue
  }

  export type VolunteerSessionCreateInput = {
    id?: string
    sessionType: $Enums.VolunteerSessionType
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    crisisSessionId?: string | null
    responseTime?: number | null
    userSatisfaction?: number | null
    outcome?: $Enums.SessionOutcome | null
    volunteer: VolunteerCreateNestedOneWithoutSessionsInput
  }

  export type VolunteerSessionUncheckedCreateInput = {
    id?: string
    volunteerId: string
    sessionType: $Enums.VolunteerSessionType
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    crisisSessionId?: string | null
    responseTime?: number | null
    userSatisfaction?: number | null
    outcome?: $Enums.SessionOutcome | null
  }

  export type VolunteerSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumVolunteerSessionTypeFieldUpdateOperationsInput | $Enums.VolunteerSessionType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    crisisSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableEnumSessionOutcomeFieldUpdateOperationsInput | $Enums.SessionOutcome | null
    volunteer?: VolunteerUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type VolunteerSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    volunteerId?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumVolunteerSessionTypeFieldUpdateOperationsInput | $Enums.VolunteerSessionType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    crisisSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableEnumSessionOutcomeFieldUpdateOperationsInput | $Enums.SessionOutcome | null
  }

  export type VolunteerSessionCreateManyInput = {
    id?: string
    volunteerId: string
    sessionType: $Enums.VolunteerSessionType
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    crisisSessionId?: string | null
    responseTime?: number | null
    userSatisfaction?: number | null
    outcome?: $Enums.SessionOutcome | null
  }

  export type VolunteerSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumVolunteerSessionTypeFieldUpdateOperationsInput | $Enums.VolunteerSessionType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    crisisSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableEnumSessionOutcomeFieldUpdateOperationsInput | $Enums.SessionOutcome | null
  }

  export type VolunteerSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    volunteerId?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumVolunteerSessionTypeFieldUpdateOperationsInput | $Enums.VolunteerSessionType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    crisisSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableEnumSessionOutcomeFieldUpdateOperationsInput | $Enums.SessionOutcome | null
  }

  export type VolunteerFeedbackCreateInput = {
    id?: string
    sessionId?: string | null
    feedbackType: $Enums.FeedbackType
    rating: number
    comment?: string | null
    submittedBy?: string | null
    sourceType?: $Enums.FeedbackSource
    submittedAt?: Date | string
    isAnonymous?: boolean
    isApproved?: boolean
    moderatedAt?: Date | string | null
    moderatedBy?: string | null
    volunteer: VolunteerCreateNestedOneWithoutFeedbackInput
  }

  export type VolunteerFeedbackUncheckedCreateInput = {
    id?: string
    volunteerId: string
    sessionId?: string | null
    feedbackType: $Enums.FeedbackType
    rating: number
    comment?: string | null
    submittedBy?: string | null
    sourceType?: $Enums.FeedbackSource
    submittedAt?: Date | string
    isAnonymous?: boolean
    isApproved?: boolean
    moderatedAt?: Date | string | null
    moderatedBy?: string | null
  }

  export type VolunteerFeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | $Enums.FeedbackSource
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    volunteer?: VolunteerUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type VolunteerFeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    volunteerId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | $Enums.FeedbackSource
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VolunteerFeedbackCreateManyInput = {
    id?: string
    volunteerId: string
    sessionId?: string | null
    feedbackType: $Enums.FeedbackType
    rating: number
    comment?: string | null
    submittedBy?: string | null
    sourceType?: $Enums.FeedbackSource
    submittedAt?: Date | string
    isAnonymous?: boolean
    isApproved?: boolean
    moderatedAt?: Date | string | null
    moderatedBy?: string | null
  }

  export type VolunteerFeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | $Enums.FeedbackSource
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VolunteerFeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    volunteerId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | $Enums.FeedbackSource
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CrisisResourceUsageCreateInput = {
    id?: string
    resourceId: string
    accessedAt?: Date | string
    timeSpent?: number | null
    wasHelpful?: boolean | null
    helpfulRating?: number | null
    resourceTitle: string
    resourceType: $Enums.ResourceCategory
    session: CrisisSessionCreateNestedOneWithoutResourcesInput
  }

  export type CrisisResourceUsageUncheckedCreateInput = {
    id?: string
    sessionId: string
    resourceId: string
    accessedAt?: Date | string
    timeSpent?: number | null
    wasHelpful?: boolean | null
    helpfulRating?: number | null
    resourceTitle: string
    resourceType: $Enums.ResourceCategory
  }

  export type CrisisResourceUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    helpfulRating?: NullableIntFieldUpdateOperationsInput | number | null
    resourceTitle?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceCategoryFieldUpdateOperationsInput | $Enums.ResourceCategory
    session?: CrisisSessionUpdateOneRequiredWithoutResourcesNestedInput
  }

  export type CrisisResourceUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    helpfulRating?: NullableIntFieldUpdateOperationsInput | number | null
    resourceTitle?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceCategoryFieldUpdateOperationsInput | $Enums.ResourceCategory
  }

  export type CrisisResourceUsageCreateManyInput = {
    id?: string
    sessionId: string
    resourceId: string
    accessedAt?: Date | string
    timeSpent?: number | null
    wasHelpful?: boolean | null
    helpfulRating?: number | null
    resourceTitle: string
    resourceType: $Enums.ResourceCategory
  }

  export type CrisisResourceUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    helpfulRating?: NullableIntFieldUpdateOperationsInput | number | null
    resourceTitle?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceCategoryFieldUpdateOperationsInput | $Enums.ResourceCategory
  }

  export type CrisisResourceUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    helpfulRating?: NullableIntFieldUpdateOperationsInput | number | null
    resourceTitle?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceCategoryFieldUpdateOperationsInput | $Enums.ResourceCategory
  }

  export type SafetyReportCreateInput = {
    id?: string
    sessionId?: string | null
    messageId?: string | null
    reportType: $Enums.ReportType
    severity: $Enums.ReportSeverity
    status?: $Enums.ReportStatus
    content?: string | null
    reason: string
    confidence: number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    keywordsMatched?: string | null
    riskScore: number
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SafetyReportUncheckedCreateInput = {
    id?: string
    sessionId?: string | null
    messageId?: string | null
    reportType: $Enums.ReportType
    severity: $Enums.ReportSeverity
    status?: $Enums.ReportStatus
    content?: string | null
    reason: string
    confidence: number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    keywordsMatched?: string | null
    riskScore: number
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SafetyReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    severity?: EnumReportSeverityFieldUpdateOperationsInput | $Enums.ReportSeverity
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    keywordsMatched?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: IntFieldUpdateOperationsInput | number
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetyReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    severity?: EnumReportSeverityFieldUpdateOperationsInput | $Enums.ReportSeverity
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    keywordsMatched?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: IntFieldUpdateOperationsInput | number
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetyReportCreateManyInput = {
    id?: string
    sessionId?: string | null
    messageId?: string | null
    reportType: $Enums.ReportType
    severity: $Enums.ReportSeverity
    status?: $Enums.ReportStatus
    content?: string | null
    reason: string
    confidence: number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    keywordsMatched?: string | null
    riskScore: number
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SafetyReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    severity?: EnumReportSeverityFieldUpdateOperationsInput | $Enums.ReportSeverity
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    keywordsMatched?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: IntFieldUpdateOperationsInput | number
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetyReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    severity?: EnumReportSeverityFieldUpdateOperationsInput | $Enums.ReportSeverity
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    keywordsMatched?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: IntFieldUpdateOperationsInput | number
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    timestamp?: Date | string
    sessionId?: string | null
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    timestamp?: Date | string
    sessionId?: string | null
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    timestamp?: Date | string
    sessionId?: string | null
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnalyticsEventCreateInput = {
    id?: string
    eventType: string
    eventName: string
    userHash?: string | null
    sessionId?: string | null
    properties?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    responseTime?: number | null
    success?: boolean
    errorCode?: string | null
  }

  export type AnalyticsEventUncheckedCreateInput = {
    id?: string
    eventType: string
    eventName: string
    userHash?: string | null
    sessionId?: string | null
    properties?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    responseTime?: number | null
    success?: boolean
    errorCode?: string | null
  }

  export type AnalyticsEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    userHash?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnalyticsEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    userHash?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnalyticsEventCreateManyInput = {
    id?: string
    eventType: string
    eventName: string
    userHash?: string | null
    sessionId?: string | null
    properties?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    responseTime?: number | null
    success?: boolean
    errorCode?: string | null
  }

  export type AnalyticsEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    userHash?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnalyticsEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    userHash?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PerformanceMetricCreateInput = {
    id?: string
    metricType: string
    value: number
    unit: string
    endpoint?: string | null
    region?: string | null
    timestamp?: Date | string
    target?: number | null
    threshold?: number | null
    status?: $Enums.MetricStatus
  }

  export type PerformanceMetricUncheckedCreateInput = {
    id?: string
    metricType: string
    value: number
    unit: string
    endpoint?: string | null
    region?: string | null
    timestamp?: Date | string
    target?: number | null
    threshold?: number | null
    status?: $Enums.MetricStatus
  }

  export type PerformanceMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    target?: NullableFloatFieldUpdateOperationsInput | number | null
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumMetricStatusFieldUpdateOperationsInput | $Enums.MetricStatus
  }

  export type PerformanceMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    target?: NullableFloatFieldUpdateOperationsInput | number | null
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumMetricStatusFieldUpdateOperationsInput | $Enums.MetricStatus
  }

  export type PerformanceMetricCreateManyInput = {
    id?: string
    metricType: string
    value: number
    unit: string
    endpoint?: string | null
    region?: string | null
    timestamp?: Date | string
    target?: number | null
    threshold?: number | null
    status?: $Enums.MetricStatus
  }

  export type PerformanceMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    target?: NullableFloatFieldUpdateOperationsInput | number | null
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumMetricStatusFieldUpdateOperationsInput | $Enums.MetricStatus
  }

  export type PerformanceMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    target?: NullableFloatFieldUpdateOperationsInput | number | null
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumMetricStatusFieldUpdateOperationsInput | $Enums.MetricStatus
  }

  export type SystemHealthCreateInput = {
    id?: string
    component: string
    status: $Enums.HealthStatus
    responseTime?: number | null
    uptime?: number | null
    errorRate?: number | null
    lastError?: Date | string | null
    errorMessage?: string | null
    cpuUsage?: number | null
    memoryUsage?: number | null
    diskUsage?: number | null
    timestamp?: Date | string
  }

  export type SystemHealthUncheckedCreateInput = {
    id?: string
    component: string
    status: $Enums.HealthStatus
    responseTime?: number | null
    uptime?: number | null
    errorRate?: number | null
    lastError?: Date | string | null
    errorMessage?: string | null
    cpuUsage?: number | null
    memoryUsage?: number | null
    diskUsage?: number | null
    timestamp?: Date | string
  }

  export type SystemHealthUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    status?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    responseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: NullableFloatFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    lastError?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemHealthUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    status?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    responseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: NullableFloatFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    lastError?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemHealthCreateManyInput = {
    id?: string
    component: string
    status: $Enums.HealthStatus
    responseTime?: number | null
    uptime?: number | null
    errorRate?: number | null
    lastError?: Date | string | null
    errorMessage?: string | null
    cpuUsage?: number | null
    memoryUsage?: number | null
    diskUsage?: number | null
    timestamp?: Date | string
  }

  export type SystemHealthUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    status?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    responseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: NullableFloatFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    lastError?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemHealthUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    status?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    responseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: NullableFloatFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    lastError?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrisisResourceCreateInput = {
    id?: string
    title: string
    description: string
    category: $Enums.ResourceCategory
    phoneNumber?: string | null
    url?: string | null
    email?: string | null
    textNumber?: string | null
    content?: string | null
    instructions?: string | null
    available24_7?: boolean
    languages?: string | null
    countries?: string | null
    regions?: string | null
    priority?: number
    isEmergency?: boolean
    severityMin?: number
    tags?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrisisResourceUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    category: $Enums.ResourceCategory
    phoneNumber?: string | null
    url?: string | null
    email?: string | null
    textNumber?: string | null
    content?: string | null
    instructions?: string | null
    available24_7?: boolean
    languages?: string | null
    countries?: string | null
    regions?: string | null
    priority?: number
    isEmergency?: boolean
    severityMin?: number
    tags?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrisisResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumResourceCategoryFieldUpdateOperationsInput | $Enums.ResourceCategory
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    textNumber?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    available24_7?: BoolFieldUpdateOperationsInput | boolean
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    countries?: NullableStringFieldUpdateOperationsInput | string | null
    regions?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    severityMin?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrisisResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumResourceCategoryFieldUpdateOperationsInput | $Enums.ResourceCategory
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    textNumber?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    available24_7?: BoolFieldUpdateOperationsInput | boolean
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    countries?: NullableStringFieldUpdateOperationsInput | string | null
    regions?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    severityMin?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrisisResourceCreateManyInput = {
    id?: string
    title: string
    description: string
    category: $Enums.ResourceCategory
    phoneNumber?: string | null
    url?: string | null
    email?: string | null
    textNumber?: string | null
    content?: string | null
    instructions?: string | null
    available24_7?: boolean
    languages?: string | null
    countries?: string | null
    regions?: string | null
    priority?: number
    isEmergency?: boolean
    severityMin?: number
    tags?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrisisResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumResourceCategoryFieldUpdateOperationsInput | $Enums.ResourceCategory
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    textNumber?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    available24_7?: BoolFieldUpdateOperationsInput | boolean
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    countries?: NullableStringFieldUpdateOperationsInput | string | null
    regions?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    severityMin?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrisisResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumResourceCategoryFieldUpdateOperationsInput | $Enums.ResourceCategory
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    textNumber?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    available24_7?: BoolFieldUpdateOperationsInput | boolean
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    countries?: NullableStringFieldUpdateOperationsInput | string | null
    regions?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    severityMin?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicMetricsCreateInput = {
    id?: string
    metricName: string
    value: number
    displayValue: string
    description: string
    isPublic?: boolean
    displayOrder?: number
    icon?: string | null
    color?: string | null
    lastUpdated?: Date | string
    updateFrequency?: string
  }

  export type PublicMetricsUncheckedCreateInput = {
    id?: string
    metricName: string
    value: number
    displayValue: string
    description: string
    isPublic?: boolean
    displayOrder?: number
    icon?: string | null
    color?: string | null
    lastUpdated?: Date | string
    updateFrequency?: string
  }

  export type PublicMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    displayValue?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updateFrequency?: StringFieldUpdateOperationsInput | string
  }

  export type PublicMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    displayValue?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updateFrequency?: StringFieldUpdateOperationsInput | string
  }

  export type PublicMetricsCreateManyInput = {
    id?: string
    metricName: string
    value: number
    displayValue: string
    description: string
    isPublic?: boolean
    displayOrder?: number
    icon?: string | null
    color?: string | null
    lastUpdated?: Date | string
    updateFrequency?: string
  }

  export type PublicMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    displayValue?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updateFrequency?: StringFieldUpdateOperationsInput | string
  }

  export type PublicMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    displayValue?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updateFrequency?: StringFieldUpdateOperationsInput | string
  }

  export type EmergencyContactCreateInput = {
    id?: string
    encryptedName: Uint8Array
    encryptedPhone: Uint8Array
    encryptedEmail?: Uint8Array | null
    relationship: string
    priority?: number
    contactMethod?: string
    timezone?: string | null
    availableHours?: NullableJsonNullValueInput | InputJsonValue
    preferredMethod?: string | null
    autoNotify?: boolean
    crisisOnly?: boolean
    hasConsent?: boolean
    consentDate?: Date | string | null
    keyDerivationSalt: Uint8Array
    isVerified?: boolean
    verifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContacted?: Date | string | null
    user: UserCreateNestedOneWithoutEmergencyContactsInput
    notifications?: EmergencyNotificationCreateNestedManyWithoutEmergencyContactInput
  }

  export type EmergencyContactUncheckedCreateInput = {
    id?: string
    userId: string
    encryptedName: Uint8Array
    encryptedPhone: Uint8Array
    encryptedEmail?: Uint8Array | null
    relationship: string
    priority?: number
    contactMethod?: string
    timezone?: string | null
    availableHours?: NullableJsonNullValueInput | InputJsonValue
    preferredMethod?: string | null
    autoNotify?: boolean
    crisisOnly?: boolean
    hasConsent?: boolean
    consentDate?: Date | string | null
    keyDerivationSalt: Uint8Array
    isVerified?: boolean
    verifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContacted?: Date | string | null
    notifications?: EmergencyNotificationUncheckedCreateNestedManyWithoutEmergencyContactInput
  }

  export type EmergencyContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedName?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedPhone?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    relationship?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    contactMethod?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    availableHours?: NullableJsonNullValueInput | InputJsonValue
    preferredMethod?: NullableStringFieldUpdateOperationsInput | string | null
    autoNotify?: BoolFieldUpdateOperationsInput | boolean
    crisisOnly?: BoolFieldUpdateOperationsInput | boolean
    hasConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keyDerivationSalt?: BytesFieldUpdateOperationsInput | Uint8Array
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContacted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutEmergencyContactsNestedInput
    notifications?: EmergencyNotificationUpdateManyWithoutEmergencyContactNestedInput
  }

  export type EmergencyContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    encryptedName?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedPhone?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    relationship?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    contactMethod?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    availableHours?: NullableJsonNullValueInput | InputJsonValue
    preferredMethod?: NullableStringFieldUpdateOperationsInput | string | null
    autoNotify?: BoolFieldUpdateOperationsInput | boolean
    crisisOnly?: BoolFieldUpdateOperationsInput | boolean
    hasConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keyDerivationSalt?: BytesFieldUpdateOperationsInput | Uint8Array
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContacted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifications?: EmergencyNotificationUncheckedUpdateManyWithoutEmergencyContactNestedInput
  }

  export type EmergencyContactCreateManyInput = {
    id?: string
    userId: string
    encryptedName: Uint8Array
    encryptedPhone: Uint8Array
    encryptedEmail?: Uint8Array | null
    relationship: string
    priority?: number
    contactMethod?: string
    timezone?: string | null
    availableHours?: NullableJsonNullValueInput | InputJsonValue
    preferredMethod?: string | null
    autoNotify?: boolean
    crisisOnly?: boolean
    hasConsent?: boolean
    consentDate?: Date | string | null
    keyDerivationSalt: Uint8Array
    isVerified?: boolean
    verifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContacted?: Date | string | null
  }

  export type EmergencyContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedName?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedPhone?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    relationship?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    contactMethod?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    availableHours?: NullableJsonNullValueInput | InputJsonValue
    preferredMethod?: NullableStringFieldUpdateOperationsInput | string | null
    autoNotify?: BoolFieldUpdateOperationsInput | boolean
    crisisOnly?: BoolFieldUpdateOperationsInput | boolean
    hasConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keyDerivationSalt?: BytesFieldUpdateOperationsInput | Uint8Array
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContacted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    encryptedName?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedPhone?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    relationship?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    contactMethod?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    availableHours?: NullableJsonNullValueInput | InputJsonValue
    preferredMethod?: NullableStringFieldUpdateOperationsInput | string | null
    autoNotify?: BoolFieldUpdateOperationsInput | boolean
    crisisOnly?: BoolFieldUpdateOperationsInput | boolean
    hasConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keyDerivationSalt?: BytesFieldUpdateOperationsInput | Uint8Array
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContacted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyNotificationCreateInput = {
    id?: string
    sessionId?: string | null
    tetherEmergencyId?: string | null
    notificationType: $Enums.EmergencyNotificationType
    severity: $Enums.EmergencySeverity
    message: string
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    acknowledgedAt?: Date | string | null
    responseReceived?: boolean
    responseTime?: number | null
    method: string
    status?: $Enums.NotificationStatus
    attempts?: number
    maxAttempts?: number
    errorMessage?: string | null
    nextRetryAt?: Date | string | null
    emergencyContact: EmergencyContactCreateNestedOneWithoutNotificationsInput
  }

  export type EmergencyNotificationUncheckedCreateInput = {
    id?: string
    emergencyContactId: string
    sessionId?: string | null
    tetherEmergencyId?: string | null
    notificationType: $Enums.EmergencyNotificationType
    severity: $Enums.EmergencySeverity
    message: string
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    acknowledgedAt?: Date | string | null
    responseReceived?: boolean
    responseTime?: number | null
    method: string
    status?: $Enums.NotificationStatus
    attempts?: number
    maxAttempts?: number
    errorMessage?: string | null
    nextRetryAt?: Date | string | null
  }

  export type EmergencyNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    tetherEmergencyId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumEmergencyNotificationTypeFieldUpdateOperationsInput | $Enums.EmergencyNotificationType
    severity?: EnumEmergencySeverityFieldUpdateOperationsInput | $Enums.EmergencySeverity
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseReceived?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    method?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergencyContact?: EmergencyContactUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type EmergencyNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emergencyContactId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    tetherEmergencyId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumEmergencyNotificationTypeFieldUpdateOperationsInput | $Enums.EmergencyNotificationType
    severity?: EnumEmergencySeverityFieldUpdateOperationsInput | $Enums.EmergencySeverity
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseReceived?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    method?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyNotificationCreateManyInput = {
    id?: string
    emergencyContactId: string
    sessionId?: string | null
    tetherEmergencyId?: string | null
    notificationType: $Enums.EmergencyNotificationType
    severity: $Enums.EmergencySeverity
    message: string
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    acknowledgedAt?: Date | string | null
    responseReceived?: boolean
    responseTime?: number | null
    method: string
    status?: $Enums.NotificationStatus
    attempts?: number
    maxAttempts?: number
    errorMessage?: string | null
    nextRetryAt?: Date | string | null
  }

  export type EmergencyNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    tetherEmergencyId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumEmergencyNotificationTypeFieldUpdateOperationsInput | $Enums.EmergencyNotificationType
    severity?: EnumEmergencySeverityFieldUpdateOperationsInput | $Enums.EmergencySeverity
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseReceived?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    method?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    emergencyContactId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    tetherEmergencyId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumEmergencyNotificationTypeFieldUpdateOperationsInput | $Enums.EmergencyNotificationType
    severity?: EnumEmergencySeverityFieldUpdateOperationsInput | $Enums.EmergencySeverity
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseReceived?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    method?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebSocketConnectionCreateInput = {
    id?: string
    sessionId: string
    userType: string
    userId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    lastActivity?: Date | string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type WebSocketConnectionUncheckedCreateInput = {
    id?: string
    sessionId: string
    userType: string
    userId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    lastActivity?: Date | string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type WebSocketConnectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebSocketConnectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebSocketConnectionCreateManyInput = {
    id?: string
    sessionId: string
    userType: string
    userId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    lastActivity?: Date | string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type WebSocketConnectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebSocketConnectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    challenges?: UserChallengeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    challenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionUncheckedCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionUncheckedCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUncheckedUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUncheckedUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodEntryCreateInput = {
    id?: string
    mood: number
    emotions: JsonNullValueInput | InputJsonValue
    triggers: JsonNullValueInput | InputJsonValue
    activities: JsonNullValueInput | InputJsonValue
    sleepHours?: number | null
    notes?: string | null
    weather?: string | null
    medication?: boolean | null
    socialInteraction?: number | null
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutMoodEntriesInput
  }

  export type MoodEntryUncheckedCreateInput = {
    id?: string
    userId: string
    mood: number
    emotions: JsonNullValueInput | InputJsonValue
    triggers: JsonNullValueInput | InputJsonValue
    activities: JsonNullValueInput | InputJsonValue
    sleepHours?: number | null
    notes?: string | null
    weather?: string | null
    medication?: boolean | null
    socialInteraction?: number | null
    timestamp?: Date | string
  }

  export type MoodEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: IntFieldUpdateOperationsInput | number
    emotions?: JsonNullValueInput | InputJsonValue
    triggers?: JsonNullValueInput | InputJsonValue
    activities?: JsonNullValueInput | InputJsonValue
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    medication?: NullableBoolFieldUpdateOperationsInput | boolean | null
    socialInteraction?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMoodEntriesNestedInput
  }

  export type MoodEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mood?: IntFieldUpdateOperationsInput | number
    emotions?: JsonNullValueInput | InputJsonValue
    triggers?: JsonNullValueInput | InputJsonValue
    activities?: JsonNullValueInput | InputJsonValue
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    medication?: NullableBoolFieldUpdateOperationsInput | boolean | null
    socialInteraction?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodEntryCreateManyInput = {
    id?: string
    userId: string
    mood: number
    emotions: JsonNullValueInput | InputJsonValue
    triggers: JsonNullValueInput | InputJsonValue
    activities: JsonNullValueInput | InputJsonValue
    sleepHours?: number | null
    notes?: string | null
    weather?: string | null
    medication?: boolean | null
    socialInteraction?: number | null
    timestamp?: Date | string
  }

  export type MoodEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: IntFieldUpdateOperationsInput | number
    emotions?: JsonNullValueInput | InputJsonValue
    triggers?: JsonNullValueInput | InputJsonValue
    activities?: JsonNullValueInput | InputJsonValue
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    medication?: NullableBoolFieldUpdateOperationsInput | boolean | null
    socialInteraction?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mood?: IntFieldUpdateOperationsInput | number
    emotions?: JsonNullValueInput | InputJsonValue
    triggers?: JsonNullValueInput | InputJsonValue
    activities?: JsonNullValueInput | InputJsonValue
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    medication?: NullableBoolFieldUpdateOperationsInput | boolean | null
    socialInteraction?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetyPlanCreateInput = {
    id?: string
    title: string
    version?: number
    isActive?: boolean
    encryptedContent: Uint8Array
    contentHash: string
    sharedWith?: NullableJsonNullValueInput | InputJsonValue
    emergencyShare?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSafetyPlansInput
    versions?: SafetyPlanVersionCreateNestedManyWithoutSafetyPlanInput
  }

  export type SafetyPlanUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    version?: number
    isActive?: boolean
    encryptedContent: Uint8Array
    contentHash: string
    sharedWith?: NullableJsonNullValueInput | InputJsonValue
    emergencyShare?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: SafetyPlanVersionUncheckedCreateNestedManyWithoutSafetyPlanInput
  }

  export type SafetyPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    sharedWith?: NullableJsonNullValueInput | InputJsonValue
    emergencyShare?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSafetyPlansNestedInput
    versions?: SafetyPlanVersionUpdateManyWithoutSafetyPlanNestedInput
  }

  export type SafetyPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    sharedWith?: NullableJsonNullValueInput | InputJsonValue
    emergencyShare?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: SafetyPlanVersionUncheckedUpdateManyWithoutSafetyPlanNestedInput
  }

  export type SafetyPlanCreateManyInput = {
    id?: string
    userId: string
    title: string
    version?: number
    isActive?: boolean
    encryptedContent: Uint8Array
    contentHash: string
    sharedWith?: NullableJsonNullValueInput | InputJsonValue
    emergencyShare?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SafetyPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    sharedWith?: NullableJsonNullValueInput | InputJsonValue
    emergencyShare?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetyPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    sharedWith?: NullableJsonNullValueInput | InputJsonValue
    emergencyShare?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetyPlanVersionCreateInput = {
    id?: string
    version: number
    changeLog?: string | null
    encryptedContent: Uint8Array
    contentHash: string
    createdAt?: Date | string
    createdBy: string
    safetyPlan: SafetyPlanCreateNestedOneWithoutVersionsInput
  }

  export type SafetyPlanVersionUncheckedCreateInput = {
    id?: string
    safetyPlanId: string
    version: number
    changeLog?: string | null
    encryptedContent: Uint8Array
    contentHash: string
    createdAt?: Date | string
    createdBy: string
  }

  export type SafetyPlanVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    changeLog?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    safetyPlan?: SafetyPlanUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type SafetyPlanVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    safetyPlanId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    changeLog?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type SafetyPlanVersionCreateManyInput = {
    id?: string
    safetyPlanId: string
    version: number
    changeLog?: string | null
    encryptedContent: Uint8Array
    contentHash: string
    createdAt?: Date | string
    createdBy: string
  }

  export type SafetyPlanVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    changeLog?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type SafetyPlanVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    safetyPlanId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    changeLog?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type UserProfileCreateInput = {
    id?: string
    displayName: string
    level?: number
    totalXP?: number
    preferences: JsonNullValueInput | InputJsonValue
    stats: JsonNullValueInput | InputJsonValue
    joinDate?: Date | string
    lastActiveDate?: Date | string
    user: UserCreateNestedOneWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: string
    userId: string
    displayName: string
    level?: number
    totalXP?: number
    preferences: JsonNullValueInput | InputJsonValue
    stats: JsonNullValueInput | InputJsonValue
    joinDate?: Date | string
    lastActiveDate?: Date | string
  }

  export type UserProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    preferences?: JsonNullValueInput | InputJsonValue
    stats?: JsonNullValueInput | InputJsonValue
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    preferences?: JsonNullValueInput | InputJsonValue
    stats?: JsonNullValueInput | InputJsonValue
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateManyInput = {
    id?: string
    userId: string
    displayName: string
    level?: number
    totalXP?: number
    preferences: JsonNullValueInput | InputJsonValue
    stats: JsonNullValueInput | InputJsonValue
    joinDate?: Date | string
    lastActiveDate?: Date | string
  }

  export type UserProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    preferences?: JsonNullValueInput | InputJsonValue
    stats?: JsonNullValueInput | InputJsonValue
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    preferences?: JsonNullValueInput | InputJsonValue
    stats?: JsonNullValueInput | InputJsonValue
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateInput = {
    id?: string
    name: string
    description: string
    category: $Enums.AchievementCategory
    rarity?: $Enums.AchievementRarity
    requirements: JsonNullValueInput | InputJsonValue
    xpReward?: number
    pointReward?: number
    icon?: string | null
    color?: string | null
    isActive?: boolean
    userAchievements?: UserAchievementCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    category: $Enums.AchievementCategory
    rarity?: $Enums.AchievementRarity
    requirements: JsonNullValueInput | InputJsonValue
    xpReward?: number
    pointReward?: number
    icon?: string | null
    color?: string | null
    isActive?: boolean
    userAchievements?: UserAchievementUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    rarity?: EnumAchievementRarityFieldUpdateOperationsInput | $Enums.AchievementRarity
    requirements?: JsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    pointReward?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userAchievements?: UserAchievementUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    rarity?: EnumAchievementRarityFieldUpdateOperationsInput | $Enums.AchievementRarity
    requirements?: JsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    pointReward?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userAchievements?: UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementCreateManyInput = {
    id?: string
    name: string
    description: string
    category: $Enums.AchievementCategory
    rarity?: $Enums.AchievementRarity
    requirements: JsonNullValueInput | InputJsonValue
    xpReward?: number
    pointReward?: number
    icon?: string | null
    color?: string | null
    isActive?: boolean
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    rarity?: EnumAchievementRarityFieldUpdateOperationsInput | $Enums.AchievementRarity
    requirements?: JsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    pointReward?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    rarity?: EnumAchievementRarityFieldUpdateOperationsInput | $Enums.AchievementRarity
    requirements?: JsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    pointReward?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAchievementCreateInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAchievementsInput
    achievement: AchievementCreateNestedOneWithoutUserAchievementsInput
  }

  export type UserAchievementUncheckedCreateInput = {
    id?: string
    userId: string
    achievementId: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateManyInput = {
    id?: string
    userId: string
    achievementId: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeCreateInput = {
    id?: string
    name: string
    description: string
    type: $Enums.ChallengeType
    difficulty?: $Enums.ChallengeDifficulty
    requirements: JsonNullValueInput | InputJsonValue
    duration: number
    xpReward?: number
    pointReward?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    userChallenges?: UserChallengeCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    type: $Enums.ChallengeType
    difficulty?: $Enums.ChallengeDifficulty
    requirements: JsonNullValueInput | InputJsonValue
    duration: number
    xpReward?: number
    pointReward?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    difficulty?: EnumChallengeDifficultyFieldUpdateOperationsInput | $Enums.ChallengeDifficulty
    requirements?: JsonNullValueInput | InputJsonValue
    duration?: IntFieldUpdateOperationsInput | number
    xpReward?: IntFieldUpdateOperationsInput | number
    pointReward?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userChallenges?: UserChallengeUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    difficulty?: EnumChallengeDifficultyFieldUpdateOperationsInput | $Enums.ChallengeDifficulty
    requirements?: JsonNullValueInput | InputJsonValue
    duration?: IntFieldUpdateOperationsInput | number
    xpReward?: IntFieldUpdateOperationsInput | number
    pointReward?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateManyInput = {
    id?: string
    name: string
    description: string
    type: $Enums.ChallengeType
    difficulty?: $Enums.ChallengeDifficulty
    requirements: JsonNullValueInput | InputJsonValue
    duration: number
    xpReward?: number
    pointReward?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
  }

  export type ChallengeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    difficulty?: EnumChallengeDifficultyFieldUpdateOperationsInput | $Enums.ChallengeDifficulty
    requirements?: JsonNullValueInput | InputJsonValue
    duration?: IntFieldUpdateOperationsInput | number
    xpReward?: IntFieldUpdateOperationsInput | number
    pointReward?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChallengeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    difficulty?: EnumChallengeDifficultyFieldUpdateOperationsInput | $Enums.ChallengeDifficulty
    requirements?: JsonNullValueInput | InputJsonValue
    duration?: IntFieldUpdateOperationsInput | number
    xpReward?: IntFieldUpdateOperationsInput | number
    pointReward?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserChallengeCreateInput = {
    id?: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    startedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutChallengesInput
    challenge: ChallengeCreateNestedOneWithoutUserChallengesInput
  }

  export type UserChallengeUncheckedCreateInput = {
    id?: string
    userId: string
    challengeId: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    startedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserChallengeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutChallengesNestedInput
    challenge?: ChallengeUpdateOneRequiredWithoutUserChallengesNestedInput
  }

  export type UserChallengeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserChallengeCreateManyInput = {
    id?: string
    userId: string
    challengeId: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    startedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserChallengeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserChallengeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserActivityCreateInput = {
    id?: string
    type: $Enums.ActivityType
    description: string
    xpEarned?: number
    pointsEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
  }

  export type UserActivityUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description: string
    xpEarned?: number
    pointsEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type UserActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: StringFieldUpdateOperationsInput | string
    xpEarned?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type UserActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: StringFieldUpdateOperationsInput | string
    xpEarned?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description: string
    xpEarned?: number
    pointsEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type UserActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: StringFieldUpdateOperationsInput | string
    xpEarned?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: StringFieldUpdateOperationsInput | string
    xpEarned?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryCreateInput = {
    id?: string
    title?: string | null
    promptId?: string | null
    promptText?: string | null
    entryType?: $Enums.JournalType
    encryptedContent: Uint8Array
    contentHash: string
    keyDerivationSalt: Uint8Array
    mood?: number | null
    sentimentScore?: number | null
    emotions?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    isPrivate?: boolean
    shareWithTherapist?: boolean
    wordCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutJournalEntriesInput
  }

  export type JournalEntryUncheckedCreateInput = {
    id?: string
    userId: string
    title?: string | null
    promptId?: string | null
    promptText?: string | null
    entryType?: $Enums.JournalType
    encryptedContent: Uint8Array
    contentHash: string
    keyDerivationSalt: Uint8Array
    mood?: number | null
    sentimentScore?: number | null
    emotions?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    isPrivate?: boolean
    shareWithTherapist?: boolean
    wordCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    promptText?: NullableStringFieldUpdateOperationsInput | string | null
    entryType?: EnumJournalTypeFieldUpdateOperationsInput | $Enums.JournalType
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    keyDerivationSalt?: BytesFieldUpdateOperationsInput | Uint8Array
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    emotions?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    shareWithTherapist?: BoolFieldUpdateOperationsInput | boolean
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutJournalEntriesNestedInput
  }

  export type JournalEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    promptText?: NullableStringFieldUpdateOperationsInput | string | null
    entryType?: EnumJournalTypeFieldUpdateOperationsInput | $Enums.JournalType
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    keyDerivationSalt?: BytesFieldUpdateOperationsInput | Uint8Array
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    emotions?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    shareWithTherapist?: BoolFieldUpdateOperationsInput | boolean
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryCreateManyInput = {
    id?: string
    userId: string
    title?: string | null
    promptId?: string | null
    promptText?: string | null
    entryType?: $Enums.JournalType
    encryptedContent: Uint8Array
    contentHash: string
    keyDerivationSalt: Uint8Array
    mood?: number | null
    sentimentScore?: number | null
    emotions?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    isPrivate?: boolean
    shareWithTherapist?: boolean
    wordCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    promptText?: NullableStringFieldUpdateOperationsInput | string | null
    entryType?: EnumJournalTypeFieldUpdateOperationsInput | $Enums.JournalType
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    keyDerivationSalt?: BytesFieldUpdateOperationsInput | Uint8Array
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    emotions?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    shareWithTherapist?: BoolFieldUpdateOperationsInput | boolean
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    promptText?: NullableStringFieldUpdateOperationsInput | string | null
    entryType?: EnumJournalTypeFieldUpdateOperationsInput | $Enums.JournalType
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    keyDerivationSalt?: BytesFieldUpdateOperationsInput | Uint8Array
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    emotions?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    shareWithTherapist?: BoolFieldUpdateOperationsInput | boolean
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreathingExerciseCreateInput = {
    id?: string
    name: string
    description: string
    technique: $Enums.BreathingTechnique
    difficulty?: $Enums.ExerciseDifficulty
    inhaleSeconds: number
    holdSeconds?: number | null
    exhaleSeconds: number
    pauseSeconds?: number | null
    cyclesRecommended?: number
    instructions: JsonNullValueInput | InputJsonValue
    visualGuideUrl?: string | null
    audioGuideUrl?: string | null
    benefits: JsonNullValueInput | InputJsonValue
    bestFor: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    sessions?: BreathingSessionCreateNestedManyWithoutExerciseInput
  }

  export type BreathingExerciseUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    technique: $Enums.BreathingTechnique
    difficulty?: $Enums.ExerciseDifficulty
    inhaleSeconds: number
    holdSeconds?: number | null
    exhaleSeconds: number
    pauseSeconds?: number | null
    cyclesRecommended?: number
    instructions: JsonNullValueInput | InputJsonValue
    visualGuideUrl?: string | null
    audioGuideUrl?: string | null
    benefits: JsonNullValueInput | InputJsonValue
    bestFor: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    sessions?: BreathingSessionUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type BreathingExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    technique?: EnumBreathingTechniqueFieldUpdateOperationsInput | $Enums.BreathingTechnique
    difficulty?: EnumExerciseDifficultyFieldUpdateOperationsInput | $Enums.ExerciseDifficulty
    inhaleSeconds?: IntFieldUpdateOperationsInput | number
    holdSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    exhaleSeconds?: IntFieldUpdateOperationsInput | number
    pauseSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    cyclesRecommended?: IntFieldUpdateOperationsInput | number
    instructions?: JsonNullValueInput | InputJsonValue
    visualGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: JsonNullValueInput | InputJsonValue
    bestFor?: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: BreathingSessionUpdateManyWithoutExerciseNestedInput
  }

  export type BreathingExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    technique?: EnumBreathingTechniqueFieldUpdateOperationsInput | $Enums.BreathingTechnique
    difficulty?: EnumExerciseDifficultyFieldUpdateOperationsInput | $Enums.ExerciseDifficulty
    inhaleSeconds?: IntFieldUpdateOperationsInput | number
    holdSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    exhaleSeconds?: IntFieldUpdateOperationsInput | number
    pauseSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    cyclesRecommended?: IntFieldUpdateOperationsInput | number
    instructions?: JsonNullValueInput | InputJsonValue
    visualGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: JsonNullValueInput | InputJsonValue
    bestFor?: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: BreathingSessionUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type BreathingExerciseCreateManyInput = {
    id?: string
    name: string
    description: string
    technique: $Enums.BreathingTechnique
    difficulty?: $Enums.ExerciseDifficulty
    inhaleSeconds: number
    holdSeconds?: number | null
    exhaleSeconds: number
    pauseSeconds?: number | null
    cyclesRecommended?: number
    instructions: JsonNullValueInput | InputJsonValue
    visualGuideUrl?: string | null
    audioGuideUrl?: string | null
    benefits: JsonNullValueInput | InputJsonValue
    bestFor: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
  }

  export type BreathingExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    technique?: EnumBreathingTechniqueFieldUpdateOperationsInput | $Enums.BreathingTechnique
    difficulty?: EnumExerciseDifficultyFieldUpdateOperationsInput | $Enums.ExerciseDifficulty
    inhaleSeconds?: IntFieldUpdateOperationsInput | number
    holdSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    exhaleSeconds?: IntFieldUpdateOperationsInput | number
    pauseSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    cyclesRecommended?: IntFieldUpdateOperationsInput | number
    instructions?: JsonNullValueInput | InputJsonValue
    visualGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: JsonNullValueInput | InputJsonValue
    bestFor?: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreathingExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    technique?: EnumBreathingTechniqueFieldUpdateOperationsInput | $Enums.BreathingTechnique
    difficulty?: EnumExerciseDifficultyFieldUpdateOperationsInput | $Enums.ExerciseDifficulty
    inhaleSeconds?: IntFieldUpdateOperationsInput | number
    holdSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    exhaleSeconds?: IntFieldUpdateOperationsInput | number
    pauseSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    cyclesRecommended?: IntFieldUpdateOperationsInput | number
    instructions?: JsonNullValueInput | InputJsonValue
    visualGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: JsonNullValueInput | InputJsonValue
    bestFor?: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreathingSessionCreateInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    cyclesCompleted?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    averageBreathRate?: number | null
    heartRateBefore?: number | null
    heartRateAfter?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    user: UserCreateNestedOneWithoutBreathingSessionsInput
    exercise: BreathingExerciseCreateNestedOneWithoutSessionsInput
  }

  export type BreathingSessionUncheckedCreateInput = {
    id?: string
    userId: string
    exerciseId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    cyclesCompleted?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    averageBreathRate?: number | null
    heartRateBefore?: number | null
    heartRateAfter?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
  }

  export type BreathingSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cyclesCompleted?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    averageBreathRate?: NullableFloatFieldUpdateOperationsInput | number | null
    heartRateBefore?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAfter?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBreathingSessionsNestedInput
    exercise?: BreathingExerciseUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type BreathingSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cyclesCompleted?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    averageBreathRate?: NullableFloatFieldUpdateOperationsInput | number | null
    heartRateBefore?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAfter?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BreathingSessionCreateManyInput = {
    id?: string
    userId: string
    exerciseId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    cyclesCompleted?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    averageBreathRate?: number | null
    heartRateBefore?: number | null
    heartRateAfter?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
  }

  export type BreathingSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cyclesCompleted?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    averageBreathRate?: NullableFloatFieldUpdateOperationsInput | number | null
    heartRateBefore?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAfter?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BreathingSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cyclesCompleted?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    averageBreathRate?: NullableFloatFieldUpdateOperationsInput | number | null
    heartRateBefore?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAfter?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroundingTechniqueCreateInput = {
    id?: string
    name: string
    description: string
    type: $Enums.GroundingType
    category: $Enums.GroundingCategory
    instructions: JsonNullValueInput | InputJsonValue
    duration: number
    materials?: NullableJsonNullValueInput | InputJsonValue
    audioGuideUrl?: string | null
    videoGuideUrl?: string | null
    imageGuides?: NullableJsonNullValueInput | InputJsonValue
    evidenceLevel?: $Enums.EvidenceLevel
    bestFor: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    sessions?: GroundingSessionCreateNestedManyWithoutTechniqueInput
  }

  export type GroundingTechniqueUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    type: $Enums.GroundingType
    category: $Enums.GroundingCategory
    instructions: JsonNullValueInput | InputJsonValue
    duration: number
    materials?: NullableJsonNullValueInput | InputJsonValue
    audioGuideUrl?: string | null
    videoGuideUrl?: string | null
    imageGuides?: NullableJsonNullValueInput | InputJsonValue
    evidenceLevel?: $Enums.EvidenceLevel
    bestFor: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    sessions?: GroundingSessionUncheckedCreateNestedManyWithoutTechniqueInput
  }

  export type GroundingTechniqueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumGroundingTypeFieldUpdateOperationsInput | $Enums.GroundingType
    category?: EnumGroundingCategoryFieldUpdateOperationsInput | $Enums.GroundingCategory
    instructions?: JsonNullValueInput | InputJsonValue
    duration?: IntFieldUpdateOperationsInput | number
    materials?: NullableJsonNullValueInput | InputJsonValue
    audioGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageGuides?: NullableJsonNullValueInput | InputJsonValue
    evidenceLevel?: EnumEvidenceLevelFieldUpdateOperationsInput | $Enums.EvidenceLevel
    bestFor?: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: GroundingSessionUpdateManyWithoutTechniqueNestedInput
  }

  export type GroundingTechniqueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumGroundingTypeFieldUpdateOperationsInput | $Enums.GroundingType
    category?: EnumGroundingCategoryFieldUpdateOperationsInput | $Enums.GroundingCategory
    instructions?: JsonNullValueInput | InputJsonValue
    duration?: IntFieldUpdateOperationsInput | number
    materials?: NullableJsonNullValueInput | InputJsonValue
    audioGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageGuides?: NullableJsonNullValueInput | InputJsonValue
    evidenceLevel?: EnumEvidenceLevelFieldUpdateOperationsInput | $Enums.EvidenceLevel
    bestFor?: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: GroundingSessionUncheckedUpdateManyWithoutTechniqueNestedInput
  }

  export type GroundingTechniqueCreateManyInput = {
    id?: string
    name: string
    description: string
    type: $Enums.GroundingType
    category: $Enums.GroundingCategory
    instructions: JsonNullValueInput | InputJsonValue
    duration: number
    materials?: NullableJsonNullValueInput | InputJsonValue
    audioGuideUrl?: string | null
    videoGuideUrl?: string | null
    imageGuides?: NullableJsonNullValueInput | InputJsonValue
    evidenceLevel?: $Enums.EvidenceLevel
    bestFor: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
  }

  export type GroundingTechniqueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumGroundingTypeFieldUpdateOperationsInput | $Enums.GroundingType
    category?: EnumGroundingCategoryFieldUpdateOperationsInput | $Enums.GroundingCategory
    instructions?: JsonNullValueInput | InputJsonValue
    duration?: IntFieldUpdateOperationsInput | number
    materials?: NullableJsonNullValueInput | InputJsonValue
    audioGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageGuides?: NullableJsonNullValueInput | InputJsonValue
    evidenceLevel?: EnumEvidenceLevelFieldUpdateOperationsInput | $Enums.EvidenceLevel
    bestFor?: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroundingTechniqueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumGroundingTypeFieldUpdateOperationsInput | $Enums.GroundingType
    category?: EnumGroundingCategoryFieldUpdateOperationsInput | $Enums.GroundingCategory
    instructions?: JsonNullValueInput | InputJsonValue
    duration?: IntFieldUpdateOperationsInput | number
    materials?: NullableJsonNullValueInput | InputJsonValue
    audioGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageGuides?: NullableJsonNullValueInput | InputJsonValue
    evidenceLevel?: EnumEvidenceLevelFieldUpdateOperationsInput | $Enums.EvidenceLevel
    bestFor?: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroundingSessionCreateInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    triggerType?: string | null
    severityBefore?: number | null
    severityAfter?: number | null
    panicBefore?: number | null
    panicAfter?: number | null
    dissociationBefore?: number | null
    dissociationAfter?: number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    wouldUseAgain?: boolean | null
    user: UserCreateNestedOneWithoutGroundingSessionsInput
    technique: GroundingTechniqueCreateNestedOneWithoutSessionsInput
  }

  export type GroundingSessionUncheckedCreateInput = {
    id?: string
    userId: string
    techniqueId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    triggerType?: string | null
    severityBefore?: number | null
    severityAfter?: number | null
    panicBefore?: number | null
    panicAfter?: number | null
    dissociationBefore?: number | null
    dissociationAfter?: number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    wouldUseAgain?: boolean | null
  }

  export type GroundingSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    severityBefore?: NullableIntFieldUpdateOperationsInput | number | null
    severityAfter?: NullableIntFieldUpdateOperationsInput | number | null
    panicBefore?: NullableIntFieldUpdateOperationsInput | number | null
    panicAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationBefore?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationAfter?: NullableIntFieldUpdateOperationsInput | number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wouldUseAgain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutGroundingSessionsNestedInput
    technique?: GroundingTechniqueUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type GroundingSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    techniqueId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    severityBefore?: NullableIntFieldUpdateOperationsInput | number | null
    severityAfter?: NullableIntFieldUpdateOperationsInput | number | null
    panicBefore?: NullableIntFieldUpdateOperationsInput | number | null
    panicAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationBefore?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationAfter?: NullableIntFieldUpdateOperationsInput | number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wouldUseAgain?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type GroundingSessionCreateManyInput = {
    id?: string
    userId: string
    techniqueId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    triggerType?: string | null
    severityBefore?: number | null
    severityAfter?: number | null
    panicBefore?: number | null
    panicAfter?: number | null
    dissociationBefore?: number | null
    dissociationAfter?: number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    wouldUseAgain?: boolean | null
  }

  export type GroundingSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    severityBefore?: NullableIntFieldUpdateOperationsInput | number | null
    severityAfter?: NullableIntFieldUpdateOperationsInput | number | null
    panicBefore?: NullableIntFieldUpdateOperationsInput | number | null
    panicAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationBefore?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationAfter?: NullableIntFieldUpdateOperationsInput | number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wouldUseAgain?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type GroundingSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    techniqueId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    severityBefore?: NullableIntFieldUpdateOperationsInput | number | null
    severityAfter?: NullableIntFieldUpdateOperationsInput | number | null
    panicBefore?: NullableIntFieldUpdateOperationsInput | number | null
    panicAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationBefore?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationAfter?: NullableIntFieldUpdateOperationsInput | number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wouldUseAgain?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SelfHelpResourceCreateInput = {
    id?: string
    title: string
    description: string
    category: $Enums.SelfHelpCategory
    type: $Enums.ResourceType
    content?: string | null
    url?: string | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    duration?: number | null
    difficulty?: $Enums.ExerciseDifficulty
    evidenceLevel?: $Enums.EvidenceLevel
    tags: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    symptoms?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: number
    helpfulCount?: number
    averageRating?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: SelfHelpInteractionCreateNestedManyWithoutResourceInput
  }

  export type SelfHelpResourceUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    category: $Enums.SelfHelpCategory
    type: $Enums.ResourceType
    content?: string | null
    url?: string | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    duration?: number | null
    difficulty?: $Enums.ExerciseDifficulty
    evidenceLevel?: $Enums.EvidenceLevel
    tags: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    symptoms?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: number
    helpfulCount?: number
    averageRating?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: SelfHelpInteractionUncheckedCreateNestedManyWithoutResourceInput
  }

  export type SelfHelpResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSelfHelpCategoryFieldUpdateOperationsInput | $Enums.SelfHelpCategory
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: EnumExerciseDifficultyFieldUpdateOperationsInput | $Enums.ExerciseDifficulty
    evidenceLevel?: EnumEvidenceLevelFieldUpdateOperationsInput | $Enums.EvidenceLevel
    tags?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    symptoms?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: SelfHelpInteractionUpdateManyWithoutResourceNestedInput
  }

  export type SelfHelpResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSelfHelpCategoryFieldUpdateOperationsInput | $Enums.SelfHelpCategory
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: EnumExerciseDifficultyFieldUpdateOperationsInput | $Enums.ExerciseDifficulty
    evidenceLevel?: EnumEvidenceLevelFieldUpdateOperationsInput | $Enums.EvidenceLevel
    tags?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    symptoms?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: SelfHelpInteractionUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type SelfHelpResourceCreateManyInput = {
    id?: string
    title: string
    description: string
    category: $Enums.SelfHelpCategory
    type: $Enums.ResourceType
    content?: string | null
    url?: string | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    duration?: number | null
    difficulty?: $Enums.ExerciseDifficulty
    evidenceLevel?: $Enums.EvidenceLevel
    tags: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    symptoms?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: number
    helpfulCount?: number
    averageRating?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SelfHelpResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSelfHelpCategoryFieldUpdateOperationsInput | $Enums.SelfHelpCategory
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: EnumExerciseDifficultyFieldUpdateOperationsInput | $Enums.ExerciseDifficulty
    evidenceLevel?: EnumEvidenceLevelFieldUpdateOperationsInput | $Enums.EvidenceLevel
    tags?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    symptoms?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SelfHelpResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSelfHelpCategoryFieldUpdateOperationsInput | $Enums.SelfHelpCategory
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: EnumExerciseDifficultyFieldUpdateOperationsInput | $Enums.ExerciseDifficulty
    evidenceLevel?: EnumEvidenceLevelFieldUpdateOperationsInput | $Enums.EvidenceLevel
    tags?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    symptoms?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SelfHelpInteractionCreateInput = {
    id?: string
    interactionType: $Enums.InteractionType
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    moodBefore?: number | null
    moodAfter?: number | null
    user: UserCreateNestedOneWithoutSelfHelpInteractionsInput
    resource: SelfHelpResourceCreateNestedOneWithoutInteractionsInput
  }

  export type SelfHelpInteractionUncheckedCreateInput = {
    id?: string
    userId: string
    resourceId: string
    interactionType: $Enums.InteractionType
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    moodBefore?: number | null
    moodAfter?: number | null
  }

  export type SelfHelpInteractionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutSelfHelpInteractionsNestedInput
    resource?: SelfHelpResourceUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type SelfHelpInteractionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SelfHelpInteractionCreateManyInput = {
    id?: string
    userId: string
    resourceId: string
    interactionType: $Enums.InteractionType
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    moodBefore?: number | null
    moodAfter?: number | null
  }

  export type SelfHelpInteractionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SelfHelpInteractionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AITherapistCreateInput = {
    id?: string
    therapistId: string
    name: string
    avatar: string
    personality: string
    description: string
    specialties: string
    approaches: string
    bestFor: string
    features: string
    availability: string
    sessionsCompleted?: number
    userRating?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AITherapySessionCreateNestedManyWithoutTherapistInput
    personalizations?: AIPersonalizationCreateNestedManyWithoutTherapistInput
  }

  export type AITherapistUncheckedCreateInput = {
    id?: string
    therapistId: string
    name: string
    avatar: string
    personality: string
    description: string
    specialties: string
    approaches: string
    bestFor: string
    features: string
    availability: string
    sessionsCompleted?: number
    userRating?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AITherapySessionUncheckedCreateNestedManyWithoutTherapistInput
    personalizations?: AIPersonalizationUncheckedCreateNestedManyWithoutTherapistInput
  }

  export type AITherapistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    specialties?: StringFieldUpdateOperationsInput | string
    approaches?: StringFieldUpdateOperationsInput | string
    bestFor?: StringFieldUpdateOperationsInput | string
    features?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    sessionsCompleted?: IntFieldUpdateOperationsInput | number
    userRating?: FloatFieldUpdateOperationsInput | number
    responseTime?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AITherapySessionUpdateManyWithoutTherapistNestedInput
    personalizations?: AIPersonalizationUpdateManyWithoutTherapistNestedInput
  }

  export type AITherapistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    specialties?: StringFieldUpdateOperationsInput | string
    approaches?: StringFieldUpdateOperationsInput | string
    bestFor?: StringFieldUpdateOperationsInput | string
    features?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    sessionsCompleted?: IntFieldUpdateOperationsInput | number
    userRating?: FloatFieldUpdateOperationsInput | number
    responseTime?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AITherapySessionUncheckedUpdateManyWithoutTherapistNestedInput
    personalizations?: AIPersonalizationUncheckedUpdateManyWithoutTherapistNestedInput
  }

  export type AITherapistCreateManyInput = {
    id?: string
    therapistId: string
    name: string
    avatar: string
    personality: string
    description: string
    specialties: string
    approaches: string
    bestFor: string
    features: string
    availability: string
    sessionsCompleted?: number
    userRating?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AITherapistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    specialties?: StringFieldUpdateOperationsInput | string
    approaches?: StringFieldUpdateOperationsInput | string
    bestFor?: StringFieldUpdateOperationsInput | string
    features?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    sessionsCompleted?: IntFieldUpdateOperationsInput | number
    userRating?: FloatFieldUpdateOperationsInput | number
    responseTime?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AITherapistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    specialties?: StringFieldUpdateOperationsInput | string
    approaches?: StringFieldUpdateOperationsInput | string
    bestFor?: StringFieldUpdateOperationsInput | string
    features?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    sessionsCompleted?: IntFieldUpdateOperationsInput | number
    userRating?: FloatFieldUpdateOperationsInput | number
    responseTime?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AITherapySessionCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    sessionType: $Enums.AISessionType
    status?: $Enums.AISessionStatus
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    pausedAt?: Date | string | null
    pausedDuration?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    encryptedNotes?: Uint8Array | null
    encryptedInsights?: Uint8Array | null
    encryptedHomework?: Uint8Array | null
    encryptedGoals?: Uint8Array | null
    topics?: string | null
    techniques?: string | null
    interventions?: string | null
    breakthroughs?: string | null
    crisisDetected?: boolean
    crisisLevel?: number | null
    crisisInterventions?: string | null
    therapist: AITherapistCreateNestedOneWithoutSessionsInput
    messages?: AITherapyMessageCreateNestedManyWithoutSessionInput
    exercises?: AIExerciseSessionCreateNestedManyWithoutSessionInput
  }

  export type AITherapySessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    therapistId: string
    sessionType: $Enums.AISessionType
    status?: $Enums.AISessionStatus
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    pausedAt?: Date | string | null
    pausedDuration?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    encryptedNotes?: Uint8Array | null
    encryptedInsights?: Uint8Array | null
    encryptedHomework?: Uint8Array | null
    encryptedGoals?: Uint8Array | null
    topics?: string | null
    techniques?: string | null
    interventions?: string | null
    breakthroughs?: string | null
    crisisDetected?: boolean
    crisisLevel?: number | null
    crisisInterventions?: string | null
    messages?: AITherapyMessageUncheckedCreateNestedManyWithoutSessionInput
    exercises?: AIExerciseSessionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AITherapySessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumAISessionTypeFieldUpdateOperationsInput | $Enums.AISessionType
    status?: EnumAISessionStatusFieldUpdateOperationsInput | $Enums.AISessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedDuration?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    energyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    encryptedNotes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedInsights?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedHomework?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedGoals?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    topics?: NullableStringFieldUpdateOperationsInput | string | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    interventions?: NullableStringFieldUpdateOperationsInput | string | null
    breakthroughs?: NullableStringFieldUpdateOperationsInput | string | null
    crisisDetected?: BoolFieldUpdateOperationsInput | boolean
    crisisLevel?: NullableIntFieldUpdateOperationsInput | number | null
    crisisInterventions?: NullableStringFieldUpdateOperationsInput | string | null
    therapist?: AITherapistUpdateOneRequiredWithoutSessionsNestedInput
    messages?: AITherapyMessageUpdateManyWithoutSessionNestedInput
    exercises?: AIExerciseSessionUpdateManyWithoutSessionNestedInput
  }

  export type AITherapySessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumAISessionTypeFieldUpdateOperationsInput | $Enums.AISessionType
    status?: EnumAISessionStatusFieldUpdateOperationsInput | $Enums.AISessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedDuration?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    energyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    encryptedNotes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedInsights?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedHomework?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedGoals?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    topics?: NullableStringFieldUpdateOperationsInput | string | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    interventions?: NullableStringFieldUpdateOperationsInput | string | null
    breakthroughs?: NullableStringFieldUpdateOperationsInput | string | null
    crisisDetected?: BoolFieldUpdateOperationsInput | boolean
    crisisLevel?: NullableIntFieldUpdateOperationsInput | number | null
    crisisInterventions?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: AITherapyMessageUncheckedUpdateManyWithoutSessionNestedInput
    exercises?: AIExerciseSessionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AITherapySessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    therapistId: string
    sessionType: $Enums.AISessionType
    status?: $Enums.AISessionStatus
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    pausedAt?: Date | string | null
    pausedDuration?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    encryptedNotes?: Uint8Array | null
    encryptedInsights?: Uint8Array | null
    encryptedHomework?: Uint8Array | null
    encryptedGoals?: Uint8Array | null
    topics?: string | null
    techniques?: string | null
    interventions?: string | null
    breakthroughs?: string | null
    crisisDetected?: boolean
    crisisLevel?: number | null
    crisisInterventions?: string | null
  }

  export type AITherapySessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumAISessionTypeFieldUpdateOperationsInput | $Enums.AISessionType
    status?: EnumAISessionStatusFieldUpdateOperationsInput | $Enums.AISessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedDuration?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    energyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    encryptedNotes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedInsights?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedHomework?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedGoals?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    topics?: NullableStringFieldUpdateOperationsInput | string | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    interventions?: NullableStringFieldUpdateOperationsInput | string | null
    breakthroughs?: NullableStringFieldUpdateOperationsInput | string | null
    crisisDetected?: BoolFieldUpdateOperationsInput | boolean
    crisisLevel?: NullableIntFieldUpdateOperationsInput | number | null
    crisisInterventions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AITherapySessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumAISessionTypeFieldUpdateOperationsInput | $Enums.AISessionType
    status?: EnumAISessionStatusFieldUpdateOperationsInput | $Enums.AISessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedDuration?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    energyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    encryptedNotes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedInsights?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedHomework?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedGoals?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    topics?: NullableStringFieldUpdateOperationsInput | string | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    interventions?: NullableStringFieldUpdateOperationsInput | string | null
    breakthroughs?: NullableStringFieldUpdateOperationsInput | string | null
    crisisDetected?: BoolFieldUpdateOperationsInput | boolean
    crisisLevel?: NullableIntFieldUpdateOperationsInput | number | null
    crisisInterventions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AITherapyMessageCreateInput = {
    id?: string
    messageType: $Enums.AIMessageType
    sender: $Enums.AIMessageSender
    encryptedContent: Uint8Array
    messageHash: string
    timestamp?: Date | string
    edited?: boolean
    editedAt?: Date | string | null
    sentiment?: number | null
    emotion?: string | null
    riskScore?: number | null
    techniques?: string | null
    hasAudio?: boolean
    audioDuration?: number | null
    audioUrl?: string | null
    session: AITherapySessionCreateNestedOneWithoutMessagesInput
  }

  export type AITherapyMessageUncheckedCreateInput = {
    id?: string
    sessionId: string
    messageType: $Enums.AIMessageType
    sender: $Enums.AIMessageSender
    encryptedContent: Uint8Array
    messageHash: string
    timestamp?: Date | string
    edited?: boolean
    editedAt?: Date | string | null
    sentiment?: number | null
    emotion?: string | null
    riskScore?: number | null
    techniques?: string | null
    hasAudio?: boolean
    audioDuration?: number | null
    audioUrl?: string | null
  }

  export type AITherapyMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageType?: EnumAIMessageTypeFieldUpdateOperationsInput | $Enums.AIMessageType
    sender?: EnumAIMessageSenderFieldUpdateOperationsInput | $Enums.AIMessageSender
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    messageHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    emotion?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    hasAudio?: BoolFieldUpdateOperationsInput | boolean
    audioDuration?: NullableIntFieldUpdateOperationsInput | number | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    session?: AITherapySessionUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type AITherapyMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    messageType?: EnumAIMessageTypeFieldUpdateOperationsInput | $Enums.AIMessageType
    sender?: EnumAIMessageSenderFieldUpdateOperationsInput | $Enums.AIMessageSender
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    messageHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    emotion?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    hasAudio?: BoolFieldUpdateOperationsInput | boolean
    audioDuration?: NullableIntFieldUpdateOperationsInput | number | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AITherapyMessageCreateManyInput = {
    id?: string
    sessionId: string
    messageType: $Enums.AIMessageType
    sender: $Enums.AIMessageSender
    encryptedContent: Uint8Array
    messageHash: string
    timestamp?: Date | string
    edited?: boolean
    editedAt?: Date | string | null
    sentiment?: number | null
    emotion?: string | null
    riskScore?: number | null
    techniques?: string | null
    hasAudio?: boolean
    audioDuration?: number | null
    audioUrl?: string | null
  }

  export type AITherapyMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageType?: EnumAIMessageTypeFieldUpdateOperationsInput | $Enums.AIMessageType
    sender?: EnumAIMessageSenderFieldUpdateOperationsInput | $Enums.AIMessageSender
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    messageHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    emotion?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    hasAudio?: BoolFieldUpdateOperationsInput | boolean
    audioDuration?: NullableIntFieldUpdateOperationsInput | number | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AITherapyMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    messageType?: EnumAIMessageTypeFieldUpdateOperationsInput | $Enums.AIMessageType
    sender?: EnumAIMessageSenderFieldUpdateOperationsInput | $Enums.AIMessageSender
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    messageHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    emotion?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    hasAudio?: BoolFieldUpdateOperationsInput | boolean
    audioDuration?: NullableIntFieldUpdateOperationsInput | number | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AIPersonalizationCreateInput = {
    id?: string
    userId: string
    preferredStyle?: string | null
    preferredTechniques?: string | null
    preferredTopics?: string | null
    avoidTopics?: string | null
    responseLength?: string
    responseComplexity?: string
    empathyLevel?: string
    directness?: string
    culturalBackground?: string | null
    languagePreference?: string
    timezone?: string
    pronouns?: string | null
    learnedPatterns?: string | null
    effectiveTechniques?: string | null
    triggerPatterns?: string | null
    copingStrategies?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    therapist?: AITherapistCreateNestedOneWithoutPersonalizationsInput
  }

  export type AIPersonalizationUncheckedCreateInput = {
    id?: string
    userId: string
    therapistId?: string | null
    preferredStyle?: string | null
    preferredTechniques?: string | null
    preferredTopics?: string | null
    avoidTopics?: string | null
    responseLength?: string
    responseComplexity?: string
    empathyLevel?: string
    directness?: string
    culturalBackground?: string | null
    languagePreference?: string
    timezone?: string
    pronouns?: string | null
    learnedPatterns?: string | null
    effectiveTechniques?: string | null
    triggerPatterns?: string | null
    copingStrategies?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIPersonalizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferredStyle?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTopics?: NullableStringFieldUpdateOperationsInput | string | null
    avoidTopics?: NullableStringFieldUpdateOperationsInput | string | null
    responseLength?: StringFieldUpdateOperationsInput | string
    responseComplexity?: StringFieldUpdateOperationsInput | string
    empathyLevel?: StringFieldUpdateOperationsInput | string
    directness?: StringFieldUpdateOperationsInput | string
    culturalBackground?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    learnedPatterns?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    triggerPatterns?: NullableStringFieldUpdateOperationsInput | string | null
    copingStrategies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    therapist?: AITherapistUpdateOneWithoutPersonalizationsNestedInput
  }

  export type AIPersonalizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    therapistId?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStyle?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTopics?: NullableStringFieldUpdateOperationsInput | string | null
    avoidTopics?: NullableStringFieldUpdateOperationsInput | string | null
    responseLength?: StringFieldUpdateOperationsInput | string
    responseComplexity?: StringFieldUpdateOperationsInput | string
    empathyLevel?: StringFieldUpdateOperationsInput | string
    directness?: StringFieldUpdateOperationsInput | string
    culturalBackground?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    learnedPatterns?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    triggerPatterns?: NullableStringFieldUpdateOperationsInput | string | null
    copingStrategies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIPersonalizationCreateManyInput = {
    id?: string
    userId: string
    therapistId?: string | null
    preferredStyle?: string | null
    preferredTechniques?: string | null
    preferredTopics?: string | null
    avoidTopics?: string | null
    responseLength?: string
    responseComplexity?: string
    empathyLevel?: string
    directness?: string
    culturalBackground?: string | null
    languagePreference?: string
    timezone?: string
    pronouns?: string | null
    learnedPatterns?: string | null
    effectiveTechniques?: string | null
    triggerPatterns?: string | null
    copingStrategies?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIPersonalizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferredStyle?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTopics?: NullableStringFieldUpdateOperationsInput | string | null
    avoidTopics?: NullableStringFieldUpdateOperationsInput | string | null
    responseLength?: StringFieldUpdateOperationsInput | string
    responseComplexity?: StringFieldUpdateOperationsInput | string
    empathyLevel?: StringFieldUpdateOperationsInput | string
    directness?: StringFieldUpdateOperationsInput | string
    culturalBackground?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    learnedPatterns?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    triggerPatterns?: NullableStringFieldUpdateOperationsInput | string | null
    copingStrategies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIPersonalizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    therapistId?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStyle?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTopics?: NullableStringFieldUpdateOperationsInput | string | null
    avoidTopics?: NullableStringFieldUpdateOperationsInput | string | null
    responseLength?: StringFieldUpdateOperationsInput | string
    responseComplexity?: StringFieldUpdateOperationsInput | string
    empathyLevel?: StringFieldUpdateOperationsInput | string
    directness?: StringFieldUpdateOperationsInput | string
    culturalBackground?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    learnedPatterns?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    triggerPatterns?: NullableStringFieldUpdateOperationsInput | string | null
    copingStrategies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIExerciseSessionCreateInput = {
    id?: string
    userId: string
    exerciseType: $Enums.AIExerciseType
    exerciseName: string
    category: string
    difficulty: string
    duration: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    completed?: boolean
    progress?: number
    results?: string | null
    feedback?: string | null
    improvement?: number | null
    moodBefore?: number | null
    moodAfter?: number | null
    session?: AITherapySessionCreateNestedOneWithoutExercisesInput
  }

  export type AIExerciseSessionUncheckedCreateInput = {
    id?: string
    sessionId?: string | null
    userId: string
    exerciseType: $Enums.AIExerciseType
    exerciseName: string
    category: string
    difficulty: string
    duration: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    completed?: boolean
    progress?: number
    results?: string | null
    feedback?: string | null
    improvement?: number | null
    moodBefore?: number | null
    moodAfter?: number | null
  }

  export type AIExerciseSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exerciseType?: EnumAIExerciseTypeFieldUpdateOperationsInput | $Enums.AIExerciseType
    exerciseName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    progress?: IntFieldUpdateOperationsInput | number
    results?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    session?: AITherapySessionUpdateOneWithoutExercisesNestedInput
  }

  export type AIExerciseSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    exerciseType?: EnumAIExerciseTypeFieldUpdateOperationsInput | $Enums.AIExerciseType
    exerciseName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    progress?: IntFieldUpdateOperationsInput | number
    results?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AIExerciseSessionCreateManyInput = {
    id?: string
    sessionId?: string | null
    userId: string
    exerciseType: $Enums.AIExerciseType
    exerciseName: string
    category: string
    difficulty: string
    duration: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    completed?: boolean
    progress?: number
    results?: string | null
    feedback?: string | null
    improvement?: number | null
    moodBefore?: number | null
    moodAfter?: number | null
  }

  export type AIExerciseSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exerciseType?: EnumAIExerciseTypeFieldUpdateOperationsInput | $Enums.AIExerciseType
    exerciseName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    progress?: IntFieldUpdateOperationsInput | number
    results?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AIExerciseSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    exerciseType?: EnumAIExerciseTypeFieldUpdateOperationsInput | $Enums.AIExerciseType
    exerciseName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    progress?: IntFieldUpdateOperationsInput | number
    results?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AITherapyInsightCreateInput = {
    id?: string
    userId: string
    insightType: $Enums.AIInsightType
    title: string
    description: string
    significance?: string
    dataPoints: string
    patterns?: string | null
    trends?: string | null
    recommendations?: string | null
    actions?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    generatedAt?: Date | string
    viewed?: boolean
    viewedAt?: Date | string | null
    helpful?: boolean | null
    dismissed?: boolean
  }

  export type AITherapyInsightUncheckedCreateInput = {
    id?: string
    userId: string
    insightType: $Enums.AIInsightType
    title: string
    description: string
    significance?: string
    dataPoints: string
    patterns?: string | null
    trends?: string | null
    recommendations?: string | null
    actions?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    generatedAt?: Date | string
    viewed?: boolean
    viewedAt?: Date | string | null
    helpful?: boolean | null
    dismissed?: boolean
  }

  export type AITherapyInsightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    insightType?: EnumAIInsightTypeFieldUpdateOperationsInput | $Enums.AIInsightType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    significance?: StringFieldUpdateOperationsInput | string
    dataPoints?: StringFieldUpdateOperationsInput | string
    patterns?: NullableStringFieldUpdateOperationsInput | string | null
    trends?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewed?: BoolFieldUpdateOperationsInput | boolean
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dismissed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AITherapyInsightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    insightType?: EnumAIInsightTypeFieldUpdateOperationsInput | $Enums.AIInsightType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    significance?: StringFieldUpdateOperationsInput | string
    dataPoints?: StringFieldUpdateOperationsInput | string
    patterns?: NullableStringFieldUpdateOperationsInput | string | null
    trends?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewed?: BoolFieldUpdateOperationsInput | boolean
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dismissed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AITherapyInsightCreateManyInput = {
    id?: string
    userId: string
    insightType: $Enums.AIInsightType
    title: string
    description: string
    significance?: string
    dataPoints: string
    patterns?: string | null
    trends?: string | null
    recommendations?: string | null
    actions?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    generatedAt?: Date | string
    viewed?: boolean
    viewedAt?: Date | string | null
    helpful?: boolean | null
    dismissed?: boolean
  }

  export type AITherapyInsightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    insightType?: EnumAIInsightTypeFieldUpdateOperationsInput | $Enums.AIInsightType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    significance?: StringFieldUpdateOperationsInput | string
    dataPoints?: StringFieldUpdateOperationsInput | string
    patterns?: NullableStringFieldUpdateOperationsInput | string | null
    trends?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewed?: BoolFieldUpdateOperationsInput | boolean
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dismissed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AITherapyInsightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    insightType?: EnumAIInsightTypeFieldUpdateOperationsInput | $Enums.AIInsightType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    significance?: StringFieldUpdateOperationsInput | string
    dataPoints?: StringFieldUpdateOperationsInput | string
    patterns?: NullableStringFieldUpdateOperationsInput | string | null
    trends?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewed?: BoolFieldUpdateOperationsInput | boolean
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dismissed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AITherapyGoalCreateInput = {
    id?: string
    userId: string
    goalType: string
    title: string
    description: string
    category: string
    priority?: string
    specific: string
    measurable: string
    achievable: string
    relevant: string
    timebound: Date | string
    status?: $Enums.AIGoalStatus
    progress?: number
    milestones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type AITherapyGoalUncheckedCreateInput = {
    id?: string
    userId: string
    goalType: string
    title: string
    description: string
    category: string
    priority?: string
    specific: string
    measurable: string
    achievable: string
    relevant: string
    timebound: Date | string
    status?: $Enums.AIGoalStatus
    progress?: number
    milestones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type AITherapyGoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    specific?: StringFieldUpdateOperationsInput | string
    measurable?: StringFieldUpdateOperationsInput | string
    achievable?: StringFieldUpdateOperationsInput | string
    relevant?: StringFieldUpdateOperationsInput | string
    timebound?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAIGoalStatusFieldUpdateOperationsInput | $Enums.AIGoalStatus
    progress?: IntFieldUpdateOperationsInput | number
    milestones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AITherapyGoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    specific?: StringFieldUpdateOperationsInput | string
    measurable?: StringFieldUpdateOperationsInput | string
    achievable?: StringFieldUpdateOperationsInput | string
    relevant?: StringFieldUpdateOperationsInput | string
    timebound?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAIGoalStatusFieldUpdateOperationsInput | $Enums.AIGoalStatus
    progress?: IntFieldUpdateOperationsInput | number
    milestones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AITherapyGoalCreateManyInput = {
    id?: string
    userId: string
    goalType: string
    title: string
    description: string
    category: string
    priority?: string
    specific: string
    measurable: string
    achievable: string
    relevant: string
    timebound: Date | string
    status?: $Enums.AIGoalStatus
    progress?: number
    milestones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type AITherapyGoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    specific?: StringFieldUpdateOperationsInput | string
    measurable?: StringFieldUpdateOperationsInput | string
    achievable?: StringFieldUpdateOperationsInput | string
    relevant?: StringFieldUpdateOperationsInput | string
    timebound?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAIGoalStatusFieldUpdateOperationsInput | $Enums.AIGoalStatus
    progress?: IntFieldUpdateOperationsInput | number
    milestones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AITherapyGoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    specific?: StringFieldUpdateOperationsInput | string
    measurable?: StringFieldUpdateOperationsInput | string
    achievable?: StringFieldUpdateOperationsInput | string
    relevant?: StringFieldUpdateOperationsInput | string
    timebound?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAIGoalStatusFieldUpdateOperationsInput | $Enums.AIGoalStatus
    progress?: IntFieldUpdateOperationsInput | number
    milestones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumCrisisStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CrisisStatus | EnumCrisisStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CrisisStatus[]
    notIn?: $Enums.CrisisStatus[]
    not?: NestedEnumCrisisStatusFilter<$PrismaModel> | $Enums.CrisisStatus
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumEscalationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EscalationType | EnumEscalationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EscalationType[] | null
    notIn?: $Enums.EscalationType[] | null
    not?: NestedEnumEscalationTypeNullableFilter<$PrismaModel> | $Enums.EscalationType | null
  }

  export type CrisisMessageListRelationFilter = {
    every?: CrisisMessageWhereInput
    some?: CrisisMessageWhereInput
    none?: CrisisMessageWhereInput
  }

  export type CrisisEscalationListRelationFilter = {
    every?: CrisisEscalationWhereInput
    some?: CrisisEscalationWhereInput
    none?: CrisisEscalationWhereInput
  }

  export type CrisisResourceUsageListRelationFilter = {
    every?: CrisisResourceUsageWhereInput
    some?: CrisisResourceUsageWhereInput
    none?: CrisisResourceUsageWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CrisisMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrisisEscalationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrisisResourceUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrisisSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    anonymousId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    responderId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    responseTimeMs?: SortOrder
    outcome?: SortOrder
    encryptedData?: SortOrder
    keyDerivationSalt?: SortOrder
    handoffTime?: SortOrder
    resolutionTime?: SortOrder
    emergencyTriggered?: SortOrder
    escalatedAt?: SortOrder
    escalationType?: SortOrder
  }

  export type CrisisSessionAvgOrderByAggregateInput = {
    severity?: SortOrder
    responseTimeMs?: SortOrder
    handoffTime?: SortOrder
    resolutionTime?: SortOrder
  }

  export type CrisisSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    anonymousId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    responderId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    responseTimeMs?: SortOrder
    outcome?: SortOrder
    encryptedData?: SortOrder
    keyDerivationSalt?: SortOrder
    handoffTime?: SortOrder
    resolutionTime?: SortOrder
    emergencyTriggered?: SortOrder
    escalatedAt?: SortOrder
    escalationType?: SortOrder
  }

  export type CrisisSessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    anonymousId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    responderId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    responseTimeMs?: SortOrder
    outcome?: SortOrder
    encryptedData?: SortOrder
    keyDerivationSalt?: SortOrder
    handoffTime?: SortOrder
    resolutionTime?: SortOrder
    emergencyTriggered?: SortOrder
    escalatedAt?: SortOrder
    escalationType?: SortOrder
  }

  export type CrisisSessionSumOrderByAggregateInput = {
    severity?: SortOrder
    responseTimeMs?: SortOrder
    handoffTime?: SortOrder
    resolutionTime?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumCrisisStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CrisisStatus | EnumCrisisStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CrisisStatus[]
    notIn?: $Enums.CrisisStatus[]
    not?: NestedEnumCrisisStatusWithAggregatesFilter<$PrismaModel> | $Enums.CrisisStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCrisisStatusFilter<$PrismaModel>
    _max?: NestedEnumCrisisStatusFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumEscalationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EscalationType | EnumEscalationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EscalationType[] | null
    notIn?: $Enums.EscalationType[] | null
    not?: NestedEnumEscalationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EscalationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEscalationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEscalationTypeNullableFilter<$PrismaModel>
  }

  export type EnumMessageSenderFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageSender | EnumMessageSenderFieldRefInput<$PrismaModel>
    in?: $Enums.MessageSender[]
    notIn?: $Enums.MessageSender[]
    not?: NestedEnumMessageSenderFilter<$PrismaModel> | $Enums.MessageSender
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[]
    notIn?: $Enums.MessageType[]
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type EnumMessagePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.MessagePriority | EnumMessagePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MessagePriority[]
    notIn?: $Enums.MessagePriority[]
    not?: NestedEnumMessagePriorityFilter<$PrismaModel> | $Enums.MessagePriority
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CrisisSessionScalarRelationFilter = {
    is?: CrisisSessionWhereInput
    isNot?: CrisisSessionWhereInput
  }

  export type CrisisMessageCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    senderType?: SortOrder
    senderId?: SortOrder
    encryptedContent?: SortOrder
    messageHash?: SortOrder
    timestamp?: SortOrder
    messageType?: SortOrder
    priority?: SortOrder
    sentimentScore?: SortOrder
    riskScore?: SortOrder
    riskLevel?: SortOrder
    keywordsDetected?: SortOrder
  }

  export type CrisisMessageAvgOrderByAggregateInput = {
    sentimentScore?: SortOrder
    riskScore?: SortOrder
  }

  export type CrisisMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    senderType?: SortOrder
    senderId?: SortOrder
    encryptedContent?: SortOrder
    messageHash?: SortOrder
    timestamp?: SortOrder
    messageType?: SortOrder
    priority?: SortOrder
    sentimentScore?: SortOrder
    riskScore?: SortOrder
    riskLevel?: SortOrder
    keywordsDetected?: SortOrder
  }

  export type CrisisMessageMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    senderType?: SortOrder
    senderId?: SortOrder
    encryptedContent?: SortOrder
    messageHash?: SortOrder
    timestamp?: SortOrder
    messageType?: SortOrder
    priority?: SortOrder
    sentimentScore?: SortOrder
    riskScore?: SortOrder
    riskLevel?: SortOrder
    keywordsDetected?: SortOrder
  }

  export type CrisisMessageSumOrderByAggregateInput = {
    sentimentScore?: SortOrder
    riskScore?: SortOrder
  }

  export type EnumMessageSenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageSender | EnumMessageSenderFieldRefInput<$PrismaModel>
    in?: $Enums.MessageSender[]
    notIn?: $Enums.MessageSender[]
    not?: NestedEnumMessageSenderWithAggregatesFilter<$PrismaModel> | $Enums.MessageSender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageSenderFilter<$PrismaModel>
    _max?: NestedEnumMessageSenderFilter<$PrismaModel>
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[]
    notIn?: $Enums.MessageType[]
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type EnumMessagePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessagePriority | EnumMessagePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MessagePriority[]
    notIn?: $Enums.MessagePriority[]
    not?: NestedEnumMessagePriorityWithAggregatesFilter<$PrismaModel> | $Enums.MessagePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessagePriorityFilter<$PrismaModel>
    _max?: NestedEnumMessagePriorityFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumEscalationTriggerFilter<$PrismaModel = never> = {
    equals?: $Enums.EscalationTrigger | EnumEscalationTriggerFieldRefInput<$PrismaModel>
    in?: $Enums.EscalationTrigger[]
    notIn?: $Enums.EscalationTrigger[]
    not?: NestedEnumEscalationTriggerFilter<$PrismaModel> | $Enums.EscalationTrigger
  }

  export type EnumEscalationSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.EscalationSeverity | EnumEscalationSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.EscalationSeverity[]
    notIn?: $Enums.EscalationSeverity[]
    not?: NestedEnumEscalationSeverityFilter<$PrismaModel> | $Enums.EscalationSeverity
  }

  export type EnumEscalationOutcomeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EscalationOutcome | EnumEscalationOutcomeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EscalationOutcome[] | null
    notIn?: $Enums.EscalationOutcome[] | null
    not?: NestedEnumEscalationOutcomeNullableFilter<$PrismaModel> | $Enums.EscalationOutcome | null
  }

  export type CrisisEscalationCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    triggeredBy?: SortOrder
    severity?: SortOrder
    reason?: SortOrder
    actionsTaken?: SortOrder
    emergencyContacted?: SortOrder
    lifeline988Called?: SortOrder
    triggeredAt?: SortOrder
    resolvedAt?: SortOrder
    responseTime?: SortOrder
    handledBy?: SortOrder
    outcome?: SortOrder
  }

  export type CrisisEscalationAvgOrderByAggregateInput = {
    responseTime?: SortOrder
  }

  export type CrisisEscalationMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    triggeredBy?: SortOrder
    severity?: SortOrder
    reason?: SortOrder
    actionsTaken?: SortOrder
    emergencyContacted?: SortOrder
    lifeline988Called?: SortOrder
    triggeredAt?: SortOrder
    resolvedAt?: SortOrder
    responseTime?: SortOrder
    handledBy?: SortOrder
    outcome?: SortOrder
  }

  export type CrisisEscalationMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    triggeredBy?: SortOrder
    severity?: SortOrder
    reason?: SortOrder
    actionsTaken?: SortOrder
    emergencyContacted?: SortOrder
    lifeline988Called?: SortOrder
    triggeredAt?: SortOrder
    resolvedAt?: SortOrder
    responseTime?: SortOrder
    handledBy?: SortOrder
    outcome?: SortOrder
  }

  export type CrisisEscalationSumOrderByAggregateInput = {
    responseTime?: SortOrder
  }

  export type EnumEscalationTriggerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EscalationTrigger | EnumEscalationTriggerFieldRefInput<$PrismaModel>
    in?: $Enums.EscalationTrigger[]
    notIn?: $Enums.EscalationTrigger[]
    not?: NestedEnumEscalationTriggerWithAggregatesFilter<$PrismaModel> | $Enums.EscalationTrigger
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEscalationTriggerFilter<$PrismaModel>
    _max?: NestedEnumEscalationTriggerFilter<$PrismaModel>
  }

  export type EnumEscalationSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EscalationSeverity | EnumEscalationSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.EscalationSeverity[]
    notIn?: $Enums.EscalationSeverity[]
    not?: NestedEnumEscalationSeverityWithAggregatesFilter<$PrismaModel> | $Enums.EscalationSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEscalationSeverityFilter<$PrismaModel>
    _max?: NestedEnumEscalationSeverityFilter<$PrismaModel>
  }

  export type EnumEscalationOutcomeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EscalationOutcome | EnumEscalationOutcomeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EscalationOutcome[] | null
    notIn?: $Enums.EscalationOutcome[] | null
    not?: NestedEnumEscalationOutcomeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EscalationOutcome | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEscalationOutcomeNullableFilter<$PrismaModel>
    _max?: NestedEnumEscalationOutcomeNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumEmergencyTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyType | EnumEmergencyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmergencyType[] | null
    notIn?: $Enums.EmergencyType[] | null
    not?: NestedEnumEmergencyTypeNullableFilter<$PrismaModel> | $Enums.EmergencyType | null
  }

  export type EnumTetherDataSharingFilter<$PrismaModel = never> = {
    equals?: $Enums.TetherDataSharing | EnumTetherDataSharingFieldRefInput<$PrismaModel>
    in?: $Enums.TetherDataSharing[]
    notIn?: $Enums.TetherDataSharing[]
    not?: NestedEnumTetherDataSharingFilter<$PrismaModel> | $Enums.TetherDataSharing
  }

  export type TetherPulseListRelationFilter = {
    every?: TetherPulseWhereInput
    some?: TetherPulseWhereInput
    none?: TetherPulseWhereInput
  }

  export type TetherEmergencyListRelationFilter = {
    every?: TetherEmergencyWhereInput
    some?: TetherEmergencyWhereInput
    none?: TetherEmergencyWhereInput
  }

  export type TetherPulseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TetherEmergencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TetherLinkSeekerIdSupporterIdCompoundUniqueInput = {
    seekerId: string
    supporterId: string
  }

  export type TetherLinkCountOrderByAggregateInput = {
    id?: SortOrder
    seekerId?: SortOrder
    supporterId?: SortOrder
    strength?: SortOrder
    trustScore?: SortOrder
    established?: SortOrder
    lastActivity?: SortOrder
    pulseInterval?: SortOrder
    lastPulse?: SortOrder
    missedPulses?: SortOrder
    emergencyActive?: SortOrder
    emergencyType?: SortOrder
    lastEmergency?: SortOrder
    matchingScore?: SortOrder
    specialties?: SortOrder
    languages?: SortOrder
    timezone?: SortOrder
    dataSharing?: SortOrder
    locationSharing?: SortOrder
    emergencyContact?: SortOrder
    encryptedMeta?: SortOrder
  }

  export type TetherLinkAvgOrderByAggregateInput = {
    strength?: SortOrder
    trustScore?: SortOrder
    pulseInterval?: SortOrder
    missedPulses?: SortOrder
    matchingScore?: SortOrder
  }

  export type TetherLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    seekerId?: SortOrder
    supporterId?: SortOrder
    strength?: SortOrder
    trustScore?: SortOrder
    established?: SortOrder
    lastActivity?: SortOrder
    pulseInterval?: SortOrder
    lastPulse?: SortOrder
    missedPulses?: SortOrder
    emergencyActive?: SortOrder
    emergencyType?: SortOrder
    lastEmergency?: SortOrder
    matchingScore?: SortOrder
    specialties?: SortOrder
    languages?: SortOrder
    timezone?: SortOrder
    dataSharing?: SortOrder
    locationSharing?: SortOrder
    emergencyContact?: SortOrder
    encryptedMeta?: SortOrder
  }

  export type TetherLinkMinOrderByAggregateInput = {
    id?: SortOrder
    seekerId?: SortOrder
    supporterId?: SortOrder
    strength?: SortOrder
    trustScore?: SortOrder
    established?: SortOrder
    lastActivity?: SortOrder
    pulseInterval?: SortOrder
    lastPulse?: SortOrder
    missedPulses?: SortOrder
    emergencyActive?: SortOrder
    emergencyType?: SortOrder
    lastEmergency?: SortOrder
    matchingScore?: SortOrder
    specialties?: SortOrder
    languages?: SortOrder
    timezone?: SortOrder
    dataSharing?: SortOrder
    locationSharing?: SortOrder
    emergencyContact?: SortOrder
    encryptedMeta?: SortOrder
  }

  export type TetherLinkSumOrderByAggregateInput = {
    strength?: SortOrder
    trustScore?: SortOrder
    pulseInterval?: SortOrder
    missedPulses?: SortOrder
    matchingScore?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumEmergencyTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyType | EnumEmergencyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmergencyType[] | null
    notIn?: $Enums.EmergencyType[] | null
    not?: NestedEnumEmergencyTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EmergencyType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEmergencyTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEmergencyTypeNullableFilter<$PrismaModel>
  }

  export type EnumTetherDataSharingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TetherDataSharing | EnumTetherDataSharingFieldRefInput<$PrismaModel>
    in?: $Enums.TetherDataSharing[]
    notIn?: $Enums.TetherDataSharing[]
    not?: NestedEnumTetherDataSharingWithAggregatesFilter<$PrismaModel> | $Enums.TetherDataSharing
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTetherDataSharingFilter<$PrismaModel>
    _max?: NestedEnumTetherDataSharingFilter<$PrismaModel>
  }

  export type EnumPulseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PulseType | EnumPulseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PulseType[]
    notIn?: $Enums.PulseType[]
    not?: NestedEnumPulseTypeFilter<$PrismaModel> | $Enums.PulseType
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[]
    notIn?: $Enums.UserStatus[]
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type EnumUrgencyLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.UrgencyLevel | EnumUrgencyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UrgencyLevel[]
    notIn?: $Enums.UrgencyLevel[]
    not?: NestedEnumUrgencyLevelFilter<$PrismaModel> | $Enums.UrgencyLevel
  }

  export type TetherLinkScalarRelationFilter = {
    is?: TetherLinkWhereInput
    isNot?: TetherLinkWhereInput
  }

  export type TetherPulseCountOrderByAggregateInput = {
    id?: SortOrder
    tetherId?: SortOrder
    pulseType?: SortOrder
    strength?: SortOrder
    mood?: SortOrder
    status?: SortOrder
    message?: SortOrder
    emergencySignal?: SortOrder
    urgencyLevel?: SortOrder
    timestamp?: SortOrder
    acknowledged?: SortOrder
    acknowledgedAt?: SortOrder
  }

  export type TetherPulseAvgOrderByAggregateInput = {
    strength?: SortOrder
    mood?: SortOrder
  }

  export type TetherPulseMaxOrderByAggregateInput = {
    id?: SortOrder
    tetherId?: SortOrder
    pulseType?: SortOrder
    strength?: SortOrder
    mood?: SortOrder
    status?: SortOrder
    message?: SortOrder
    emergencySignal?: SortOrder
    urgencyLevel?: SortOrder
    timestamp?: SortOrder
    acknowledged?: SortOrder
    acknowledgedAt?: SortOrder
  }

  export type TetherPulseMinOrderByAggregateInput = {
    id?: SortOrder
    tetherId?: SortOrder
    pulseType?: SortOrder
    strength?: SortOrder
    mood?: SortOrder
    status?: SortOrder
    message?: SortOrder
    emergencySignal?: SortOrder
    urgencyLevel?: SortOrder
    timestamp?: SortOrder
    acknowledged?: SortOrder
    acknowledgedAt?: SortOrder
  }

  export type TetherPulseSumOrderByAggregateInput = {
    strength?: SortOrder
    mood?: SortOrder
  }

  export type EnumPulseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PulseType | EnumPulseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PulseType[]
    notIn?: $Enums.PulseType[]
    not?: NestedEnumPulseTypeWithAggregatesFilter<$PrismaModel> | $Enums.PulseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPulseTypeFilter<$PrismaModel>
    _max?: NestedEnumPulseTypeFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[]
    notIn?: $Enums.UserStatus[]
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type EnumUrgencyLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UrgencyLevel | EnumUrgencyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UrgencyLevel[]
    notIn?: $Enums.UrgencyLevel[]
    not?: NestedEnumUrgencyLevelWithAggregatesFilter<$PrismaModel> | $Enums.UrgencyLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUrgencyLevelFilter<$PrismaModel>
    _max?: NestedEnumUrgencyLevelFilter<$PrismaModel>
  }

  export type EnumEmergencyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyType | EnumEmergencyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmergencyType[]
    notIn?: $Enums.EmergencyType[]
    not?: NestedEnumEmergencyTypeFilter<$PrismaModel> | $Enums.EmergencyType
  }

  export type EnumEmergencySeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencySeverity | EnumEmergencySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.EmergencySeverity[]
    notIn?: $Enums.EmergencySeverity[]
    not?: NestedEnumEmergencySeverityFilter<$PrismaModel> | $Enums.EmergencySeverity
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumEmergencyOutcomeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyOutcome | EnumEmergencyOutcomeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmergencyOutcome[] | null
    notIn?: $Enums.EmergencyOutcome[] | null
    not?: NestedEnumEmergencyOutcomeNullableFilter<$PrismaModel> | $Enums.EmergencyOutcome | null
  }

  export type TetherEmergencyCountOrderByAggregateInput = {
    id?: SortOrder
    tetherId?: SortOrder
    triggerUserId?: SortOrder
    emergencyType?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    location?: SortOrder
    triggeredAt?: SortOrder
    acknowledgedAt?: SortOrder
    respondedAt?: SortOrder
    resolvedAt?: SortOrder
    responseTime?: SortOrder
    actionsTaken?: SortOrder
    outcome?: SortOrder
    helpersNotified?: SortOrder
    emergencyContacts?: SortOrder
  }

  export type TetherEmergencyAvgOrderByAggregateInput = {
    responseTime?: SortOrder
  }

  export type TetherEmergencyMaxOrderByAggregateInput = {
    id?: SortOrder
    tetherId?: SortOrder
    triggerUserId?: SortOrder
    emergencyType?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    triggeredAt?: SortOrder
    acknowledgedAt?: SortOrder
    respondedAt?: SortOrder
    resolvedAt?: SortOrder
    responseTime?: SortOrder
    actionsTaken?: SortOrder
    outcome?: SortOrder
    helpersNotified?: SortOrder
    emergencyContacts?: SortOrder
  }

  export type TetherEmergencyMinOrderByAggregateInput = {
    id?: SortOrder
    tetherId?: SortOrder
    triggerUserId?: SortOrder
    emergencyType?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    triggeredAt?: SortOrder
    acknowledgedAt?: SortOrder
    respondedAt?: SortOrder
    resolvedAt?: SortOrder
    responseTime?: SortOrder
    actionsTaken?: SortOrder
    outcome?: SortOrder
    helpersNotified?: SortOrder
    emergencyContacts?: SortOrder
  }

  export type TetherEmergencySumOrderByAggregateInput = {
    responseTime?: SortOrder
  }

  export type EnumEmergencyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyType | EnumEmergencyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmergencyType[]
    notIn?: $Enums.EmergencyType[]
    not?: NestedEnumEmergencyTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmergencyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmergencyTypeFilter<$PrismaModel>
    _max?: NestedEnumEmergencyTypeFilter<$PrismaModel>
  }

  export type EnumEmergencySeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencySeverity | EnumEmergencySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.EmergencySeverity[]
    notIn?: $Enums.EmergencySeverity[]
    not?: NestedEnumEmergencySeverityWithAggregatesFilter<$PrismaModel> | $Enums.EmergencySeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmergencySeverityFilter<$PrismaModel>
    _max?: NestedEnumEmergencySeverityFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumEmergencyOutcomeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyOutcome | EnumEmergencyOutcomeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmergencyOutcome[] | null
    notIn?: $Enums.EmergencyOutcome[] | null
    not?: NestedEnumEmergencyOutcomeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EmergencyOutcome | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEmergencyOutcomeNullableFilter<$PrismaModel>
    _max?: NestedEnumEmergencyOutcomeNullableFilter<$PrismaModel>
  }

  export type EnumVolunteerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VolunteerStatus | EnumVolunteerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VolunteerStatus[]
    notIn?: $Enums.VolunteerStatus[]
    not?: NestedEnumVolunteerStatusFilter<$PrismaModel> | $Enums.VolunteerStatus
  }

  export type EnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[]
    notIn?: $Enums.VerificationStatus[]
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type VolunteerTrainingListRelationFilter = {
    every?: VolunteerTrainingWhereInput
    some?: VolunteerTrainingWhereInput
    none?: VolunteerTrainingWhereInput
  }

  export type VolunteerSessionListRelationFilter = {
    every?: VolunteerSessionWhereInput
    some?: VolunteerSessionWhereInput
    none?: VolunteerSessionWhereInput
  }

  export type VolunteerFeedbackListRelationFilter = {
    every?: VolunteerFeedbackWhereInput
    some?: VolunteerFeedbackWhereInput
    none?: VolunteerFeedbackWhereInput
  }

  export type VolunteerTrainingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VolunteerSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VolunteerFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VolunteerCountOrderByAggregateInput = {
    id?: SortOrder
    anonymousId?: SortOrder
    status?: SortOrder
    trainingHours?: SortOrder
    certifications?: SortOrder
    specializations?: SortOrder
    languages?: SortOrder
    backgroundCheck?: SortOrder
    sessionsCount?: SortOrder
    hoursVolunteered?: SortOrder
    averageRating?: SortOrder
    responseRate?: SortOrder
    isActive?: SortOrder
    currentLoad?: SortOrder
    maxConcurrent?: SortOrder
    schedule?: SortOrder
    timezone?: SortOrder
    lastActive?: SortOrder
    burnoutScore?: SortOrder
    needsSupport?: SortOrder
    emergencyResponder?: SortOrder
    emergencyAvailable?: SortOrder
  }

  export type VolunteerAvgOrderByAggregateInput = {
    trainingHours?: SortOrder
    sessionsCount?: SortOrder
    hoursVolunteered?: SortOrder
    averageRating?: SortOrder
    responseRate?: SortOrder
    currentLoad?: SortOrder
    maxConcurrent?: SortOrder
    burnoutScore?: SortOrder
  }

  export type VolunteerMaxOrderByAggregateInput = {
    id?: SortOrder
    anonymousId?: SortOrder
    status?: SortOrder
    trainingHours?: SortOrder
    certifications?: SortOrder
    specializations?: SortOrder
    languages?: SortOrder
    backgroundCheck?: SortOrder
    sessionsCount?: SortOrder
    hoursVolunteered?: SortOrder
    averageRating?: SortOrder
    responseRate?: SortOrder
    isActive?: SortOrder
    currentLoad?: SortOrder
    maxConcurrent?: SortOrder
    timezone?: SortOrder
    lastActive?: SortOrder
    burnoutScore?: SortOrder
    needsSupport?: SortOrder
    emergencyResponder?: SortOrder
    emergencyAvailable?: SortOrder
  }

  export type VolunteerMinOrderByAggregateInput = {
    id?: SortOrder
    anonymousId?: SortOrder
    status?: SortOrder
    trainingHours?: SortOrder
    certifications?: SortOrder
    specializations?: SortOrder
    languages?: SortOrder
    backgroundCheck?: SortOrder
    sessionsCount?: SortOrder
    hoursVolunteered?: SortOrder
    averageRating?: SortOrder
    responseRate?: SortOrder
    isActive?: SortOrder
    currentLoad?: SortOrder
    maxConcurrent?: SortOrder
    timezone?: SortOrder
    lastActive?: SortOrder
    burnoutScore?: SortOrder
    needsSupport?: SortOrder
    emergencyResponder?: SortOrder
    emergencyAvailable?: SortOrder
  }

  export type VolunteerSumOrderByAggregateInput = {
    trainingHours?: SortOrder
    sessionsCount?: SortOrder
    hoursVolunteered?: SortOrder
    averageRating?: SortOrder
    responseRate?: SortOrder
    currentLoad?: SortOrder
    maxConcurrent?: SortOrder
    burnoutScore?: SortOrder
  }

  export type EnumVolunteerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VolunteerStatus | EnumVolunteerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VolunteerStatus[]
    notIn?: $Enums.VolunteerStatus[]
    not?: NestedEnumVolunteerStatusWithAggregatesFilter<$PrismaModel> | $Enums.VolunteerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVolunteerStatusFilter<$PrismaModel>
    _max?: NestedEnumVolunteerStatusFilter<$PrismaModel>
  }

  export type EnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[]
    notIn?: $Enums.VerificationStatus[]
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type EnumTrainingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[]
    notIn?: $Enums.TrainingStatus[]
    not?: NestedEnumTrainingStatusFilter<$PrismaModel> | $Enums.TrainingStatus
  }

  export type EnumTrainingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingType | EnumTrainingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingType[]
    notIn?: $Enums.TrainingType[]
    not?: NestedEnumTrainingTypeFilter<$PrismaModel> | $Enums.TrainingType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type VolunteerScalarRelationFilter = {
    is?: VolunteerWhereInput
    isNot?: VolunteerWhereInput
  }

  export type VolunteerTrainingVolunteerIdModuleIdCompoundUniqueInput = {
    volunteerId: string
    moduleId: string
  }

  export type VolunteerTrainingCountOrderByAggregateInput = {
    id?: SortOrder
    volunteerId?: SortOrder
    moduleId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    score?: SortOrder
    passingScore?: SortOrder
    attempts?: SortOrder
    moduleTitle?: SortOrder
    moduleType?: SortOrder
    duration?: SortOrder
    content?: SortOrder
  }

  export type VolunteerTrainingAvgOrderByAggregateInput = {
    score?: SortOrder
    passingScore?: SortOrder
    attempts?: SortOrder
    duration?: SortOrder
  }

  export type VolunteerTrainingMaxOrderByAggregateInput = {
    id?: SortOrder
    volunteerId?: SortOrder
    moduleId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    score?: SortOrder
    passingScore?: SortOrder
    attempts?: SortOrder
    moduleTitle?: SortOrder
    moduleType?: SortOrder
    duration?: SortOrder
  }

  export type VolunteerTrainingMinOrderByAggregateInput = {
    id?: SortOrder
    volunteerId?: SortOrder
    moduleId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    score?: SortOrder
    passingScore?: SortOrder
    attempts?: SortOrder
    moduleTitle?: SortOrder
    moduleType?: SortOrder
    duration?: SortOrder
  }

  export type VolunteerTrainingSumOrderByAggregateInput = {
    score?: SortOrder
    passingScore?: SortOrder
    attempts?: SortOrder
    duration?: SortOrder
  }

  export type EnumTrainingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[]
    notIn?: $Enums.TrainingStatus[]
    not?: NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrainingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingStatusFilter<$PrismaModel>
    _max?: NestedEnumTrainingStatusFilter<$PrismaModel>
  }

  export type EnumTrainingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingType | EnumTrainingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingType[]
    notIn?: $Enums.TrainingType[]
    not?: NestedEnumTrainingTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrainingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingTypeFilter<$PrismaModel>
    _max?: NestedEnumTrainingTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumVolunteerSessionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VolunteerSessionType | EnumVolunteerSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VolunteerSessionType[]
    notIn?: $Enums.VolunteerSessionType[]
    not?: NestedEnumVolunteerSessionTypeFilter<$PrismaModel> | $Enums.VolunteerSessionType
  }

  export type EnumSessionOutcomeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionOutcome | EnumSessionOutcomeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SessionOutcome[] | null
    notIn?: $Enums.SessionOutcome[] | null
    not?: NestedEnumSessionOutcomeNullableFilter<$PrismaModel> | $Enums.SessionOutcome | null
  }

  export type VolunteerSessionCountOrderByAggregateInput = {
    id?: SortOrder
    volunteerId?: SortOrder
    sessionType?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    crisisSessionId?: SortOrder
    responseTime?: SortOrder
    userSatisfaction?: SortOrder
    outcome?: SortOrder
  }

  export type VolunteerSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
    responseTime?: SortOrder
    userSatisfaction?: SortOrder
  }

  export type VolunteerSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    volunteerId?: SortOrder
    sessionType?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    crisisSessionId?: SortOrder
    responseTime?: SortOrder
    userSatisfaction?: SortOrder
    outcome?: SortOrder
  }

  export type VolunteerSessionMinOrderByAggregateInput = {
    id?: SortOrder
    volunteerId?: SortOrder
    sessionType?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    crisisSessionId?: SortOrder
    responseTime?: SortOrder
    userSatisfaction?: SortOrder
    outcome?: SortOrder
  }

  export type VolunteerSessionSumOrderByAggregateInput = {
    duration?: SortOrder
    responseTime?: SortOrder
    userSatisfaction?: SortOrder
  }

  export type EnumVolunteerSessionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VolunteerSessionType | EnumVolunteerSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VolunteerSessionType[]
    notIn?: $Enums.VolunteerSessionType[]
    not?: NestedEnumVolunteerSessionTypeWithAggregatesFilter<$PrismaModel> | $Enums.VolunteerSessionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVolunteerSessionTypeFilter<$PrismaModel>
    _max?: NestedEnumVolunteerSessionTypeFilter<$PrismaModel>
  }

  export type EnumSessionOutcomeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionOutcome | EnumSessionOutcomeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SessionOutcome[] | null
    notIn?: $Enums.SessionOutcome[] | null
    not?: NestedEnumSessionOutcomeNullableWithAggregatesFilter<$PrismaModel> | $Enums.SessionOutcome | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSessionOutcomeNullableFilter<$PrismaModel>
    _max?: NestedEnumSessionOutcomeNullableFilter<$PrismaModel>
  }

  export type EnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[]
    notIn?: $Enums.FeedbackType[]
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type EnumFeedbackSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackSource | EnumFeedbackSourceFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackSource[]
    notIn?: $Enums.FeedbackSource[]
    not?: NestedEnumFeedbackSourceFilter<$PrismaModel> | $Enums.FeedbackSource
  }

  export type VolunteerFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    volunteerId?: SortOrder
    sessionId?: SortOrder
    feedbackType?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    submittedBy?: SortOrder
    sourceType?: SortOrder
    submittedAt?: SortOrder
    isAnonymous?: SortOrder
    isApproved?: SortOrder
    moderatedAt?: SortOrder
    moderatedBy?: SortOrder
  }

  export type VolunteerFeedbackAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type VolunteerFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    volunteerId?: SortOrder
    sessionId?: SortOrder
    feedbackType?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    submittedBy?: SortOrder
    sourceType?: SortOrder
    submittedAt?: SortOrder
    isAnonymous?: SortOrder
    isApproved?: SortOrder
    moderatedAt?: SortOrder
    moderatedBy?: SortOrder
  }

  export type VolunteerFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    volunteerId?: SortOrder
    sessionId?: SortOrder
    feedbackType?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    submittedBy?: SortOrder
    sourceType?: SortOrder
    submittedAt?: SortOrder
    isAnonymous?: SortOrder
    isApproved?: SortOrder
    moderatedAt?: SortOrder
    moderatedBy?: SortOrder
  }

  export type VolunteerFeedbackSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[]
    notIn?: $Enums.FeedbackType[]
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type EnumFeedbackSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackSource | EnumFeedbackSourceFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackSource[]
    notIn?: $Enums.FeedbackSource[]
    not?: NestedEnumFeedbackSourceWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackSourceFilter<$PrismaModel>
    _max?: NestedEnumFeedbackSourceFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EnumResourceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceCategory | EnumResourceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceCategory[]
    notIn?: $Enums.ResourceCategory[]
    not?: NestedEnumResourceCategoryFilter<$PrismaModel> | $Enums.ResourceCategory
  }

  export type CrisisResourceUsageCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    resourceId?: SortOrder
    accessedAt?: SortOrder
    timeSpent?: SortOrder
    wasHelpful?: SortOrder
    helpfulRating?: SortOrder
    resourceTitle?: SortOrder
    resourceType?: SortOrder
  }

  export type CrisisResourceUsageAvgOrderByAggregateInput = {
    timeSpent?: SortOrder
    helpfulRating?: SortOrder
  }

  export type CrisisResourceUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    resourceId?: SortOrder
    accessedAt?: SortOrder
    timeSpent?: SortOrder
    wasHelpful?: SortOrder
    helpfulRating?: SortOrder
    resourceTitle?: SortOrder
    resourceType?: SortOrder
  }

  export type CrisisResourceUsageMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    resourceId?: SortOrder
    accessedAt?: SortOrder
    timeSpent?: SortOrder
    wasHelpful?: SortOrder
    helpfulRating?: SortOrder
    resourceTitle?: SortOrder
    resourceType?: SortOrder
  }

  export type CrisisResourceUsageSumOrderByAggregateInput = {
    timeSpent?: SortOrder
    helpfulRating?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumResourceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceCategory | EnumResourceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceCategory[]
    notIn?: $Enums.ResourceCategory[]
    not?: NestedEnumResourceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ResourceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceCategoryFilter<$PrismaModel>
    _max?: NestedEnumResourceCategoryFilter<$PrismaModel>
  }

  export type EnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[]
    notIn?: $Enums.ReportType[]
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type EnumReportSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportSeverity | EnumReportSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ReportSeverity[]
    notIn?: $Enums.ReportSeverity[]
    not?: NestedEnumReportSeverityFilter<$PrismaModel> | $Enums.ReportSeverity
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[]
    notIn?: $Enums.ReportStatus[]
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type SafetyReportCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    messageId?: SortOrder
    reportType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    content?: SortOrder
    reason?: SortOrder
    confidence?: SortOrder
    aiAnalysis?: SortOrder
    keywordsMatched?: SortOrder
    riskScore?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reviewNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SafetyReportAvgOrderByAggregateInput = {
    confidence?: SortOrder
    riskScore?: SortOrder
  }

  export type SafetyReportMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    messageId?: SortOrder
    reportType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    content?: SortOrder
    reason?: SortOrder
    confidence?: SortOrder
    keywordsMatched?: SortOrder
    riskScore?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reviewNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SafetyReportMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    messageId?: SortOrder
    reportType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    content?: SortOrder
    reason?: SortOrder
    confidence?: SortOrder
    keywordsMatched?: SortOrder
    riskScore?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reviewNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SafetyReportSumOrderByAggregateInput = {
    confidence?: SortOrder
    riskScore?: SortOrder
  }

  export type EnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[]
    notIn?: $Enums.ReportType[]
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type EnumReportSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportSeverity | EnumReportSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ReportSeverity[]
    notIn?: $Enums.ReportSeverity[]
    not?: NestedEnumReportSeverityWithAggregatesFilter<$PrismaModel> | $Enums.ReportSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportSeverityFilter<$PrismaModel>
    _max?: NestedEnumReportSeverityFilter<$PrismaModel>
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[]
    notIn?: $Enums.ReportStatus[]
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    timestamp?: SortOrder
    sessionId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    timestamp?: SortOrder
    sessionId?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    timestamp?: SortOrder
    sessionId?: SortOrder
  }

  export type AnalyticsEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    eventName?: SortOrder
    userHash?: SortOrder
    sessionId?: SortOrder
    properties?: SortOrder
    timestamp?: SortOrder
    responseTime?: SortOrder
    success?: SortOrder
    errorCode?: SortOrder
  }

  export type AnalyticsEventAvgOrderByAggregateInput = {
    responseTime?: SortOrder
  }

  export type AnalyticsEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    eventName?: SortOrder
    userHash?: SortOrder
    sessionId?: SortOrder
    timestamp?: SortOrder
    responseTime?: SortOrder
    success?: SortOrder
    errorCode?: SortOrder
  }

  export type AnalyticsEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    eventName?: SortOrder
    userHash?: SortOrder
    sessionId?: SortOrder
    timestamp?: SortOrder
    responseTime?: SortOrder
    success?: SortOrder
    errorCode?: SortOrder
  }

  export type AnalyticsEventSumOrderByAggregateInput = {
    responseTime?: SortOrder
  }

  export type EnumMetricStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MetricStatus | EnumMetricStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MetricStatus[]
    notIn?: $Enums.MetricStatus[]
    not?: NestedEnumMetricStatusFilter<$PrismaModel> | $Enums.MetricStatus
  }

  export type PerformanceMetricCountOrderByAggregateInput = {
    id?: SortOrder
    metricType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    endpoint?: SortOrder
    region?: SortOrder
    timestamp?: SortOrder
    target?: SortOrder
    threshold?: SortOrder
    status?: SortOrder
  }

  export type PerformanceMetricAvgOrderByAggregateInput = {
    value?: SortOrder
    target?: SortOrder
    threshold?: SortOrder
  }

  export type PerformanceMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    metricType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    endpoint?: SortOrder
    region?: SortOrder
    timestamp?: SortOrder
    target?: SortOrder
    threshold?: SortOrder
    status?: SortOrder
  }

  export type PerformanceMetricMinOrderByAggregateInput = {
    id?: SortOrder
    metricType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    endpoint?: SortOrder
    region?: SortOrder
    timestamp?: SortOrder
    target?: SortOrder
    threshold?: SortOrder
    status?: SortOrder
  }

  export type PerformanceMetricSumOrderByAggregateInput = {
    value?: SortOrder
    target?: SortOrder
    threshold?: SortOrder
  }

  export type EnumMetricStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetricStatus | EnumMetricStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MetricStatus[]
    notIn?: $Enums.MetricStatus[]
    not?: NestedEnumMetricStatusWithAggregatesFilter<$PrismaModel> | $Enums.MetricStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetricStatusFilter<$PrismaModel>
    _max?: NestedEnumMetricStatusFilter<$PrismaModel>
  }

  export type EnumHealthStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HealthStatus | EnumHealthStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HealthStatus[]
    notIn?: $Enums.HealthStatus[]
    not?: NestedEnumHealthStatusFilter<$PrismaModel> | $Enums.HealthStatus
  }

  export type SystemHealthCountOrderByAggregateInput = {
    id?: SortOrder
    component?: SortOrder
    status?: SortOrder
    responseTime?: SortOrder
    uptime?: SortOrder
    errorRate?: SortOrder
    lastError?: SortOrder
    errorMessage?: SortOrder
    cpuUsage?: SortOrder
    memoryUsage?: SortOrder
    diskUsage?: SortOrder
    timestamp?: SortOrder
  }

  export type SystemHealthAvgOrderByAggregateInput = {
    responseTime?: SortOrder
    uptime?: SortOrder
    errorRate?: SortOrder
    cpuUsage?: SortOrder
    memoryUsage?: SortOrder
    diskUsage?: SortOrder
  }

  export type SystemHealthMaxOrderByAggregateInput = {
    id?: SortOrder
    component?: SortOrder
    status?: SortOrder
    responseTime?: SortOrder
    uptime?: SortOrder
    errorRate?: SortOrder
    lastError?: SortOrder
    errorMessage?: SortOrder
    cpuUsage?: SortOrder
    memoryUsage?: SortOrder
    diskUsage?: SortOrder
    timestamp?: SortOrder
  }

  export type SystemHealthMinOrderByAggregateInput = {
    id?: SortOrder
    component?: SortOrder
    status?: SortOrder
    responseTime?: SortOrder
    uptime?: SortOrder
    errorRate?: SortOrder
    lastError?: SortOrder
    errorMessage?: SortOrder
    cpuUsage?: SortOrder
    memoryUsage?: SortOrder
    diskUsage?: SortOrder
    timestamp?: SortOrder
  }

  export type SystemHealthSumOrderByAggregateInput = {
    responseTime?: SortOrder
    uptime?: SortOrder
    errorRate?: SortOrder
    cpuUsage?: SortOrder
    memoryUsage?: SortOrder
    diskUsage?: SortOrder
  }

  export type EnumHealthStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HealthStatus | EnumHealthStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HealthStatus[]
    notIn?: $Enums.HealthStatus[]
    not?: NestedEnumHealthStatusWithAggregatesFilter<$PrismaModel> | $Enums.HealthStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHealthStatusFilter<$PrismaModel>
    _max?: NestedEnumHealthStatusFilter<$PrismaModel>
  }

  export type CrisisResourceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    phoneNumber?: SortOrder
    url?: SortOrder
    email?: SortOrder
    textNumber?: SortOrder
    content?: SortOrder
    instructions?: SortOrder
    available24_7?: SortOrder
    languages?: SortOrder
    countries?: SortOrder
    regions?: SortOrder
    priority?: SortOrder
    isEmergency?: SortOrder
    severityMin?: SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrisisResourceAvgOrderByAggregateInput = {
    priority?: SortOrder
    severityMin?: SortOrder
  }

  export type CrisisResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    phoneNumber?: SortOrder
    url?: SortOrder
    email?: SortOrder
    textNumber?: SortOrder
    content?: SortOrder
    instructions?: SortOrder
    available24_7?: SortOrder
    languages?: SortOrder
    countries?: SortOrder
    regions?: SortOrder
    priority?: SortOrder
    isEmergency?: SortOrder
    severityMin?: SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrisisResourceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    phoneNumber?: SortOrder
    url?: SortOrder
    email?: SortOrder
    textNumber?: SortOrder
    content?: SortOrder
    instructions?: SortOrder
    available24_7?: SortOrder
    languages?: SortOrder
    countries?: SortOrder
    regions?: SortOrder
    priority?: SortOrder
    isEmergency?: SortOrder
    severityMin?: SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrisisResourceSumOrderByAggregateInput = {
    priority?: SortOrder
    severityMin?: SortOrder
  }

  export type PublicMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    metricName?: SortOrder
    value?: SortOrder
    displayValue?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    displayOrder?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    lastUpdated?: SortOrder
    updateFrequency?: SortOrder
  }

  export type PublicMetricsAvgOrderByAggregateInput = {
    value?: SortOrder
    displayOrder?: SortOrder
  }

  export type PublicMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    metricName?: SortOrder
    value?: SortOrder
    displayValue?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    displayOrder?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    lastUpdated?: SortOrder
    updateFrequency?: SortOrder
  }

  export type PublicMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    metricName?: SortOrder
    value?: SortOrder
    displayValue?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    displayOrder?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    lastUpdated?: SortOrder
    updateFrequency?: SortOrder
  }

  export type PublicMetricsSumOrderByAggregateInput = {
    value?: SortOrder
    displayOrder?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EmergencyNotificationListRelationFilter = {
    every?: EmergencyNotificationWhereInput
    some?: EmergencyNotificationWhereInput
    none?: EmergencyNotificationWhereInput
  }

  export type EmergencyNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmergencyContactCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    encryptedName?: SortOrder
    encryptedPhone?: SortOrder
    encryptedEmail?: SortOrder
    relationship?: SortOrder
    priority?: SortOrder
    contactMethod?: SortOrder
    timezone?: SortOrder
    availableHours?: SortOrder
    preferredMethod?: SortOrder
    autoNotify?: SortOrder
    crisisOnly?: SortOrder
    hasConsent?: SortOrder
    consentDate?: SortOrder
    keyDerivationSalt?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastContacted?: SortOrder
  }

  export type EmergencyContactAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type EmergencyContactMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    encryptedName?: SortOrder
    encryptedPhone?: SortOrder
    encryptedEmail?: SortOrder
    relationship?: SortOrder
    priority?: SortOrder
    contactMethod?: SortOrder
    timezone?: SortOrder
    preferredMethod?: SortOrder
    autoNotify?: SortOrder
    crisisOnly?: SortOrder
    hasConsent?: SortOrder
    consentDate?: SortOrder
    keyDerivationSalt?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastContacted?: SortOrder
  }

  export type EmergencyContactMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    encryptedName?: SortOrder
    encryptedPhone?: SortOrder
    encryptedEmail?: SortOrder
    relationship?: SortOrder
    priority?: SortOrder
    contactMethod?: SortOrder
    timezone?: SortOrder
    preferredMethod?: SortOrder
    autoNotify?: SortOrder
    crisisOnly?: SortOrder
    hasConsent?: SortOrder
    consentDate?: SortOrder
    keyDerivationSalt?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastContacted?: SortOrder
  }

  export type EmergencyContactSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type EnumEmergencyNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyNotificationType | EnumEmergencyNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmergencyNotificationType[]
    notIn?: $Enums.EmergencyNotificationType[]
    not?: NestedEnumEmergencyNotificationTypeFilter<$PrismaModel> | $Enums.EmergencyNotificationType
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[]
    notIn?: $Enums.NotificationStatus[]
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type EmergencyContactScalarRelationFilter = {
    is?: EmergencyContactWhereInput
    isNot?: EmergencyContactWhereInput
  }

  export type EmergencyNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    emergencyContactId?: SortOrder
    sessionId?: SortOrder
    tetherEmergencyId?: SortOrder
    notificationType?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    acknowledgedAt?: SortOrder
    responseReceived?: SortOrder
    responseTime?: SortOrder
    method?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    errorMessage?: SortOrder
    nextRetryAt?: SortOrder
  }

  export type EmergencyNotificationAvgOrderByAggregateInput = {
    responseTime?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type EmergencyNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    emergencyContactId?: SortOrder
    sessionId?: SortOrder
    tetherEmergencyId?: SortOrder
    notificationType?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    acknowledgedAt?: SortOrder
    responseReceived?: SortOrder
    responseTime?: SortOrder
    method?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    errorMessage?: SortOrder
    nextRetryAt?: SortOrder
  }

  export type EmergencyNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    emergencyContactId?: SortOrder
    sessionId?: SortOrder
    tetherEmergencyId?: SortOrder
    notificationType?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    acknowledgedAt?: SortOrder
    responseReceived?: SortOrder
    responseTime?: SortOrder
    method?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    errorMessage?: SortOrder
    nextRetryAt?: SortOrder
  }

  export type EmergencyNotificationSumOrderByAggregateInput = {
    responseTime?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type EnumEmergencyNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyNotificationType | EnumEmergencyNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmergencyNotificationType[]
    notIn?: $Enums.EmergencyNotificationType[]
    not?: NestedEnumEmergencyNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmergencyNotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmergencyNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumEmergencyNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[]
    notIn?: $Enums.NotificationStatus[]
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type WebSocketConnectionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userType?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    lastActivity?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type WebSocketConnectionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userType?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    lastActivity?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type WebSocketConnectionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userType?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    lastActivity?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type EnumUserDataSharingFilter<$PrismaModel = never> = {
    equals?: $Enums.UserDataSharing | EnumUserDataSharingFieldRefInput<$PrismaModel>
    in?: $Enums.UserDataSharing[]
    notIn?: $Enums.UserDataSharing[]
    not?: NestedEnumUserDataSharingFilter<$PrismaModel> | $Enums.UserDataSharing
  }

  export type MoodEntryListRelationFilter = {
    every?: MoodEntryWhereInput
    some?: MoodEntryWhereInput
    none?: MoodEntryWhereInput
  }

  export type SafetyPlanListRelationFilter = {
    every?: SafetyPlanWhereInput
    some?: SafetyPlanWhereInput
    none?: SafetyPlanWhereInput
  }

  export type UserProfileNullableScalarRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type UserAchievementListRelationFilter = {
    every?: UserAchievementWhereInput
    some?: UserAchievementWhereInput
    none?: UserAchievementWhereInput
  }

  export type UserChallengeListRelationFilter = {
    every?: UserChallengeWhereInput
    some?: UserChallengeWhereInput
    none?: UserChallengeWhereInput
  }

  export type UserActivityListRelationFilter = {
    every?: UserActivityWhereInput
    some?: UserActivityWhereInput
    none?: UserActivityWhereInput
  }

  export type EmergencyContactListRelationFilter = {
    every?: EmergencyContactWhereInput
    some?: EmergencyContactWhereInput
    none?: EmergencyContactWhereInput
  }

  export type JournalEntryListRelationFilter = {
    every?: JournalEntryWhereInput
    some?: JournalEntryWhereInput
    none?: JournalEntryWhereInput
  }

  export type BreathingSessionListRelationFilter = {
    every?: BreathingSessionWhereInput
    some?: BreathingSessionWhereInput
    none?: BreathingSessionWhereInput
  }

  export type GroundingSessionListRelationFilter = {
    every?: GroundingSessionWhereInput
    some?: GroundingSessionWhereInput
    none?: GroundingSessionWhereInput
  }

  export type SelfHelpInteractionListRelationFilter = {
    every?: SelfHelpInteractionWhereInput
    some?: SelfHelpInteractionWhereInput
    none?: SelfHelpInteractionWhereInput
  }

  export type MoodEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SafetyPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserChallengeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmergencyContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BreathingSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroundingSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SelfHelpInteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    anonymousId?: SortOrder
    email?: SortOrder
    username?: SortOrder
    isAnonymous?: SortOrder
    lastLogin?: SortOrder
    dataSharing?: SortOrder
    allowAnalytics?: SortOrder
    dataRetentionDays?: SortOrder
    verificationStatus?: SortOrder
    professionalType?: SortOrder
    licenseNumber?: SortOrder
    verifiedAt?: SortOrder
    encryptedProfile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    dataRetentionDays?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    anonymousId?: SortOrder
    email?: SortOrder
    username?: SortOrder
    isAnonymous?: SortOrder
    lastLogin?: SortOrder
    dataSharing?: SortOrder
    allowAnalytics?: SortOrder
    dataRetentionDays?: SortOrder
    verificationStatus?: SortOrder
    professionalType?: SortOrder
    licenseNumber?: SortOrder
    verifiedAt?: SortOrder
    encryptedProfile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    anonymousId?: SortOrder
    email?: SortOrder
    username?: SortOrder
    isAnonymous?: SortOrder
    lastLogin?: SortOrder
    dataSharing?: SortOrder
    allowAnalytics?: SortOrder
    dataRetentionDays?: SortOrder
    verificationStatus?: SortOrder
    professionalType?: SortOrder
    licenseNumber?: SortOrder
    verifiedAt?: SortOrder
    encryptedProfile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    dataRetentionDays?: SortOrder
  }

  export type EnumUserDataSharingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserDataSharing | EnumUserDataSharingFieldRefInput<$PrismaModel>
    in?: $Enums.UserDataSharing[]
    notIn?: $Enums.UserDataSharing[]
    not?: NestedEnumUserDataSharingWithAggregatesFilter<$PrismaModel> | $Enums.UserDataSharing
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserDataSharingFilter<$PrismaModel>
    _max?: NestedEnumUserDataSharingFilter<$PrismaModel>
  }

  export type MoodEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    emotions?: SortOrder
    triggers?: SortOrder
    activities?: SortOrder
    sleepHours?: SortOrder
    notes?: SortOrder
    weather?: SortOrder
    medication?: SortOrder
    socialInteraction?: SortOrder
    timestamp?: SortOrder
  }

  export type MoodEntryAvgOrderByAggregateInput = {
    mood?: SortOrder
    sleepHours?: SortOrder
    socialInteraction?: SortOrder
  }

  export type MoodEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    sleepHours?: SortOrder
    notes?: SortOrder
    weather?: SortOrder
    medication?: SortOrder
    socialInteraction?: SortOrder
    timestamp?: SortOrder
  }

  export type MoodEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    sleepHours?: SortOrder
    notes?: SortOrder
    weather?: SortOrder
    medication?: SortOrder
    socialInteraction?: SortOrder
    timestamp?: SortOrder
  }

  export type MoodEntrySumOrderByAggregateInput = {
    mood?: SortOrder
    sleepHours?: SortOrder
    socialInteraction?: SortOrder
  }

  export type SafetyPlanVersionListRelationFilter = {
    every?: SafetyPlanVersionWhereInput
    some?: SafetyPlanVersionWhereInput
    none?: SafetyPlanVersionWhereInput
  }

  export type SafetyPlanVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SafetyPlanCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    encryptedContent?: SortOrder
    contentHash?: SortOrder
    sharedWith?: SortOrder
    emergencyShare?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SafetyPlanAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type SafetyPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    encryptedContent?: SortOrder
    contentHash?: SortOrder
    emergencyShare?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SafetyPlanMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    encryptedContent?: SortOrder
    contentHash?: SortOrder
    emergencyShare?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SafetyPlanSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type SafetyPlanScalarRelationFilter = {
    is?: SafetyPlanWhereInput
    isNot?: SafetyPlanWhereInput
  }

  export type SafetyPlanVersionSafetyPlanIdVersionCompoundUniqueInput = {
    safetyPlanId: string
    version: number
  }

  export type SafetyPlanVersionCountOrderByAggregateInput = {
    id?: SortOrder
    safetyPlanId?: SortOrder
    version?: SortOrder
    changeLog?: SortOrder
    encryptedContent?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type SafetyPlanVersionAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type SafetyPlanVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    safetyPlanId?: SortOrder
    version?: SortOrder
    changeLog?: SortOrder
    encryptedContent?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type SafetyPlanVersionMinOrderByAggregateInput = {
    id?: SortOrder
    safetyPlanId?: SortOrder
    version?: SortOrder
    changeLog?: SortOrder
    encryptedContent?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type SafetyPlanVersionSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    level?: SortOrder
    totalXP?: SortOrder
    preferences?: SortOrder
    stats?: SortOrder
    joinDate?: SortOrder
    lastActiveDate?: SortOrder
  }

  export type UserProfileAvgOrderByAggregateInput = {
    level?: SortOrder
    totalXP?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    level?: SortOrder
    totalXP?: SortOrder
    joinDate?: SortOrder
    lastActiveDate?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    level?: SortOrder
    totalXP?: SortOrder
    joinDate?: SortOrder
    lastActiveDate?: SortOrder
  }

  export type UserProfileSumOrderByAggregateInput = {
    level?: SortOrder
    totalXP?: SortOrder
  }

  export type EnumAchievementCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[]
    notIn?: $Enums.AchievementCategory[]
    not?: NestedEnumAchievementCategoryFilter<$PrismaModel> | $Enums.AchievementCategory
  }

  export type EnumAchievementRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementRarity | EnumAchievementRarityFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementRarity[]
    notIn?: $Enums.AchievementRarity[]
    not?: NestedEnumAchievementRarityFilter<$PrismaModel> | $Enums.AchievementRarity
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    rarity?: SortOrder
    requirements?: SortOrder
    xpReward?: SortOrder
    pointReward?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    xpReward?: SortOrder
    pointReward?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    rarity?: SortOrder
    xpReward?: SortOrder
    pointReward?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    rarity?: SortOrder
    xpReward?: SortOrder
    pointReward?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    xpReward?: SortOrder
    pointReward?: SortOrder
  }

  export type EnumAchievementCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[]
    notIn?: $Enums.AchievementCategory[]
    not?: NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AchievementCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementCategoryFilter<$PrismaModel>
    _max?: NestedEnumAchievementCategoryFilter<$PrismaModel>
  }

  export type EnumAchievementRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementRarity | EnumAchievementRarityFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementRarity[]
    notIn?: $Enums.AchievementRarity[]
    not?: NestedEnumAchievementRarityWithAggregatesFilter<$PrismaModel> | $Enums.AchievementRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementRarityFilter<$PrismaModel>
    _max?: NestedEnumAchievementRarityFilter<$PrismaModel>
  }

  export type AchievementScalarRelationFilter = {
    is?: AchievementWhereInput
    isNot?: AchievementWhereInput
  }

  export type UserAchievementUserIdAchievementIdCompoundUniqueInput = {
    userId: string
    achievementId: string
  }

  export type UserAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAchievementAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type UserAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAchievementSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumChallengeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeType | EnumChallengeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeType[]
    notIn?: $Enums.ChallengeType[]
    not?: NestedEnumChallengeTypeFilter<$PrismaModel> | $Enums.ChallengeType
  }

  export type EnumChallengeDifficultyFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeDifficulty | EnumChallengeDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeDifficulty[]
    notIn?: $Enums.ChallengeDifficulty[]
    not?: NestedEnumChallengeDifficultyFilter<$PrismaModel> | $Enums.ChallengeDifficulty
  }

  export type ChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    requirements?: SortOrder
    duration?: SortOrder
    xpReward?: SortOrder
    pointReward?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
  }

  export type ChallengeAvgOrderByAggregateInput = {
    duration?: SortOrder
    xpReward?: SortOrder
    pointReward?: SortOrder
  }

  export type ChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    xpReward?: SortOrder
    pointReward?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
  }

  export type ChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    xpReward?: SortOrder
    pointReward?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
  }

  export type ChallengeSumOrderByAggregateInput = {
    duration?: SortOrder
    xpReward?: SortOrder
    pointReward?: SortOrder
  }

  export type EnumChallengeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeType | EnumChallengeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeType[]
    notIn?: $Enums.ChallengeType[]
    not?: NestedEnumChallengeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeTypeFilter<$PrismaModel>
    _max?: NestedEnumChallengeTypeFilter<$PrismaModel>
  }

  export type EnumChallengeDifficultyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeDifficulty | EnumChallengeDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeDifficulty[]
    notIn?: $Enums.ChallengeDifficulty[]
    not?: NestedEnumChallengeDifficultyWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeDifficulty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeDifficultyFilter<$PrismaModel>
    _max?: NestedEnumChallengeDifficultyFilter<$PrismaModel>
  }

  export type ChallengeScalarRelationFilter = {
    is?: ChallengeWhereInput
    isNot?: ChallengeWhereInput
  }

  export type UserChallengeUserIdChallengeIdCompoundUniqueInput = {
    userId: string
    challengeId: string
  }

  export type UserChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    progress?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    startedAt?: SortOrder
    data?: SortOrder
  }

  export type UserChallengeAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type UserChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    progress?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    startedAt?: SortOrder
  }

  export type UserChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    progress?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    startedAt?: SortOrder
  }

  export type UserChallengeSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[]
    notIn?: $Enums.ActivityType[]
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type UserActivityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    xpEarned?: SortOrder
    pointsEarned?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
  }

  export type UserActivityAvgOrderByAggregateInput = {
    xpEarned?: SortOrder
    pointsEarned?: SortOrder
  }

  export type UserActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    xpEarned?: SortOrder
    pointsEarned?: SortOrder
    timestamp?: SortOrder
  }

  export type UserActivityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    xpEarned?: SortOrder
    pointsEarned?: SortOrder
    timestamp?: SortOrder
  }

  export type UserActivitySumOrderByAggregateInput = {
    xpEarned?: SortOrder
    pointsEarned?: SortOrder
  }

  export type EnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[]
    notIn?: $Enums.ActivityType[]
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type EnumJournalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalType | EnumJournalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JournalType[]
    notIn?: $Enums.JournalType[]
    not?: NestedEnumJournalTypeFilter<$PrismaModel> | $Enums.JournalType
  }

  export type JournalEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    promptId?: SortOrder
    promptText?: SortOrder
    entryType?: SortOrder
    encryptedContent?: SortOrder
    contentHash?: SortOrder
    keyDerivationSalt?: SortOrder
    mood?: SortOrder
    sentimentScore?: SortOrder
    emotions?: SortOrder
    tags?: SortOrder
    isPrivate?: SortOrder
    shareWithTherapist?: SortOrder
    wordCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalEntryAvgOrderByAggregateInput = {
    mood?: SortOrder
    sentimentScore?: SortOrder
    wordCount?: SortOrder
  }

  export type JournalEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    promptId?: SortOrder
    promptText?: SortOrder
    entryType?: SortOrder
    encryptedContent?: SortOrder
    contentHash?: SortOrder
    keyDerivationSalt?: SortOrder
    mood?: SortOrder
    sentimentScore?: SortOrder
    isPrivate?: SortOrder
    shareWithTherapist?: SortOrder
    wordCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    promptId?: SortOrder
    promptText?: SortOrder
    entryType?: SortOrder
    encryptedContent?: SortOrder
    contentHash?: SortOrder
    keyDerivationSalt?: SortOrder
    mood?: SortOrder
    sentimentScore?: SortOrder
    isPrivate?: SortOrder
    shareWithTherapist?: SortOrder
    wordCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalEntrySumOrderByAggregateInput = {
    mood?: SortOrder
    sentimentScore?: SortOrder
    wordCount?: SortOrder
  }

  export type EnumJournalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalType | EnumJournalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JournalType[]
    notIn?: $Enums.JournalType[]
    not?: NestedEnumJournalTypeWithAggregatesFilter<$PrismaModel> | $Enums.JournalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJournalTypeFilter<$PrismaModel>
    _max?: NestedEnumJournalTypeFilter<$PrismaModel>
  }

  export type EnumBreathingTechniqueFilter<$PrismaModel = never> = {
    equals?: $Enums.BreathingTechnique | EnumBreathingTechniqueFieldRefInput<$PrismaModel>
    in?: $Enums.BreathingTechnique[]
    notIn?: $Enums.BreathingTechnique[]
    not?: NestedEnumBreathingTechniqueFilter<$PrismaModel> | $Enums.BreathingTechnique
  }

  export type EnumExerciseDifficultyFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseDifficulty | EnumExerciseDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseDifficulty[]
    notIn?: $Enums.ExerciseDifficulty[]
    not?: NestedEnumExerciseDifficultyFilter<$PrismaModel> | $Enums.ExerciseDifficulty
  }

  export type BreathingExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    technique?: SortOrder
    difficulty?: SortOrder
    inhaleSeconds?: SortOrder
    holdSeconds?: SortOrder
    exhaleSeconds?: SortOrder
    pauseSeconds?: SortOrder
    cyclesRecommended?: SortOrder
    instructions?: SortOrder
    visualGuideUrl?: SortOrder
    audioGuideUrl?: SortOrder
    benefits?: SortOrder
    bestFor?: SortOrder
    contraindications?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type BreathingExerciseAvgOrderByAggregateInput = {
    inhaleSeconds?: SortOrder
    holdSeconds?: SortOrder
    exhaleSeconds?: SortOrder
    pauseSeconds?: SortOrder
    cyclesRecommended?: SortOrder
  }

  export type BreathingExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    technique?: SortOrder
    difficulty?: SortOrder
    inhaleSeconds?: SortOrder
    holdSeconds?: SortOrder
    exhaleSeconds?: SortOrder
    pauseSeconds?: SortOrder
    cyclesRecommended?: SortOrder
    visualGuideUrl?: SortOrder
    audioGuideUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type BreathingExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    technique?: SortOrder
    difficulty?: SortOrder
    inhaleSeconds?: SortOrder
    holdSeconds?: SortOrder
    exhaleSeconds?: SortOrder
    pauseSeconds?: SortOrder
    cyclesRecommended?: SortOrder
    visualGuideUrl?: SortOrder
    audioGuideUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type BreathingExerciseSumOrderByAggregateInput = {
    inhaleSeconds?: SortOrder
    holdSeconds?: SortOrder
    exhaleSeconds?: SortOrder
    pauseSeconds?: SortOrder
    cyclesRecommended?: SortOrder
  }

  export type EnumBreathingTechniqueWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BreathingTechnique | EnumBreathingTechniqueFieldRefInput<$PrismaModel>
    in?: $Enums.BreathingTechnique[]
    notIn?: $Enums.BreathingTechnique[]
    not?: NestedEnumBreathingTechniqueWithAggregatesFilter<$PrismaModel> | $Enums.BreathingTechnique
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBreathingTechniqueFilter<$PrismaModel>
    _max?: NestedEnumBreathingTechniqueFilter<$PrismaModel>
  }

  export type EnumExerciseDifficultyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseDifficulty | EnumExerciseDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseDifficulty[]
    notIn?: $Enums.ExerciseDifficulty[]
    not?: NestedEnumExerciseDifficultyWithAggregatesFilter<$PrismaModel> | $Enums.ExerciseDifficulty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExerciseDifficultyFilter<$PrismaModel>
    _max?: NestedEnumExerciseDifficultyFilter<$PrismaModel>
  }

  export type BreathingExerciseScalarRelationFilter = {
    is?: BreathingExerciseWhereInput
    isNot?: BreathingExerciseWhereInput
  }

  export type BreathingSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    duration?: SortOrder
    cyclesCompleted?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
    anxietyBefore?: SortOrder
    anxietyAfter?: SortOrder
    averageBreathRate?: SortOrder
    heartRateBefore?: SortOrder
    heartRateAfter?: SortOrder
    wasHelpful?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
  }

  export type BreathingSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
    cyclesCompleted?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
    anxietyBefore?: SortOrder
    anxietyAfter?: SortOrder
    averageBreathRate?: SortOrder
    heartRateBefore?: SortOrder
    heartRateAfter?: SortOrder
    rating?: SortOrder
  }

  export type BreathingSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    duration?: SortOrder
    cyclesCompleted?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
    anxietyBefore?: SortOrder
    anxietyAfter?: SortOrder
    averageBreathRate?: SortOrder
    heartRateBefore?: SortOrder
    heartRateAfter?: SortOrder
    wasHelpful?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
  }

  export type BreathingSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    duration?: SortOrder
    cyclesCompleted?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
    anxietyBefore?: SortOrder
    anxietyAfter?: SortOrder
    averageBreathRate?: SortOrder
    heartRateBefore?: SortOrder
    heartRateAfter?: SortOrder
    wasHelpful?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
  }

  export type BreathingSessionSumOrderByAggregateInput = {
    duration?: SortOrder
    cyclesCompleted?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
    anxietyBefore?: SortOrder
    anxietyAfter?: SortOrder
    averageBreathRate?: SortOrder
    heartRateBefore?: SortOrder
    heartRateAfter?: SortOrder
    rating?: SortOrder
  }

  export type EnumGroundingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GroundingType | EnumGroundingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GroundingType[]
    notIn?: $Enums.GroundingType[]
    not?: NestedEnumGroundingTypeFilter<$PrismaModel> | $Enums.GroundingType
  }

  export type EnumGroundingCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.GroundingCategory | EnumGroundingCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.GroundingCategory[]
    notIn?: $Enums.GroundingCategory[]
    not?: NestedEnumGroundingCategoryFilter<$PrismaModel> | $Enums.GroundingCategory
  }

  export type EnumEvidenceLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceLevel | EnumEvidenceLevelFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceLevel[]
    notIn?: $Enums.EvidenceLevel[]
    not?: NestedEnumEvidenceLevelFilter<$PrismaModel> | $Enums.EvidenceLevel
  }

  export type GroundingTechniqueCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    instructions?: SortOrder
    duration?: SortOrder
    materials?: SortOrder
    audioGuideUrl?: SortOrder
    videoGuideUrl?: SortOrder
    imageGuides?: SortOrder
    evidenceLevel?: SortOrder
    bestFor?: SortOrder
    contraindications?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type GroundingTechniqueAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type GroundingTechniqueMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    duration?: SortOrder
    audioGuideUrl?: SortOrder
    videoGuideUrl?: SortOrder
    evidenceLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type GroundingTechniqueMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    duration?: SortOrder
    audioGuideUrl?: SortOrder
    videoGuideUrl?: SortOrder
    evidenceLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type GroundingTechniqueSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumGroundingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroundingType | EnumGroundingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GroundingType[]
    notIn?: $Enums.GroundingType[]
    not?: NestedEnumGroundingTypeWithAggregatesFilter<$PrismaModel> | $Enums.GroundingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroundingTypeFilter<$PrismaModel>
    _max?: NestedEnumGroundingTypeFilter<$PrismaModel>
  }

  export type EnumGroundingCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroundingCategory | EnumGroundingCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.GroundingCategory[]
    notIn?: $Enums.GroundingCategory[]
    not?: NestedEnumGroundingCategoryWithAggregatesFilter<$PrismaModel> | $Enums.GroundingCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroundingCategoryFilter<$PrismaModel>
    _max?: NestedEnumGroundingCategoryFilter<$PrismaModel>
  }

  export type EnumEvidenceLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceLevel | EnumEvidenceLevelFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceLevel[]
    notIn?: $Enums.EvidenceLevel[]
    not?: NestedEnumEvidenceLevelWithAggregatesFilter<$PrismaModel> | $Enums.EvidenceLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvidenceLevelFilter<$PrismaModel>
    _max?: NestedEnumEvidenceLevelFilter<$PrismaModel>
  }

  export type GroundingTechniqueScalarRelationFilter = {
    is?: GroundingTechniqueWhereInput
    isNot?: GroundingTechniqueWhereInput
  }

  export type GroundingSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    techniqueId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    duration?: SortOrder
    triggerType?: SortOrder
    severityBefore?: SortOrder
    severityAfter?: SortOrder
    panicBefore?: SortOrder
    panicAfter?: SortOrder
    dissociationBefore?: SortOrder
    dissociationAfter?: SortOrder
    stepsCompleted?: SortOrder
    completionRate?: SortOrder
    wasHelpful?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    wouldUseAgain?: SortOrder
  }

  export type GroundingSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
    severityBefore?: SortOrder
    severityAfter?: SortOrder
    panicBefore?: SortOrder
    panicAfter?: SortOrder
    dissociationBefore?: SortOrder
    dissociationAfter?: SortOrder
    completionRate?: SortOrder
    rating?: SortOrder
  }

  export type GroundingSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    techniqueId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    duration?: SortOrder
    triggerType?: SortOrder
    severityBefore?: SortOrder
    severityAfter?: SortOrder
    panicBefore?: SortOrder
    panicAfter?: SortOrder
    dissociationBefore?: SortOrder
    dissociationAfter?: SortOrder
    completionRate?: SortOrder
    wasHelpful?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    wouldUseAgain?: SortOrder
  }

  export type GroundingSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    techniqueId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    duration?: SortOrder
    triggerType?: SortOrder
    severityBefore?: SortOrder
    severityAfter?: SortOrder
    panicBefore?: SortOrder
    panicAfter?: SortOrder
    dissociationBefore?: SortOrder
    dissociationAfter?: SortOrder
    completionRate?: SortOrder
    wasHelpful?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    wouldUseAgain?: SortOrder
  }

  export type GroundingSessionSumOrderByAggregateInput = {
    duration?: SortOrder
    severityBefore?: SortOrder
    severityAfter?: SortOrder
    panicBefore?: SortOrder
    panicAfter?: SortOrder
    dissociationBefore?: SortOrder
    dissociationAfter?: SortOrder
    completionRate?: SortOrder
    rating?: SortOrder
  }

  export type EnumSelfHelpCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SelfHelpCategory | EnumSelfHelpCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SelfHelpCategory[]
    notIn?: $Enums.SelfHelpCategory[]
    not?: NestedEnumSelfHelpCategoryFilter<$PrismaModel> | $Enums.SelfHelpCategory
  }

  export type EnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[]
    notIn?: $Enums.ResourceType[]
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type SelfHelpResourceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    content?: SortOrder
    url?: SortOrder
    mediaUrl?: SortOrder
    thumbnailUrl?: SortOrder
    duration?: SortOrder
    difficulty?: SortOrder
    evidenceLevel?: SortOrder
    tags?: SortOrder
    conditions?: SortOrder
    symptoms?: SortOrder
    viewCount?: SortOrder
    helpfulCount?: SortOrder
    averageRating?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SelfHelpResourceAvgOrderByAggregateInput = {
    duration?: SortOrder
    viewCount?: SortOrder
    helpfulCount?: SortOrder
    averageRating?: SortOrder
  }

  export type SelfHelpResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    content?: SortOrder
    url?: SortOrder
    mediaUrl?: SortOrder
    thumbnailUrl?: SortOrder
    duration?: SortOrder
    difficulty?: SortOrder
    evidenceLevel?: SortOrder
    viewCount?: SortOrder
    helpfulCount?: SortOrder
    averageRating?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SelfHelpResourceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    content?: SortOrder
    url?: SortOrder
    mediaUrl?: SortOrder
    thumbnailUrl?: SortOrder
    duration?: SortOrder
    difficulty?: SortOrder
    evidenceLevel?: SortOrder
    viewCount?: SortOrder
    helpfulCount?: SortOrder
    averageRating?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SelfHelpResourceSumOrderByAggregateInput = {
    duration?: SortOrder
    viewCount?: SortOrder
    helpfulCount?: SortOrder
    averageRating?: SortOrder
  }

  export type EnumSelfHelpCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SelfHelpCategory | EnumSelfHelpCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SelfHelpCategory[]
    notIn?: $Enums.SelfHelpCategory[]
    not?: NestedEnumSelfHelpCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SelfHelpCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSelfHelpCategoryFilter<$PrismaModel>
    _max?: NestedEnumSelfHelpCategoryFilter<$PrismaModel>
  }

  export type EnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[]
    notIn?: $Enums.ResourceType[]
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type EnumInteractionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[]
    notIn?: $Enums.InteractionType[]
    not?: NestedEnumInteractionTypeFilter<$PrismaModel> | $Enums.InteractionType
  }

  export type SelfHelpResourceScalarRelationFilter = {
    is?: SelfHelpResourceWhereInput
    isNot?: SelfHelpResourceWhereInput
  }

  export type SelfHelpInteractionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resourceId?: SortOrder
    interactionType?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    duration?: SortOrder
    wasHelpful?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
  }

  export type SelfHelpInteractionAvgOrderByAggregateInput = {
    duration?: SortOrder
    rating?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
  }

  export type SelfHelpInteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resourceId?: SortOrder
    interactionType?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    duration?: SortOrder
    wasHelpful?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
  }

  export type SelfHelpInteractionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resourceId?: SortOrder
    interactionType?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    duration?: SortOrder
    wasHelpful?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
  }

  export type SelfHelpInteractionSumOrderByAggregateInput = {
    duration?: SortOrder
    rating?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
  }

  export type EnumInteractionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[]
    notIn?: $Enums.InteractionType[]
    not?: NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InteractionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInteractionTypeFilter<$PrismaModel>
    _max?: NestedEnumInteractionTypeFilter<$PrismaModel>
  }

  export type AITherapySessionListRelationFilter = {
    every?: AITherapySessionWhereInput
    some?: AITherapySessionWhereInput
    none?: AITherapySessionWhereInput
  }

  export type AIPersonalizationListRelationFilter = {
    every?: AIPersonalizationWhereInput
    some?: AIPersonalizationWhereInput
    none?: AIPersonalizationWhereInput
  }

  export type AITherapySessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIPersonalizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AITherapistCountOrderByAggregateInput = {
    id?: SortOrder
    therapistId?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    personality?: SortOrder
    description?: SortOrder
    specialties?: SortOrder
    approaches?: SortOrder
    bestFor?: SortOrder
    features?: SortOrder
    availability?: SortOrder
    sessionsCompleted?: SortOrder
    userRating?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AITherapistAvgOrderByAggregateInput = {
    sessionsCompleted?: SortOrder
    userRating?: SortOrder
    responseTime?: SortOrder
  }

  export type AITherapistMaxOrderByAggregateInput = {
    id?: SortOrder
    therapistId?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    personality?: SortOrder
    description?: SortOrder
    specialties?: SortOrder
    approaches?: SortOrder
    bestFor?: SortOrder
    features?: SortOrder
    availability?: SortOrder
    sessionsCompleted?: SortOrder
    userRating?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AITherapistMinOrderByAggregateInput = {
    id?: SortOrder
    therapistId?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    personality?: SortOrder
    description?: SortOrder
    specialties?: SortOrder
    approaches?: SortOrder
    bestFor?: SortOrder
    features?: SortOrder
    availability?: SortOrder
    sessionsCompleted?: SortOrder
    userRating?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AITherapistSumOrderByAggregateInput = {
    sessionsCompleted?: SortOrder
    userRating?: SortOrder
    responseTime?: SortOrder
  }

  export type EnumAISessionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AISessionType | EnumAISessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AISessionType[]
    notIn?: $Enums.AISessionType[]
    not?: NestedEnumAISessionTypeFilter<$PrismaModel> | $Enums.AISessionType
  }

  export type EnumAISessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AISessionStatus | EnumAISessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AISessionStatus[]
    notIn?: $Enums.AISessionStatus[]
    not?: NestedEnumAISessionStatusFilter<$PrismaModel> | $Enums.AISessionStatus
  }

  export type AITherapistScalarRelationFilter = {
    is?: AITherapistWhereInput
    isNot?: AITherapistWhereInput
  }

  export type AITherapyMessageListRelationFilter = {
    every?: AITherapyMessageWhereInput
    some?: AITherapyMessageWhereInput
    none?: AITherapyMessageWhereInput
  }

  export type AIExerciseSessionListRelationFilter = {
    every?: AIExerciseSessionWhereInput
    some?: AIExerciseSessionWhereInput
    none?: AIExerciseSessionWhereInput
  }

  export type AITherapyMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIExerciseSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AITherapySessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    therapistId?: SortOrder
    sessionType?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    pausedAt?: SortOrder
    pausedDuration?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
    anxietyBefore?: SortOrder
    anxietyAfter?: SortOrder
    energyBefore?: SortOrder
    energyAfter?: SortOrder
    encryptedNotes?: SortOrder
    encryptedInsights?: SortOrder
    encryptedHomework?: SortOrder
    encryptedGoals?: SortOrder
    topics?: SortOrder
    techniques?: SortOrder
    interventions?: SortOrder
    breakthroughs?: SortOrder
    crisisDetected?: SortOrder
    crisisLevel?: SortOrder
    crisisInterventions?: SortOrder
  }

  export type AITherapySessionAvgOrderByAggregateInput = {
    duration?: SortOrder
    pausedDuration?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
    anxietyBefore?: SortOrder
    anxietyAfter?: SortOrder
    energyBefore?: SortOrder
    energyAfter?: SortOrder
    crisisLevel?: SortOrder
  }

  export type AITherapySessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    therapistId?: SortOrder
    sessionType?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    pausedAt?: SortOrder
    pausedDuration?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
    anxietyBefore?: SortOrder
    anxietyAfter?: SortOrder
    energyBefore?: SortOrder
    energyAfter?: SortOrder
    encryptedNotes?: SortOrder
    encryptedInsights?: SortOrder
    encryptedHomework?: SortOrder
    encryptedGoals?: SortOrder
    topics?: SortOrder
    techniques?: SortOrder
    interventions?: SortOrder
    breakthroughs?: SortOrder
    crisisDetected?: SortOrder
    crisisLevel?: SortOrder
    crisisInterventions?: SortOrder
  }

  export type AITherapySessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    therapistId?: SortOrder
    sessionType?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    pausedAt?: SortOrder
    pausedDuration?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
    anxietyBefore?: SortOrder
    anxietyAfter?: SortOrder
    energyBefore?: SortOrder
    energyAfter?: SortOrder
    encryptedNotes?: SortOrder
    encryptedInsights?: SortOrder
    encryptedHomework?: SortOrder
    encryptedGoals?: SortOrder
    topics?: SortOrder
    techniques?: SortOrder
    interventions?: SortOrder
    breakthroughs?: SortOrder
    crisisDetected?: SortOrder
    crisisLevel?: SortOrder
    crisisInterventions?: SortOrder
  }

  export type AITherapySessionSumOrderByAggregateInput = {
    duration?: SortOrder
    pausedDuration?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
    anxietyBefore?: SortOrder
    anxietyAfter?: SortOrder
    energyBefore?: SortOrder
    energyAfter?: SortOrder
    crisisLevel?: SortOrder
  }

  export type EnumAISessionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AISessionType | EnumAISessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AISessionType[]
    notIn?: $Enums.AISessionType[]
    not?: NestedEnumAISessionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AISessionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAISessionTypeFilter<$PrismaModel>
    _max?: NestedEnumAISessionTypeFilter<$PrismaModel>
  }

  export type EnumAISessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AISessionStatus | EnumAISessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AISessionStatus[]
    notIn?: $Enums.AISessionStatus[]
    not?: NestedEnumAISessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AISessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAISessionStatusFilter<$PrismaModel>
    _max?: NestedEnumAISessionStatusFilter<$PrismaModel>
  }

  export type EnumAIMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AIMessageType | EnumAIMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIMessageType[]
    notIn?: $Enums.AIMessageType[]
    not?: NestedEnumAIMessageTypeFilter<$PrismaModel> | $Enums.AIMessageType
  }

  export type EnumAIMessageSenderFilter<$PrismaModel = never> = {
    equals?: $Enums.AIMessageSender | EnumAIMessageSenderFieldRefInput<$PrismaModel>
    in?: $Enums.AIMessageSender[]
    notIn?: $Enums.AIMessageSender[]
    not?: NestedEnumAIMessageSenderFilter<$PrismaModel> | $Enums.AIMessageSender
  }

  export type AITherapySessionScalarRelationFilter = {
    is?: AITherapySessionWhereInput
    isNot?: AITherapySessionWhereInput
  }

  export type AITherapyMessageCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    messageType?: SortOrder
    sender?: SortOrder
    encryptedContent?: SortOrder
    messageHash?: SortOrder
    timestamp?: SortOrder
    edited?: SortOrder
    editedAt?: SortOrder
    sentiment?: SortOrder
    emotion?: SortOrder
    riskScore?: SortOrder
    techniques?: SortOrder
    hasAudio?: SortOrder
    audioDuration?: SortOrder
    audioUrl?: SortOrder
  }

  export type AITherapyMessageAvgOrderByAggregateInput = {
    sentiment?: SortOrder
    riskScore?: SortOrder
    audioDuration?: SortOrder
  }

  export type AITherapyMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    messageType?: SortOrder
    sender?: SortOrder
    encryptedContent?: SortOrder
    messageHash?: SortOrder
    timestamp?: SortOrder
    edited?: SortOrder
    editedAt?: SortOrder
    sentiment?: SortOrder
    emotion?: SortOrder
    riskScore?: SortOrder
    techniques?: SortOrder
    hasAudio?: SortOrder
    audioDuration?: SortOrder
    audioUrl?: SortOrder
  }

  export type AITherapyMessageMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    messageType?: SortOrder
    sender?: SortOrder
    encryptedContent?: SortOrder
    messageHash?: SortOrder
    timestamp?: SortOrder
    edited?: SortOrder
    editedAt?: SortOrder
    sentiment?: SortOrder
    emotion?: SortOrder
    riskScore?: SortOrder
    techniques?: SortOrder
    hasAudio?: SortOrder
    audioDuration?: SortOrder
    audioUrl?: SortOrder
  }

  export type AITherapyMessageSumOrderByAggregateInput = {
    sentiment?: SortOrder
    riskScore?: SortOrder
    audioDuration?: SortOrder
  }

  export type EnumAIMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIMessageType | EnumAIMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIMessageType[]
    notIn?: $Enums.AIMessageType[]
    not?: NestedEnumAIMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.AIMessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumAIMessageTypeFilter<$PrismaModel>
  }

  export type EnumAIMessageSenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIMessageSender | EnumAIMessageSenderFieldRefInput<$PrismaModel>
    in?: $Enums.AIMessageSender[]
    notIn?: $Enums.AIMessageSender[]
    not?: NestedEnumAIMessageSenderWithAggregatesFilter<$PrismaModel> | $Enums.AIMessageSender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIMessageSenderFilter<$PrismaModel>
    _max?: NestedEnumAIMessageSenderFilter<$PrismaModel>
  }

  export type AITherapistNullableScalarRelationFilter = {
    is?: AITherapistWhereInput | null
    isNot?: AITherapistWhereInput | null
  }

  export type AIPersonalizationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    therapistId?: SortOrder
    preferredStyle?: SortOrder
    preferredTechniques?: SortOrder
    preferredTopics?: SortOrder
    avoidTopics?: SortOrder
    responseLength?: SortOrder
    responseComplexity?: SortOrder
    empathyLevel?: SortOrder
    directness?: SortOrder
    culturalBackground?: SortOrder
    languagePreference?: SortOrder
    timezone?: SortOrder
    pronouns?: SortOrder
    learnedPatterns?: SortOrder
    effectiveTechniques?: SortOrder
    triggerPatterns?: SortOrder
    copingStrategies?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIPersonalizationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    therapistId?: SortOrder
    preferredStyle?: SortOrder
    preferredTechniques?: SortOrder
    preferredTopics?: SortOrder
    avoidTopics?: SortOrder
    responseLength?: SortOrder
    responseComplexity?: SortOrder
    empathyLevel?: SortOrder
    directness?: SortOrder
    culturalBackground?: SortOrder
    languagePreference?: SortOrder
    timezone?: SortOrder
    pronouns?: SortOrder
    learnedPatterns?: SortOrder
    effectiveTechniques?: SortOrder
    triggerPatterns?: SortOrder
    copingStrategies?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIPersonalizationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    therapistId?: SortOrder
    preferredStyle?: SortOrder
    preferredTechniques?: SortOrder
    preferredTopics?: SortOrder
    avoidTopics?: SortOrder
    responseLength?: SortOrder
    responseComplexity?: SortOrder
    empathyLevel?: SortOrder
    directness?: SortOrder
    culturalBackground?: SortOrder
    languagePreference?: SortOrder
    timezone?: SortOrder
    pronouns?: SortOrder
    learnedPatterns?: SortOrder
    effectiveTechniques?: SortOrder
    triggerPatterns?: SortOrder
    copingStrategies?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAIExerciseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AIExerciseType | EnumAIExerciseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIExerciseType[]
    notIn?: $Enums.AIExerciseType[]
    not?: NestedEnumAIExerciseTypeFilter<$PrismaModel> | $Enums.AIExerciseType
  }

  export type AITherapySessionNullableScalarRelationFilter = {
    is?: AITherapySessionWhereInput | null
    isNot?: AITherapySessionWhereInput | null
  }

  export type AIExerciseSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    exerciseType?: SortOrder
    exerciseName?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    completed?: SortOrder
    progress?: SortOrder
    results?: SortOrder
    feedback?: SortOrder
    improvement?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
  }

  export type AIExerciseSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
    progress?: SortOrder
    improvement?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
  }

  export type AIExerciseSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    exerciseType?: SortOrder
    exerciseName?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    completed?: SortOrder
    progress?: SortOrder
    results?: SortOrder
    feedback?: SortOrder
    improvement?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
  }

  export type AIExerciseSessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    exerciseType?: SortOrder
    exerciseName?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    completed?: SortOrder
    progress?: SortOrder
    results?: SortOrder
    feedback?: SortOrder
    improvement?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
  }

  export type AIExerciseSessionSumOrderByAggregateInput = {
    duration?: SortOrder
    progress?: SortOrder
    improvement?: SortOrder
    moodBefore?: SortOrder
    moodAfter?: SortOrder
  }

  export type EnumAIExerciseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIExerciseType | EnumAIExerciseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIExerciseType[]
    notIn?: $Enums.AIExerciseType[]
    not?: NestedEnumAIExerciseTypeWithAggregatesFilter<$PrismaModel> | $Enums.AIExerciseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIExerciseTypeFilter<$PrismaModel>
    _max?: NestedEnumAIExerciseTypeFilter<$PrismaModel>
  }

  export type EnumAIInsightTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AIInsightType | EnumAIInsightTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIInsightType[]
    notIn?: $Enums.AIInsightType[]
    not?: NestedEnumAIInsightTypeFilter<$PrismaModel> | $Enums.AIInsightType
  }

  export type AITherapyInsightCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    significance?: SortOrder
    dataPoints?: SortOrder
    patterns?: SortOrder
    trends?: SortOrder
    recommendations?: SortOrder
    actions?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    generatedAt?: SortOrder
    viewed?: SortOrder
    viewedAt?: SortOrder
    helpful?: SortOrder
    dismissed?: SortOrder
  }

  export type AITherapyInsightMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    significance?: SortOrder
    dataPoints?: SortOrder
    patterns?: SortOrder
    trends?: SortOrder
    recommendations?: SortOrder
    actions?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    generatedAt?: SortOrder
    viewed?: SortOrder
    viewedAt?: SortOrder
    helpful?: SortOrder
    dismissed?: SortOrder
  }

  export type AITherapyInsightMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    significance?: SortOrder
    dataPoints?: SortOrder
    patterns?: SortOrder
    trends?: SortOrder
    recommendations?: SortOrder
    actions?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    generatedAt?: SortOrder
    viewed?: SortOrder
    viewedAt?: SortOrder
    helpful?: SortOrder
    dismissed?: SortOrder
  }

  export type EnumAIInsightTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIInsightType | EnumAIInsightTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIInsightType[]
    notIn?: $Enums.AIInsightType[]
    not?: NestedEnumAIInsightTypeWithAggregatesFilter<$PrismaModel> | $Enums.AIInsightType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIInsightTypeFilter<$PrismaModel>
    _max?: NestedEnumAIInsightTypeFilter<$PrismaModel>
  }

  export type EnumAIGoalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AIGoalStatus | EnumAIGoalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIGoalStatus[]
    notIn?: $Enums.AIGoalStatus[]
    not?: NestedEnumAIGoalStatusFilter<$PrismaModel> | $Enums.AIGoalStatus
  }

  export type AITherapyGoalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    goalType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    specific?: SortOrder
    measurable?: SortOrder
    achievable?: SortOrder
    relevant?: SortOrder
    timebound?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    milestones?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AITherapyGoalAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type AITherapyGoalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    goalType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    specific?: SortOrder
    measurable?: SortOrder
    achievable?: SortOrder
    relevant?: SortOrder
    timebound?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    milestones?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AITherapyGoalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    goalType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    specific?: SortOrder
    measurable?: SortOrder
    achievable?: SortOrder
    relevant?: SortOrder
    timebound?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    milestones?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AITherapyGoalSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumAIGoalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIGoalStatus | EnumAIGoalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIGoalStatus[]
    notIn?: $Enums.AIGoalStatus[]
    not?: NestedEnumAIGoalStatusWithAggregatesFilter<$PrismaModel> | $Enums.AIGoalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIGoalStatusFilter<$PrismaModel>
    _max?: NestedEnumAIGoalStatusFilter<$PrismaModel>
  }

  export type CrisisMessageCreateNestedManyWithoutSessionInput = {
    create?: XOR<CrisisMessageCreateWithoutSessionInput, CrisisMessageUncheckedCreateWithoutSessionInput> | CrisisMessageCreateWithoutSessionInput[] | CrisisMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CrisisMessageCreateOrConnectWithoutSessionInput | CrisisMessageCreateOrConnectWithoutSessionInput[]
    createMany?: CrisisMessageCreateManySessionInputEnvelope
    connect?: CrisisMessageWhereUniqueInput | CrisisMessageWhereUniqueInput[]
  }

  export type CrisisEscalationCreateNestedManyWithoutSessionInput = {
    create?: XOR<CrisisEscalationCreateWithoutSessionInput, CrisisEscalationUncheckedCreateWithoutSessionInput> | CrisisEscalationCreateWithoutSessionInput[] | CrisisEscalationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CrisisEscalationCreateOrConnectWithoutSessionInput | CrisisEscalationCreateOrConnectWithoutSessionInput[]
    createMany?: CrisisEscalationCreateManySessionInputEnvelope
    connect?: CrisisEscalationWhereUniqueInput | CrisisEscalationWhereUniqueInput[]
  }

  export type CrisisResourceUsageCreateNestedManyWithoutSessionInput = {
    create?: XOR<CrisisResourceUsageCreateWithoutSessionInput, CrisisResourceUsageUncheckedCreateWithoutSessionInput> | CrisisResourceUsageCreateWithoutSessionInput[] | CrisisResourceUsageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CrisisResourceUsageCreateOrConnectWithoutSessionInput | CrisisResourceUsageCreateOrConnectWithoutSessionInput[]
    createMany?: CrisisResourceUsageCreateManySessionInputEnvelope
    connect?: CrisisResourceUsageWhereUniqueInput | CrisisResourceUsageWhereUniqueInput[]
  }

  export type CrisisMessageUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<CrisisMessageCreateWithoutSessionInput, CrisisMessageUncheckedCreateWithoutSessionInput> | CrisisMessageCreateWithoutSessionInput[] | CrisisMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CrisisMessageCreateOrConnectWithoutSessionInput | CrisisMessageCreateOrConnectWithoutSessionInput[]
    createMany?: CrisisMessageCreateManySessionInputEnvelope
    connect?: CrisisMessageWhereUniqueInput | CrisisMessageWhereUniqueInput[]
  }

  export type CrisisEscalationUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<CrisisEscalationCreateWithoutSessionInput, CrisisEscalationUncheckedCreateWithoutSessionInput> | CrisisEscalationCreateWithoutSessionInput[] | CrisisEscalationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CrisisEscalationCreateOrConnectWithoutSessionInput | CrisisEscalationCreateOrConnectWithoutSessionInput[]
    createMany?: CrisisEscalationCreateManySessionInputEnvelope
    connect?: CrisisEscalationWhereUniqueInput | CrisisEscalationWhereUniqueInput[]
  }

  export type CrisisResourceUsageUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<CrisisResourceUsageCreateWithoutSessionInput, CrisisResourceUsageUncheckedCreateWithoutSessionInput> | CrisisResourceUsageCreateWithoutSessionInput[] | CrisisResourceUsageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CrisisResourceUsageCreateOrConnectWithoutSessionInput | CrisisResourceUsageCreateOrConnectWithoutSessionInput[]
    createMany?: CrisisResourceUsageCreateManySessionInputEnvelope
    connect?: CrisisResourceUsageWhereUniqueInput | CrisisResourceUsageWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCrisisStatusFieldUpdateOperationsInput = {
    set?: $Enums.CrisisStatus
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableEnumEscalationTypeFieldUpdateOperationsInput = {
    set?: $Enums.EscalationType | null
  }

  export type CrisisMessageUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CrisisMessageCreateWithoutSessionInput, CrisisMessageUncheckedCreateWithoutSessionInput> | CrisisMessageCreateWithoutSessionInput[] | CrisisMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CrisisMessageCreateOrConnectWithoutSessionInput | CrisisMessageCreateOrConnectWithoutSessionInput[]
    upsert?: CrisisMessageUpsertWithWhereUniqueWithoutSessionInput | CrisisMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CrisisMessageCreateManySessionInputEnvelope
    set?: CrisisMessageWhereUniqueInput | CrisisMessageWhereUniqueInput[]
    disconnect?: CrisisMessageWhereUniqueInput | CrisisMessageWhereUniqueInput[]
    delete?: CrisisMessageWhereUniqueInput | CrisisMessageWhereUniqueInput[]
    connect?: CrisisMessageWhereUniqueInput | CrisisMessageWhereUniqueInput[]
    update?: CrisisMessageUpdateWithWhereUniqueWithoutSessionInput | CrisisMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CrisisMessageUpdateManyWithWhereWithoutSessionInput | CrisisMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CrisisMessageScalarWhereInput | CrisisMessageScalarWhereInput[]
  }

  export type CrisisEscalationUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CrisisEscalationCreateWithoutSessionInput, CrisisEscalationUncheckedCreateWithoutSessionInput> | CrisisEscalationCreateWithoutSessionInput[] | CrisisEscalationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CrisisEscalationCreateOrConnectWithoutSessionInput | CrisisEscalationCreateOrConnectWithoutSessionInput[]
    upsert?: CrisisEscalationUpsertWithWhereUniqueWithoutSessionInput | CrisisEscalationUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CrisisEscalationCreateManySessionInputEnvelope
    set?: CrisisEscalationWhereUniqueInput | CrisisEscalationWhereUniqueInput[]
    disconnect?: CrisisEscalationWhereUniqueInput | CrisisEscalationWhereUniqueInput[]
    delete?: CrisisEscalationWhereUniqueInput | CrisisEscalationWhereUniqueInput[]
    connect?: CrisisEscalationWhereUniqueInput | CrisisEscalationWhereUniqueInput[]
    update?: CrisisEscalationUpdateWithWhereUniqueWithoutSessionInput | CrisisEscalationUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CrisisEscalationUpdateManyWithWhereWithoutSessionInput | CrisisEscalationUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CrisisEscalationScalarWhereInput | CrisisEscalationScalarWhereInput[]
  }

  export type CrisisResourceUsageUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CrisisResourceUsageCreateWithoutSessionInput, CrisisResourceUsageUncheckedCreateWithoutSessionInput> | CrisisResourceUsageCreateWithoutSessionInput[] | CrisisResourceUsageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CrisisResourceUsageCreateOrConnectWithoutSessionInput | CrisisResourceUsageCreateOrConnectWithoutSessionInput[]
    upsert?: CrisisResourceUsageUpsertWithWhereUniqueWithoutSessionInput | CrisisResourceUsageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CrisisResourceUsageCreateManySessionInputEnvelope
    set?: CrisisResourceUsageWhereUniqueInput | CrisisResourceUsageWhereUniqueInput[]
    disconnect?: CrisisResourceUsageWhereUniqueInput | CrisisResourceUsageWhereUniqueInput[]
    delete?: CrisisResourceUsageWhereUniqueInput | CrisisResourceUsageWhereUniqueInput[]
    connect?: CrisisResourceUsageWhereUniqueInput | CrisisResourceUsageWhereUniqueInput[]
    update?: CrisisResourceUsageUpdateWithWhereUniqueWithoutSessionInput | CrisisResourceUsageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CrisisResourceUsageUpdateManyWithWhereWithoutSessionInput | CrisisResourceUsageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CrisisResourceUsageScalarWhereInput | CrisisResourceUsageScalarWhereInput[]
  }

  export type CrisisMessageUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CrisisMessageCreateWithoutSessionInput, CrisisMessageUncheckedCreateWithoutSessionInput> | CrisisMessageCreateWithoutSessionInput[] | CrisisMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CrisisMessageCreateOrConnectWithoutSessionInput | CrisisMessageCreateOrConnectWithoutSessionInput[]
    upsert?: CrisisMessageUpsertWithWhereUniqueWithoutSessionInput | CrisisMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CrisisMessageCreateManySessionInputEnvelope
    set?: CrisisMessageWhereUniqueInput | CrisisMessageWhereUniqueInput[]
    disconnect?: CrisisMessageWhereUniqueInput | CrisisMessageWhereUniqueInput[]
    delete?: CrisisMessageWhereUniqueInput | CrisisMessageWhereUniqueInput[]
    connect?: CrisisMessageWhereUniqueInput | CrisisMessageWhereUniqueInput[]
    update?: CrisisMessageUpdateWithWhereUniqueWithoutSessionInput | CrisisMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CrisisMessageUpdateManyWithWhereWithoutSessionInput | CrisisMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CrisisMessageScalarWhereInput | CrisisMessageScalarWhereInput[]
  }

  export type CrisisEscalationUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CrisisEscalationCreateWithoutSessionInput, CrisisEscalationUncheckedCreateWithoutSessionInput> | CrisisEscalationCreateWithoutSessionInput[] | CrisisEscalationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CrisisEscalationCreateOrConnectWithoutSessionInput | CrisisEscalationCreateOrConnectWithoutSessionInput[]
    upsert?: CrisisEscalationUpsertWithWhereUniqueWithoutSessionInput | CrisisEscalationUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CrisisEscalationCreateManySessionInputEnvelope
    set?: CrisisEscalationWhereUniqueInput | CrisisEscalationWhereUniqueInput[]
    disconnect?: CrisisEscalationWhereUniqueInput | CrisisEscalationWhereUniqueInput[]
    delete?: CrisisEscalationWhereUniqueInput | CrisisEscalationWhereUniqueInput[]
    connect?: CrisisEscalationWhereUniqueInput | CrisisEscalationWhereUniqueInput[]
    update?: CrisisEscalationUpdateWithWhereUniqueWithoutSessionInput | CrisisEscalationUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CrisisEscalationUpdateManyWithWhereWithoutSessionInput | CrisisEscalationUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CrisisEscalationScalarWhereInput | CrisisEscalationScalarWhereInput[]
  }

  export type CrisisResourceUsageUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CrisisResourceUsageCreateWithoutSessionInput, CrisisResourceUsageUncheckedCreateWithoutSessionInput> | CrisisResourceUsageCreateWithoutSessionInput[] | CrisisResourceUsageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CrisisResourceUsageCreateOrConnectWithoutSessionInput | CrisisResourceUsageCreateOrConnectWithoutSessionInput[]
    upsert?: CrisisResourceUsageUpsertWithWhereUniqueWithoutSessionInput | CrisisResourceUsageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CrisisResourceUsageCreateManySessionInputEnvelope
    set?: CrisisResourceUsageWhereUniqueInput | CrisisResourceUsageWhereUniqueInput[]
    disconnect?: CrisisResourceUsageWhereUniqueInput | CrisisResourceUsageWhereUniqueInput[]
    delete?: CrisisResourceUsageWhereUniqueInput | CrisisResourceUsageWhereUniqueInput[]
    connect?: CrisisResourceUsageWhereUniqueInput | CrisisResourceUsageWhereUniqueInput[]
    update?: CrisisResourceUsageUpdateWithWhereUniqueWithoutSessionInput | CrisisResourceUsageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CrisisResourceUsageUpdateManyWithWhereWithoutSessionInput | CrisisResourceUsageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CrisisResourceUsageScalarWhereInput | CrisisResourceUsageScalarWhereInput[]
  }

  export type CrisisSessionCreateNestedOneWithoutMessagesInput = {
    create?: XOR<CrisisSessionCreateWithoutMessagesInput, CrisisSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CrisisSessionCreateOrConnectWithoutMessagesInput
    connect?: CrisisSessionWhereUniqueInput
  }

  export type EnumMessageSenderFieldUpdateOperationsInput = {
    set?: $Enums.MessageSender
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Uint8Array
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type EnumMessagePriorityFieldUpdateOperationsInput = {
    set?: $Enums.MessagePriority
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CrisisSessionUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<CrisisSessionCreateWithoutMessagesInput, CrisisSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CrisisSessionCreateOrConnectWithoutMessagesInput
    upsert?: CrisisSessionUpsertWithoutMessagesInput
    connect?: CrisisSessionWhereUniqueInput
    update?: XOR<XOR<CrisisSessionUpdateToOneWithWhereWithoutMessagesInput, CrisisSessionUpdateWithoutMessagesInput>, CrisisSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type CrisisSessionCreateNestedOneWithoutEscalationsInput = {
    create?: XOR<CrisisSessionCreateWithoutEscalationsInput, CrisisSessionUncheckedCreateWithoutEscalationsInput>
    connectOrCreate?: CrisisSessionCreateOrConnectWithoutEscalationsInput
    connect?: CrisisSessionWhereUniqueInput
  }

  export type EnumEscalationTriggerFieldUpdateOperationsInput = {
    set?: $Enums.EscalationTrigger
  }

  export type EnumEscalationSeverityFieldUpdateOperationsInput = {
    set?: $Enums.EscalationSeverity
  }

  export type NullableEnumEscalationOutcomeFieldUpdateOperationsInput = {
    set?: $Enums.EscalationOutcome | null
  }

  export type CrisisSessionUpdateOneRequiredWithoutEscalationsNestedInput = {
    create?: XOR<CrisisSessionCreateWithoutEscalationsInput, CrisisSessionUncheckedCreateWithoutEscalationsInput>
    connectOrCreate?: CrisisSessionCreateOrConnectWithoutEscalationsInput
    upsert?: CrisisSessionUpsertWithoutEscalationsInput
    connect?: CrisisSessionWhereUniqueInput
    update?: XOR<XOR<CrisisSessionUpdateToOneWithWhereWithoutEscalationsInput, CrisisSessionUpdateWithoutEscalationsInput>, CrisisSessionUncheckedUpdateWithoutEscalationsInput>
  }

  export type TetherPulseCreateNestedManyWithoutTetherInput = {
    create?: XOR<TetherPulseCreateWithoutTetherInput, TetherPulseUncheckedCreateWithoutTetherInput> | TetherPulseCreateWithoutTetherInput[] | TetherPulseUncheckedCreateWithoutTetherInput[]
    connectOrCreate?: TetherPulseCreateOrConnectWithoutTetherInput | TetherPulseCreateOrConnectWithoutTetherInput[]
    createMany?: TetherPulseCreateManyTetherInputEnvelope
    connect?: TetherPulseWhereUniqueInput | TetherPulseWhereUniqueInput[]
  }

  export type TetherEmergencyCreateNestedManyWithoutTetherInput = {
    create?: XOR<TetherEmergencyCreateWithoutTetherInput, TetherEmergencyUncheckedCreateWithoutTetherInput> | TetherEmergencyCreateWithoutTetherInput[] | TetherEmergencyUncheckedCreateWithoutTetherInput[]
    connectOrCreate?: TetherEmergencyCreateOrConnectWithoutTetherInput | TetherEmergencyCreateOrConnectWithoutTetherInput[]
    createMany?: TetherEmergencyCreateManyTetherInputEnvelope
    connect?: TetherEmergencyWhereUniqueInput | TetherEmergencyWhereUniqueInput[]
  }

  export type TetherPulseUncheckedCreateNestedManyWithoutTetherInput = {
    create?: XOR<TetherPulseCreateWithoutTetherInput, TetherPulseUncheckedCreateWithoutTetherInput> | TetherPulseCreateWithoutTetherInput[] | TetherPulseUncheckedCreateWithoutTetherInput[]
    connectOrCreate?: TetherPulseCreateOrConnectWithoutTetherInput | TetherPulseCreateOrConnectWithoutTetherInput[]
    createMany?: TetherPulseCreateManyTetherInputEnvelope
    connect?: TetherPulseWhereUniqueInput | TetherPulseWhereUniqueInput[]
  }

  export type TetherEmergencyUncheckedCreateNestedManyWithoutTetherInput = {
    create?: XOR<TetherEmergencyCreateWithoutTetherInput, TetherEmergencyUncheckedCreateWithoutTetherInput> | TetherEmergencyCreateWithoutTetherInput[] | TetherEmergencyUncheckedCreateWithoutTetherInput[]
    connectOrCreate?: TetherEmergencyCreateOrConnectWithoutTetherInput | TetherEmergencyCreateOrConnectWithoutTetherInput[]
    createMany?: TetherEmergencyCreateManyTetherInputEnvelope
    connect?: TetherEmergencyWhereUniqueInput | TetherEmergencyWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumEmergencyTypeFieldUpdateOperationsInput = {
    set?: $Enums.EmergencyType | null
  }

  export type EnumTetherDataSharingFieldUpdateOperationsInput = {
    set?: $Enums.TetherDataSharing
  }

  export type TetherPulseUpdateManyWithoutTetherNestedInput = {
    create?: XOR<TetherPulseCreateWithoutTetherInput, TetherPulseUncheckedCreateWithoutTetherInput> | TetherPulseCreateWithoutTetherInput[] | TetherPulseUncheckedCreateWithoutTetherInput[]
    connectOrCreate?: TetherPulseCreateOrConnectWithoutTetherInput | TetherPulseCreateOrConnectWithoutTetherInput[]
    upsert?: TetherPulseUpsertWithWhereUniqueWithoutTetherInput | TetherPulseUpsertWithWhereUniqueWithoutTetherInput[]
    createMany?: TetherPulseCreateManyTetherInputEnvelope
    set?: TetherPulseWhereUniqueInput | TetherPulseWhereUniqueInput[]
    disconnect?: TetherPulseWhereUniqueInput | TetherPulseWhereUniqueInput[]
    delete?: TetherPulseWhereUniqueInput | TetherPulseWhereUniqueInput[]
    connect?: TetherPulseWhereUniqueInput | TetherPulseWhereUniqueInput[]
    update?: TetherPulseUpdateWithWhereUniqueWithoutTetherInput | TetherPulseUpdateWithWhereUniqueWithoutTetherInput[]
    updateMany?: TetherPulseUpdateManyWithWhereWithoutTetherInput | TetherPulseUpdateManyWithWhereWithoutTetherInput[]
    deleteMany?: TetherPulseScalarWhereInput | TetherPulseScalarWhereInput[]
  }

  export type TetherEmergencyUpdateManyWithoutTetherNestedInput = {
    create?: XOR<TetherEmergencyCreateWithoutTetherInput, TetherEmergencyUncheckedCreateWithoutTetherInput> | TetherEmergencyCreateWithoutTetherInput[] | TetherEmergencyUncheckedCreateWithoutTetherInput[]
    connectOrCreate?: TetherEmergencyCreateOrConnectWithoutTetherInput | TetherEmergencyCreateOrConnectWithoutTetherInput[]
    upsert?: TetherEmergencyUpsertWithWhereUniqueWithoutTetherInput | TetherEmergencyUpsertWithWhereUniqueWithoutTetherInput[]
    createMany?: TetherEmergencyCreateManyTetherInputEnvelope
    set?: TetherEmergencyWhereUniqueInput | TetherEmergencyWhereUniqueInput[]
    disconnect?: TetherEmergencyWhereUniqueInput | TetherEmergencyWhereUniqueInput[]
    delete?: TetherEmergencyWhereUniqueInput | TetherEmergencyWhereUniqueInput[]
    connect?: TetherEmergencyWhereUniqueInput | TetherEmergencyWhereUniqueInput[]
    update?: TetherEmergencyUpdateWithWhereUniqueWithoutTetherInput | TetherEmergencyUpdateWithWhereUniqueWithoutTetherInput[]
    updateMany?: TetherEmergencyUpdateManyWithWhereWithoutTetherInput | TetherEmergencyUpdateManyWithWhereWithoutTetherInput[]
    deleteMany?: TetherEmergencyScalarWhereInput | TetherEmergencyScalarWhereInput[]
  }

  export type TetherPulseUncheckedUpdateManyWithoutTetherNestedInput = {
    create?: XOR<TetherPulseCreateWithoutTetherInput, TetherPulseUncheckedCreateWithoutTetherInput> | TetherPulseCreateWithoutTetherInput[] | TetherPulseUncheckedCreateWithoutTetherInput[]
    connectOrCreate?: TetherPulseCreateOrConnectWithoutTetherInput | TetherPulseCreateOrConnectWithoutTetherInput[]
    upsert?: TetherPulseUpsertWithWhereUniqueWithoutTetherInput | TetherPulseUpsertWithWhereUniqueWithoutTetherInput[]
    createMany?: TetherPulseCreateManyTetherInputEnvelope
    set?: TetherPulseWhereUniqueInput | TetherPulseWhereUniqueInput[]
    disconnect?: TetherPulseWhereUniqueInput | TetherPulseWhereUniqueInput[]
    delete?: TetherPulseWhereUniqueInput | TetherPulseWhereUniqueInput[]
    connect?: TetherPulseWhereUniqueInput | TetherPulseWhereUniqueInput[]
    update?: TetherPulseUpdateWithWhereUniqueWithoutTetherInput | TetherPulseUpdateWithWhereUniqueWithoutTetherInput[]
    updateMany?: TetherPulseUpdateManyWithWhereWithoutTetherInput | TetherPulseUpdateManyWithWhereWithoutTetherInput[]
    deleteMany?: TetherPulseScalarWhereInput | TetherPulseScalarWhereInput[]
  }

  export type TetherEmergencyUncheckedUpdateManyWithoutTetherNestedInput = {
    create?: XOR<TetherEmergencyCreateWithoutTetherInput, TetherEmergencyUncheckedCreateWithoutTetherInput> | TetherEmergencyCreateWithoutTetherInput[] | TetherEmergencyUncheckedCreateWithoutTetherInput[]
    connectOrCreate?: TetherEmergencyCreateOrConnectWithoutTetherInput | TetherEmergencyCreateOrConnectWithoutTetherInput[]
    upsert?: TetherEmergencyUpsertWithWhereUniqueWithoutTetherInput | TetherEmergencyUpsertWithWhereUniqueWithoutTetherInput[]
    createMany?: TetherEmergencyCreateManyTetherInputEnvelope
    set?: TetherEmergencyWhereUniqueInput | TetherEmergencyWhereUniqueInput[]
    disconnect?: TetherEmergencyWhereUniqueInput | TetherEmergencyWhereUniqueInput[]
    delete?: TetherEmergencyWhereUniqueInput | TetherEmergencyWhereUniqueInput[]
    connect?: TetherEmergencyWhereUniqueInput | TetherEmergencyWhereUniqueInput[]
    update?: TetherEmergencyUpdateWithWhereUniqueWithoutTetherInput | TetherEmergencyUpdateWithWhereUniqueWithoutTetherInput[]
    updateMany?: TetherEmergencyUpdateManyWithWhereWithoutTetherInput | TetherEmergencyUpdateManyWithWhereWithoutTetherInput[]
    deleteMany?: TetherEmergencyScalarWhereInput | TetherEmergencyScalarWhereInput[]
  }

  export type TetherLinkCreateNestedOneWithoutPulsesInput = {
    create?: XOR<TetherLinkCreateWithoutPulsesInput, TetherLinkUncheckedCreateWithoutPulsesInput>
    connectOrCreate?: TetherLinkCreateOrConnectWithoutPulsesInput
    connect?: TetherLinkWhereUniqueInput
  }

  export type EnumPulseTypeFieldUpdateOperationsInput = {
    set?: $Enums.PulseType
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type EnumUrgencyLevelFieldUpdateOperationsInput = {
    set?: $Enums.UrgencyLevel
  }

  export type TetherLinkUpdateOneRequiredWithoutPulsesNestedInput = {
    create?: XOR<TetherLinkCreateWithoutPulsesInput, TetherLinkUncheckedCreateWithoutPulsesInput>
    connectOrCreate?: TetherLinkCreateOrConnectWithoutPulsesInput
    upsert?: TetherLinkUpsertWithoutPulsesInput
    connect?: TetherLinkWhereUniqueInput
    update?: XOR<XOR<TetherLinkUpdateToOneWithWhereWithoutPulsesInput, TetherLinkUpdateWithoutPulsesInput>, TetherLinkUncheckedUpdateWithoutPulsesInput>
  }

  export type TetherLinkCreateNestedOneWithoutEmergenciesInput = {
    create?: XOR<TetherLinkCreateWithoutEmergenciesInput, TetherLinkUncheckedCreateWithoutEmergenciesInput>
    connectOrCreate?: TetherLinkCreateOrConnectWithoutEmergenciesInput
    connect?: TetherLinkWhereUniqueInput
  }

  export type EnumEmergencyTypeFieldUpdateOperationsInput = {
    set?: $Enums.EmergencyType
  }

  export type EnumEmergencySeverityFieldUpdateOperationsInput = {
    set?: $Enums.EmergencySeverity
  }

  export type NullableEnumEmergencyOutcomeFieldUpdateOperationsInput = {
    set?: $Enums.EmergencyOutcome | null
  }

  export type TetherLinkUpdateOneRequiredWithoutEmergenciesNestedInput = {
    create?: XOR<TetherLinkCreateWithoutEmergenciesInput, TetherLinkUncheckedCreateWithoutEmergenciesInput>
    connectOrCreate?: TetherLinkCreateOrConnectWithoutEmergenciesInput
    upsert?: TetherLinkUpsertWithoutEmergenciesInput
    connect?: TetherLinkWhereUniqueInput
    update?: XOR<XOR<TetherLinkUpdateToOneWithWhereWithoutEmergenciesInput, TetherLinkUpdateWithoutEmergenciesInput>, TetherLinkUncheckedUpdateWithoutEmergenciesInput>
  }

  export type VolunteerTrainingCreateNestedManyWithoutVolunteerInput = {
    create?: XOR<VolunteerTrainingCreateWithoutVolunteerInput, VolunteerTrainingUncheckedCreateWithoutVolunteerInput> | VolunteerTrainingCreateWithoutVolunteerInput[] | VolunteerTrainingUncheckedCreateWithoutVolunteerInput[]
    connectOrCreate?: VolunteerTrainingCreateOrConnectWithoutVolunteerInput | VolunteerTrainingCreateOrConnectWithoutVolunteerInput[]
    createMany?: VolunteerTrainingCreateManyVolunteerInputEnvelope
    connect?: VolunteerTrainingWhereUniqueInput | VolunteerTrainingWhereUniqueInput[]
  }

  export type VolunteerSessionCreateNestedManyWithoutVolunteerInput = {
    create?: XOR<VolunteerSessionCreateWithoutVolunteerInput, VolunteerSessionUncheckedCreateWithoutVolunteerInput> | VolunteerSessionCreateWithoutVolunteerInput[] | VolunteerSessionUncheckedCreateWithoutVolunteerInput[]
    connectOrCreate?: VolunteerSessionCreateOrConnectWithoutVolunteerInput | VolunteerSessionCreateOrConnectWithoutVolunteerInput[]
    createMany?: VolunteerSessionCreateManyVolunteerInputEnvelope
    connect?: VolunteerSessionWhereUniqueInput | VolunteerSessionWhereUniqueInput[]
  }

  export type VolunteerFeedbackCreateNestedManyWithoutVolunteerInput = {
    create?: XOR<VolunteerFeedbackCreateWithoutVolunteerInput, VolunteerFeedbackUncheckedCreateWithoutVolunteerInput> | VolunteerFeedbackCreateWithoutVolunteerInput[] | VolunteerFeedbackUncheckedCreateWithoutVolunteerInput[]
    connectOrCreate?: VolunteerFeedbackCreateOrConnectWithoutVolunteerInput | VolunteerFeedbackCreateOrConnectWithoutVolunteerInput[]
    createMany?: VolunteerFeedbackCreateManyVolunteerInputEnvelope
    connect?: VolunteerFeedbackWhereUniqueInput | VolunteerFeedbackWhereUniqueInput[]
  }

  export type VolunteerTrainingUncheckedCreateNestedManyWithoutVolunteerInput = {
    create?: XOR<VolunteerTrainingCreateWithoutVolunteerInput, VolunteerTrainingUncheckedCreateWithoutVolunteerInput> | VolunteerTrainingCreateWithoutVolunteerInput[] | VolunteerTrainingUncheckedCreateWithoutVolunteerInput[]
    connectOrCreate?: VolunteerTrainingCreateOrConnectWithoutVolunteerInput | VolunteerTrainingCreateOrConnectWithoutVolunteerInput[]
    createMany?: VolunteerTrainingCreateManyVolunteerInputEnvelope
    connect?: VolunteerTrainingWhereUniqueInput | VolunteerTrainingWhereUniqueInput[]
  }

  export type VolunteerSessionUncheckedCreateNestedManyWithoutVolunteerInput = {
    create?: XOR<VolunteerSessionCreateWithoutVolunteerInput, VolunteerSessionUncheckedCreateWithoutVolunteerInput> | VolunteerSessionCreateWithoutVolunteerInput[] | VolunteerSessionUncheckedCreateWithoutVolunteerInput[]
    connectOrCreate?: VolunteerSessionCreateOrConnectWithoutVolunteerInput | VolunteerSessionCreateOrConnectWithoutVolunteerInput[]
    createMany?: VolunteerSessionCreateManyVolunteerInputEnvelope
    connect?: VolunteerSessionWhereUniqueInput | VolunteerSessionWhereUniqueInput[]
  }

  export type VolunteerFeedbackUncheckedCreateNestedManyWithoutVolunteerInput = {
    create?: XOR<VolunteerFeedbackCreateWithoutVolunteerInput, VolunteerFeedbackUncheckedCreateWithoutVolunteerInput> | VolunteerFeedbackCreateWithoutVolunteerInput[] | VolunteerFeedbackUncheckedCreateWithoutVolunteerInput[]
    connectOrCreate?: VolunteerFeedbackCreateOrConnectWithoutVolunteerInput | VolunteerFeedbackCreateOrConnectWithoutVolunteerInput[]
    createMany?: VolunteerFeedbackCreateManyVolunteerInputEnvelope
    connect?: VolunteerFeedbackWhereUniqueInput | VolunteerFeedbackWhereUniqueInput[]
  }

  export type EnumVolunteerStatusFieldUpdateOperationsInput = {
    set?: $Enums.VolunteerStatus
  }

  export type EnumVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerificationStatus
  }

  export type VolunteerTrainingUpdateManyWithoutVolunteerNestedInput = {
    create?: XOR<VolunteerTrainingCreateWithoutVolunteerInput, VolunteerTrainingUncheckedCreateWithoutVolunteerInput> | VolunteerTrainingCreateWithoutVolunteerInput[] | VolunteerTrainingUncheckedCreateWithoutVolunteerInput[]
    connectOrCreate?: VolunteerTrainingCreateOrConnectWithoutVolunteerInput | VolunteerTrainingCreateOrConnectWithoutVolunteerInput[]
    upsert?: VolunteerTrainingUpsertWithWhereUniqueWithoutVolunteerInput | VolunteerTrainingUpsertWithWhereUniqueWithoutVolunteerInput[]
    createMany?: VolunteerTrainingCreateManyVolunteerInputEnvelope
    set?: VolunteerTrainingWhereUniqueInput | VolunteerTrainingWhereUniqueInput[]
    disconnect?: VolunteerTrainingWhereUniqueInput | VolunteerTrainingWhereUniqueInput[]
    delete?: VolunteerTrainingWhereUniqueInput | VolunteerTrainingWhereUniqueInput[]
    connect?: VolunteerTrainingWhereUniqueInput | VolunteerTrainingWhereUniqueInput[]
    update?: VolunteerTrainingUpdateWithWhereUniqueWithoutVolunteerInput | VolunteerTrainingUpdateWithWhereUniqueWithoutVolunteerInput[]
    updateMany?: VolunteerTrainingUpdateManyWithWhereWithoutVolunteerInput | VolunteerTrainingUpdateManyWithWhereWithoutVolunteerInput[]
    deleteMany?: VolunteerTrainingScalarWhereInput | VolunteerTrainingScalarWhereInput[]
  }

  export type VolunteerSessionUpdateManyWithoutVolunteerNestedInput = {
    create?: XOR<VolunteerSessionCreateWithoutVolunteerInput, VolunteerSessionUncheckedCreateWithoutVolunteerInput> | VolunteerSessionCreateWithoutVolunteerInput[] | VolunteerSessionUncheckedCreateWithoutVolunteerInput[]
    connectOrCreate?: VolunteerSessionCreateOrConnectWithoutVolunteerInput | VolunteerSessionCreateOrConnectWithoutVolunteerInput[]
    upsert?: VolunteerSessionUpsertWithWhereUniqueWithoutVolunteerInput | VolunteerSessionUpsertWithWhereUniqueWithoutVolunteerInput[]
    createMany?: VolunteerSessionCreateManyVolunteerInputEnvelope
    set?: VolunteerSessionWhereUniqueInput | VolunteerSessionWhereUniqueInput[]
    disconnect?: VolunteerSessionWhereUniqueInput | VolunteerSessionWhereUniqueInput[]
    delete?: VolunteerSessionWhereUniqueInput | VolunteerSessionWhereUniqueInput[]
    connect?: VolunteerSessionWhereUniqueInput | VolunteerSessionWhereUniqueInput[]
    update?: VolunteerSessionUpdateWithWhereUniqueWithoutVolunteerInput | VolunteerSessionUpdateWithWhereUniqueWithoutVolunteerInput[]
    updateMany?: VolunteerSessionUpdateManyWithWhereWithoutVolunteerInput | VolunteerSessionUpdateManyWithWhereWithoutVolunteerInput[]
    deleteMany?: VolunteerSessionScalarWhereInput | VolunteerSessionScalarWhereInput[]
  }

  export type VolunteerFeedbackUpdateManyWithoutVolunteerNestedInput = {
    create?: XOR<VolunteerFeedbackCreateWithoutVolunteerInput, VolunteerFeedbackUncheckedCreateWithoutVolunteerInput> | VolunteerFeedbackCreateWithoutVolunteerInput[] | VolunteerFeedbackUncheckedCreateWithoutVolunteerInput[]
    connectOrCreate?: VolunteerFeedbackCreateOrConnectWithoutVolunteerInput | VolunteerFeedbackCreateOrConnectWithoutVolunteerInput[]
    upsert?: VolunteerFeedbackUpsertWithWhereUniqueWithoutVolunteerInput | VolunteerFeedbackUpsertWithWhereUniqueWithoutVolunteerInput[]
    createMany?: VolunteerFeedbackCreateManyVolunteerInputEnvelope
    set?: VolunteerFeedbackWhereUniqueInput | VolunteerFeedbackWhereUniqueInput[]
    disconnect?: VolunteerFeedbackWhereUniqueInput | VolunteerFeedbackWhereUniqueInput[]
    delete?: VolunteerFeedbackWhereUniqueInput | VolunteerFeedbackWhereUniqueInput[]
    connect?: VolunteerFeedbackWhereUniqueInput | VolunteerFeedbackWhereUniqueInput[]
    update?: VolunteerFeedbackUpdateWithWhereUniqueWithoutVolunteerInput | VolunteerFeedbackUpdateWithWhereUniqueWithoutVolunteerInput[]
    updateMany?: VolunteerFeedbackUpdateManyWithWhereWithoutVolunteerInput | VolunteerFeedbackUpdateManyWithWhereWithoutVolunteerInput[]
    deleteMany?: VolunteerFeedbackScalarWhereInput | VolunteerFeedbackScalarWhereInput[]
  }

  export type VolunteerTrainingUncheckedUpdateManyWithoutVolunteerNestedInput = {
    create?: XOR<VolunteerTrainingCreateWithoutVolunteerInput, VolunteerTrainingUncheckedCreateWithoutVolunteerInput> | VolunteerTrainingCreateWithoutVolunteerInput[] | VolunteerTrainingUncheckedCreateWithoutVolunteerInput[]
    connectOrCreate?: VolunteerTrainingCreateOrConnectWithoutVolunteerInput | VolunteerTrainingCreateOrConnectWithoutVolunteerInput[]
    upsert?: VolunteerTrainingUpsertWithWhereUniqueWithoutVolunteerInput | VolunteerTrainingUpsertWithWhereUniqueWithoutVolunteerInput[]
    createMany?: VolunteerTrainingCreateManyVolunteerInputEnvelope
    set?: VolunteerTrainingWhereUniqueInput | VolunteerTrainingWhereUniqueInput[]
    disconnect?: VolunteerTrainingWhereUniqueInput | VolunteerTrainingWhereUniqueInput[]
    delete?: VolunteerTrainingWhereUniqueInput | VolunteerTrainingWhereUniqueInput[]
    connect?: VolunteerTrainingWhereUniqueInput | VolunteerTrainingWhereUniqueInput[]
    update?: VolunteerTrainingUpdateWithWhereUniqueWithoutVolunteerInput | VolunteerTrainingUpdateWithWhereUniqueWithoutVolunteerInput[]
    updateMany?: VolunteerTrainingUpdateManyWithWhereWithoutVolunteerInput | VolunteerTrainingUpdateManyWithWhereWithoutVolunteerInput[]
    deleteMany?: VolunteerTrainingScalarWhereInput | VolunteerTrainingScalarWhereInput[]
  }

  export type VolunteerSessionUncheckedUpdateManyWithoutVolunteerNestedInput = {
    create?: XOR<VolunteerSessionCreateWithoutVolunteerInput, VolunteerSessionUncheckedCreateWithoutVolunteerInput> | VolunteerSessionCreateWithoutVolunteerInput[] | VolunteerSessionUncheckedCreateWithoutVolunteerInput[]
    connectOrCreate?: VolunteerSessionCreateOrConnectWithoutVolunteerInput | VolunteerSessionCreateOrConnectWithoutVolunteerInput[]
    upsert?: VolunteerSessionUpsertWithWhereUniqueWithoutVolunteerInput | VolunteerSessionUpsertWithWhereUniqueWithoutVolunteerInput[]
    createMany?: VolunteerSessionCreateManyVolunteerInputEnvelope
    set?: VolunteerSessionWhereUniqueInput | VolunteerSessionWhereUniqueInput[]
    disconnect?: VolunteerSessionWhereUniqueInput | VolunteerSessionWhereUniqueInput[]
    delete?: VolunteerSessionWhereUniqueInput | VolunteerSessionWhereUniqueInput[]
    connect?: VolunteerSessionWhereUniqueInput | VolunteerSessionWhereUniqueInput[]
    update?: VolunteerSessionUpdateWithWhereUniqueWithoutVolunteerInput | VolunteerSessionUpdateWithWhereUniqueWithoutVolunteerInput[]
    updateMany?: VolunteerSessionUpdateManyWithWhereWithoutVolunteerInput | VolunteerSessionUpdateManyWithWhereWithoutVolunteerInput[]
    deleteMany?: VolunteerSessionScalarWhereInput | VolunteerSessionScalarWhereInput[]
  }

  export type VolunteerFeedbackUncheckedUpdateManyWithoutVolunteerNestedInput = {
    create?: XOR<VolunteerFeedbackCreateWithoutVolunteerInput, VolunteerFeedbackUncheckedCreateWithoutVolunteerInput> | VolunteerFeedbackCreateWithoutVolunteerInput[] | VolunteerFeedbackUncheckedCreateWithoutVolunteerInput[]
    connectOrCreate?: VolunteerFeedbackCreateOrConnectWithoutVolunteerInput | VolunteerFeedbackCreateOrConnectWithoutVolunteerInput[]
    upsert?: VolunteerFeedbackUpsertWithWhereUniqueWithoutVolunteerInput | VolunteerFeedbackUpsertWithWhereUniqueWithoutVolunteerInput[]
    createMany?: VolunteerFeedbackCreateManyVolunteerInputEnvelope
    set?: VolunteerFeedbackWhereUniqueInput | VolunteerFeedbackWhereUniqueInput[]
    disconnect?: VolunteerFeedbackWhereUniqueInput | VolunteerFeedbackWhereUniqueInput[]
    delete?: VolunteerFeedbackWhereUniqueInput | VolunteerFeedbackWhereUniqueInput[]
    connect?: VolunteerFeedbackWhereUniqueInput | VolunteerFeedbackWhereUniqueInput[]
    update?: VolunteerFeedbackUpdateWithWhereUniqueWithoutVolunteerInput | VolunteerFeedbackUpdateWithWhereUniqueWithoutVolunteerInput[]
    updateMany?: VolunteerFeedbackUpdateManyWithWhereWithoutVolunteerInput | VolunteerFeedbackUpdateManyWithWhereWithoutVolunteerInput[]
    deleteMany?: VolunteerFeedbackScalarWhereInput | VolunteerFeedbackScalarWhereInput[]
  }

  export type VolunteerCreateNestedOneWithoutTrainingInput = {
    create?: XOR<VolunteerCreateWithoutTrainingInput, VolunteerUncheckedCreateWithoutTrainingInput>
    connectOrCreate?: VolunteerCreateOrConnectWithoutTrainingInput
    connect?: VolunteerWhereUniqueInput
  }

  export type EnumTrainingStatusFieldUpdateOperationsInput = {
    set?: $Enums.TrainingStatus
  }

  export type EnumTrainingTypeFieldUpdateOperationsInput = {
    set?: $Enums.TrainingType
  }

  export type VolunteerUpdateOneRequiredWithoutTrainingNestedInput = {
    create?: XOR<VolunteerCreateWithoutTrainingInput, VolunteerUncheckedCreateWithoutTrainingInput>
    connectOrCreate?: VolunteerCreateOrConnectWithoutTrainingInput
    upsert?: VolunteerUpsertWithoutTrainingInput
    connect?: VolunteerWhereUniqueInput
    update?: XOR<XOR<VolunteerUpdateToOneWithWhereWithoutTrainingInput, VolunteerUpdateWithoutTrainingInput>, VolunteerUncheckedUpdateWithoutTrainingInput>
  }

  export type VolunteerCreateNestedOneWithoutSessionsInput = {
    create?: XOR<VolunteerCreateWithoutSessionsInput, VolunteerUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: VolunteerCreateOrConnectWithoutSessionsInput
    connect?: VolunteerWhereUniqueInput
  }

  export type EnumVolunteerSessionTypeFieldUpdateOperationsInput = {
    set?: $Enums.VolunteerSessionType
  }

  export type NullableEnumSessionOutcomeFieldUpdateOperationsInput = {
    set?: $Enums.SessionOutcome | null
  }

  export type VolunteerUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<VolunteerCreateWithoutSessionsInput, VolunteerUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: VolunteerCreateOrConnectWithoutSessionsInput
    upsert?: VolunteerUpsertWithoutSessionsInput
    connect?: VolunteerWhereUniqueInput
    update?: XOR<XOR<VolunteerUpdateToOneWithWhereWithoutSessionsInput, VolunteerUpdateWithoutSessionsInput>, VolunteerUncheckedUpdateWithoutSessionsInput>
  }

  export type VolunteerCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<VolunteerCreateWithoutFeedbackInput, VolunteerUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: VolunteerCreateOrConnectWithoutFeedbackInput
    connect?: VolunteerWhereUniqueInput
  }

  export type EnumFeedbackTypeFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackType
  }

  export type EnumFeedbackSourceFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackSource
  }

  export type VolunteerUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<VolunteerCreateWithoutFeedbackInput, VolunteerUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: VolunteerCreateOrConnectWithoutFeedbackInput
    upsert?: VolunteerUpsertWithoutFeedbackInput
    connect?: VolunteerWhereUniqueInput
    update?: XOR<XOR<VolunteerUpdateToOneWithWhereWithoutFeedbackInput, VolunteerUpdateWithoutFeedbackInput>, VolunteerUncheckedUpdateWithoutFeedbackInput>
  }

  export type CrisisSessionCreateNestedOneWithoutResourcesInput = {
    create?: XOR<CrisisSessionCreateWithoutResourcesInput, CrisisSessionUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: CrisisSessionCreateOrConnectWithoutResourcesInput
    connect?: CrisisSessionWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EnumResourceCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ResourceCategory
  }

  export type CrisisSessionUpdateOneRequiredWithoutResourcesNestedInput = {
    create?: XOR<CrisisSessionCreateWithoutResourcesInput, CrisisSessionUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: CrisisSessionCreateOrConnectWithoutResourcesInput
    upsert?: CrisisSessionUpsertWithoutResourcesInput
    connect?: CrisisSessionWhereUniqueInput
    update?: XOR<XOR<CrisisSessionUpdateToOneWithWhereWithoutResourcesInput, CrisisSessionUpdateWithoutResourcesInput>, CrisisSessionUncheckedUpdateWithoutResourcesInput>
  }

  export type EnumReportTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReportType
  }

  export type EnumReportSeverityFieldUpdateOperationsInput = {
    set?: $Enums.ReportSeverity
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type EnumMetricStatusFieldUpdateOperationsInput = {
    set?: $Enums.MetricStatus
  }

  export type EnumHealthStatusFieldUpdateOperationsInput = {
    set?: $Enums.HealthStatus
  }

  export type UserCreateNestedOneWithoutEmergencyContactsInput = {
    create?: XOR<UserCreateWithoutEmergencyContactsInput, UserUncheckedCreateWithoutEmergencyContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmergencyContactsInput
    connect?: UserWhereUniqueInput
  }

  export type EmergencyNotificationCreateNestedManyWithoutEmergencyContactInput = {
    create?: XOR<EmergencyNotificationCreateWithoutEmergencyContactInput, EmergencyNotificationUncheckedCreateWithoutEmergencyContactInput> | EmergencyNotificationCreateWithoutEmergencyContactInput[] | EmergencyNotificationUncheckedCreateWithoutEmergencyContactInput[]
    connectOrCreate?: EmergencyNotificationCreateOrConnectWithoutEmergencyContactInput | EmergencyNotificationCreateOrConnectWithoutEmergencyContactInput[]
    createMany?: EmergencyNotificationCreateManyEmergencyContactInputEnvelope
    connect?: EmergencyNotificationWhereUniqueInput | EmergencyNotificationWhereUniqueInput[]
  }

  export type EmergencyNotificationUncheckedCreateNestedManyWithoutEmergencyContactInput = {
    create?: XOR<EmergencyNotificationCreateWithoutEmergencyContactInput, EmergencyNotificationUncheckedCreateWithoutEmergencyContactInput> | EmergencyNotificationCreateWithoutEmergencyContactInput[] | EmergencyNotificationUncheckedCreateWithoutEmergencyContactInput[]
    connectOrCreate?: EmergencyNotificationCreateOrConnectWithoutEmergencyContactInput | EmergencyNotificationCreateOrConnectWithoutEmergencyContactInput[]
    createMany?: EmergencyNotificationCreateManyEmergencyContactInputEnvelope
    connect?: EmergencyNotificationWhereUniqueInput | EmergencyNotificationWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutEmergencyContactsNestedInput = {
    create?: XOR<UserCreateWithoutEmergencyContactsInput, UserUncheckedCreateWithoutEmergencyContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmergencyContactsInput
    upsert?: UserUpsertWithoutEmergencyContactsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmergencyContactsInput, UserUpdateWithoutEmergencyContactsInput>, UserUncheckedUpdateWithoutEmergencyContactsInput>
  }

  export type EmergencyNotificationUpdateManyWithoutEmergencyContactNestedInput = {
    create?: XOR<EmergencyNotificationCreateWithoutEmergencyContactInput, EmergencyNotificationUncheckedCreateWithoutEmergencyContactInput> | EmergencyNotificationCreateWithoutEmergencyContactInput[] | EmergencyNotificationUncheckedCreateWithoutEmergencyContactInput[]
    connectOrCreate?: EmergencyNotificationCreateOrConnectWithoutEmergencyContactInput | EmergencyNotificationCreateOrConnectWithoutEmergencyContactInput[]
    upsert?: EmergencyNotificationUpsertWithWhereUniqueWithoutEmergencyContactInput | EmergencyNotificationUpsertWithWhereUniqueWithoutEmergencyContactInput[]
    createMany?: EmergencyNotificationCreateManyEmergencyContactInputEnvelope
    set?: EmergencyNotificationWhereUniqueInput | EmergencyNotificationWhereUniqueInput[]
    disconnect?: EmergencyNotificationWhereUniqueInput | EmergencyNotificationWhereUniqueInput[]
    delete?: EmergencyNotificationWhereUniqueInput | EmergencyNotificationWhereUniqueInput[]
    connect?: EmergencyNotificationWhereUniqueInput | EmergencyNotificationWhereUniqueInput[]
    update?: EmergencyNotificationUpdateWithWhereUniqueWithoutEmergencyContactInput | EmergencyNotificationUpdateWithWhereUniqueWithoutEmergencyContactInput[]
    updateMany?: EmergencyNotificationUpdateManyWithWhereWithoutEmergencyContactInput | EmergencyNotificationUpdateManyWithWhereWithoutEmergencyContactInput[]
    deleteMany?: EmergencyNotificationScalarWhereInput | EmergencyNotificationScalarWhereInput[]
  }

  export type EmergencyNotificationUncheckedUpdateManyWithoutEmergencyContactNestedInput = {
    create?: XOR<EmergencyNotificationCreateWithoutEmergencyContactInput, EmergencyNotificationUncheckedCreateWithoutEmergencyContactInput> | EmergencyNotificationCreateWithoutEmergencyContactInput[] | EmergencyNotificationUncheckedCreateWithoutEmergencyContactInput[]
    connectOrCreate?: EmergencyNotificationCreateOrConnectWithoutEmergencyContactInput | EmergencyNotificationCreateOrConnectWithoutEmergencyContactInput[]
    upsert?: EmergencyNotificationUpsertWithWhereUniqueWithoutEmergencyContactInput | EmergencyNotificationUpsertWithWhereUniqueWithoutEmergencyContactInput[]
    createMany?: EmergencyNotificationCreateManyEmergencyContactInputEnvelope
    set?: EmergencyNotificationWhereUniqueInput | EmergencyNotificationWhereUniqueInput[]
    disconnect?: EmergencyNotificationWhereUniqueInput | EmergencyNotificationWhereUniqueInput[]
    delete?: EmergencyNotificationWhereUniqueInput | EmergencyNotificationWhereUniqueInput[]
    connect?: EmergencyNotificationWhereUniqueInput | EmergencyNotificationWhereUniqueInput[]
    update?: EmergencyNotificationUpdateWithWhereUniqueWithoutEmergencyContactInput | EmergencyNotificationUpdateWithWhereUniqueWithoutEmergencyContactInput[]
    updateMany?: EmergencyNotificationUpdateManyWithWhereWithoutEmergencyContactInput | EmergencyNotificationUpdateManyWithWhereWithoutEmergencyContactInput[]
    deleteMany?: EmergencyNotificationScalarWhereInput | EmergencyNotificationScalarWhereInput[]
  }

  export type EmergencyContactCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<EmergencyContactCreateWithoutNotificationsInput, EmergencyContactUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutNotificationsInput
    connect?: EmergencyContactWhereUniqueInput
  }

  export type EnumEmergencyNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.EmergencyNotificationType
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type EmergencyContactUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<EmergencyContactCreateWithoutNotificationsInput, EmergencyContactUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutNotificationsInput
    upsert?: EmergencyContactUpsertWithoutNotificationsInput
    connect?: EmergencyContactWhereUniqueInput
    update?: XOR<XOR<EmergencyContactUpdateToOneWithWhereWithoutNotificationsInput, EmergencyContactUpdateWithoutNotificationsInput>, EmergencyContactUncheckedUpdateWithoutNotificationsInput>
  }

  export type MoodEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<MoodEntryCreateWithoutUserInput, MoodEntryUncheckedCreateWithoutUserInput> | MoodEntryCreateWithoutUserInput[] | MoodEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MoodEntryCreateOrConnectWithoutUserInput | MoodEntryCreateOrConnectWithoutUserInput[]
    createMany?: MoodEntryCreateManyUserInputEnvelope
    connect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
  }

  export type SafetyPlanCreateNestedManyWithoutUserInput = {
    create?: XOR<SafetyPlanCreateWithoutUserInput, SafetyPlanUncheckedCreateWithoutUserInput> | SafetyPlanCreateWithoutUserInput[] | SafetyPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SafetyPlanCreateOrConnectWithoutUserInput | SafetyPlanCreateOrConnectWithoutUserInput[]
    createMany?: SafetyPlanCreateManyUserInputEnvelope
    connect?: SafetyPlanWhereUniqueInput | SafetyPlanWhereUniqueInput[]
  }

  export type UserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserAchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserChallengeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput> | UserChallengeCreateWithoutUserInput[] | UserChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutUserInput | UserChallengeCreateOrConnectWithoutUserInput[]
    createMany?: UserChallengeCreateManyUserInputEnvelope
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
  }

  export type UserActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput> | UserActivityCreateWithoutUserInput[] | UserActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivityCreateOrConnectWithoutUserInput | UserActivityCreateOrConnectWithoutUserInput[]
    createMany?: UserActivityCreateManyUserInputEnvelope
    connect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
  }

  export type EmergencyContactCreateNestedManyWithoutUserInput = {
    create?: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput> | EmergencyContactCreateWithoutUserInput[] | EmergencyContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutUserInput | EmergencyContactCreateOrConnectWithoutUserInput[]
    createMany?: EmergencyContactCreateManyUserInputEnvelope
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
  }

  export type JournalEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput> | JournalEntryCreateWithoutUserInput[] | JournalEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutUserInput | JournalEntryCreateOrConnectWithoutUserInput[]
    createMany?: JournalEntryCreateManyUserInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type BreathingSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<BreathingSessionCreateWithoutUserInput, BreathingSessionUncheckedCreateWithoutUserInput> | BreathingSessionCreateWithoutUserInput[] | BreathingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BreathingSessionCreateOrConnectWithoutUserInput | BreathingSessionCreateOrConnectWithoutUserInput[]
    createMany?: BreathingSessionCreateManyUserInputEnvelope
    connect?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
  }

  export type GroundingSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<GroundingSessionCreateWithoutUserInput, GroundingSessionUncheckedCreateWithoutUserInput> | GroundingSessionCreateWithoutUserInput[] | GroundingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroundingSessionCreateOrConnectWithoutUserInput | GroundingSessionCreateOrConnectWithoutUserInput[]
    createMany?: GroundingSessionCreateManyUserInputEnvelope
    connect?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
  }

  export type SelfHelpInteractionCreateNestedManyWithoutUserInput = {
    create?: XOR<SelfHelpInteractionCreateWithoutUserInput, SelfHelpInteractionUncheckedCreateWithoutUserInput> | SelfHelpInteractionCreateWithoutUserInput[] | SelfHelpInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SelfHelpInteractionCreateOrConnectWithoutUserInput | SelfHelpInteractionCreateOrConnectWithoutUserInput[]
    createMany?: SelfHelpInteractionCreateManyUserInputEnvelope
    connect?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
  }

  export type MoodEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MoodEntryCreateWithoutUserInput, MoodEntryUncheckedCreateWithoutUserInput> | MoodEntryCreateWithoutUserInput[] | MoodEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MoodEntryCreateOrConnectWithoutUserInput | MoodEntryCreateOrConnectWithoutUserInput[]
    createMany?: MoodEntryCreateManyUserInputEnvelope
    connect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
  }

  export type SafetyPlanUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SafetyPlanCreateWithoutUserInput, SafetyPlanUncheckedCreateWithoutUserInput> | SafetyPlanCreateWithoutUserInput[] | SafetyPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SafetyPlanCreateOrConnectWithoutUserInput | SafetyPlanCreateOrConnectWithoutUserInput[]
    createMany?: SafetyPlanCreateManyUserInputEnvelope
    connect?: SafetyPlanWhereUniqueInput | SafetyPlanWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserChallengeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput> | UserChallengeCreateWithoutUserInput[] | UserChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutUserInput | UserChallengeCreateOrConnectWithoutUserInput[]
    createMany?: UserChallengeCreateManyUserInputEnvelope
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
  }

  export type UserActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput> | UserActivityCreateWithoutUserInput[] | UserActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivityCreateOrConnectWithoutUserInput | UserActivityCreateOrConnectWithoutUserInput[]
    createMany?: UserActivityCreateManyUserInputEnvelope
    connect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
  }

  export type EmergencyContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput> | EmergencyContactCreateWithoutUserInput[] | EmergencyContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutUserInput | EmergencyContactCreateOrConnectWithoutUserInput[]
    createMany?: EmergencyContactCreateManyUserInputEnvelope
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
  }

  export type JournalEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput> | JournalEntryCreateWithoutUserInput[] | JournalEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutUserInput | JournalEntryCreateOrConnectWithoutUserInput[]
    createMany?: JournalEntryCreateManyUserInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type BreathingSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BreathingSessionCreateWithoutUserInput, BreathingSessionUncheckedCreateWithoutUserInput> | BreathingSessionCreateWithoutUserInput[] | BreathingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BreathingSessionCreateOrConnectWithoutUserInput | BreathingSessionCreateOrConnectWithoutUserInput[]
    createMany?: BreathingSessionCreateManyUserInputEnvelope
    connect?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
  }

  export type GroundingSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GroundingSessionCreateWithoutUserInput, GroundingSessionUncheckedCreateWithoutUserInput> | GroundingSessionCreateWithoutUserInput[] | GroundingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroundingSessionCreateOrConnectWithoutUserInput | GroundingSessionCreateOrConnectWithoutUserInput[]
    createMany?: GroundingSessionCreateManyUserInputEnvelope
    connect?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
  }

  export type SelfHelpInteractionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SelfHelpInteractionCreateWithoutUserInput, SelfHelpInteractionUncheckedCreateWithoutUserInput> | SelfHelpInteractionCreateWithoutUserInput[] | SelfHelpInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SelfHelpInteractionCreateOrConnectWithoutUserInput | SelfHelpInteractionCreateOrConnectWithoutUserInput[]
    createMany?: SelfHelpInteractionCreateManyUserInputEnvelope
    connect?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
  }

  export type EnumUserDataSharingFieldUpdateOperationsInput = {
    set?: $Enums.UserDataSharing
  }

  export type MoodEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<MoodEntryCreateWithoutUserInput, MoodEntryUncheckedCreateWithoutUserInput> | MoodEntryCreateWithoutUserInput[] | MoodEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MoodEntryCreateOrConnectWithoutUserInput | MoodEntryCreateOrConnectWithoutUserInput[]
    upsert?: MoodEntryUpsertWithWhereUniqueWithoutUserInput | MoodEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MoodEntryCreateManyUserInputEnvelope
    set?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    disconnect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    delete?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    connect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    update?: MoodEntryUpdateWithWhereUniqueWithoutUserInput | MoodEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MoodEntryUpdateManyWithWhereWithoutUserInput | MoodEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MoodEntryScalarWhereInput | MoodEntryScalarWhereInput[]
  }

  export type SafetyPlanUpdateManyWithoutUserNestedInput = {
    create?: XOR<SafetyPlanCreateWithoutUserInput, SafetyPlanUncheckedCreateWithoutUserInput> | SafetyPlanCreateWithoutUserInput[] | SafetyPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SafetyPlanCreateOrConnectWithoutUserInput | SafetyPlanCreateOrConnectWithoutUserInput[]
    upsert?: SafetyPlanUpsertWithWhereUniqueWithoutUserInput | SafetyPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SafetyPlanCreateManyUserInputEnvelope
    set?: SafetyPlanWhereUniqueInput | SafetyPlanWhereUniqueInput[]
    disconnect?: SafetyPlanWhereUniqueInput | SafetyPlanWhereUniqueInput[]
    delete?: SafetyPlanWhereUniqueInput | SafetyPlanWhereUniqueInput[]
    connect?: SafetyPlanWhereUniqueInput | SafetyPlanWhereUniqueInput[]
    update?: SafetyPlanUpdateWithWhereUniqueWithoutUserInput | SafetyPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SafetyPlanUpdateManyWithWhereWithoutUserInput | SafetyPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SafetyPlanScalarWhereInput | SafetyPlanScalarWhereInput[]
  }

  export type UserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserChallengeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput> | UserChallengeCreateWithoutUserInput[] | UserChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutUserInput | UserChallengeCreateOrConnectWithoutUserInput[]
    upsert?: UserChallengeUpsertWithWhereUniqueWithoutUserInput | UserChallengeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserChallengeCreateManyUserInputEnvelope
    set?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    disconnect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    delete?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    update?: UserChallengeUpdateWithWhereUniqueWithoutUserInput | UserChallengeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserChallengeUpdateManyWithWhereWithoutUserInput | UserChallengeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
  }

  export type UserActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput> | UserActivityCreateWithoutUserInput[] | UserActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivityCreateOrConnectWithoutUserInput | UserActivityCreateOrConnectWithoutUserInput[]
    upsert?: UserActivityUpsertWithWhereUniqueWithoutUserInput | UserActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserActivityCreateManyUserInputEnvelope
    set?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    disconnect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    delete?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    connect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    update?: UserActivityUpdateWithWhereUniqueWithoutUserInput | UserActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserActivityUpdateManyWithWhereWithoutUserInput | UserActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserActivityScalarWhereInput | UserActivityScalarWhereInput[]
  }

  export type EmergencyContactUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput> | EmergencyContactCreateWithoutUserInput[] | EmergencyContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutUserInput | EmergencyContactCreateOrConnectWithoutUserInput[]
    upsert?: EmergencyContactUpsertWithWhereUniqueWithoutUserInput | EmergencyContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmergencyContactCreateManyUserInputEnvelope
    set?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    disconnect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    delete?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    update?: EmergencyContactUpdateWithWhereUniqueWithoutUserInput | EmergencyContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmergencyContactUpdateManyWithWhereWithoutUserInput | EmergencyContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
  }

  export type JournalEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput> | JournalEntryCreateWithoutUserInput[] | JournalEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutUserInput | JournalEntryCreateOrConnectWithoutUserInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutUserInput | JournalEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JournalEntryCreateManyUserInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutUserInput | JournalEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutUserInput | JournalEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type BreathingSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<BreathingSessionCreateWithoutUserInput, BreathingSessionUncheckedCreateWithoutUserInput> | BreathingSessionCreateWithoutUserInput[] | BreathingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BreathingSessionCreateOrConnectWithoutUserInput | BreathingSessionCreateOrConnectWithoutUserInput[]
    upsert?: BreathingSessionUpsertWithWhereUniqueWithoutUserInput | BreathingSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BreathingSessionCreateManyUserInputEnvelope
    set?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
    disconnect?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
    delete?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
    connect?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
    update?: BreathingSessionUpdateWithWhereUniqueWithoutUserInput | BreathingSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BreathingSessionUpdateManyWithWhereWithoutUserInput | BreathingSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BreathingSessionScalarWhereInput | BreathingSessionScalarWhereInput[]
  }

  export type GroundingSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroundingSessionCreateWithoutUserInput, GroundingSessionUncheckedCreateWithoutUserInput> | GroundingSessionCreateWithoutUserInput[] | GroundingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroundingSessionCreateOrConnectWithoutUserInput | GroundingSessionCreateOrConnectWithoutUserInput[]
    upsert?: GroundingSessionUpsertWithWhereUniqueWithoutUserInput | GroundingSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroundingSessionCreateManyUserInputEnvelope
    set?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
    disconnect?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
    delete?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
    connect?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
    update?: GroundingSessionUpdateWithWhereUniqueWithoutUserInput | GroundingSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroundingSessionUpdateManyWithWhereWithoutUserInput | GroundingSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroundingSessionScalarWhereInput | GroundingSessionScalarWhereInput[]
  }

  export type SelfHelpInteractionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SelfHelpInteractionCreateWithoutUserInput, SelfHelpInteractionUncheckedCreateWithoutUserInput> | SelfHelpInteractionCreateWithoutUserInput[] | SelfHelpInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SelfHelpInteractionCreateOrConnectWithoutUserInput | SelfHelpInteractionCreateOrConnectWithoutUserInput[]
    upsert?: SelfHelpInteractionUpsertWithWhereUniqueWithoutUserInput | SelfHelpInteractionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SelfHelpInteractionCreateManyUserInputEnvelope
    set?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
    disconnect?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
    delete?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
    connect?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
    update?: SelfHelpInteractionUpdateWithWhereUniqueWithoutUserInput | SelfHelpInteractionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SelfHelpInteractionUpdateManyWithWhereWithoutUserInput | SelfHelpInteractionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SelfHelpInteractionScalarWhereInput | SelfHelpInteractionScalarWhereInput[]
  }

  export type MoodEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MoodEntryCreateWithoutUserInput, MoodEntryUncheckedCreateWithoutUserInput> | MoodEntryCreateWithoutUserInput[] | MoodEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MoodEntryCreateOrConnectWithoutUserInput | MoodEntryCreateOrConnectWithoutUserInput[]
    upsert?: MoodEntryUpsertWithWhereUniqueWithoutUserInput | MoodEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MoodEntryCreateManyUserInputEnvelope
    set?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    disconnect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    delete?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    connect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    update?: MoodEntryUpdateWithWhereUniqueWithoutUserInput | MoodEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MoodEntryUpdateManyWithWhereWithoutUserInput | MoodEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MoodEntryScalarWhereInput | MoodEntryScalarWhereInput[]
  }

  export type SafetyPlanUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SafetyPlanCreateWithoutUserInput, SafetyPlanUncheckedCreateWithoutUserInput> | SafetyPlanCreateWithoutUserInput[] | SafetyPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SafetyPlanCreateOrConnectWithoutUserInput | SafetyPlanCreateOrConnectWithoutUserInput[]
    upsert?: SafetyPlanUpsertWithWhereUniqueWithoutUserInput | SafetyPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SafetyPlanCreateManyUserInputEnvelope
    set?: SafetyPlanWhereUniqueInput | SafetyPlanWhereUniqueInput[]
    disconnect?: SafetyPlanWhereUniqueInput | SafetyPlanWhereUniqueInput[]
    delete?: SafetyPlanWhereUniqueInput | SafetyPlanWhereUniqueInput[]
    connect?: SafetyPlanWhereUniqueInput | SafetyPlanWhereUniqueInput[]
    update?: SafetyPlanUpdateWithWhereUniqueWithoutUserInput | SafetyPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SafetyPlanUpdateManyWithWhereWithoutUserInput | SafetyPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SafetyPlanScalarWhereInput | SafetyPlanScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserChallengeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput> | UserChallengeCreateWithoutUserInput[] | UserChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutUserInput | UserChallengeCreateOrConnectWithoutUserInput[]
    upsert?: UserChallengeUpsertWithWhereUniqueWithoutUserInput | UserChallengeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserChallengeCreateManyUserInputEnvelope
    set?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    disconnect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    delete?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    update?: UserChallengeUpdateWithWhereUniqueWithoutUserInput | UserChallengeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserChallengeUpdateManyWithWhereWithoutUserInput | UserChallengeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
  }

  export type UserActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput> | UserActivityCreateWithoutUserInput[] | UserActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivityCreateOrConnectWithoutUserInput | UserActivityCreateOrConnectWithoutUserInput[]
    upsert?: UserActivityUpsertWithWhereUniqueWithoutUserInput | UserActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserActivityCreateManyUserInputEnvelope
    set?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    disconnect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    delete?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    connect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    update?: UserActivityUpdateWithWhereUniqueWithoutUserInput | UserActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserActivityUpdateManyWithWhereWithoutUserInput | UserActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserActivityScalarWhereInput | UserActivityScalarWhereInput[]
  }

  export type EmergencyContactUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput> | EmergencyContactCreateWithoutUserInput[] | EmergencyContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutUserInput | EmergencyContactCreateOrConnectWithoutUserInput[]
    upsert?: EmergencyContactUpsertWithWhereUniqueWithoutUserInput | EmergencyContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmergencyContactCreateManyUserInputEnvelope
    set?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    disconnect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    delete?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    update?: EmergencyContactUpdateWithWhereUniqueWithoutUserInput | EmergencyContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmergencyContactUpdateManyWithWhereWithoutUserInput | EmergencyContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
  }

  export type JournalEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput> | JournalEntryCreateWithoutUserInput[] | JournalEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutUserInput | JournalEntryCreateOrConnectWithoutUserInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutUserInput | JournalEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JournalEntryCreateManyUserInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutUserInput | JournalEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutUserInput | JournalEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type BreathingSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BreathingSessionCreateWithoutUserInput, BreathingSessionUncheckedCreateWithoutUserInput> | BreathingSessionCreateWithoutUserInput[] | BreathingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BreathingSessionCreateOrConnectWithoutUserInput | BreathingSessionCreateOrConnectWithoutUserInput[]
    upsert?: BreathingSessionUpsertWithWhereUniqueWithoutUserInput | BreathingSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BreathingSessionCreateManyUserInputEnvelope
    set?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
    disconnect?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
    delete?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
    connect?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
    update?: BreathingSessionUpdateWithWhereUniqueWithoutUserInput | BreathingSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BreathingSessionUpdateManyWithWhereWithoutUserInput | BreathingSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BreathingSessionScalarWhereInput | BreathingSessionScalarWhereInput[]
  }

  export type GroundingSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroundingSessionCreateWithoutUserInput, GroundingSessionUncheckedCreateWithoutUserInput> | GroundingSessionCreateWithoutUserInput[] | GroundingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroundingSessionCreateOrConnectWithoutUserInput | GroundingSessionCreateOrConnectWithoutUserInput[]
    upsert?: GroundingSessionUpsertWithWhereUniqueWithoutUserInput | GroundingSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroundingSessionCreateManyUserInputEnvelope
    set?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
    disconnect?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
    delete?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
    connect?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
    update?: GroundingSessionUpdateWithWhereUniqueWithoutUserInput | GroundingSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroundingSessionUpdateManyWithWhereWithoutUserInput | GroundingSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroundingSessionScalarWhereInput | GroundingSessionScalarWhereInput[]
  }

  export type SelfHelpInteractionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SelfHelpInteractionCreateWithoutUserInput, SelfHelpInteractionUncheckedCreateWithoutUserInput> | SelfHelpInteractionCreateWithoutUserInput[] | SelfHelpInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SelfHelpInteractionCreateOrConnectWithoutUserInput | SelfHelpInteractionCreateOrConnectWithoutUserInput[]
    upsert?: SelfHelpInteractionUpsertWithWhereUniqueWithoutUserInput | SelfHelpInteractionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SelfHelpInteractionCreateManyUserInputEnvelope
    set?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
    disconnect?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
    delete?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
    connect?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
    update?: SelfHelpInteractionUpdateWithWhereUniqueWithoutUserInput | SelfHelpInteractionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SelfHelpInteractionUpdateManyWithWhereWithoutUserInput | SelfHelpInteractionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SelfHelpInteractionScalarWhereInput | SelfHelpInteractionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMoodEntriesInput = {
    create?: XOR<UserCreateWithoutMoodEntriesInput, UserUncheckedCreateWithoutMoodEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMoodEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMoodEntriesNestedInput = {
    create?: XOR<UserCreateWithoutMoodEntriesInput, UserUncheckedCreateWithoutMoodEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMoodEntriesInput
    upsert?: UserUpsertWithoutMoodEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMoodEntriesInput, UserUpdateWithoutMoodEntriesInput>, UserUncheckedUpdateWithoutMoodEntriesInput>
  }

  export type UserCreateNestedOneWithoutSafetyPlansInput = {
    create?: XOR<UserCreateWithoutSafetyPlansInput, UserUncheckedCreateWithoutSafetyPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutSafetyPlansInput
    connect?: UserWhereUniqueInput
  }

  export type SafetyPlanVersionCreateNestedManyWithoutSafetyPlanInput = {
    create?: XOR<SafetyPlanVersionCreateWithoutSafetyPlanInput, SafetyPlanVersionUncheckedCreateWithoutSafetyPlanInput> | SafetyPlanVersionCreateWithoutSafetyPlanInput[] | SafetyPlanVersionUncheckedCreateWithoutSafetyPlanInput[]
    connectOrCreate?: SafetyPlanVersionCreateOrConnectWithoutSafetyPlanInput | SafetyPlanVersionCreateOrConnectWithoutSafetyPlanInput[]
    createMany?: SafetyPlanVersionCreateManySafetyPlanInputEnvelope
    connect?: SafetyPlanVersionWhereUniqueInput | SafetyPlanVersionWhereUniqueInput[]
  }

  export type SafetyPlanVersionUncheckedCreateNestedManyWithoutSafetyPlanInput = {
    create?: XOR<SafetyPlanVersionCreateWithoutSafetyPlanInput, SafetyPlanVersionUncheckedCreateWithoutSafetyPlanInput> | SafetyPlanVersionCreateWithoutSafetyPlanInput[] | SafetyPlanVersionUncheckedCreateWithoutSafetyPlanInput[]
    connectOrCreate?: SafetyPlanVersionCreateOrConnectWithoutSafetyPlanInput | SafetyPlanVersionCreateOrConnectWithoutSafetyPlanInput[]
    createMany?: SafetyPlanVersionCreateManySafetyPlanInputEnvelope
    connect?: SafetyPlanVersionWhereUniqueInput | SafetyPlanVersionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSafetyPlansNestedInput = {
    create?: XOR<UserCreateWithoutSafetyPlansInput, UserUncheckedCreateWithoutSafetyPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutSafetyPlansInput
    upsert?: UserUpsertWithoutSafetyPlansInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSafetyPlansInput, UserUpdateWithoutSafetyPlansInput>, UserUncheckedUpdateWithoutSafetyPlansInput>
  }

  export type SafetyPlanVersionUpdateManyWithoutSafetyPlanNestedInput = {
    create?: XOR<SafetyPlanVersionCreateWithoutSafetyPlanInput, SafetyPlanVersionUncheckedCreateWithoutSafetyPlanInput> | SafetyPlanVersionCreateWithoutSafetyPlanInput[] | SafetyPlanVersionUncheckedCreateWithoutSafetyPlanInput[]
    connectOrCreate?: SafetyPlanVersionCreateOrConnectWithoutSafetyPlanInput | SafetyPlanVersionCreateOrConnectWithoutSafetyPlanInput[]
    upsert?: SafetyPlanVersionUpsertWithWhereUniqueWithoutSafetyPlanInput | SafetyPlanVersionUpsertWithWhereUniqueWithoutSafetyPlanInput[]
    createMany?: SafetyPlanVersionCreateManySafetyPlanInputEnvelope
    set?: SafetyPlanVersionWhereUniqueInput | SafetyPlanVersionWhereUniqueInput[]
    disconnect?: SafetyPlanVersionWhereUniqueInput | SafetyPlanVersionWhereUniqueInput[]
    delete?: SafetyPlanVersionWhereUniqueInput | SafetyPlanVersionWhereUniqueInput[]
    connect?: SafetyPlanVersionWhereUniqueInput | SafetyPlanVersionWhereUniqueInput[]
    update?: SafetyPlanVersionUpdateWithWhereUniqueWithoutSafetyPlanInput | SafetyPlanVersionUpdateWithWhereUniqueWithoutSafetyPlanInput[]
    updateMany?: SafetyPlanVersionUpdateManyWithWhereWithoutSafetyPlanInput | SafetyPlanVersionUpdateManyWithWhereWithoutSafetyPlanInput[]
    deleteMany?: SafetyPlanVersionScalarWhereInput | SafetyPlanVersionScalarWhereInput[]
  }

  export type SafetyPlanVersionUncheckedUpdateManyWithoutSafetyPlanNestedInput = {
    create?: XOR<SafetyPlanVersionCreateWithoutSafetyPlanInput, SafetyPlanVersionUncheckedCreateWithoutSafetyPlanInput> | SafetyPlanVersionCreateWithoutSafetyPlanInput[] | SafetyPlanVersionUncheckedCreateWithoutSafetyPlanInput[]
    connectOrCreate?: SafetyPlanVersionCreateOrConnectWithoutSafetyPlanInput | SafetyPlanVersionCreateOrConnectWithoutSafetyPlanInput[]
    upsert?: SafetyPlanVersionUpsertWithWhereUniqueWithoutSafetyPlanInput | SafetyPlanVersionUpsertWithWhereUniqueWithoutSafetyPlanInput[]
    createMany?: SafetyPlanVersionCreateManySafetyPlanInputEnvelope
    set?: SafetyPlanVersionWhereUniqueInput | SafetyPlanVersionWhereUniqueInput[]
    disconnect?: SafetyPlanVersionWhereUniqueInput | SafetyPlanVersionWhereUniqueInput[]
    delete?: SafetyPlanVersionWhereUniqueInput | SafetyPlanVersionWhereUniqueInput[]
    connect?: SafetyPlanVersionWhereUniqueInput | SafetyPlanVersionWhereUniqueInput[]
    update?: SafetyPlanVersionUpdateWithWhereUniqueWithoutSafetyPlanInput | SafetyPlanVersionUpdateWithWhereUniqueWithoutSafetyPlanInput[]
    updateMany?: SafetyPlanVersionUpdateManyWithWhereWithoutSafetyPlanInput | SafetyPlanVersionUpdateManyWithWhereWithoutSafetyPlanInput[]
    deleteMany?: SafetyPlanVersionScalarWhereInput | SafetyPlanVersionScalarWhereInput[]
  }

  export type SafetyPlanCreateNestedOneWithoutVersionsInput = {
    create?: XOR<SafetyPlanCreateWithoutVersionsInput, SafetyPlanUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: SafetyPlanCreateOrConnectWithoutVersionsInput
    connect?: SafetyPlanWhereUniqueInput
  }

  export type SafetyPlanUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<SafetyPlanCreateWithoutVersionsInput, SafetyPlanUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: SafetyPlanCreateOrConnectWithoutVersionsInput
    upsert?: SafetyPlanUpsertWithoutVersionsInput
    connect?: SafetyPlanWhereUniqueInput
    update?: XOR<XOR<SafetyPlanUpdateToOneWithWhereWithoutVersionsInput, SafetyPlanUpdateWithoutVersionsInput>, SafetyPlanUncheckedUpdateWithoutVersionsInput>
  }

  export type UserCreateNestedOneWithoutUserProfileInput = {
    create?: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserProfileNestedInput = {
    create?: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProfileInput
    upsert?: UserUpsertWithoutUserProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserProfileInput, UserUpdateWithoutUserProfileInput>, UserUncheckedUpdateWithoutUserProfileInput>
  }

  export type UserAchievementCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type EnumAchievementCategoryFieldUpdateOperationsInput = {
    set?: $Enums.AchievementCategory
  }

  export type EnumAchievementRarityFieldUpdateOperationsInput = {
    set?: $Enums.AchievementRarity
  }

  export type UserAchievementUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type AchievementCreateNestedOneWithoutUserAchievementsInput = {
    create?: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUserAchievementsInput
    connect?: AchievementWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput = {
    create?: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUserAchievementsInput
    upsert?: AchievementUpsertWithoutUserAchievementsInput
    connect?: AchievementWhereUniqueInput
    update?: XOR<XOR<AchievementUpdateToOneWithWhereWithoutUserAchievementsInput, AchievementUpdateWithoutUserAchievementsInput>, AchievementUncheckedUpdateWithoutUserAchievementsInput>
  }

  export type UserChallengeCreateNestedManyWithoutChallengeInput = {
    create?: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput> | UserChallengeCreateWithoutChallengeInput[] | UserChallengeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutChallengeInput | UserChallengeCreateOrConnectWithoutChallengeInput[]
    createMany?: UserChallengeCreateManyChallengeInputEnvelope
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
  }

  export type UserChallengeUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput> | UserChallengeCreateWithoutChallengeInput[] | UserChallengeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutChallengeInput | UserChallengeCreateOrConnectWithoutChallengeInput[]
    createMany?: UserChallengeCreateManyChallengeInputEnvelope
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
  }

  export type EnumChallengeTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeType
  }

  export type EnumChallengeDifficultyFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeDifficulty
  }

  export type UserChallengeUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput> | UserChallengeCreateWithoutChallengeInput[] | UserChallengeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutChallengeInput | UserChallengeCreateOrConnectWithoutChallengeInput[]
    upsert?: UserChallengeUpsertWithWhereUniqueWithoutChallengeInput | UserChallengeUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: UserChallengeCreateManyChallengeInputEnvelope
    set?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    disconnect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    delete?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    update?: UserChallengeUpdateWithWhereUniqueWithoutChallengeInput | UserChallengeUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: UserChallengeUpdateManyWithWhereWithoutChallengeInput | UserChallengeUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
  }

  export type UserChallengeUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput> | UserChallengeCreateWithoutChallengeInput[] | UserChallengeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutChallengeInput | UserChallengeCreateOrConnectWithoutChallengeInput[]
    upsert?: UserChallengeUpsertWithWhereUniqueWithoutChallengeInput | UserChallengeUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: UserChallengeCreateManyChallengeInputEnvelope
    set?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    disconnect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    delete?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    update?: UserChallengeUpdateWithWhereUniqueWithoutChallengeInput | UserChallengeUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: UserChallengeUpdateManyWithWhereWithoutChallengeInput | UserChallengeUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutChallengesInput = {
    create?: XOR<UserCreateWithoutChallengesInput, UserUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengesInput
    connect?: UserWhereUniqueInput
  }

  export type ChallengeCreateNestedOneWithoutUserChallengesInput = {
    create?: XOR<ChallengeCreateWithoutUserChallengesInput, ChallengeUncheckedCreateWithoutUserChallengesInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutUserChallengesInput
    connect?: ChallengeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChallengesNestedInput = {
    create?: XOR<UserCreateWithoutChallengesInput, UserUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengesInput
    upsert?: UserUpsertWithoutChallengesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChallengesInput, UserUpdateWithoutChallengesInput>, UserUncheckedUpdateWithoutChallengesInput>
  }

  export type ChallengeUpdateOneRequiredWithoutUserChallengesNestedInput = {
    create?: XOR<ChallengeCreateWithoutUserChallengesInput, ChallengeUncheckedCreateWithoutUserChallengesInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutUserChallengesInput
    upsert?: ChallengeUpsertWithoutUserChallengesInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutUserChallengesInput, ChallengeUpdateWithoutUserChallengesInput>, ChallengeUncheckedUpdateWithoutUserChallengesInput>
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumActivityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityType
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserCreateNestedOneWithoutJournalEntriesInput = {
    create?: XOR<UserCreateWithoutJournalEntriesInput, UserUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutJournalEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumJournalTypeFieldUpdateOperationsInput = {
    set?: $Enums.JournalType
  }

  export type UserUpdateOneRequiredWithoutJournalEntriesNestedInput = {
    create?: XOR<UserCreateWithoutJournalEntriesInput, UserUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutJournalEntriesInput
    upsert?: UserUpsertWithoutJournalEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJournalEntriesInput, UserUpdateWithoutJournalEntriesInput>, UserUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type BreathingSessionCreateNestedManyWithoutExerciseInput = {
    create?: XOR<BreathingSessionCreateWithoutExerciseInput, BreathingSessionUncheckedCreateWithoutExerciseInput> | BreathingSessionCreateWithoutExerciseInput[] | BreathingSessionUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: BreathingSessionCreateOrConnectWithoutExerciseInput | BreathingSessionCreateOrConnectWithoutExerciseInput[]
    createMany?: BreathingSessionCreateManyExerciseInputEnvelope
    connect?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
  }

  export type BreathingSessionUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<BreathingSessionCreateWithoutExerciseInput, BreathingSessionUncheckedCreateWithoutExerciseInput> | BreathingSessionCreateWithoutExerciseInput[] | BreathingSessionUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: BreathingSessionCreateOrConnectWithoutExerciseInput | BreathingSessionCreateOrConnectWithoutExerciseInput[]
    createMany?: BreathingSessionCreateManyExerciseInputEnvelope
    connect?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
  }

  export type EnumBreathingTechniqueFieldUpdateOperationsInput = {
    set?: $Enums.BreathingTechnique
  }

  export type EnumExerciseDifficultyFieldUpdateOperationsInput = {
    set?: $Enums.ExerciseDifficulty
  }

  export type BreathingSessionUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<BreathingSessionCreateWithoutExerciseInput, BreathingSessionUncheckedCreateWithoutExerciseInput> | BreathingSessionCreateWithoutExerciseInput[] | BreathingSessionUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: BreathingSessionCreateOrConnectWithoutExerciseInput | BreathingSessionCreateOrConnectWithoutExerciseInput[]
    upsert?: BreathingSessionUpsertWithWhereUniqueWithoutExerciseInput | BreathingSessionUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: BreathingSessionCreateManyExerciseInputEnvelope
    set?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
    disconnect?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
    delete?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
    connect?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
    update?: BreathingSessionUpdateWithWhereUniqueWithoutExerciseInput | BreathingSessionUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: BreathingSessionUpdateManyWithWhereWithoutExerciseInput | BreathingSessionUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: BreathingSessionScalarWhereInput | BreathingSessionScalarWhereInput[]
  }

  export type BreathingSessionUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<BreathingSessionCreateWithoutExerciseInput, BreathingSessionUncheckedCreateWithoutExerciseInput> | BreathingSessionCreateWithoutExerciseInput[] | BreathingSessionUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: BreathingSessionCreateOrConnectWithoutExerciseInput | BreathingSessionCreateOrConnectWithoutExerciseInput[]
    upsert?: BreathingSessionUpsertWithWhereUniqueWithoutExerciseInput | BreathingSessionUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: BreathingSessionCreateManyExerciseInputEnvelope
    set?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
    disconnect?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
    delete?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
    connect?: BreathingSessionWhereUniqueInput | BreathingSessionWhereUniqueInput[]
    update?: BreathingSessionUpdateWithWhereUniqueWithoutExerciseInput | BreathingSessionUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: BreathingSessionUpdateManyWithWhereWithoutExerciseInput | BreathingSessionUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: BreathingSessionScalarWhereInput | BreathingSessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBreathingSessionsInput = {
    create?: XOR<UserCreateWithoutBreathingSessionsInput, UserUncheckedCreateWithoutBreathingSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBreathingSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type BreathingExerciseCreateNestedOneWithoutSessionsInput = {
    create?: XOR<BreathingExerciseCreateWithoutSessionsInput, BreathingExerciseUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: BreathingExerciseCreateOrConnectWithoutSessionsInput
    connect?: BreathingExerciseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBreathingSessionsNestedInput = {
    create?: XOR<UserCreateWithoutBreathingSessionsInput, UserUncheckedCreateWithoutBreathingSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBreathingSessionsInput
    upsert?: UserUpsertWithoutBreathingSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBreathingSessionsInput, UserUpdateWithoutBreathingSessionsInput>, UserUncheckedUpdateWithoutBreathingSessionsInput>
  }

  export type BreathingExerciseUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<BreathingExerciseCreateWithoutSessionsInput, BreathingExerciseUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: BreathingExerciseCreateOrConnectWithoutSessionsInput
    upsert?: BreathingExerciseUpsertWithoutSessionsInput
    connect?: BreathingExerciseWhereUniqueInput
    update?: XOR<XOR<BreathingExerciseUpdateToOneWithWhereWithoutSessionsInput, BreathingExerciseUpdateWithoutSessionsInput>, BreathingExerciseUncheckedUpdateWithoutSessionsInput>
  }

  export type GroundingSessionCreateNestedManyWithoutTechniqueInput = {
    create?: XOR<GroundingSessionCreateWithoutTechniqueInput, GroundingSessionUncheckedCreateWithoutTechniqueInput> | GroundingSessionCreateWithoutTechniqueInput[] | GroundingSessionUncheckedCreateWithoutTechniqueInput[]
    connectOrCreate?: GroundingSessionCreateOrConnectWithoutTechniqueInput | GroundingSessionCreateOrConnectWithoutTechniqueInput[]
    createMany?: GroundingSessionCreateManyTechniqueInputEnvelope
    connect?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
  }

  export type GroundingSessionUncheckedCreateNestedManyWithoutTechniqueInput = {
    create?: XOR<GroundingSessionCreateWithoutTechniqueInput, GroundingSessionUncheckedCreateWithoutTechniqueInput> | GroundingSessionCreateWithoutTechniqueInput[] | GroundingSessionUncheckedCreateWithoutTechniqueInput[]
    connectOrCreate?: GroundingSessionCreateOrConnectWithoutTechniqueInput | GroundingSessionCreateOrConnectWithoutTechniqueInput[]
    createMany?: GroundingSessionCreateManyTechniqueInputEnvelope
    connect?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
  }

  export type EnumGroundingTypeFieldUpdateOperationsInput = {
    set?: $Enums.GroundingType
  }

  export type EnumGroundingCategoryFieldUpdateOperationsInput = {
    set?: $Enums.GroundingCategory
  }

  export type EnumEvidenceLevelFieldUpdateOperationsInput = {
    set?: $Enums.EvidenceLevel
  }

  export type GroundingSessionUpdateManyWithoutTechniqueNestedInput = {
    create?: XOR<GroundingSessionCreateWithoutTechniqueInput, GroundingSessionUncheckedCreateWithoutTechniqueInput> | GroundingSessionCreateWithoutTechniqueInput[] | GroundingSessionUncheckedCreateWithoutTechniqueInput[]
    connectOrCreate?: GroundingSessionCreateOrConnectWithoutTechniqueInput | GroundingSessionCreateOrConnectWithoutTechniqueInput[]
    upsert?: GroundingSessionUpsertWithWhereUniqueWithoutTechniqueInput | GroundingSessionUpsertWithWhereUniqueWithoutTechniqueInput[]
    createMany?: GroundingSessionCreateManyTechniqueInputEnvelope
    set?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
    disconnect?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
    delete?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
    connect?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
    update?: GroundingSessionUpdateWithWhereUniqueWithoutTechniqueInput | GroundingSessionUpdateWithWhereUniqueWithoutTechniqueInput[]
    updateMany?: GroundingSessionUpdateManyWithWhereWithoutTechniqueInput | GroundingSessionUpdateManyWithWhereWithoutTechniqueInput[]
    deleteMany?: GroundingSessionScalarWhereInput | GroundingSessionScalarWhereInput[]
  }

  export type GroundingSessionUncheckedUpdateManyWithoutTechniqueNestedInput = {
    create?: XOR<GroundingSessionCreateWithoutTechniqueInput, GroundingSessionUncheckedCreateWithoutTechniqueInput> | GroundingSessionCreateWithoutTechniqueInput[] | GroundingSessionUncheckedCreateWithoutTechniqueInput[]
    connectOrCreate?: GroundingSessionCreateOrConnectWithoutTechniqueInput | GroundingSessionCreateOrConnectWithoutTechniqueInput[]
    upsert?: GroundingSessionUpsertWithWhereUniqueWithoutTechniqueInput | GroundingSessionUpsertWithWhereUniqueWithoutTechniqueInput[]
    createMany?: GroundingSessionCreateManyTechniqueInputEnvelope
    set?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
    disconnect?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
    delete?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
    connect?: GroundingSessionWhereUniqueInput | GroundingSessionWhereUniqueInput[]
    update?: GroundingSessionUpdateWithWhereUniqueWithoutTechniqueInput | GroundingSessionUpdateWithWhereUniqueWithoutTechniqueInput[]
    updateMany?: GroundingSessionUpdateManyWithWhereWithoutTechniqueInput | GroundingSessionUpdateManyWithWhereWithoutTechniqueInput[]
    deleteMany?: GroundingSessionScalarWhereInput | GroundingSessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutGroundingSessionsInput = {
    create?: XOR<UserCreateWithoutGroundingSessionsInput, UserUncheckedCreateWithoutGroundingSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroundingSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type GroundingTechniqueCreateNestedOneWithoutSessionsInput = {
    create?: XOR<GroundingTechniqueCreateWithoutSessionsInput, GroundingTechniqueUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: GroundingTechniqueCreateOrConnectWithoutSessionsInput
    connect?: GroundingTechniqueWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGroundingSessionsNestedInput = {
    create?: XOR<UserCreateWithoutGroundingSessionsInput, UserUncheckedCreateWithoutGroundingSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroundingSessionsInput
    upsert?: UserUpsertWithoutGroundingSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGroundingSessionsInput, UserUpdateWithoutGroundingSessionsInput>, UserUncheckedUpdateWithoutGroundingSessionsInput>
  }

  export type GroundingTechniqueUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<GroundingTechniqueCreateWithoutSessionsInput, GroundingTechniqueUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: GroundingTechniqueCreateOrConnectWithoutSessionsInput
    upsert?: GroundingTechniqueUpsertWithoutSessionsInput
    connect?: GroundingTechniqueWhereUniqueInput
    update?: XOR<XOR<GroundingTechniqueUpdateToOneWithWhereWithoutSessionsInput, GroundingTechniqueUpdateWithoutSessionsInput>, GroundingTechniqueUncheckedUpdateWithoutSessionsInput>
  }

  export type SelfHelpInteractionCreateNestedManyWithoutResourceInput = {
    create?: XOR<SelfHelpInteractionCreateWithoutResourceInput, SelfHelpInteractionUncheckedCreateWithoutResourceInput> | SelfHelpInteractionCreateWithoutResourceInput[] | SelfHelpInteractionUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: SelfHelpInteractionCreateOrConnectWithoutResourceInput | SelfHelpInteractionCreateOrConnectWithoutResourceInput[]
    createMany?: SelfHelpInteractionCreateManyResourceInputEnvelope
    connect?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
  }

  export type SelfHelpInteractionUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<SelfHelpInteractionCreateWithoutResourceInput, SelfHelpInteractionUncheckedCreateWithoutResourceInput> | SelfHelpInteractionCreateWithoutResourceInput[] | SelfHelpInteractionUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: SelfHelpInteractionCreateOrConnectWithoutResourceInput | SelfHelpInteractionCreateOrConnectWithoutResourceInput[]
    createMany?: SelfHelpInteractionCreateManyResourceInputEnvelope
    connect?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
  }

  export type EnumSelfHelpCategoryFieldUpdateOperationsInput = {
    set?: $Enums.SelfHelpCategory
  }

  export type EnumResourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ResourceType
  }

  export type SelfHelpInteractionUpdateManyWithoutResourceNestedInput = {
    create?: XOR<SelfHelpInteractionCreateWithoutResourceInput, SelfHelpInteractionUncheckedCreateWithoutResourceInput> | SelfHelpInteractionCreateWithoutResourceInput[] | SelfHelpInteractionUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: SelfHelpInteractionCreateOrConnectWithoutResourceInput | SelfHelpInteractionCreateOrConnectWithoutResourceInput[]
    upsert?: SelfHelpInteractionUpsertWithWhereUniqueWithoutResourceInput | SelfHelpInteractionUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: SelfHelpInteractionCreateManyResourceInputEnvelope
    set?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
    disconnect?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
    delete?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
    connect?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
    update?: SelfHelpInteractionUpdateWithWhereUniqueWithoutResourceInput | SelfHelpInteractionUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: SelfHelpInteractionUpdateManyWithWhereWithoutResourceInput | SelfHelpInteractionUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: SelfHelpInteractionScalarWhereInput | SelfHelpInteractionScalarWhereInput[]
  }

  export type SelfHelpInteractionUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<SelfHelpInteractionCreateWithoutResourceInput, SelfHelpInteractionUncheckedCreateWithoutResourceInput> | SelfHelpInteractionCreateWithoutResourceInput[] | SelfHelpInteractionUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: SelfHelpInteractionCreateOrConnectWithoutResourceInput | SelfHelpInteractionCreateOrConnectWithoutResourceInput[]
    upsert?: SelfHelpInteractionUpsertWithWhereUniqueWithoutResourceInput | SelfHelpInteractionUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: SelfHelpInteractionCreateManyResourceInputEnvelope
    set?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
    disconnect?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
    delete?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
    connect?: SelfHelpInteractionWhereUniqueInput | SelfHelpInteractionWhereUniqueInput[]
    update?: SelfHelpInteractionUpdateWithWhereUniqueWithoutResourceInput | SelfHelpInteractionUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: SelfHelpInteractionUpdateManyWithWhereWithoutResourceInput | SelfHelpInteractionUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: SelfHelpInteractionScalarWhereInput | SelfHelpInteractionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSelfHelpInteractionsInput = {
    create?: XOR<UserCreateWithoutSelfHelpInteractionsInput, UserUncheckedCreateWithoutSelfHelpInteractionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSelfHelpInteractionsInput
    connect?: UserWhereUniqueInput
  }

  export type SelfHelpResourceCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<SelfHelpResourceCreateWithoutInteractionsInput, SelfHelpResourceUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: SelfHelpResourceCreateOrConnectWithoutInteractionsInput
    connect?: SelfHelpResourceWhereUniqueInput
  }

  export type EnumInteractionTypeFieldUpdateOperationsInput = {
    set?: $Enums.InteractionType
  }

  export type UserUpdateOneRequiredWithoutSelfHelpInteractionsNestedInput = {
    create?: XOR<UserCreateWithoutSelfHelpInteractionsInput, UserUncheckedCreateWithoutSelfHelpInteractionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSelfHelpInteractionsInput
    upsert?: UserUpsertWithoutSelfHelpInteractionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSelfHelpInteractionsInput, UserUpdateWithoutSelfHelpInteractionsInput>, UserUncheckedUpdateWithoutSelfHelpInteractionsInput>
  }

  export type SelfHelpResourceUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<SelfHelpResourceCreateWithoutInteractionsInput, SelfHelpResourceUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: SelfHelpResourceCreateOrConnectWithoutInteractionsInput
    upsert?: SelfHelpResourceUpsertWithoutInteractionsInput
    connect?: SelfHelpResourceWhereUniqueInput
    update?: XOR<XOR<SelfHelpResourceUpdateToOneWithWhereWithoutInteractionsInput, SelfHelpResourceUpdateWithoutInteractionsInput>, SelfHelpResourceUncheckedUpdateWithoutInteractionsInput>
  }

  export type AITherapySessionCreateNestedManyWithoutTherapistInput = {
    create?: XOR<AITherapySessionCreateWithoutTherapistInput, AITherapySessionUncheckedCreateWithoutTherapistInput> | AITherapySessionCreateWithoutTherapistInput[] | AITherapySessionUncheckedCreateWithoutTherapistInput[]
    connectOrCreate?: AITherapySessionCreateOrConnectWithoutTherapistInput | AITherapySessionCreateOrConnectWithoutTherapistInput[]
    createMany?: AITherapySessionCreateManyTherapistInputEnvelope
    connect?: AITherapySessionWhereUniqueInput | AITherapySessionWhereUniqueInput[]
  }

  export type AIPersonalizationCreateNestedManyWithoutTherapistInput = {
    create?: XOR<AIPersonalizationCreateWithoutTherapistInput, AIPersonalizationUncheckedCreateWithoutTherapistInput> | AIPersonalizationCreateWithoutTherapistInput[] | AIPersonalizationUncheckedCreateWithoutTherapistInput[]
    connectOrCreate?: AIPersonalizationCreateOrConnectWithoutTherapistInput | AIPersonalizationCreateOrConnectWithoutTherapistInput[]
    createMany?: AIPersonalizationCreateManyTherapistInputEnvelope
    connect?: AIPersonalizationWhereUniqueInput | AIPersonalizationWhereUniqueInput[]
  }

  export type AITherapySessionUncheckedCreateNestedManyWithoutTherapistInput = {
    create?: XOR<AITherapySessionCreateWithoutTherapistInput, AITherapySessionUncheckedCreateWithoutTherapistInput> | AITherapySessionCreateWithoutTherapistInput[] | AITherapySessionUncheckedCreateWithoutTherapistInput[]
    connectOrCreate?: AITherapySessionCreateOrConnectWithoutTherapistInput | AITherapySessionCreateOrConnectWithoutTherapistInput[]
    createMany?: AITherapySessionCreateManyTherapistInputEnvelope
    connect?: AITherapySessionWhereUniqueInput | AITherapySessionWhereUniqueInput[]
  }

  export type AIPersonalizationUncheckedCreateNestedManyWithoutTherapistInput = {
    create?: XOR<AIPersonalizationCreateWithoutTherapistInput, AIPersonalizationUncheckedCreateWithoutTherapistInput> | AIPersonalizationCreateWithoutTherapistInput[] | AIPersonalizationUncheckedCreateWithoutTherapistInput[]
    connectOrCreate?: AIPersonalizationCreateOrConnectWithoutTherapistInput | AIPersonalizationCreateOrConnectWithoutTherapistInput[]
    createMany?: AIPersonalizationCreateManyTherapistInputEnvelope
    connect?: AIPersonalizationWhereUniqueInput | AIPersonalizationWhereUniqueInput[]
  }

  export type AITherapySessionUpdateManyWithoutTherapistNestedInput = {
    create?: XOR<AITherapySessionCreateWithoutTherapistInput, AITherapySessionUncheckedCreateWithoutTherapistInput> | AITherapySessionCreateWithoutTherapistInput[] | AITherapySessionUncheckedCreateWithoutTherapistInput[]
    connectOrCreate?: AITherapySessionCreateOrConnectWithoutTherapistInput | AITherapySessionCreateOrConnectWithoutTherapistInput[]
    upsert?: AITherapySessionUpsertWithWhereUniqueWithoutTherapistInput | AITherapySessionUpsertWithWhereUniqueWithoutTherapistInput[]
    createMany?: AITherapySessionCreateManyTherapistInputEnvelope
    set?: AITherapySessionWhereUniqueInput | AITherapySessionWhereUniqueInput[]
    disconnect?: AITherapySessionWhereUniqueInput | AITherapySessionWhereUniqueInput[]
    delete?: AITherapySessionWhereUniqueInput | AITherapySessionWhereUniqueInput[]
    connect?: AITherapySessionWhereUniqueInput | AITherapySessionWhereUniqueInput[]
    update?: AITherapySessionUpdateWithWhereUniqueWithoutTherapistInput | AITherapySessionUpdateWithWhereUniqueWithoutTherapistInput[]
    updateMany?: AITherapySessionUpdateManyWithWhereWithoutTherapistInput | AITherapySessionUpdateManyWithWhereWithoutTherapistInput[]
    deleteMany?: AITherapySessionScalarWhereInput | AITherapySessionScalarWhereInput[]
  }

  export type AIPersonalizationUpdateManyWithoutTherapistNestedInput = {
    create?: XOR<AIPersonalizationCreateWithoutTherapistInput, AIPersonalizationUncheckedCreateWithoutTherapistInput> | AIPersonalizationCreateWithoutTherapistInput[] | AIPersonalizationUncheckedCreateWithoutTherapistInput[]
    connectOrCreate?: AIPersonalizationCreateOrConnectWithoutTherapistInput | AIPersonalizationCreateOrConnectWithoutTherapistInput[]
    upsert?: AIPersonalizationUpsertWithWhereUniqueWithoutTherapistInput | AIPersonalizationUpsertWithWhereUniqueWithoutTherapistInput[]
    createMany?: AIPersonalizationCreateManyTherapistInputEnvelope
    set?: AIPersonalizationWhereUniqueInput | AIPersonalizationWhereUniqueInput[]
    disconnect?: AIPersonalizationWhereUniqueInput | AIPersonalizationWhereUniqueInput[]
    delete?: AIPersonalizationWhereUniqueInput | AIPersonalizationWhereUniqueInput[]
    connect?: AIPersonalizationWhereUniqueInput | AIPersonalizationWhereUniqueInput[]
    update?: AIPersonalizationUpdateWithWhereUniqueWithoutTherapistInput | AIPersonalizationUpdateWithWhereUniqueWithoutTherapistInput[]
    updateMany?: AIPersonalizationUpdateManyWithWhereWithoutTherapistInput | AIPersonalizationUpdateManyWithWhereWithoutTherapistInput[]
    deleteMany?: AIPersonalizationScalarWhereInput | AIPersonalizationScalarWhereInput[]
  }

  export type AITherapySessionUncheckedUpdateManyWithoutTherapistNestedInput = {
    create?: XOR<AITherapySessionCreateWithoutTherapistInput, AITherapySessionUncheckedCreateWithoutTherapistInput> | AITherapySessionCreateWithoutTherapistInput[] | AITherapySessionUncheckedCreateWithoutTherapistInput[]
    connectOrCreate?: AITherapySessionCreateOrConnectWithoutTherapistInput | AITherapySessionCreateOrConnectWithoutTherapistInput[]
    upsert?: AITherapySessionUpsertWithWhereUniqueWithoutTherapistInput | AITherapySessionUpsertWithWhereUniqueWithoutTherapistInput[]
    createMany?: AITherapySessionCreateManyTherapistInputEnvelope
    set?: AITherapySessionWhereUniqueInput | AITherapySessionWhereUniqueInput[]
    disconnect?: AITherapySessionWhereUniqueInput | AITherapySessionWhereUniqueInput[]
    delete?: AITherapySessionWhereUniqueInput | AITherapySessionWhereUniqueInput[]
    connect?: AITherapySessionWhereUniqueInput | AITherapySessionWhereUniqueInput[]
    update?: AITherapySessionUpdateWithWhereUniqueWithoutTherapistInput | AITherapySessionUpdateWithWhereUniqueWithoutTherapistInput[]
    updateMany?: AITherapySessionUpdateManyWithWhereWithoutTherapistInput | AITherapySessionUpdateManyWithWhereWithoutTherapistInput[]
    deleteMany?: AITherapySessionScalarWhereInput | AITherapySessionScalarWhereInput[]
  }

  export type AIPersonalizationUncheckedUpdateManyWithoutTherapistNestedInput = {
    create?: XOR<AIPersonalizationCreateWithoutTherapistInput, AIPersonalizationUncheckedCreateWithoutTherapistInput> | AIPersonalizationCreateWithoutTherapistInput[] | AIPersonalizationUncheckedCreateWithoutTherapistInput[]
    connectOrCreate?: AIPersonalizationCreateOrConnectWithoutTherapistInput | AIPersonalizationCreateOrConnectWithoutTherapistInput[]
    upsert?: AIPersonalizationUpsertWithWhereUniqueWithoutTherapistInput | AIPersonalizationUpsertWithWhereUniqueWithoutTherapistInput[]
    createMany?: AIPersonalizationCreateManyTherapistInputEnvelope
    set?: AIPersonalizationWhereUniqueInput | AIPersonalizationWhereUniqueInput[]
    disconnect?: AIPersonalizationWhereUniqueInput | AIPersonalizationWhereUniqueInput[]
    delete?: AIPersonalizationWhereUniqueInput | AIPersonalizationWhereUniqueInput[]
    connect?: AIPersonalizationWhereUniqueInput | AIPersonalizationWhereUniqueInput[]
    update?: AIPersonalizationUpdateWithWhereUniqueWithoutTherapistInput | AIPersonalizationUpdateWithWhereUniqueWithoutTherapistInput[]
    updateMany?: AIPersonalizationUpdateManyWithWhereWithoutTherapistInput | AIPersonalizationUpdateManyWithWhereWithoutTherapistInput[]
    deleteMany?: AIPersonalizationScalarWhereInput | AIPersonalizationScalarWhereInput[]
  }

  export type AITherapistCreateNestedOneWithoutSessionsInput = {
    create?: XOR<AITherapistCreateWithoutSessionsInput, AITherapistUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AITherapistCreateOrConnectWithoutSessionsInput
    connect?: AITherapistWhereUniqueInput
  }

  export type AITherapyMessageCreateNestedManyWithoutSessionInput = {
    create?: XOR<AITherapyMessageCreateWithoutSessionInput, AITherapyMessageUncheckedCreateWithoutSessionInput> | AITherapyMessageCreateWithoutSessionInput[] | AITherapyMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AITherapyMessageCreateOrConnectWithoutSessionInput | AITherapyMessageCreateOrConnectWithoutSessionInput[]
    createMany?: AITherapyMessageCreateManySessionInputEnvelope
    connect?: AITherapyMessageWhereUniqueInput | AITherapyMessageWhereUniqueInput[]
  }

  export type AIExerciseSessionCreateNestedManyWithoutSessionInput = {
    create?: XOR<AIExerciseSessionCreateWithoutSessionInput, AIExerciseSessionUncheckedCreateWithoutSessionInput> | AIExerciseSessionCreateWithoutSessionInput[] | AIExerciseSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AIExerciseSessionCreateOrConnectWithoutSessionInput | AIExerciseSessionCreateOrConnectWithoutSessionInput[]
    createMany?: AIExerciseSessionCreateManySessionInputEnvelope
    connect?: AIExerciseSessionWhereUniqueInput | AIExerciseSessionWhereUniqueInput[]
  }

  export type AITherapyMessageUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<AITherapyMessageCreateWithoutSessionInput, AITherapyMessageUncheckedCreateWithoutSessionInput> | AITherapyMessageCreateWithoutSessionInput[] | AITherapyMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AITherapyMessageCreateOrConnectWithoutSessionInput | AITherapyMessageCreateOrConnectWithoutSessionInput[]
    createMany?: AITherapyMessageCreateManySessionInputEnvelope
    connect?: AITherapyMessageWhereUniqueInput | AITherapyMessageWhereUniqueInput[]
  }

  export type AIExerciseSessionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<AIExerciseSessionCreateWithoutSessionInput, AIExerciseSessionUncheckedCreateWithoutSessionInput> | AIExerciseSessionCreateWithoutSessionInput[] | AIExerciseSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AIExerciseSessionCreateOrConnectWithoutSessionInput | AIExerciseSessionCreateOrConnectWithoutSessionInput[]
    createMany?: AIExerciseSessionCreateManySessionInputEnvelope
    connect?: AIExerciseSessionWhereUniqueInput | AIExerciseSessionWhereUniqueInput[]
  }

  export type EnumAISessionTypeFieldUpdateOperationsInput = {
    set?: $Enums.AISessionType
  }

  export type EnumAISessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.AISessionStatus
  }

  export type AITherapistUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<AITherapistCreateWithoutSessionsInput, AITherapistUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AITherapistCreateOrConnectWithoutSessionsInput
    upsert?: AITherapistUpsertWithoutSessionsInput
    connect?: AITherapistWhereUniqueInput
    update?: XOR<XOR<AITherapistUpdateToOneWithWhereWithoutSessionsInput, AITherapistUpdateWithoutSessionsInput>, AITherapistUncheckedUpdateWithoutSessionsInput>
  }

  export type AITherapyMessageUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AITherapyMessageCreateWithoutSessionInput, AITherapyMessageUncheckedCreateWithoutSessionInput> | AITherapyMessageCreateWithoutSessionInput[] | AITherapyMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AITherapyMessageCreateOrConnectWithoutSessionInput | AITherapyMessageCreateOrConnectWithoutSessionInput[]
    upsert?: AITherapyMessageUpsertWithWhereUniqueWithoutSessionInput | AITherapyMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AITherapyMessageCreateManySessionInputEnvelope
    set?: AITherapyMessageWhereUniqueInput | AITherapyMessageWhereUniqueInput[]
    disconnect?: AITherapyMessageWhereUniqueInput | AITherapyMessageWhereUniqueInput[]
    delete?: AITherapyMessageWhereUniqueInput | AITherapyMessageWhereUniqueInput[]
    connect?: AITherapyMessageWhereUniqueInput | AITherapyMessageWhereUniqueInput[]
    update?: AITherapyMessageUpdateWithWhereUniqueWithoutSessionInput | AITherapyMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AITherapyMessageUpdateManyWithWhereWithoutSessionInput | AITherapyMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AITherapyMessageScalarWhereInput | AITherapyMessageScalarWhereInput[]
  }

  export type AIExerciseSessionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AIExerciseSessionCreateWithoutSessionInput, AIExerciseSessionUncheckedCreateWithoutSessionInput> | AIExerciseSessionCreateWithoutSessionInput[] | AIExerciseSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AIExerciseSessionCreateOrConnectWithoutSessionInput | AIExerciseSessionCreateOrConnectWithoutSessionInput[]
    upsert?: AIExerciseSessionUpsertWithWhereUniqueWithoutSessionInput | AIExerciseSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AIExerciseSessionCreateManySessionInputEnvelope
    set?: AIExerciseSessionWhereUniqueInput | AIExerciseSessionWhereUniqueInput[]
    disconnect?: AIExerciseSessionWhereUniqueInput | AIExerciseSessionWhereUniqueInput[]
    delete?: AIExerciseSessionWhereUniqueInput | AIExerciseSessionWhereUniqueInput[]
    connect?: AIExerciseSessionWhereUniqueInput | AIExerciseSessionWhereUniqueInput[]
    update?: AIExerciseSessionUpdateWithWhereUniqueWithoutSessionInput | AIExerciseSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AIExerciseSessionUpdateManyWithWhereWithoutSessionInput | AIExerciseSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AIExerciseSessionScalarWhereInput | AIExerciseSessionScalarWhereInput[]
  }

  export type AITherapyMessageUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AITherapyMessageCreateWithoutSessionInput, AITherapyMessageUncheckedCreateWithoutSessionInput> | AITherapyMessageCreateWithoutSessionInput[] | AITherapyMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AITherapyMessageCreateOrConnectWithoutSessionInput | AITherapyMessageCreateOrConnectWithoutSessionInput[]
    upsert?: AITherapyMessageUpsertWithWhereUniqueWithoutSessionInput | AITherapyMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AITherapyMessageCreateManySessionInputEnvelope
    set?: AITherapyMessageWhereUniqueInput | AITherapyMessageWhereUniqueInput[]
    disconnect?: AITherapyMessageWhereUniqueInput | AITherapyMessageWhereUniqueInput[]
    delete?: AITherapyMessageWhereUniqueInput | AITherapyMessageWhereUniqueInput[]
    connect?: AITherapyMessageWhereUniqueInput | AITherapyMessageWhereUniqueInput[]
    update?: AITherapyMessageUpdateWithWhereUniqueWithoutSessionInput | AITherapyMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AITherapyMessageUpdateManyWithWhereWithoutSessionInput | AITherapyMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AITherapyMessageScalarWhereInput | AITherapyMessageScalarWhereInput[]
  }

  export type AIExerciseSessionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AIExerciseSessionCreateWithoutSessionInput, AIExerciseSessionUncheckedCreateWithoutSessionInput> | AIExerciseSessionCreateWithoutSessionInput[] | AIExerciseSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AIExerciseSessionCreateOrConnectWithoutSessionInput | AIExerciseSessionCreateOrConnectWithoutSessionInput[]
    upsert?: AIExerciseSessionUpsertWithWhereUniqueWithoutSessionInput | AIExerciseSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AIExerciseSessionCreateManySessionInputEnvelope
    set?: AIExerciseSessionWhereUniqueInput | AIExerciseSessionWhereUniqueInput[]
    disconnect?: AIExerciseSessionWhereUniqueInput | AIExerciseSessionWhereUniqueInput[]
    delete?: AIExerciseSessionWhereUniqueInput | AIExerciseSessionWhereUniqueInput[]
    connect?: AIExerciseSessionWhereUniqueInput | AIExerciseSessionWhereUniqueInput[]
    update?: AIExerciseSessionUpdateWithWhereUniqueWithoutSessionInput | AIExerciseSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AIExerciseSessionUpdateManyWithWhereWithoutSessionInput | AIExerciseSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AIExerciseSessionScalarWhereInput | AIExerciseSessionScalarWhereInput[]
  }

  export type AITherapySessionCreateNestedOneWithoutMessagesInput = {
    create?: XOR<AITherapySessionCreateWithoutMessagesInput, AITherapySessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AITherapySessionCreateOrConnectWithoutMessagesInput
    connect?: AITherapySessionWhereUniqueInput
  }

  export type EnumAIMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.AIMessageType
  }

  export type EnumAIMessageSenderFieldUpdateOperationsInput = {
    set?: $Enums.AIMessageSender
  }

  export type AITherapySessionUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<AITherapySessionCreateWithoutMessagesInput, AITherapySessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AITherapySessionCreateOrConnectWithoutMessagesInput
    upsert?: AITherapySessionUpsertWithoutMessagesInput
    connect?: AITherapySessionWhereUniqueInput
    update?: XOR<XOR<AITherapySessionUpdateToOneWithWhereWithoutMessagesInput, AITherapySessionUpdateWithoutMessagesInput>, AITherapySessionUncheckedUpdateWithoutMessagesInput>
  }

  export type AITherapistCreateNestedOneWithoutPersonalizationsInput = {
    create?: XOR<AITherapistCreateWithoutPersonalizationsInput, AITherapistUncheckedCreateWithoutPersonalizationsInput>
    connectOrCreate?: AITherapistCreateOrConnectWithoutPersonalizationsInput
    connect?: AITherapistWhereUniqueInput
  }

  export type AITherapistUpdateOneWithoutPersonalizationsNestedInput = {
    create?: XOR<AITherapistCreateWithoutPersonalizationsInput, AITherapistUncheckedCreateWithoutPersonalizationsInput>
    connectOrCreate?: AITherapistCreateOrConnectWithoutPersonalizationsInput
    upsert?: AITherapistUpsertWithoutPersonalizationsInput
    disconnect?: AITherapistWhereInput | boolean
    delete?: AITherapistWhereInput | boolean
    connect?: AITherapistWhereUniqueInput
    update?: XOR<XOR<AITherapistUpdateToOneWithWhereWithoutPersonalizationsInput, AITherapistUpdateWithoutPersonalizationsInput>, AITherapistUncheckedUpdateWithoutPersonalizationsInput>
  }

  export type AITherapySessionCreateNestedOneWithoutExercisesInput = {
    create?: XOR<AITherapySessionCreateWithoutExercisesInput, AITherapySessionUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: AITherapySessionCreateOrConnectWithoutExercisesInput
    connect?: AITherapySessionWhereUniqueInput
  }

  export type EnumAIExerciseTypeFieldUpdateOperationsInput = {
    set?: $Enums.AIExerciseType
  }

  export type AITherapySessionUpdateOneWithoutExercisesNestedInput = {
    create?: XOR<AITherapySessionCreateWithoutExercisesInput, AITherapySessionUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: AITherapySessionCreateOrConnectWithoutExercisesInput
    upsert?: AITherapySessionUpsertWithoutExercisesInput
    disconnect?: AITherapySessionWhereInput | boolean
    delete?: AITherapySessionWhereInput | boolean
    connect?: AITherapySessionWhereUniqueInput
    update?: XOR<XOR<AITherapySessionUpdateToOneWithWhereWithoutExercisesInput, AITherapySessionUpdateWithoutExercisesInput>, AITherapySessionUncheckedUpdateWithoutExercisesInput>
  }

  export type EnumAIInsightTypeFieldUpdateOperationsInput = {
    set?: $Enums.AIInsightType
  }

  export type EnumAIGoalStatusFieldUpdateOperationsInput = {
    set?: $Enums.AIGoalStatus
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumCrisisStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CrisisStatus | EnumCrisisStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CrisisStatus[]
    notIn?: $Enums.CrisisStatus[]
    not?: NestedEnumCrisisStatusFilter<$PrismaModel> | $Enums.CrisisStatus
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumEscalationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EscalationType | EnumEscalationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EscalationType[] | null
    notIn?: $Enums.EscalationType[] | null
    not?: NestedEnumEscalationTypeNullableFilter<$PrismaModel> | $Enums.EscalationType | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumCrisisStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CrisisStatus | EnumCrisisStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CrisisStatus[]
    notIn?: $Enums.CrisisStatus[]
    not?: NestedEnumCrisisStatusWithAggregatesFilter<$PrismaModel> | $Enums.CrisisStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCrisisStatusFilter<$PrismaModel>
    _max?: NestedEnumCrisisStatusFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumEscalationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EscalationType | EnumEscalationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EscalationType[] | null
    notIn?: $Enums.EscalationType[] | null
    not?: NestedEnumEscalationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EscalationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEscalationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEscalationTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumMessageSenderFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageSender | EnumMessageSenderFieldRefInput<$PrismaModel>
    in?: $Enums.MessageSender[]
    notIn?: $Enums.MessageSender[]
    not?: NestedEnumMessageSenderFilter<$PrismaModel> | $Enums.MessageSender
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[]
    notIn?: $Enums.MessageType[]
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumMessagePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.MessagePriority | EnumMessagePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MessagePriority[]
    notIn?: $Enums.MessagePriority[]
    not?: NestedEnumMessagePriorityFilter<$PrismaModel> | $Enums.MessagePriority
  }

  export type NestedEnumMessageSenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageSender | EnumMessageSenderFieldRefInput<$PrismaModel>
    in?: $Enums.MessageSender[]
    notIn?: $Enums.MessageSender[]
    not?: NestedEnumMessageSenderWithAggregatesFilter<$PrismaModel> | $Enums.MessageSender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageSenderFilter<$PrismaModel>
    _max?: NestedEnumMessageSenderFilter<$PrismaModel>
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[]
    notIn?: $Enums.MessageType[]
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type NestedEnumMessagePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessagePriority | EnumMessagePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MessagePriority[]
    notIn?: $Enums.MessagePriority[]
    not?: NestedEnumMessagePriorityWithAggregatesFilter<$PrismaModel> | $Enums.MessagePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessagePriorityFilter<$PrismaModel>
    _max?: NestedEnumMessagePriorityFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumEscalationTriggerFilter<$PrismaModel = never> = {
    equals?: $Enums.EscalationTrigger | EnumEscalationTriggerFieldRefInput<$PrismaModel>
    in?: $Enums.EscalationTrigger[]
    notIn?: $Enums.EscalationTrigger[]
    not?: NestedEnumEscalationTriggerFilter<$PrismaModel> | $Enums.EscalationTrigger
  }

  export type NestedEnumEscalationSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.EscalationSeverity | EnumEscalationSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.EscalationSeverity[]
    notIn?: $Enums.EscalationSeverity[]
    not?: NestedEnumEscalationSeverityFilter<$PrismaModel> | $Enums.EscalationSeverity
  }

  export type NestedEnumEscalationOutcomeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EscalationOutcome | EnumEscalationOutcomeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EscalationOutcome[] | null
    notIn?: $Enums.EscalationOutcome[] | null
    not?: NestedEnumEscalationOutcomeNullableFilter<$PrismaModel> | $Enums.EscalationOutcome | null
  }

  export type NestedEnumEscalationTriggerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EscalationTrigger | EnumEscalationTriggerFieldRefInput<$PrismaModel>
    in?: $Enums.EscalationTrigger[]
    notIn?: $Enums.EscalationTrigger[]
    not?: NestedEnumEscalationTriggerWithAggregatesFilter<$PrismaModel> | $Enums.EscalationTrigger
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEscalationTriggerFilter<$PrismaModel>
    _max?: NestedEnumEscalationTriggerFilter<$PrismaModel>
  }

  export type NestedEnumEscalationSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EscalationSeverity | EnumEscalationSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.EscalationSeverity[]
    notIn?: $Enums.EscalationSeverity[]
    not?: NestedEnumEscalationSeverityWithAggregatesFilter<$PrismaModel> | $Enums.EscalationSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEscalationSeverityFilter<$PrismaModel>
    _max?: NestedEnumEscalationSeverityFilter<$PrismaModel>
  }

  export type NestedEnumEscalationOutcomeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EscalationOutcome | EnumEscalationOutcomeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EscalationOutcome[] | null
    notIn?: $Enums.EscalationOutcome[] | null
    not?: NestedEnumEscalationOutcomeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EscalationOutcome | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEscalationOutcomeNullableFilter<$PrismaModel>
    _max?: NestedEnumEscalationOutcomeNullableFilter<$PrismaModel>
  }

  export type NestedEnumEmergencyTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyType | EnumEmergencyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmergencyType[] | null
    notIn?: $Enums.EmergencyType[] | null
    not?: NestedEnumEmergencyTypeNullableFilter<$PrismaModel> | $Enums.EmergencyType | null
  }

  export type NestedEnumTetherDataSharingFilter<$PrismaModel = never> = {
    equals?: $Enums.TetherDataSharing | EnumTetherDataSharingFieldRefInput<$PrismaModel>
    in?: $Enums.TetherDataSharing[]
    notIn?: $Enums.TetherDataSharing[]
    not?: NestedEnumTetherDataSharingFilter<$PrismaModel> | $Enums.TetherDataSharing
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumEmergencyTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyType | EnumEmergencyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmergencyType[] | null
    notIn?: $Enums.EmergencyType[] | null
    not?: NestedEnumEmergencyTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EmergencyType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEmergencyTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEmergencyTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTetherDataSharingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TetherDataSharing | EnumTetherDataSharingFieldRefInput<$PrismaModel>
    in?: $Enums.TetherDataSharing[]
    notIn?: $Enums.TetherDataSharing[]
    not?: NestedEnumTetherDataSharingWithAggregatesFilter<$PrismaModel> | $Enums.TetherDataSharing
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTetherDataSharingFilter<$PrismaModel>
    _max?: NestedEnumTetherDataSharingFilter<$PrismaModel>
  }

  export type NestedEnumPulseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PulseType | EnumPulseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PulseType[]
    notIn?: $Enums.PulseType[]
    not?: NestedEnumPulseTypeFilter<$PrismaModel> | $Enums.PulseType
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[]
    notIn?: $Enums.UserStatus[]
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedEnumUrgencyLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.UrgencyLevel | EnumUrgencyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UrgencyLevel[]
    notIn?: $Enums.UrgencyLevel[]
    not?: NestedEnumUrgencyLevelFilter<$PrismaModel> | $Enums.UrgencyLevel
  }

  export type NestedEnumPulseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PulseType | EnumPulseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PulseType[]
    notIn?: $Enums.PulseType[]
    not?: NestedEnumPulseTypeWithAggregatesFilter<$PrismaModel> | $Enums.PulseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPulseTypeFilter<$PrismaModel>
    _max?: NestedEnumPulseTypeFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[]
    notIn?: $Enums.UserStatus[]
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedEnumUrgencyLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UrgencyLevel | EnumUrgencyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UrgencyLevel[]
    notIn?: $Enums.UrgencyLevel[]
    not?: NestedEnumUrgencyLevelWithAggregatesFilter<$PrismaModel> | $Enums.UrgencyLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUrgencyLevelFilter<$PrismaModel>
    _max?: NestedEnumUrgencyLevelFilter<$PrismaModel>
  }

  export type NestedEnumEmergencyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyType | EnumEmergencyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmergencyType[]
    notIn?: $Enums.EmergencyType[]
    not?: NestedEnumEmergencyTypeFilter<$PrismaModel> | $Enums.EmergencyType
  }

  export type NestedEnumEmergencySeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencySeverity | EnumEmergencySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.EmergencySeverity[]
    notIn?: $Enums.EmergencySeverity[]
    not?: NestedEnumEmergencySeverityFilter<$PrismaModel> | $Enums.EmergencySeverity
  }

  export type NestedEnumEmergencyOutcomeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyOutcome | EnumEmergencyOutcomeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmergencyOutcome[] | null
    notIn?: $Enums.EmergencyOutcome[] | null
    not?: NestedEnumEmergencyOutcomeNullableFilter<$PrismaModel> | $Enums.EmergencyOutcome | null
  }

  export type NestedEnumEmergencyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyType | EnumEmergencyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmergencyType[]
    notIn?: $Enums.EmergencyType[]
    not?: NestedEnumEmergencyTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmergencyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmergencyTypeFilter<$PrismaModel>
    _max?: NestedEnumEmergencyTypeFilter<$PrismaModel>
  }

  export type NestedEnumEmergencySeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencySeverity | EnumEmergencySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.EmergencySeverity[]
    notIn?: $Enums.EmergencySeverity[]
    not?: NestedEnumEmergencySeverityWithAggregatesFilter<$PrismaModel> | $Enums.EmergencySeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmergencySeverityFilter<$PrismaModel>
    _max?: NestedEnumEmergencySeverityFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumEmergencyOutcomeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyOutcome | EnumEmergencyOutcomeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmergencyOutcome[] | null
    notIn?: $Enums.EmergencyOutcome[] | null
    not?: NestedEnumEmergencyOutcomeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EmergencyOutcome | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEmergencyOutcomeNullableFilter<$PrismaModel>
    _max?: NestedEnumEmergencyOutcomeNullableFilter<$PrismaModel>
  }

  export type NestedEnumVolunteerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VolunteerStatus | EnumVolunteerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VolunteerStatus[]
    notIn?: $Enums.VolunteerStatus[]
    not?: NestedEnumVolunteerStatusFilter<$PrismaModel> | $Enums.VolunteerStatus
  }

  export type NestedEnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[]
    notIn?: $Enums.VerificationStatus[]
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type NestedEnumVolunteerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VolunteerStatus | EnumVolunteerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VolunteerStatus[]
    notIn?: $Enums.VolunteerStatus[]
    not?: NestedEnumVolunteerStatusWithAggregatesFilter<$PrismaModel> | $Enums.VolunteerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVolunteerStatusFilter<$PrismaModel>
    _max?: NestedEnumVolunteerStatusFilter<$PrismaModel>
  }

  export type NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[]
    notIn?: $Enums.VerificationStatus[]
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumTrainingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[]
    notIn?: $Enums.TrainingStatus[]
    not?: NestedEnumTrainingStatusFilter<$PrismaModel> | $Enums.TrainingStatus
  }

  export type NestedEnumTrainingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingType | EnumTrainingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingType[]
    notIn?: $Enums.TrainingType[]
    not?: NestedEnumTrainingTypeFilter<$PrismaModel> | $Enums.TrainingType
  }

  export type NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[]
    notIn?: $Enums.TrainingStatus[]
    not?: NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrainingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingStatusFilter<$PrismaModel>
    _max?: NestedEnumTrainingStatusFilter<$PrismaModel>
  }

  export type NestedEnumTrainingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingType | EnumTrainingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingType[]
    notIn?: $Enums.TrainingType[]
    not?: NestedEnumTrainingTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrainingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingTypeFilter<$PrismaModel>
    _max?: NestedEnumTrainingTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumVolunteerSessionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VolunteerSessionType | EnumVolunteerSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VolunteerSessionType[]
    notIn?: $Enums.VolunteerSessionType[]
    not?: NestedEnumVolunteerSessionTypeFilter<$PrismaModel> | $Enums.VolunteerSessionType
  }

  export type NestedEnumSessionOutcomeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionOutcome | EnumSessionOutcomeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SessionOutcome[] | null
    notIn?: $Enums.SessionOutcome[] | null
    not?: NestedEnumSessionOutcomeNullableFilter<$PrismaModel> | $Enums.SessionOutcome | null
  }

  export type NestedEnumVolunteerSessionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VolunteerSessionType | EnumVolunteerSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VolunteerSessionType[]
    notIn?: $Enums.VolunteerSessionType[]
    not?: NestedEnumVolunteerSessionTypeWithAggregatesFilter<$PrismaModel> | $Enums.VolunteerSessionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVolunteerSessionTypeFilter<$PrismaModel>
    _max?: NestedEnumVolunteerSessionTypeFilter<$PrismaModel>
  }

  export type NestedEnumSessionOutcomeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionOutcome | EnumSessionOutcomeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SessionOutcome[] | null
    notIn?: $Enums.SessionOutcome[] | null
    not?: NestedEnumSessionOutcomeNullableWithAggregatesFilter<$PrismaModel> | $Enums.SessionOutcome | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSessionOutcomeNullableFilter<$PrismaModel>
    _max?: NestedEnumSessionOutcomeNullableFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[]
    notIn?: $Enums.FeedbackType[]
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type NestedEnumFeedbackSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackSource | EnumFeedbackSourceFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackSource[]
    notIn?: $Enums.FeedbackSource[]
    not?: NestedEnumFeedbackSourceFilter<$PrismaModel> | $Enums.FeedbackSource
  }

  export type NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[]
    notIn?: $Enums.FeedbackType[]
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackSource | EnumFeedbackSourceFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackSource[]
    notIn?: $Enums.FeedbackSource[]
    not?: NestedEnumFeedbackSourceWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackSourceFilter<$PrismaModel>
    _max?: NestedEnumFeedbackSourceFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumResourceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceCategory | EnumResourceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceCategory[]
    notIn?: $Enums.ResourceCategory[]
    not?: NestedEnumResourceCategoryFilter<$PrismaModel> | $Enums.ResourceCategory
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumResourceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceCategory | EnumResourceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceCategory[]
    notIn?: $Enums.ResourceCategory[]
    not?: NestedEnumResourceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ResourceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceCategoryFilter<$PrismaModel>
    _max?: NestedEnumResourceCategoryFilter<$PrismaModel>
  }

  export type NestedEnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[]
    notIn?: $Enums.ReportType[]
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type NestedEnumReportSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportSeverity | EnumReportSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ReportSeverity[]
    notIn?: $Enums.ReportSeverity[]
    not?: NestedEnumReportSeverityFilter<$PrismaModel> | $Enums.ReportSeverity
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[]
    notIn?: $Enums.ReportStatus[]
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[]
    notIn?: $Enums.ReportType[]
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type NestedEnumReportSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportSeverity | EnumReportSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ReportSeverity[]
    notIn?: $Enums.ReportSeverity[]
    not?: NestedEnumReportSeverityWithAggregatesFilter<$PrismaModel> | $Enums.ReportSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportSeverityFilter<$PrismaModel>
    _max?: NestedEnumReportSeverityFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[]
    notIn?: $Enums.ReportStatus[]
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumMetricStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MetricStatus | EnumMetricStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MetricStatus[]
    notIn?: $Enums.MetricStatus[]
    not?: NestedEnumMetricStatusFilter<$PrismaModel> | $Enums.MetricStatus
  }

  export type NestedEnumMetricStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetricStatus | EnumMetricStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MetricStatus[]
    notIn?: $Enums.MetricStatus[]
    not?: NestedEnumMetricStatusWithAggregatesFilter<$PrismaModel> | $Enums.MetricStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetricStatusFilter<$PrismaModel>
    _max?: NestedEnumMetricStatusFilter<$PrismaModel>
  }

  export type NestedEnumHealthStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HealthStatus | EnumHealthStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HealthStatus[]
    notIn?: $Enums.HealthStatus[]
    not?: NestedEnumHealthStatusFilter<$PrismaModel> | $Enums.HealthStatus
  }

  export type NestedEnumHealthStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HealthStatus | EnumHealthStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HealthStatus[]
    notIn?: $Enums.HealthStatus[]
    not?: NestedEnumHealthStatusWithAggregatesFilter<$PrismaModel> | $Enums.HealthStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHealthStatusFilter<$PrismaModel>
    _max?: NestedEnumHealthStatusFilter<$PrismaModel>
  }

  export type NestedEnumEmergencyNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyNotificationType | EnumEmergencyNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmergencyNotificationType[]
    notIn?: $Enums.EmergencyNotificationType[]
    not?: NestedEnumEmergencyNotificationTypeFilter<$PrismaModel> | $Enums.EmergencyNotificationType
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[]
    notIn?: $Enums.NotificationStatus[]
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumEmergencyNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyNotificationType | EnumEmergencyNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmergencyNotificationType[]
    notIn?: $Enums.EmergencyNotificationType[]
    not?: NestedEnumEmergencyNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmergencyNotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmergencyNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumEmergencyNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[]
    notIn?: $Enums.NotificationStatus[]
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumUserDataSharingFilter<$PrismaModel = never> = {
    equals?: $Enums.UserDataSharing | EnumUserDataSharingFieldRefInput<$PrismaModel>
    in?: $Enums.UserDataSharing[]
    notIn?: $Enums.UserDataSharing[]
    not?: NestedEnumUserDataSharingFilter<$PrismaModel> | $Enums.UserDataSharing
  }

  export type NestedEnumUserDataSharingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserDataSharing | EnumUserDataSharingFieldRefInput<$PrismaModel>
    in?: $Enums.UserDataSharing[]
    notIn?: $Enums.UserDataSharing[]
    not?: NestedEnumUserDataSharingWithAggregatesFilter<$PrismaModel> | $Enums.UserDataSharing
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserDataSharingFilter<$PrismaModel>
    _max?: NestedEnumUserDataSharingFilter<$PrismaModel>
  }

  export type NestedEnumAchievementCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[]
    notIn?: $Enums.AchievementCategory[]
    not?: NestedEnumAchievementCategoryFilter<$PrismaModel> | $Enums.AchievementCategory
  }

  export type NestedEnumAchievementRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementRarity | EnumAchievementRarityFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementRarity[]
    notIn?: $Enums.AchievementRarity[]
    not?: NestedEnumAchievementRarityFilter<$PrismaModel> | $Enums.AchievementRarity
  }

  export type NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[]
    notIn?: $Enums.AchievementCategory[]
    not?: NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AchievementCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementCategoryFilter<$PrismaModel>
    _max?: NestedEnumAchievementCategoryFilter<$PrismaModel>
  }

  export type NestedEnumAchievementRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementRarity | EnumAchievementRarityFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementRarity[]
    notIn?: $Enums.AchievementRarity[]
    not?: NestedEnumAchievementRarityWithAggregatesFilter<$PrismaModel> | $Enums.AchievementRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementRarityFilter<$PrismaModel>
    _max?: NestedEnumAchievementRarityFilter<$PrismaModel>
  }

  export type NestedEnumChallengeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeType | EnumChallengeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeType[]
    notIn?: $Enums.ChallengeType[]
    not?: NestedEnumChallengeTypeFilter<$PrismaModel> | $Enums.ChallengeType
  }

  export type NestedEnumChallengeDifficultyFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeDifficulty | EnumChallengeDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeDifficulty[]
    notIn?: $Enums.ChallengeDifficulty[]
    not?: NestedEnumChallengeDifficultyFilter<$PrismaModel> | $Enums.ChallengeDifficulty
  }

  export type NestedEnumChallengeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeType | EnumChallengeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeType[]
    notIn?: $Enums.ChallengeType[]
    not?: NestedEnumChallengeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeTypeFilter<$PrismaModel>
    _max?: NestedEnumChallengeTypeFilter<$PrismaModel>
  }

  export type NestedEnumChallengeDifficultyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeDifficulty | EnumChallengeDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeDifficulty[]
    notIn?: $Enums.ChallengeDifficulty[]
    not?: NestedEnumChallengeDifficultyWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeDifficulty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeDifficultyFilter<$PrismaModel>
    _max?: NestedEnumChallengeDifficultyFilter<$PrismaModel>
  }

  export type NestedEnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[]
    notIn?: $Enums.ActivityType[]
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[]
    notIn?: $Enums.ActivityType[]
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type NestedEnumJournalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalType | EnumJournalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JournalType[]
    notIn?: $Enums.JournalType[]
    not?: NestedEnumJournalTypeFilter<$PrismaModel> | $Enums.JournalType
  }

  export type NestedEnumJournalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalType | EnumJournalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JournalType[]
    notIn?: $Enums.JournalType[]
    not?: NestedEnumJournalTypeWithAggregatesFilter<$PrismaModel> | $Enums.JournalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJournalTypeFilter<$PrismaModel>
    _max?: NestedEnumJournalTypeFilter<$PrismaModel>
  }

  export type NestedEnumBreathingTechniqueFilter<$PrismaModel = never> = {
    equals?: $Enums.BreathingTechnique | EnumBreathingTechniqueFieldRefInput<$PrismaModel>
    in?: $Enums.BreathingTechnique[]
    notIn?: $Enums.BreathingTechnique[]
    not?: NestedEnumBreathingTechniqueFilter<$PrismaModel> | $Enums.BreathingTechnique
  }

  export type NestedEnumExerciseDifficultyFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseDifficulty | EnumExerciseDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseDifficulty[]
    notIn?: $Enums.ExerciseDifficulty[]
    not?: NestedEnumExerciseDifficultyFilter<$PrismaModel> | $Enums.ExerciseDifficulty
  }

  export type NestedEnumBreathingTechniqueWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BreathingTechnique | EnumBreathingTechniqueFieldRefInput<$PrismaModel>
    in?: $Enums.BreathingTechnique[]
    notIn?: $Enums.BreathingTechnique[]
    not?: NestedEnumBreathingTechniqueWithAggregatesFilter<$PrismaModel> | $Enums.BreathingTechnique
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBreathingTechniqueFilter<$PrismaModel>
    _max?: NestedEnumBreathingTechniqueFilter<$PrismaModel>
  }

  export type NestedEnumExerciseDifficultyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseDifficulty | EnumExerciseDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseDifficulty[]
    notIn?: $Enums.ExerciseDifficulty[]
    not?: NestedEnumExerciseDifficultyWithAggregatesFilter<$PrismaModel> | $Enums.ExerciseDifficulty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExerciseDifficultyFilter<$PrismaModel>
    _max?: NestedEnumExerciseDifficultyFilter<$PrismaModel>
  }

  export type NestedEnumGroundingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GroundingType | EnumGroundingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GroundingType[]
    notIn?: $Enums.GroundingType[]
    not?: NestedEnumGroundingTypeFilter<$PrismaModel> | $Enums.GroundingType
  }

  export type NestedEnumGroundingCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.GroundingCategory | EnumGroundingCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.GroundingCategory[]
    notIn?: $Enums.GroundingCategory[]
    not?: NestedEnumGroundingCategoryFilter<$PrismaModel> | $Enums.GroundingCategory
  }

  export type NestedEnumEvidenceLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceLevel | EnumEvidenceLevelFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceLevel[]
    notIn?: $Enums.EvidenceLevel[]
    not?: NestedEnumEvidenceLevelFilter<$PrismaModel> | $Enums.EvidenceLevel
  }

  export type NestedEnumGroundingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroundingType | EnumGroundingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GroundingType[]
    notIn?: $Enums.GroundingType[]
    not?: NestedEnumGroundingTypeWithAggregatesFilter<$PrismaModel> | $Enums.GroundingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroundingTypeFilter<$PrismaModel>
    _max?: NestedEnumGroundingTypeFilter<$PrismaModel>
  }

  export type NestedEnumGroundingCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroundingCategory | EnumGroundingCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.GroundingCategory[]
    notIn?: $Enums.GroundingCategory[]
    not?: NestedEnumGroundingCategoryWithAggregatesFilter<$PrismaModel> | $Enums.GroundingCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroundingCategoryFilter<$PrismaModel>
    _max?: NestedEnumGroundingCategoryFilter<$PrismaModel>
  }

  export type NestedEnumEvidenceLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceLevel | EnumEvidenceLevelFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceLevel[]
    notIn?: $Enums.EvidenceLevel[]
    not?: NestedEnumEvidenceLevelWithAggregatesFilter<$PrismaModel> | $Enums.EvidenceLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvidenceLevelFilter<$PrismaModel>
    _max?: NestedEnumEvidenceLevelFilter<$PrismaModel>
  }

  export type NestedEnumSelfHelpCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SelfHelpCategory | EnumSelfHelpCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SelfHelpCategory[]
    notIn?: $Enums.SelfHelpCategory[]
    not?: NestedEnumSelfHelpCategoryFilter<$PrismaModel> | $Enums.SelfHelpCategory
  }

  export type NestedEnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[]
    notIn?: $Enums.ResourceType[]
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type NestedEnumSelfHelpCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SelfHelpCategory | EnumSelfHelpCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SelfHelpCategory[]
    notIn?: $Enums.SelfHelpCategory[]
    not?: NestedEnumSelfHelpCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SelfHelpCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSelfHelpCategoryFilter<$PrismaModel>
    _max?: NestedEnumSelfHelpCategoryFilter<$PrismaModel>
  }

  export type NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[]
    notIn?: $Enums.ResourceType[]
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type NestedEnumInteractionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[]
    notIn?: $Enums.InteractionType[]
    not?: NestedEnumInteractionTypeFilter<$PrismaModel> | $Enums.InteractionType
  }

  export type NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[]
    notIn?: $Enums.InteractionType[]
    not?: NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InteractionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInteractionTypeFilter<$PrismaModel>
    _max?: NestedEnumInteractionTypeFilter<$PrismaModel>
  }

  export type NestedEnumAISessionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AISessionType | EnumAISessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AISessionType[]
    notIn?: $Enums.AISessionType[]
    not?: NestedEnumAISessionTypeFilter<$PrismaModel> | $Enums.AISessionType
  }

  export type NestedEnumAISessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AISessionStatus | EnumAISessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AISessionStatus[]
    notIn?: $Enums.AISessionStatus[]
    not?: NestedEnumAISessionStatusFilter<$PrismaModel> | $Enums.AISessionStatus
  }

  export type NestedEnumAISessionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AISessionType | EnumAISessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AISessionType[]
    notIn?: $Enums.AISessionType[]
    not?: NestedEnumAISessionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AISessionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAISessionTypeFilter<$PrismaModel>
    _max?: NestedEnumAISessionTypeFilter<$PrismaModel>
  }

  export type NestedEnumAISessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AISessionStatus | EnumAISessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AISessionStatus[]
    notIn?: $Enums.AISessionStatus[]
    not?: NestedEnumAISessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AISessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAISessionStatusFilter<$PrismaModel>
    _max?: NestedEnumAISessionStatusFilter<$PrismaModel>
  }

  export type NestedEnumAIMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AIMessageType | EnumAIMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIMessageType[]
    notIn?: $Enums.AIMessageType[]
    not?: NestedEnumAIMessageTypeFilter<$PrismaModel> | $Enums.AIMessageType
  }

  export type NestedEnumAIMessageSenderFilter<$PrismaModel = never> = {
    equals?: $Enums.AIMessageSender | EnumAIMessageSenderFieldRefInput<$PrismaModel>
    in?: $Enums.AIMessageSender[]
    notIn?: $Enums.AIMessageSender[]
    not?: NestedEnumAIMessageSenderFilter<$PrismaModel> | $Enums.AIMessageSender
  }

  export type NestedEnumAIMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIMessageType | EnumAIMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIMessageType[]
    notIn?: $Enums.AIMessageType[]
    not?: NestedEnumAIMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.AIMessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumAIMessageTypeFilter<$PrismaModel>
  }

  export type NestedEnumAIMessageSenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIMessageSender | EnumAIMessageSenderFieldRefInput<$PrismaModel>
    in?: $Enums.AIMessageSender[]
    notIn?: $Enums.AIMessageSender[]
    not?: NestedEnumAIMessageSenderWithAggregatesFilter<$PrismaModel> | $Enums.AIMessageSender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIMessageSenderFilter<$PrismaModel>
    _max?: NestedEnumAIMessageSenderFilter<$PrismaModel>
  }

  export type NestedEnumAIExerciseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AIExerciseType | EnumAIExerciseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIExerciseType[]
    notIn?: $Enums.AIExerciseType[]
    not?: NestedEnumAIExerciseTypeFilter<$PrismaModel> | $Enums.AIExerciseType
  }

  export type NestedEnumAIExerciseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIExerciseType | EnumAIExerciseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIExerciseType[]
    notIn?: $Enums.AIExerciseType[]
    not?: NestedEnumAIExerciseTypeWithAggregatesFilter<$PrismaModel> | $Enums.AIExerciseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIExerciseTypeFilter<$PrismaModel>
    _max?: NestedEnumAIExerciseTypeFilter<$PrismaModel>
  }

  export type NestedEnumAIInsightTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AIInsightType | EnumAIInsightTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIInsightType[]
    notIn?: $Enums.AIInsightType[]
    not?: NestedEnumAIInsightTypeFilter<$PrismaModel> | $Enums.AIInsightType
  }

  export type NestedEnumAIInsightTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIInsightType | EnumAIInsightTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIInsightType[]
    notIn?: $Enums.AIInsightType[]
    not?: NestedEnumAIInsightTypeWithAggregatesFilter<$PrismaModel> | $Enums.AIInsightType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIInsightTypeFilter<$PrismaModel>
    _max?: NestedEnumAIInsightTypeFilter<$PrismaModel>
  }

  export type NestedEnumAIGoalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AIGoalStatus | EnumAIGoalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIGoalStatus[]
    notIn?: $Enums.AIGoalStatus[]
    not?: NestedEnumAIGoalStatusFilter<$PrismaModel> | $Enums.AIGoalStatus
  }

  export type NestedEnumAIGoalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIGoalStatus | EnumAIGoalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIGoalStatus[]
    notIn?: $Enums.AIGoalStatus[]
    not?: NestedEnumAIGoalStatusWithAggregatesFilter<$PrismaModel> | $Enums.AIGoalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIGoalStatusFilter<$PrismaModel>
    _max?: NestedEnumAIGoalStatusFilter<$PrismaModel>
  }

  export type CrisisMessageCreateWithoutSessionInput = {
    id?: string
    senderType: $Enums.MessageSender
    senderId: string
    encryptedContent: Uint8Array
    messageHash: string
    timestamp?: Date | string
    messageType?: $Enums.MessageType
    priority?: $Enums.MessagePriority
    sentimentScore?: number | null
    riskScore?: number | null
    riskLevel?: string | null
    keywordsDetected?: string | null
  }

  export type CrisisMessageUncheckedCreateWithoutSessionInput = {
    id?: string
    senderType: $Enums.MessageSender
    senderId: string
    encryptedContent: Uint8Array
    messageHash: string
    timestamp?: Date | string
    messageType?: $Enums.MessageType
    priority?: $Enums.MessagePriority
    sentimentScore?: number | null
    riskScore?: number | null
    riskLevel?: string | null
    keywordsDetected?: string | null
  }

  export type CrisisMessageCreateOrConnectWithoutSessionInput = {
    where: CrisisMessageWhereUniqueInput
    create: XOR<CrisisMessageCreateWithoutSessionInput, CrisisMessageUncheckedCreateWithoutSessionInput>
  }

  export type CrisisMessageCreateManySessionInputEnvelope = {
    data: CrisisMessageCreateManySessionInput | CrisisMessageCreateManySessionInput[]
  }

  export type CrisisEscalationCreateWithoutSessionInput = {
    id?: string
    triggeredBy: $Enums.EscalationTrigger
    severity: $Enums.EscalationSeverity
    reason: string
    actionsTaken?: string | null
    emergencyContacted?: boolean
    lifeline988Called?: boolean
    triggeredAt?: Date | string
    resolvedAt?: Date | string | null
    responseTime?: number | null
    handledBy?: string | null
    outcome?: $Enums.EscalationOutcome | null
  }

  export type CrisisEscalationUncheckedCreateWithoutSessionInput = {
    id?: string
    triggeredBy: $Enums.EscalationTrigger
    severity: $Enums.EscalationSeverity
    reason: string
    actionsTaken?: string | null
    emergencyContacted?: boolean
    lifeline988Called?: boolean
    triggeredAt?: Date | string
    resolvedAt?: Date | string | null
    responseTime?: number | null
    handledBy?: string | null
    outcome?: $Enums.EscalationOutcome | null
  }

  export type CrisisEscalationCreateOrConnectWithoutSessionInput = {
    where: CrisisEscalationWhereUniqueInput
    create: XOR<CrisisEscalationCreateWithoutSessionInput, CrisisEscalationUncheckedCreateWithoutSessionInput>
  }

  export type CrisisEscalationCreateManySessionInputEnvelope = {
    data: CrisisEscalationCreateManySessionInput | CrisisEscalationCreateManySessionInput[]
  }

  export type CrisisResourceUsageCreateWithoutSessionInput = {
    id?: string
    resourceId: string
    accessedAt?: Date | string
    timeSpent?: number | null
    wasHelpful?: boolean | null
    helpfulRating?: number | null
    resourceTitle: string
    resourceType: $Enums.ResourceCategory
  }

  export type CrisisResourceUsageUncheckedCreateWithoutSessionInput = {
    id?: string
    resourceId: string
    accessedAt?: Date | string
    timeSpent?: number | null
    wasHelpful?: boolean | null
    helpfulRating?: number | null
    resourceTitle: string
    resourceType: $Enums.ResourceCategory
  }

  export type CrisisResourceUsageCreateOrConnectWithoutSessionInput = {
    where: CrisisResourceUsageWhereUniqueInput
    create: XOR<CrisisResourceUsageCreateWithoutSessionInput, CrisisResourceUsageUncheckedCreateWithoutSessionInput>
  }

  export type CrisisResourceUsageCreateManySessionInputEnvelope = {
    data: CrisisResourceUsageCreateManySessionInput | CrisisResourceUsageCreateManySessionInput[]
  }

  export type CrisisMessageUpsertWithWhereUniqueWithoutSessionInput = {
    where: CrisisMessageWhereUniqueInput
    update: XOR<CrisisMessageUpdateWithoutSessionInput, CrisisMessageUncheckedUpdateWithoutSessionInput>
    create: XOR<CrisisMessageCreateWithoutSessionInput, CrisisMessageUncheckedCreateWithoutSessionInput>
  }

  export type CrisisMessageUpdateWithWhereUniqueWithoutSessionInput = {
    where: CrisisMessageWhereUniqueInput
    data: XOR<CrisisMessageUpdateWithoutSessionInput, CrisisMessageUncheckedUpdateWithoutSessionInput>
  }

  export type CrisisMessageUpdateManyWithWhereWithoutSessionInput = {
    where: CrisisMessageScalarWhereInput
    data: XOR<CrisisMessageUpdateManyMutationInput, CrisisMessageUncheckedUpdateManyWithoutSessionInput>
  }

  export type CrisisMessageScalarWhereInput = {
    AND?: CrisisMessageScalarWhereInput | CrisisMessageScalarWhereInput[]
    OR?: CrisisMessageScalarWhereInput[]
    NOT?: CrisisMessageScalarWhereInput | CrisisMessageScalarWhereInput[]
    id?: StringFilter<"CrisisMessage"> | string
    sessionId?: StringFilter<"CrisisMessage"> | string
    senderType?: EnumMessageSenderFilter<"CrisisMessage"> | $Enums.MessageSender
    senderId?: StringFilter<"CrisisMessage"> | string
    encryptedContent?: BytesFilter<"CrisisMessage"> | Uint8Array
    messageHash?: StringFilter<"CrisisMessage"> | string
    timestamp?: DateTimeFilter<"CrisisMessage"> | Date | string
    messageType?: EnumMessageTypeFilter<"CrisisMessage"> | $Enums.MessageType
    priority?: EnumMessagePriorityFilter<"CrisisMessage"> | $Enums.MessagePriority
    sentimentScore?: FloatNullableFilter<"CrisisMessage"> | number | null
    riskScore?: IntNullableFilter<"CrisisMessage"> | number | null
    riskLevel?: StringNullableFilter<"CrisisMessage"> | string | null
    keywordsDetected?: StringNullableFilter<"CrisisMessage"> | string | null
  }

  export type CrisisEscalationUpsertWithWhereUniqueWithoutSessionInput = {
    where: CrisisEscalationWhereUniqueInput
    update: XOR<CrisisEscalationUpdateWithoutSessionInput, CrisisEscalationUncheckedUpdateWithoutSessionInput>
    create: XOR<CrisisEscalationCreateWithoutSessionInput, CrisisEscalationUncheckedCreateWithoutSessionInput>
  }

  export type CrisisEscalationUpdateWithWhereUniqueWithoutSessionInput = {
    where: CrisisEscalationWhereUniqueInput
    data: XOR<CrisisEscalationUpdateWithoutSessionInput, CrisisEscalationUncheckedUpdateWithoutSessionInput>
  }

  export type CrisisEscalationUpdateManyWithWhereWithoutSessionInput = {
    where: CrisisEscalationScalarWhereInput
    data: XOR<CrisisEscalationUpdateManyMutationInput, CrisisEscalationUncheckedUpdateManyWithoutSessionInput>
  }

  export type CrisisEscalationScalarWhereInput = {
    AND?: CrisisEscalationScalarWhereInput | CrisisEscalationScalarWhereInput[]
    OR?: CrisisEscalationScalarWhereInput[]
    NOT?: CrisisEscalationScalarWhereInput | CrisisEscalationScalarWhereInput[]
    id?: StringFilter<"CrisisEscalation"> | string
    sessionId?: StringFilter<"CrisisEscalation"> | string
    triggeredBy?: EnumEscalationTriggerFilter<"CrisisEscalation"> | $Enums.EscalationTrigger
    severity?: EnumEscalationSeverityFilter<"CrisisEscalation"> | $Enums.EscalationSeverity
    reason?: StringFilter<"CrisisEscalation"> | string
    actionsTaken?: StringNullableFilter<"CrisisEscalation"> | string | null
    emergencyContacted?: BoolFilter<"CrisisEscalation"> | boolean
    lifeline988Called?: BoolFilter<"CrisisEscalation"> | boolean
    triggeredAt?: DateTimeFilter<"CrisisEscalation"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"CrisisEscalation"> | Date | string | null
    responseTime?: IntNullableFilter<"CrisisEscalation"> | number | null
    handledBy?: StringNullableFilter<"CrisisEscalation"> | string | null
    outcome?: EnumEscalationOutcomeNullableFilter<"CrisisEscalation"> | $Enums.EscalationOutcome | null
  }

  export type CrisisResourceUsageUpsertWithWhereUniqueWithoutSessionInput = {
    where: CrisisResourceUsageWhereUniqueInput
    update: XOR<CrisisResourceUsageUpdateWithoutSessionInput, CrisisResourceUsageUncheckedUpdateWithoutSessionInput>
    create: XOR<CrisisResourceUsageCreateWithoutSessionInput, CrisisResourceUsageUncheckedCreateWithoutSessionInput>
  }

  export type CrisisResourceUsageUpdateWithWhereUniqueWithoutSessionInput = {
    where: CrisisResourceUsageWhereUniqueInput
    data: XOR<CrisisResourceUsageUpdateWithoutSessionInput, CrisisResourceUsageUncheckedUpdateWithoutSessionInput>
  }

  export type CrisisResourceUsageUpdateManyWithWhereWithoutSessionInput = {
    where: CrisisResourceUsageScalarWhereInput
    data: XOR<CrisisResourceUsageUpdateManyMutationInput, CrisisResourceUsageUncheckedUpdateManyWithoutSessionInput>
  }

  export type CrisisResourceUsageScalarWhereInput = {
    AND?: CrisisResourceUsageScalarWhereInput | CrisisResourceUsageScalarWhereInput[]
    OR?: CrisisResourceUsageScalarWhereInput[]
    NOT?: CrisisResourceUsageScalarWhereInput | CrisisResourceUsageScalarWhereInput[]
    id?: StringFilter<"CrisisResourceUsage"> | string
    sessionId?: StringFilter<"CrisisResourceUsage"> | string
    resourceId?: StringFilter<"CrisisResourceUsage"> | string
    accessedAt?: DateTimeFilter<"CrisisResourceUsage"> | Date | string
    timeSpent?: IntNullableFilter<"CrisisResourceUsage"> | number | null
    wasHelpful?: BoolNullableFilter<"CrisisResourceUsage"> | boolean | null
    helpfulRating?: IntNullableFilter<"CrisisResourceUsage"> | number | null
    resourceTitle?: StringFilter<"CrisisResourceUsage"> | string
    resourceType?: EnumResourceCategoryFilter<"CrisisResourceUsage"> | $Enums.ResourceCategory
  }

  export type CrisisSessionCreateWithoutMessagesInput = {
    id?: string
    sessionToken: string
    anonymousId: string
    severity: number
    status?: $Enums.CrisisStatus
    responderId?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    responseTimeMs?: number | null
    outcome?: string | null
    encryptedData?: Uint8Array | null
    keyDerivationSalt?: Uint8Array | null
    handoffTime?: number | null
    resolutionTime?: number | null
    emergencyTriggered?: boolean
    escalatedAt?: Date | string | null
    escalationType?: $Enums.EscalationType | null
    escalations?: CrisisEscalationCreateNestedManyWithoutSessionInput
    resources?: CrisisResourceUsageCreateNestedManyWithoutSessionInput
  }

  export type CrisisSessionUncheckedCreateWithoutMessagesInput = {
    id?: string
    sessionToken: string
    anonymousId: string
    severity: number
    status?: $Enums.CrisisStatus
    responderId?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    responseTimeMs?: number | null
    outcome?: string | null
    encryptedData?: Uint8Array | null
    keyDerivationSalt?: Uint8Array | null
    handoffTime?: number | null
    resolutionTime?: number | null
    emergencyTriggered?: boolean
    escalatedAt?: Date | string | null
    escalationType?: $Enums.EscalationType | null
    escalations?: CrisisEscalationUncheckedCreateNestedManyWithoutSessionInput
    resources?: CrisisResourceUsageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type CrisisSessionCreateOrConnectWithoutMessagesInput = {
    where: CrisisSessionWhereUniqueInput
    create: XOR<CrisisSessionCreateWithoutMessagesInput, CrisisSessionUncheckedCreateWithoutMessagesInput>
  }

  export type CrisisSessionUpsertWithoutMessagesInput = {
    update: XOR<CrisisSessionUpdateWithoutMessagesInput, CrisisSessionUncheckedUpdateWithoutMessagesInput>
    create: XOR<CrisisSessionCreateWithoutMessagesInput, CrisisSessionUncheckedCreateWithoutMessagesInput>
    where?: CrisisSessionWhereInput
  }

  export type CrisisSessionUpdateToOneWithWhereWithoutMessagesInput = {
    where?: CrisisSessionWhereInput
    data: XOR<CrisisSessionUpdateWithoutMessagesInput, CrisisSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type CrisisSessionUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    status?: EnumCrisisStatusFieldUpdateOperationsInput | $Enums.CrisisStatus
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedData?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    keyDerivationSalt?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    handoffTime?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionTime?: NullableIntFieldUpdateOperationsInput | number | null
    emergencyTriggered?: BoolFieldUpdateOperationsInput | boolean
    escalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationType?: NullableEnumEscalationTypeFieldUpdateOperationsInput | $Enums.EscalationType | null
    escalations?: CrisisEscalationUpdateManyWithoutSessionNestedInput
    resources?: CrisisResourceUsageUpdateManyWithoutSessionNestedInput
  }

  export type CrisisSessionUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    status?: EnumCrisisStatusFieldUpdateOperationsInput | $Enums.CrisisStatus
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedData?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    keyDerivationSalt?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    handoffTime?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionTime?: NullableIntFieldUpdateOperationsInput | number | null
    emergencyTriggered?: BoolFieldUpdateOperationsInput | boolean
    escalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationType?: NullableEnumEscalationTypeFieldUpdateOperationsInput | $Enums.EscalationType | null
    escalations?: CrisisEscalationUncheckedUpdateManyWithoutSessionNestedInput
    resources?: CrisisResourceUsageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CrisisSessionCreateWithoutEscalationsInput = {
    id?: string
    sessionToken: string
    anonymousId: string
    severity: number
    status?: $Enums.CrisisStatus
    responderId?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    responseTimeMs?: number | null
    outcome?: string | null
    encryptedData?: Uint8Array | null
    keyDerivationSalt?: Uint8Array | null
    handoffTime?: number | null
    resolutionTime?: number | null
    emergencyTriggered?: boolean
    escalatedAt?: Date | string | null
    escalationType?: $Enums.EscalationType | null
    messages?: CrisisMessageCreateNestedManyWithoutSessionInput
    resources?: CrisisResourceUsageCreateNestedManyWithoutSessionInput
  }

  export type CrisisSessionUncheckedCreateWithoutEscalationsInput = {
    id?: string
    sessionToken: string
    anonymousId: string
    severity: number
    status?: $Enums.CrisisStatus
    responderId?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    responseTimeMs?: number | null
    outcome?: string | null
    encryptedData?: Uint8Array | null
    keyDerivationSalt?: Uint8Array | null
    handoffTime?: number | null
    resolutionTime?: number | null
    emergencyTriggered?: boolean
    escalatedAt?: Date | string | null
    escalationType?: $Enums.EscalationType | null
    messages?: CrisisMessageUncheckedCreateNestedManyWithoutSessionInput
    resources?: CrisisResourceUsageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type CrisisSessionCreateOrConnectWithoutEscalationsInput = {
    where: CrisisSessionWhereUniqueInput
    create: XOR<CrisisSessionCreateWithoutEscalationsInput, CrisisSessionUncheckedCreateWithoutEscalationsInput>
  }

  export type CrisisSessionUpsertWithoutEscalationsInput = {
    update: XOR<CrisisSessionUpdateWithoutEscalationsInput, CrisisSessionUncheckedUpdateWithoutEscalationsInput>
    create: XOR<CrisisSessionCreateWithoutEscalationsInput, CrisisSessionUncheckedCreateWithoutEscalationsInput>
    where?: CrisisSessionWhereInput
  }

  export type CrisisSessionUpdateToOneWithWhereWithoutEscalationsInput = {
    where?: CrisisSessionWhereInput
    data: XOR<CrisisSessionUpdateWithoutEscalationsInput, CrisisSessionUncheckedUpdateWithoutEscalationsInput>
  }

  export type CrisisSessionUpdateWithoutEscalationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    status?: EnumCrisisStatusFieldUpdateOperationsInput | $Enums.CrisisStatus
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedData?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    keyDerivationSalt?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    handoffTime?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionTime?: NullableIntFieldUpdateOperationsInput | number | null
    emergencyTriggered?: BoolFieldUpdateOperationsInput | boolean
    escalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationType?: NullableEnumEscalationTypeFieldUpdateOperationsInput | $Enums.EscalationType | null
    messages?: CrisisMessageUpdateManyWithoutSessionNestedInput
    resources?: CrisisResourceUsageUpdateManyWithoutSessionNestedInput
  }

  export type CrisisSessionUncheckedUpdateWithoutEscalationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    status?: EnumCrisisStatusFieldUpdateOperationsInput | $Enums.CrisisStatus
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedData?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    keyDerivationSalt?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    handoffTime?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionTime?: NullableIntFieldUpdateOperationsInput | number | null
    emergencyTriggered?: BoolFieldUpdateOperationsInput | boolean
    escalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationType?: NullableEnumEscalationTypeFieldUpdateOperationsInput | $Enums.EscalationType | null
    messages?: CrisisMessageUncheckedUpdateManyWithoutSessionNestedInput
    resources?: CrisisResourceUsageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type TetherPulseCreateWithoutTetherInput = {
    id?: string
    pulseType?: $Enums.PulseType
    strength: number
    mood?: number | null
    status?: $Enums.UserStatus
    message?: string | null
    emergencySignal?: boolean
    urgencyLevel?: $Enums.UrgencyLevel
    timestamp?: Date | string
    acknowledged?: boolean
    acknowledgedAt?: Date | string | null
  }

  export type TetherPulseUncheckedCreateWithoutTetherInput = {
    id?: string
    pulseType?: $Enums.PulseType
    strength: number
    mood?: number | null
    status?: $Enums.UserStatus
    message?: string | null
    emergencySignal?: boolean
    urgencyLevel?: $Enums.UrgencyLevel
    timestamp?: Date | string
    acknowledged?: boolean
    acknowledgedAt?: Date | string | null
  }

  export type TetherPulseCreateOrConnectWithoutTetherInput = {
    where: TetherPulseWhereUniqueInput
    create: XOR<TetherPulseCreateWithoutTetherInput, TetherPulseUncheckedCreateWithoutTetherInput>
  }

  export type TetherPulseCreateManyTetherInputEnvelope = {
    data: TetherPulseCreateManyTetherInput | TetherPulseCreateManyTetherInput[]
  }

  export type TetherEmergencyCreateWithoutTetherInput = {
    id?: string
    triggerUserId: string
    emergencyType: $Enums.EmergencyType
    severity: $Enums.EmergencySeverity
    description: string
    location?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: Date | string
    acknowledgedAt?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    responseTime?: number | null
    actionsTaken?: string | null
    outcome?: $Enums.EmergencyOutcome | null
    helpersNotified?: string | null
    emergencyContacts?: string | null
  }

  export type TetherEmergencyUncheckedCreateWithoutTetherInput = {
    id?: string
    triggerUserId: string
    emergencyType: $Enums.EmergencyType
    severity: $Enums.EmergencySeverity
    description: string
    location?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: Date | string
    acknowledgedAt?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    responseTime?: number | null
    actionsTaken?: string | null
    outcome?: $Enums.EmergencyOutcome | null
    helpersNotified?: string | null
    emergencyContacts?: string | null
  }

  export type TetherEmergencyCreateOrConnectWithoutTetherInput = {
    where: TetherEmergencyWhereUniqueInput
    create: XOR<TetherEmergencyCreateWithoutTetherInput, TetherEmergencyUncheckedCreateWithoutTetherInput>
  }

  export type TetherEmergencyCreateManyTetherInputEnvelope = {
    data: TetherEmergencyCreateManyTetherInput | TetherEmergencyCreateManyTetherInput[]
  }

  export type TetherPulseUpsertWithWhereUniqueWithoutTetherInput = {
    where: TetherPulseWhereUniqueInput
    update: XOR<TetherPulseUpdateWithoutTetherInput, TetherPulseUncheckedUpdateWithoutTetherInput>
    create: XOR<TetherPulseCreateWithoutTetherInput, TetherPulseUncheckedCreateWithoutTetherInput>
  }

  export type TetherPulseUpdateWithWhereUniqueWithoutTetherInput = {
    where: TetherPulseWhereUniqueInput
    data: XOR<TetherPulseUpdateWithoutTetherInput, TetherPulseUncheckedUpdateWithoutTetherInput>
  }

  export type TetherPulseUpdateManyWithWhereWithoutTetherInput = {
    where: TetherPulseScalarWhereInput
    data: XOR<TetherPulseUpdateManyMutationInput, TetherPulseUncheckedUpdateManyWithoutTetherInput>
  }

  export type TetherPulseScalarWhereInput = {
    AND?: TetherPulseScalarWhereInput | TetherPulseScalarWhereInput[]
    OR?: TetherPulseScalarWhereInput[]
    NOT?: TetherPulseScalarWhereInput | TetherPulseScalarWhereInput[]
    id?: StringFilter<"TetherPulse"> | string
    tetherId?: StringFilter<"TetherPulse"> | string
    pulseType?: EnumPulseTypeFilter<"TetherPulse"> | $Enums.PulseType
    strength?: FloatFilter<"TetherPulse"> | number
    mood?: IntNullableFilter<"TetherPulse"> | number | null
    status?: EnumUserStatusFilter<"TetherPulse"> | $Enums.UserStatus
    message?: StringNullableFilter<"TetherPulse"> | string | null
    emergencySignal?: BoolFilter<"TetherPulse"> | boolean
    urgencyLevel?: EnumUrgencyLevelFilter<"TetherPulse"> | $Enums.UrgencyLevel
    timestamp?: DateTimeFilter<"TetherPulse"> | Date | string
    acknowledged?: BoolFilter<"TetherPulse"> | boolean
    acknowledgedAt?: DateTimeNullableFilter<"TetherPulse"> | Date | string | null
  }

  export type TetherEmergencyUpsertWithWhereUniqueWithoutTetherInput = {
    where: TetherEmergencyWhereUniqueInput
    update: XOR<TetherEmergencyUpdateWithoutTetherInput, TetherEmergencyUncheckedUpdateWithoutTetherInput>
    create: XOR<TetherEmergencyCreateWithoutTetherInput, TetherEmergencyUncheckedCreateWithoutTetherInput>
  }

  export type TetherEmergencyUpdateWithWhereUniqueWithoutTetherInput = {
    where: TetherEmergencyWhereUniqueInput
    data: XOR<TetherEmergencyUpdateWithoutTetherInput, TetherEmergencyUncheckedUpdateWithoutTetherInput>
  }

  export type TetherEmergencyUpdateManyWithWhereWithoutTetherInput = {
    where: TetherEmergencyScalarWhereInput
    data: XOR<TetherEmergencyUpdateManyMutationInput, TetherEmergencyUncheckedUpdateManyWithoutTetherInput>
  }

  export type TetherEmergencyScalarWhereInput = {
    AND?: TetherEmergencyScalarWhereInput | TetherEmergencyScalarWhereInput[]
    OR?: TetherEmergencyScalarWhereInput[]
    NOT?: TetherEmergencyScalarWhereInput | TetherEmergencyScalarWhereInput[]
    id?: StringFilter<"TetherEmergency"> | string
    tetherId?: StringFilter<"TetherEmergency"> | string
    triggerUserId?: StringFilter<"TetherEmergency"> | string
    emergencyType?: EnumEmergencyTypeFilter<"TetherEmergency"> | $Enums.EmergencyType
    severity?: EnumEmergencySeverityFilter<"TetherEmergency"> | $Enums.EmergencySeverity
    description?: StringFilter<"TetherEmergency"> | string
    location?: JsonNullableFilter<"TetherEmergency">
    triggeredAt?: DateTimeFilter<"TetherEmergency"> | Date | string
    acknowledgedAt?: DateTimeNullableFilter<"TetherEmergency"> | Date | string | null
    respondedAt?: DateTimeNullableFilter<"TetherEmergency"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"TetherEmergency"> | Date | string | null
    responseTime?: IntNullableFilter<"TetherEmergency"> | number | null
    actionsTaken?: StringNullableFilter<"TetherEmergency"> | string | null
    outcome?: EnumEmergencyOutcomeNullableFilter<"TetherEmergency"> | $Enums.EmergencyOutcome | null
    helpersNotified?: StringNullableFilter<"TetherEmergency"> | string | null
    emergencyContacts?: StringNullableFilter<"TetherEmergency"> | string | null
  }

  export type TetherLinkCreateWithoutPulsesInput = {
    id?: string
    seekerId: string
    supporterId: string
    strength?: number
    trustScore?: number
    established?: Date | string
    lastActivity?: Date | string
    pulseInterval?: number
    lastPulse?: Date | string
    missedPulses?: number
    emergencyActive?: boolean
    emergencyType?: $Enums.EmergencyType | null
    lastEmergency?: Date | string | null
    matchingScore?: number | null
    specialties?: string | null
    languages?: string | null
    timezone?: string | null
    dataSharing?: $Enums.TetherDataSharing
    locationSharing?: boolean
    emergencyContact?: boolean
    encryptedMeta?: Uint8Array | null
    emergencies?: TetherEmergencyCreateNestedManyWithoutTetherInput
  }

  export type TetherLinkUncheckedCreateWithoutPulsesInput = {
    id?: string
    seekerId: string
    supporterId: string
    strength?: number
    trustScore?: number
    established?: Date | string
    lastActivity?: Date | string
    pulseInterval?: number
    lastPulse?: Date | string
    missedPulses?: number
    emergencyActive?: boolean
    emergencyType?: $Enums.EmergencyType | null
    lastEmergency?: Date | string | null
    matchingScore?: number | null
    specialties?: string | null
    languages?: string | null
    timezone?: string | null
    dataSharing?: $Enums.TetherDataSharing
    locationSharing?: boolean
    emergencyContact?: boolean
    encryptedMeta?: Uint8Array | null
    emergencies?: TetherEmergencyUncheckedCreateNestedManyWithoutTetherInput
  }

  export type TetherLinkCreateOrConnectWithoutPulsesInput = {
    where: TetherLinkWhereUniqueInput
    create: XOR<TetherLinkCreateWithoutPulsesInput, TetherLinkUncheckedCreateWithoutPulsesInput>
  }

  export type TetherLinkUpsertWithoutPulsesInput = {
    update: XOR<TetherLinkUpdateWithoutPulsesInput, TetherLinkUncheckedUpdateWithoutPulsesInput>
    create: XOR<TetherLinkCreateWithoutPulsesInput, TetherLinkUncheckedCreateWithoutPulsesInput>
    where?: TetherLinkWhereInput
  }

  export type TetherLinkUpdateToOneWithWhereWithoutPulsesInput = {
    where?: TetherLinkWhereInput
    data: XOR<TetherLinkUpdateWithoutPulsesInput, TetherLinkUncheckedUpdateWithoutPulsesInput>
  }

  export type TetherLinkUpdateWithoutPulsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    seekerId?: StringFieldUpdateOperationsInput | string
    supporterId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    trustScore?: FloatFieldUpdateOperationsInput | number
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    pulseInterval?: IntFieldUpdateOperationsInput | number
    lastPulse?: DateTimeFieldUpdateOperationsInput | Date | string
    missedPulses?: IntFieldUpdateOperationsInput | number
    emergencyActive?: BoolFieldUpdateOperationsInput | boolean
    emergencyType?: NullableEnumEmergencyTypeFieldUpdateOperationsInput | $Enums.EmergencyType | null
    lastEmergency?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    matchingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    specialties?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dataSharing?: EnumTetherDataSharingFieldUpdateOperationsInput | $Enums.TetherDataSharing
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    emergencyContact?: BoolFieldUpdateOperationsInput | boolean
    encryptedMeta?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    emergencies?: TetherEmergencyUpdateManyWithoutTetherNestedInput
  }

  export type TetherLinkUncheckedUpdateWithoutPulsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    seekerId?: StringFieldUpdateOperationsInput | string
    supporterId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    trustScore?: FloatFieldUpdateOperationsInput | number
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    pulseInterval?: IntFieldUpdateOperationsInput | number
    lastPulse?: DateTimeFieldUpdateOperationsInput | Date | string
    missedPulses?: IntFieldUpdateOperationsInput | number
    emergencyActive?: BoolFieldUpdateOperationsInput | boolean
    emergencyType?: NullableEnumEmergencyTypeFieldUpdateOperationsInput | $Enums.EmergencyType | null
    lastEmergency?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    matchingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    specialties?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dataSharing?: EnumTetherDataSharingFieldUpdateOperationsInput | $Enums.TetherDataSharing
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    emergencyContact?: BoolFieldUpdateOperationsInput | boolean
    encryptedMeta?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    emergencies?: TetherEmergencyUncheckedUpdateManyWithoutTetherNestedInput
  }

  export type TetherLinkCreateWithoutEmergenciesInput = {
    id?: string
    seekerId: string
    supporterId: string
    strength?: number
    trustScore?: number
    established?: Date | string
    lastActivity?: Date | string
    pulseInterval?: number
    lastPulse?: Date | string
    missedPulses?: number
    emergencyActive?: boolean
    emergencyType?: $Enums.EmergencyType | null
    lastEmergency?: Date | string | null
    matchingScore?: number | null
    specialties?: string | null
    languages?: string | null
    timezone?: string | null
    dataSharing?: $Enums.TetherDataSharing
    locationSharing?: boolean
    emergencyContact?: boolean
    encryptedMeta?: Uint8Array | null
    pulses?: TetherPulseCreateNestedManyWithoutTetherInput
  }

  export type TetherLinkUncheckedCreateWithoutEmergenciesInput = {
    id?: string
    seekerId: string
    supporterId: string
    strength?: number
    trustScore?: number
    established?: Date | string
    lastActivity?: Date | string
    pulseInterval?: number
    lastPulse?: Date | string
    missedPulses?: number
    emergencyActive?: boolean
    emergencyType?: $Enums.EmergencyType | null
    lastEmergency?: Date | string | null
    matchingScore?: number | null
    specialties?: string | null
    languages?: string | null
    timezone?: string | null
    dataSharing?: $Enums.TetherDataSharing
    locationSharing?: boolean
    emergencyContact?: boolean
    encryptedMeta?: Uint8Array | null
    pulses?: TetherPulseUncheckedCreateNestedManyWithoutTetherInput
  }

  export type TetherLinkCreateOrConnectWithoutEmergenciesInput = {
    where: TetherLinkWhereUniqueInput
    create: XOR<TetherLinkCreateWithoutEmergenciesInput, TetherLinkUncheckedCreateWithoutEmergenciesInput>
  }

  export type TetherLinkUpsertWithoutEmergenciesInput = {
    update: XOR<TetherLinkUpdateWithoutEmergenciesInput, TetherLinkUncheckedUpdateWithoutEmergenciesInput>
    create: XOR<TetherLinkCreateWithoutEmergenciesInput, TetherLinkUncheckedCreateWithoutEmergenciesInput>
    where?: TetherLinkWhereInput
  }

  export type TetherLinkUpdateToOneWithWhereWithoutEmergenciesInput = {
    where?: TetherLinkWhereInput
    data: XOR<TetherLinkUpdateWithoutEmergenciesInput, TetherLinkUncheckedUpdateWithoutEmergenciesInput>
  }

  export type TetherLinkUpdateWithoutEmergenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    seekerId?: StringFieldUpdateOperationsInput | string
    supporterId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    trustScore?: FloatFieldUpdateOperationsInput | number
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    pulseInterval?: IntFieldUpdateOperationsInput | number
    lastPulse?: DateTimeFieldUpdateOperationsInput | Date | string
    missedPulses?: IntFieldUpdateOperationsInput | number
    emergencyActive?: BoolFieldUpdateOperationsInput | boolean
    emergencyType?: NullableEnumEmergencyTypeFieldUpdateOperationsInput | $Enums.EmergencyType | null
    lastEmergency?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    matchingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    specialties?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dataSharing?: EnumTetherDataSharingFieldUpdateOperationsInput | $Enums.TetherDataSharing
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    emergencyContact?: BoolFieldUpdateOperationsInput | boolean
    encryptedMeta?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    pulses?: TetherPulseUpdateManyWithoutTetherNestedInput
  }

  export type TetherLinkUncheckedUpdateWithoutEmergenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    seekerId?: StringFieldUpdateOperationsInput | string
    supporterId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    trustScore?: FloatFieldUpdateOperationsInput | number
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    pulseInterval?: IntFieldUpdateOperationsInput | number
    lastPulse?: DateTimeFieldUpdateOperationsInput | Date | string
    missedPulses?: IntFieldUpdateOperationsInput | number
    emergencyActive?: BoolFieldUpdateOperationsInput | boolean
    emergencyType?: NullableEnumEmergencyTypeFieldUpdateOperationsInput | $Enums.EmergencyType | null
    lastEmergency?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    matchingScore?: NullableFloatFieldUpdateOperationsInput | number | null
    specialties?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dataSharing?: EnumTetherDataSharingFieldUpdateOperationsInput | $Enums.TetherDataSharing
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    emergencyContact?: BoolFieldUpdateOperationsInput | boolean
    encryptedMeta?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    pulses?: TetherPulseUncheckedUpdateManyWithoutTetherNestedInput
  }

  export type VolunteerTrainingCreateWithoutVolunteerInput = {
    id?: string
    moduleId: string
    status?: $Enums.TrainingStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    score?: number | null
    passingScore?: number
    attempts?: number
    moduleTitle: string
    moduleType: $Enums.TrainingType
    duration: number
    content: JsonNullValueInput | InputJsonValue
  }

  export type VolunteerTrainingUncheckedCreateWithoutVolunteerInput = {
    id?: string
    moduleId: string
    status?: $Enums.TrainingStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    score?: number | null
    passingScore?: number
    attempts?: number
    moduleTitle: string
    moduleType: $Enums.TrainingType
    duration: number
    content: JsonNullValueInput | InputJsonValue
  }

  export type VolunteerTrainingCreateOrConnectWithoutVolunteerInput = {
    where: VolunteerTrainingWhereUniqueInput
    create: XOR<VolunteerTrainingCreateWithoutVolunteerInput, VolunteerTrainingUncheckedCreateWithoutVolunteerInput>
  }

  export type VolunteerTrainingCreateManyVolunteerInputEnvelope = {
    data: VolunteerTrainingCreateManyVolunteerInput | VolunteerTrainingCreateManyVolunteerInput[]
  }

  export type VolunteerSessionCreateWithoutVolunteerInput = {
    id?: string
    sessionType: $Enums.VolunteerSessionType
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    crisisSessionId?: string | null
    responseTime?: number | null
    userSatisfaction?: number | null
    outcome?: $Enums.SessionOutcome | null
  }

  export type VolunteerSessionUncheckedCreateWithoutVolunteerInput = {
    id?: string
    sessionType: $Enums.VolunteerSessionType
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    crisisSessionId?: string | null
    responseTime?: number | null
    userSatisfaction?: number | null
    outcome?: $Enums.SessionOutcome | null
  }

  export type VolunteerSessionCreateOrConnectWithoutVolunteerInput = {
    where: VolunteerSessionWhereUniqueInput
    create: XOR<VolunteerSessionCreateWithoutVolunteerInput, VolunteerSessionUncheckedCreateWithoutVolunteerInput>
  }

  export type VolunteerSessionCreateManyVolunteerInputEnvelope = {
    data: VolunteerSessionCreateManyVolunteerInput | VolunteerSessionCreateManyVolunteerInput[]
  }

  export type VolunteerFeedbackCreateWithoutVolunteerInput = {
    id?: string
    sessionId?: string | null
    feedbackType: $Enums.FeedbackType
    rating: number
    comment?: string | null
    submittedBy?: string | null
    sourceType?: $Enums.FeedbackSource
    submittedAt?: Date | string
    isAnonymous?: boolean
    isApproved?: boolean
    moderatedAt?: Date | string | null
    moderatedBy?: string | null
  }

  export type VolunteerFeedbackUncheckedCreateWithoutVolunteerInput = {
    id?: string
    sessionId?: string | null
    feedbackType: $Enums.FeedbackType
    rating: number
    comment?: string | null
    submittedBy?: string | null
    sourceType?: $Enums.FeedbackSource
    submittedAt?: Date | string
    isAnonymous?: boolean
    isApproved?: boolean
    moderatedAt?: Date | string | null
    moderatedBy?: string | null
  }

  export type VolunteerFeedbackCreateOrConnectWithoutVolunteerInput = {
    where: VolunteerFeedbackWhereUniqueInput
    create: XOR<VolunteerFeedbackCreateWithoutVolunteerInput, VolunteerFeedbackUncheckedCreateWithoutVolunteerInput>
  }

  export type VolunteerFeedbackCreateManyVolunteerInputEnvelope = {
    data: VolunteerFeedbackCreateManyVolunteerInput | VolunteerFeedbackCreateManyVolunteerInput[]
  }

  export type VolunteerTrainingUpsertWithWhereUniqueWithoutVolunteerInput = {
    where: VolunteerTrainingWhereUniqueInput
    update: XOR<VolunteerTrainingUpdateWithoutVolunteerInput, VolunteerTrainingUncheckedUpdateWithoutVolunteerInput>
    create: XOR<VolunteerTrainingCreateWithoutVolunteerInput, VolunteerTrainingUncheckedCreateWithoutVolunteerInput>
  }

  export type VolunteerTrainingUpdateWithWhereUniqueWithoutVolunteerInput = {
    where: VolunteerTrainingWhereUniqueInput
    data: XOR<VolunteerTrainingUpdateWithoutVolunteerInput, VolunteerTrainingUncheckedUpdateWithoutVolunteerInput>
  }

  export type VolunteerTrainingUpdateManyWithWhereWithoutVolunteerInput = {
    where: VolunteerTrainingScalarWhereInput
    data: XOR<VolunteerTrainingUpdateManyMutationInput, VolunteerTrainingUncheckedUpdateManyWithoutVolunteerInput>
  }

  export type VolunteerTrainingScalarWhereInput = {
    AND?: VolunteerTrainingScalarWhereInput | VolunteerTrainingScalarWhereInput[]
    OR?: VolunteerTrainingScalarWhereInput[]
    NOT?: VolunteerTrainingScalarWhereInput | VolunteerTrainingScalarWhereInput[]
    id?: StringFilter<"VolunteerTraining"> | string
    volunteerId?: StringFilter<"VolunteerTraining"> | string
    moduleId?: StringFilter<"VolunteerTraining"> | string
    status?: EnumTrainingStatusFilter<"VolunteerTraining"> | $Enums.TrainingStatus
    startedAt?: DateTimeNullableFilter<"VolunteerTraining"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"VolunteerTraining"> | Date | string | null
    score?: FloatNullableFilter<"VolunteerTraining"> | number | null
    passingScore?: FloatFilter<"VolunteerTraining"> | number
    attempts?: IntFilter<"VolunteerTraining"> | number
    moduleTitle?: StringFilter<"VolunteerTraining"> | string
    moduleType?: EnumTrainingTypeFilter<"VolunteerTraining"> | $Enums.TrainingType
    duration?: IntFilter<"VolunteerTraining"> | number
    content?: JsonFilter<"VolunteerTraining">
  }

  export type VolunteerSessionUpsertWithWhereUniqueWithoutVolunteerInput = {
    where: VolunteerSessionWhereUniqueInput
    update: XOR<VolunteerSessionUpdateWithoutVolunteerInput, VolunteerSessionUncheckedUpdateWithoutVolunteerInput>
    create: XOR<VolunteerSessionCreateWithoutVolunteerInput, VolunteerSessionUncheckedCreateWithoutVolunteerInput>
  }

  export type VolunteerSessionUpdateWithWhereUniqueWithoutVolunteerInput = {
    where: VolunteerSessionWhereUniqueInput
    data: XOR<VolunteerSessionUpdateWithoutVolunteerInput, VolunteerSessionUncheckedUpdateWithoutVolunteerInput>
  }

  export type VolunteerSessionUpdateManyWithWhereWithoutVolunteerInput = {
    where: VolunteerSessionScalarWhereInput
    data: XOR<VolunteerSessionUpdateManyMutationInput, VolunteerSessionUncheckedUpdateManyWithoutVolunteerInput>
  }

  export type VolunteerSessionScalarWhereInput = {
    AND?: VolunteerSessionScalarWhereInput | VolunteerSessionScalarWhereInput[]
    OR?: VolunteerSessionScalarWhereInput[]
    NOT?: VolunteerSessionScalarWhereInput | VolunteerSessionScalarWhereInput[]
    id?: StringFilter<"VolunteerSession"> | string
    volunteerId?: StringFilter<"VolunteerSession"> | string
    sessionType?: EnumVolunteerSessionTypeFilter<"VolunteerSession"> | $Enums.VolunteerSessionType
    startedAt?: DateTimeFilter<"VolunteerSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"VolunteerSession"> | Date | string | null
    duration?: IntNullableFilter<"VolunteerSession"> | number | null
    crisisSessionId?: StringNullableFilter<"VolunteerSession"> | string | null
    responseTime?: IntNullableFilter<"VolunteerSession"> | number | null
    userSatisfaction?: FloatNullableFilter<"VolunteerSession"> | number | null
    outcome?: EnumSessionOutcomeNullableFilter<"VolunteerSession"> | $Enums.SessionOutcome | null
  }

  export type VolunteerFeedbackUpsertWithWhereUniqueWithoutVolunteerInput = {
    where: VolunteerFeedbackWhereUniqueInput
    update: XOR<VolunteerFeedbackUpdateWithoutVolunteerInput, VolunteerFeedbackUncheckedUpdateWithoutVolunteerInput>
    create: XOR<VolunteerFeedbackCreateWithoutVolunteerInput, VolunteerFeedbackUncheckedCreateWithoutVolunteerInput>
  }

  export type VolunteerFeedbackUpdateWithWhereUniqueWithoutVolunteerInput = {
    where: VolunteerFeedbackWhereUniqueInput
    data: XOR<VolunteerFeedbackUpdateWithoutVolunteerInput, VolunteerFeedbackUncheckedUpdateWithoutVolunteerInput>
  }

  export type VolunteerFeedbackUpdateManyWithWhereWithoutVolunteerInput = {
    where: VolunteerFeedbackScalarWhereInput
    data: XOR<VolunteerFeedbackUpdateManyMutationInput, VolunteerFeedbackUncheckedUpdateManyWithoutVolunteerInput>
  }

  export type VolunteerFeedbackScalarWhereInput = {
    AND?: VolunteerFeedbackScalarWhereInput | VolunteerFeedbackScalarWhereInput[]
    OR?: VolunteerFeedbackScalarWhereInput[]
    NOT?: VolunteerFeedbackScalarWhereInput | VolunteerFeedbackScalarWhereInput[]
    id?: StringFilter<"VolunteerFeedback"> | string
    volunteerId?: StringFilter<"VolunteerFeedback"> | string
    sessionId?: StringNullableFilter<"VolunteerFeedback"> | string | null
    feedbackType?: EnumFeedbackTypeFilter<"VolunteerFeedback"> | $Enums.FeedbackType
    rating?: IntFilter<"VolunteerFeedback"> | number
    comment?: StringNullableFilter<"VolunteerFeedback"> | string | null
    submittedBy?: StringNullableFilter<"VolunteerFeedback"> | string | null
    sourceType?: EnumFeedbackSourceFilter<"VolunteerFeedback"> | $Enums.FeedbackSource
    submittedAt?: DateTimeFilter<"VolunteerFeedback"> | Date | string
    isAnonymous?: BoolFilter<"VolunteerFeedback"> | boolean
    isApproved?: BoolFilter<"VolunteerFeedback"> | boolean
    moderatedAt?: DateTimeNullableFilter<"VolunteerFeedback"> | Date | string | null
    moderatedBy?: StringNullableFilter<"VolunteerFeedback"> | string | null
  }

  export type VolunteerCreateWithoutTrainingInput = {
    id?: string
    anonymousId: string
    status?: $Enums.VolunteerStatus
    trainingHours?: number
    certifications?: string | null
    specializations?: string | null
    languages?: string | null
    backgroundCheck?: $Enums.VerificationStatus
    sessionsCount?: number
    hoursVolunteered?: number
    averageRating?: number | null
    responseRate?: number
    isActive?: boolean
    currentLoad?: number
    maxConcurrent?: number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    lastActive?: Date | string
    burnoutScore?: number
    needsSupport?: boolean
    emergencyResponder?: boolean
    emergencyAvailable?: boolean
    sessions?: VolunteerSessionCreateNestedManyWithoutVolunteerInput
    feedback?: VolunteerFeedbackCreateNestedManyWithoutVolunteerInput
  }

  export type VolunteerUncheckedCreateWithoutTrainingInput = {
    id?: string
    anonymousId: string
    status?: $Enums.VolunteerStatus
    trainingHours?: number
    certifications?: string | null
    specializations?: string | null
    languages?: string | null
    backgroundCheck?: $Enums.VerificationStatus
    sessionsCount?: number
    hoursVolunteered?: number
    averageRating?: number | null
    responseRate?: number
    isActive?: boolean
    currentLoad?: number
    maxConcurrent?: number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    lastActive?: Date | string
    burnoutScore?: number
    needsSupport?: boolean
    emergencyResponder?: boolean
    emergencyAvailable?: boolean
    sessions?: VolunteerSessionUncheckedCreateNestedManyWithoutVolunteerInput
    feedback?: VolunteerFeedbackUncheckedCreateNestedManyWithoutVolunteerInput
  }

  export type VolunteerCreateOrConnectWithoutTrainingInput = {
    where: VolunteerWhereUniqueInput
    create: XOR<VolunteerCreateWithoutTrainingInput, VolunteerUncheckedCreateWithoutTrainingInput>
  }

  export type VolunteerUpsertWithoutTrainingInput = {
    update: XOR<VolunteerUpdateWithoutTrainingInput, VolunteerUncheckedUpdateWithoutTrainingInput>
    create: XOR<VolunteerCreateWithoutTrainingInput, VolunteerUncheckedCreateWithoutTrainingInput>
    where?: VolunteerWhereInput
  }

  export type VolunteerUpdateToOneWithWhereWithoutTrainingInput = {
    where?: VolunteerWhereInput
    data: XOR<VolunteerUpdateWithoutTrainingInput, VolunteerUncheckedUpdateWithoutTrainingInput>
  }

  export type VolunteerUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    status?: EnumVolunteerStatusFieldUpdateOperationsInput | $Enums.VolunteerStatus
    trainingHours?: FloatFieldUpdateOperationsInput | number
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    sessionsCount?: IntFieldUpdateOperationsInput | number
    hoursVolunteered?: FloatFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentLoad?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    burnoutScore?: FloatFieldUpdateOperationsInput | number
    needsSupport?: BoolFieldUpdateOperationsInput | boolean
    emergencyResponder?: BoolFieldUpdateOperationsInput | boolean
    emergencyAvailable?: BoolFieldUpdateOperationsInput | boolean
    sessions?: VolunteerSessionUpdateManyWithoutVolunteerNestedInput
    feedback?: VolunteerFeedbackUpdateManyWithoutVolunteerNestedInput
  }

  export type VolunteerUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    status?: EnumVolunteerStatusFieldUpdateOperationsInput | $Enums.VolunteerStatus
    trainingHours?: FloatFieldUpdateOperationsInput | number
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    sessionsCount?: IntFieldUpdateOperationsInput | number
    hoursVolunteered?: FloatFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentLoad?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    burnoutScore?: FloatFieldUpdateOperationsInput | number
    needsSupport?: BoolFieldUpdateOperationsInput | boolean
    emergencyResponder?: BoolFieldUpdateOperationsInput | boolean
    emergencyAvailable?: BoolFieldUpdateOperationsInput | boolean
    sessions?: VolunteerSessionUncheckedUpdateManyWithoutVolunteerNestedInput
    feedback?: VolunteerFeedbackUncheckedUpdateManyWithoutVolunteerNestedInput
  }

  export type VolunteerCreateWithoutSessionsInput = {
    id?: string
    anonymousId: string
    status?: $Enums.VolunteerStatus
    trainingHours?: number
    certifications?: string | null
    specializations?: string | null
    languages?: string | null
    backgroundCheck?: $Enums.VerificationStatus
    sessionsCount?: number
    hoursVolunteered?: number
    averageRating?: number | null
    responseRate?: number
    isActive?: boolean
    currentLoad?: number
    maxConcurrent?: number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    lastActive?: Date | string
    burnoutScore?: number
    needsSupport?: boolean
    emergencyResponder?: boolean
    emergencyAvailable?: boolean
    training?: VolunteerTrainingCreateNestedManyWithoutVolunteerInput
    feedback?: VolunteerFeedbackCreateNestedManyWithoutVolunteerInput
  }

  export type VolunteerUncheckedCreateWithoutSessionsInput = {
    id?: string
    anonymousId: string
    status?: $Enums.VolunteerStatus
    trainingHours?: number
    certifications?: string | null
    specializations?: string | null
    languages?: string | null
    backgroundCheck?: $Enums.VerificationStatus
    sessionsCount?: number
    hoursVolunteered?: number
    averageRating?: number | null
    responseRate?: number
    isActive?: boolean
    currentLoad?: number
    maxConcurrent?: number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    lastActive?: Date | string
    burnoutScore?: number
    needsSupport?: boolean
    emergencyResponder?: boolean
    emergencyAvailable?: boolean
    training?: VolunteerTrainingUncheckedCreateNestedManyWithoutVolunteerInput
    feedback?: VolunteerFeedbackUncheckedCreateNestedManyWithoutVolunteerInput
  }

  export type VolunteerCreateOrConnectWithoutSessionsInput = {
    where: VolunteerWhereUniqueInput
    create: XOR<VolunteerCreateWithoutSessionsInput, VolunteerUncheckedCreateWithoutSessionsInput>
  }

  export type VolunteerUpsertWithoutSessionsInput = {
    update: XOR<VolunteerUpdateWithoutSessionsInput, VolunteerUncheckedUpdateWithoutSessionsInput>
    create: XOR<VolunteerCreateWithoutSessionsInput, VolunteerUncheckedCreateWithoutSessionsInput>
    where?: VolunteerWhereInput
  }

  export type VolunteerUpdateToOneWithWhereWithoutSessionsInput = {
    where?: VolunteerWhereInput
    data: XOR<VolunteerUpdateWithoutSessionsInput, VolunteerUncheckedUpdateWithoutSessionsInput>
  }

  export type VolunteerUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    status?: EnumVolunteerStatusFieldUpdateOperationsInput | $Enums.VolunteerStatus
    trainingHours?: FloatFieldUpdateOperationsInput | number
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    sessionsCount?: IntFieldUpdateOperationsInput | number
    hoursVolunteered?: FloatFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentLoad?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    burnoutScore?: FloatFieldUpdateOperationsInput | number
    needsSupport?: BoolFieldUpdateOperationsInput | boolean
    emergencyResponder?: BoolFieldUpdateOperationsInput | boolean
    emergencyAvailable?: BoolFieldUpdateOperationsInput | boolean
    training?: VolunteerTrainingUpdateManyWithoutVolunteerNestedInput
    feedback?: VolunteerFeedbackUpdateManyWithoutVolunteerNestedInput
  }

  export type VolunteerUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    status?: EnumVolunteerStatusFieldUpdateOperationsInput | $Enums.VolunteerStatus
    trainingHours?: FloatFieldUpdateOperationsInput | number
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    sessionsCount?: IntFieldUpdateOperationsInput | number
    hoursVolunteered?: FloatFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentLoad?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    burnoutScore?: FloatFieldUpdateOperationsInput | number
    needsSupport?: BoolFieldUpdateOperationsInput | boolean
    emergencyResponder?: BoolFieldUpdateOperationsInput | boolean
    emergencyAvailable?: BoolFieldUpdateOperationsInput | boolean
    training?: VolunteerTrainingUncheckedUpdateManyWithoutVolunteerNestedInput
    feedback?: VolunteerFeedbackUncheckedUpdateManyWithoutVolunteerNestedInput
  }

  export type VolunteerCreateWithoutFeedbackInput = {
    id?: string
    anonymousId: string
    status?: $Enums.VolunteerStatus
    trainingHours?: number
    certifications?: string | null
    specializations?: string | null
    languages?: string | null
    backgroundCheck?: $Enums.VerificationStatus
    sessionsCount?: number
    hoursVolunteered?: number
    averageRating?: number | null
    responseRate?: number
    isActive?: boolean
    currentLoad?: number
    maxConcurrent?: number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    lastActive?: Date | string
    burnoutScore?: number
    needsSupport?: boolean
    emergencyResponder?: boolean
    emergencyAvailable?: boolean
    training?: VolunteerTrainingCreateNestedManyWithoutVolunteerInput
    sessions?: VolunteerSessionCreateNestedManyWithoutVolunteerInput
  }

  export type VolunteerUncheckedCreateWithoutFeedbackInput = {
    id?: string
    anonymousId: string
    status?: $Enums.VolunteerStatus
    trainingHours?: number
    certifications?: string | null
    specializations?: string | null
    languages?: string | null
    backgroundCheck?: $Enums.VerificationStatus
    sessionsCount?: number
    hoursVolunteered?: number
    averageRating?: number | null
    responseRate?: number
    isActive?: boolean
    currentLoad?: number
    maxConcurrent?: number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    lastActive?: Date | string
    burnoutScore?: number
    needsSupport?: boolean
    emergencyResponder?: boolean
    emergencyAvailable?: boolean
    training?: VolunteerTrainingUncheckedCreateNestedManyWithoutVolunteerInput
    sessions?: VolunteerSessionUncheckedCreateNestedManyWithoutVolunteerInput
  }

  export type VolunteerCreateOrConnectWithoutFeedbackInput = {
    where: VolunteerWhereUniqueInput
    create: XOR<VolunteerCreateWithoutFeedbackInput, VolunteerUncheckedCreateWithoutFeedbackInput>
  }

  export type VolunteerUpsertWithoutFeedbackInput = {
    update: XOR<VolunteerUpdateWithoutFeedbackInput, VolunteerUncheckedUpdateWithoutFeedbackInput>
    create: XOR<VolunteerCreateWithoutFeedbackInput, VolunteerUncheckedCreateWithoutFeedbackInput>
    where?: VolunteerWhereInput
  }

  export type VolunteerUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: VolunteerWhereInput
    data: XOR<VolunteerUpdateWithoutFeedbackInput, VolunteerUncheckedUpdateWithoutFeedbackInput>
  }

  export type VolunteerUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    status?: EnumVolunteerStatusFieldUpdateOperationsInput | $Enums.VolunteerStatus
    trainingHours?: FloatFieldUpdateOperationsInput | number
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    sessionsCount?: IntFieldUpdateOperationsInput | number
    hoursVolunteered?: FloatFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentLoad?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    burnoutScore?: FloatFieldUpdateOperationsInput | number
    needsSupport?: BoolFieldUpdateOperationsInput | boolean
    emergencyResponder?: BoolFieldUpdateOperationsInput | boolean
    emergencyAvailable?: BoolFieldUpdateOperationsInput | boolean
    training?: VolunteerTrainingUpdateManyWithoutVolunteerNestedInput
    sessions?: VolunteerSessionUpdateManyWithoutVolunteerNestedInput
  }

  export type VolunteerUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    status?: EnumVolunteerStatusFieldUpdateOperationsInput | $Enums.VolunteerStatus
    trainingHours?: FloatFieldUpdateOperationsInput | number
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    sessionsCount?: IntFieldUpdateOperationsInput | number
    hoursVolunteered?: FloatFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentLoad?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    schedule?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    burnoutScore?: FloatFieldUpdateOperationsInput | number
    needsSupport?: BoolFieldUpdateOperationsInput | boolean
    emergencyResponder?: BoolFieldUpdateOperationsInput | boolean
    emergencyAvailable?: BoolFieldUpdateOperationsInput | boolean
    training?: VolunteerTrainingUncheckedUpdateManyWithoutVolunteerNestedInput
    sessions?: VolunteerSessionUncheckedUpdateManyWithoutVolunteerNestedInput
  }

  export type CrisisSessionCreateWithoutResourcesInput = {
    id?: string
    sessionToken: string
    anonymousId: string
    severity: number
    status?: $Enums.CrisisStatus
    responderId?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    responseTimeMs?: number | null
    outcome?: string | null
    encryptedData?: Uint8Array | null
    keyDerivationSalt?: Uint8Array | null
    handoffTime?: number | null
    resolutionTime?: number | null
    emergencyTriggered?: boolean
    escalatedAt?: Date | string | null
    escalationType?: $Enums.EscalationType | null
    messages?: CrisisMessageCreateNestedManyWithoutSessionInput
    escalations?: CrisisEscalationCreateNestedManyWithoutSessionInput
  }

  export type CrisisSessionUncheckedCreateWithoutResourcesInput = {
    id?: string
    sessionToken: string
    anonymousId: string
    severity: number
    status?: $Enums.CrisisStatus
    responderId?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    responseTimeMs?: number | null
    outcome?: string | null
    encryptedData?: Uint8Array | null
    keyDerivationSalt?: Uint8Array | null
    handoffTime?: number | null
    resolutionTime?: number | null
    emergencyTriggered?: boolean
    escalatedAt?: Date | string | null
    escalationType?: $Enums.EscalationType | null
    messages?: CrisisMessageUncheckedCreateNestedManyWithoutSessionInput
    escalations?: CrisisEscalationUncheckedCreateNestedManyWithoutSessionInput
  }

  export type CrisisSessionCreateOrConnectWithoutResourcesInput = {
    where: CrisisSessionWhereUniqueInput
    create: XOR<CrisisSessionCreateWithoutResourcesInput, CrisisSessionUncheckedCreateWithoutResourcesInput>
  }

  export type CrisisSessionUpsertWithoutResourcesInput = {
    update: XOR<CrisisSessionUpdateWithoutResourcesInput, CrisisSessionUncheckedUpdateWithoutResourcesInput>
    create: XOR<CrisisSessionCreateWithoutResourcesInput, CrisisSessionUncheckedCreateWithoutResourcesInput>
    where?: CrisisSessionWhereInput
  }

  export type CrisisSessionUpdateToOneWithWhereWithoutResourcesInput = {
    where?: CrisisSessionWhereInput
    data: XOR<CrisisSessionUpdateWithoutResourcesInput, CrisisSessionUncheckedUpdateWithoutResourcesInput>
  }

  export type CrisisSessionUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    status?: EnumCrisisStatusFieldUpdateOperationsInput | $Enums.CrisisStatus
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedData?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    keyDerivationSalt?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    handoffTime?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionTime?: NullableIntFieldUpdateOperationsInput | number | null
    emergencyTriggered?: BoolFieldUpdateOperationsInput | boolean
    escalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationType?: NullableEnumEscalationTypeFieldUpdateOperationsInput | $Enums.EscalationType | null
    messages?: CrisisMessageUpdateManyWithoutSessionNestedInput
    escalations?: CrisisEscalationUpdateManyWithoutSessionNestedInput
  }

  export type CrisisSessionUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    status?: EnumCrisisStatusFieldUpdateOperationsInput | $Enums.CrisisStatus
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedData?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    keyDerivationSalt?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    handoffTime?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionTime?: NullableIntFieldUpdateOperationsInput | number | null
    emergencyTriggered?: BoolFieldUpdateOperationsInput | boolean
    escalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationType?: NullableEnumEscalationTypeFieldUpdateOperationsInput | $Enums.EscalationType | null
    messages?: CrisisMessageUncheckedUpdateManyWithoutSessionNestedInput
    escalations?: CrisisEscalationUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserCreateWithoutEmergencyContactsInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    challenges?: UserChallengeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmergencyContactsInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    challenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionUncheckedCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionUncheckedCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmergencyContactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmergencyContactsInput, UserUncheckedCreateWithoutEmergencyContactsInput>
  }

  export type EmergencyNotificationCreateWithoutEmergencyContactInput = {
    id?: string
    sessionId?: string | null
    tetherEmergencyId?: string | null
    notificationType: $Enums.EmergencyNotificationType
    severity: $Enums.EmergencySeverity
    message: string
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    acknowledgedAt?: Date | string | null
    responseReceived?: boolean
    responseTime?: number | null
    method: string
    status?: $Enums.NotificationStatus
    attempts?: number
    maxAttempts?: number
    errorMessage?: string | null
    nextRetryAt?: Date | string | null
  }

  export type EmergencyNotificationUncheckedCreateWithoutEmergencyContactInput = {
    id?: string
    sessionId?: string | null
    tetherEmergencyId?: string | null
    notificationType: $Enums.EmergencyNotificationType
    severity: $Enums.EmergencySeverity
    message: string
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    acknowledgedAt?: Date | string | null
    responseReceived?: boolean
    responseTime?: number | null
    method: string
    status?: $Enums.NotificationStatus
    attempts?: number
    maxAttempts?: number
    errorMessage?: string | null
    nextRetryAt?: Date | string | null
  }

  export type EmergencyNotificationCreateOrConnectWithoutEmergencyContactInput = {
    where: EmergencyNotificationWhereUniqueInput
    create: XOR<EmergencyNotificationCreateWithoutEmergencyContactInput, EmergencyNotificationUncheckedCreateWithoutEmergencyContactInput>
  }

  export type EmergencyNotificationCreateManyEmergencyContactInputEnvelope = {
    data: EmergencyNotificationCreateManyEmergencyContactInput | EmergencyNotificationCreateManyEmergencyContactInput[]
  }

  export type UserUpsertWithoutEmergencyContactsInput = {
    update: XOR<UserUpdateWithoutEmergencyContactsInput, UserUncheckedUpdateWithoutEmergencyContactsInput>
    create: XOR<UserCreateWithoutEmergencyContactsInput, UserUncheckedCreateWithoutEmergencyContactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmergencyContactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmergencyContactsInput, UserUncheckedUpdateWithoutEmergencyContactsInput>
  }

  export type UserUpdateWithoutEmergencyContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmergencyContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUncheckedUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUncheckedUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmergencyNotificationUpsertWithWhereUniqueWithoutEmergencyContactInput = {
    where: EmergencyNotificationWhereUniqueInput
    update: XOR<EmergencyNotificationUpdateWithoutEmergencyContactInput, EmergencyNotificationUncheckedUpdateWithoutEmergencyContactInput>
    create: XOR<EmergencyNotificationCreateWithoutEmergencyContactInput, EmergencyNotificationUncheckedCreateWithoutEmergencyContactInput>
  }

  export type EmergencyNotificationUpdateWithWhereUniqueWithoutEmergencyContactInput = {
    where: EmergencyNotificationWhereUniqueInput
    data: XOR<EmergencyNotificationUpdateWithoutEmergencyContactInput, EmergencyNotificationUncheckedUpdateWithoutEmergencyContactInput>
  }

  export type EmergencyNotificationUpdateManyWithWhereWithoutEmergencyContactInput = {
    where: EmergencyNotificationScalarWhereInput
    data: XOR<EmergencyNotificationUpdateManyMutationInput, EmergencyNotificationUncheckedUpdateManyWithoutEmergencyContactInput>
  }

  export type EmergencyNotificationScalarWhereInput = {
    AND?: EmergencyNotificationScalarWhereInput | EmergencyNotificationScalarWhereInput[]
    OR?: EmergencyNotificationScalarWhereInput[]
    NOT?: EmergencyNotificationScalarWhereInput | EmergencyNotificationScalarWhereInput[]
    id?: StringFilter<"EmergencyNotification"> | string
    emergencyContactId?: StringFilter<"EmergencyNotification"> | string
    sessionId?: StringNullableFilter<"EmergencyNotification"> | string | null
    tetherEmergencyId?: StringNullableFilter<"EmergencyNotification"> | string | null
    notificationType?: EnumEmergencyNotificationTypeFilter<"EmergencyNotification"> | $Enums.EmergencyNotificationType
    severity?: EnumEmergencySeverityFilter<"EmergencyNotification"> | $Enums.EmergencySeverity
    message?: StringFilter<"EmergencyNotification"> | string
    sentAt?: DateTimeFilter<"EmergencyNotification"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"EmergencyNotification"> | Date | string | null
    acknowledgedAt?: DateTimeNullableFilter<"EmergencyNotification"> | Date | string | null
    responseReceived?: BoolFilter<"EmergencyNotification"> | boolean
    responseTime?: IntNullableFilter<"EmergencyNotification"> | number | null
    method?: StringFilter<"EmergencyNotification"> | string
    status?: EnumNotificationStatusFilter<"EmergencyNotification"> | $Enums.NotificationStatus
    attempts?: IntFilter<"EmergencyNotification"> | number
    maxAttempts?: IntFilter<"EmergencyNotification"> | number
    errorMessage?: StringNullableFilter<"EmergencyNotification"> | string | null
    nextRetryAt?: DateTimeNullableFilter<"EmergencyNotification"> | Date | string | null
  }

  export type EmergencyContactCreateWithoutNotificationsInput = {
    id?: string
    encryptedName: Uint8Array
    encryptedPhone: Uint8Array
    encryptedEmail?: Uint8Array | null
    relationship: string
    priority?: number
    contactMethod?: string
    timezone?: string | null
    availableHours?: NullableJsonNullValueInput | InputJsonValue
    preferredMethod?: string | null
    autoNotify?: boolean
    crisisOnly?: boolean
    hasConsent?: boolean
    consentDate?: Date | string | null
    keyDerivationSalt: Uint8Array
    isVerified?: boolean
    verifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContacted?: Date | string | null
    user: UserCreateNestedOneWithoutEmergencyContactsInput
  }

  export type EmergencyContactUncheckedCreateWithoutNotificationsInput = {
    id?: string
    userId: string
    encryptedName: Uint8Array
    encryptedPhone: Uint8Array
    encryptedEmail?: Uint8Array | null
    relationship: string
    priority?: number
    contactMethod?: string
    timezone?: string | null
    availableHours?: NullableJsonNullValueInput | InputJsonValue
    preferredMethod?: string | null
    autoNotify?: boolean
    crisisOnly?: boolean
    hasConsent?: boolean
    consentDate?: Date | string | null
    keyDerivationSalt: Uint8Array
    isVerified?: boolean
    verifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContacted?: Date | string | null
  }

  export type EmergencyContactCreateOrConnectWithoutNotificationsInput = {
    where: EmergencyContactWhereUniqueInput
    create: XOR<EmergencyContactCreateWithoutNotificationsInput, EmergencyContactUncheckedCreateWithoutNotificationsInput>
  }

  export type EmergencyContactUpsertWithoutNotificationsInput = {
    update: XOR<EmergencyContactUpdateWithoutNotificationsInput, EmergencyContactUncheckedUpdateWithoutNotificationsInput>
    create: XOR<EmergencyContactCreateWithoutNotificationsInput, EmergencyContactUncheckedCreateWithoutNotificationsInput>
    where?: EmergencyContactWhereInput
  }

  export type EmergencyContactUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: EmergencyContactWhereInput
    data: XOR<EmergencyContactUpdateWithoutNotificationsInput, EmergencyContactUncheckedUpdateWithoutNotificationsInput>
  }

  export type EmergencyContactUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedName?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedPhone?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    relationship?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    contactMethod?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    availableHours?: NullableJsonNullValueInput | InputJsonValue
    preferredMethod?: NullableStringFieldUpdateOperationsInput | string | null
    autoNotify?: BoolFieldUpdateOperationsInput | boolean
    crisisOnly?: BoolFieldUpdateOperationsInput | boolean
    hasConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keyDerivationSalt?: BytesFieldUpdateOperationsInput | Uint8Array
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContacted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutEmergencyContactsNestedInput
  }

  export type EmergencyContactUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    encryptedName?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedPhone?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    relationship?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    contactMethod?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    availableHours?: NullableJsonNullValueInput | InputJsonValue
    preferredMethod?: NullableStringFieldUpdateOperationsInput | string | null
    autoNotify?: BoolFieldUpdateOperationsInput | boolean
    crisisOnly?: BoolFieldUpdateOperationsInput | boolean
    hasConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keyDerivationSalt?: BytesFieldUpdateOperationsInput | Uint8Array
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContacted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MoodEntryCreateWithoutUserInput = {
    id?: string
    mood: number
    emotions: JsonNullValueInput | InputJsonValue
    triggers: JsonNullValueInput | InputJsonValue
    activities: JsonNullValueInput | InputJsonValue
    sleepHours?: number | null
    notes?: string | null
    weather?: string | null
    medication?: boolean | null
    socialInteraction?: number | null
    timestamp?: Date | string
  }

  export type MoodEntryUncheckedCreateWithoutUserInput = {
    id?: string
    mood: number
    emotions: JsonNullValueInput | InputJsonValue
    triggers: JsonNullValueInput | InputJsonValue
    activities: JsonNullValueInput | InputJsonValue
    sleepHours?: number | null
    notes?: string | null
    weather?: string | null
    medication?: boolean | null
    socialInteraction?: number | null
    timestamp?: Date | string
  }

  export type MoodEntryCreateOrConnectWithoutUserInput = {
    where: MoodEntryWhereUniqueInput
    create: XOR<MoodEntryCreateWithoutUserInput, MoodEntryUncheckedCreateWithoutUserInput>
  }

  export type MoodEntryCreateManyUserInputEnvelope = {
    data: MoodEntryCreateManyUserInput | MoodEntryCreateManyUserInput[]
  }

  export type SafetyPlanCreateWithoutUserInput = {
    id?: string
    title: string
    version?: number
    isActive?: boolean
    encryptedContent: Uint8Array
    contentHash: string
    sharedWith?: NullableJsonNullValueInput | InputJsonValue
    emergencyShare?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: SafetyPlanVersionCreateNestedManyWithoutSafetyPlanInput
  }

  export type SafetyPlanUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    version?: number
    isActive?: boolean
    encryptedContent: Uint8Array
    contentHash: string
    sharedWith?: NullableJsonNullValueInput | InputJsonValue
    emergencyShare?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: SafetyPlanVersionUncheckedCreateNestedManyWithoutSafetyPlanInput
  }

  export type SafetyPlanCreateOrConnectWithoutUserInput = {
    where: SafetyPlanWhereUniqueInput
    create: XOR<SafetyPlanCreateWithoutUserInput, SafetyPlanUncheckedCreateWithoutUserInput>
  }

  export type SafetyPlanCreateManyUserInputEnvelope = {
    data: SafetyPlanCreateManyUserInput | SafetyPlanCreateManyUserInput[]
  }

  export type UserProfileCreateWithoutUserInput = {
    id?: string
    displayName: string
    level?: number
    totalXP?: number
    preferences: JsonNullValueInput | InputJsonValue
    stats: JsonNullValueInput | InputJsonValue
    joinDate?: Date | string
    lastActiveDate?: Date | string
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    id?: string
    displayName: string
    level?: number
    totalXP?: number
    preferences: JsonNullValueInput | InputJsonValue
    stats: JsonNullValueInput | InputJsonValue
    joinDate?: Date | string
    lastActiveDate?: Date | string
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementCreateWithoutUserInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    achievement: AchievementCreateNestedOneWithoutUserAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutUserInput = {
    id?: string
    achievementId: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserAchievementCreateOrConnectWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementCreateManyUserInputEnvelope = {
    data: UserAchievementCreateManyUserInput | UserAchievementCreateManyUserInput[]
  }

  export type UserChallengeCreateWithoutUserInput = {
    id?: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    startedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    challenge: ChallengeCreateNestedOneWithoutUserChallengesInput
  }

  export type UserChallengeUncheckedCreateWithoutUserInput = {
    id?: string
    challengeId: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    startedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserChallengeCreateOrConnectWithoutUserInput = {
    where: UserChallengeWhereUniqueInput
    create: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput>
  }

  export type UserChallengeCreateManyUserInputEnvelope = {
    data: UserChallengeCreateManyUserInput | UserChallengeCreateManyUserInput[]
  }

  export type UserActivityCreateWithoutUserInput = {
    id?: string
    type: $Enums.ActivityType
    description: string
    xpEarned?: number
    pointsEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type UserActivityUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.ActivityType
    description: string
    xpEarned?: number
    pointsEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type UserActivityCreateOrConnectWithoutUserInput = {
    where: UserActivityWhereUniqueInput
    create: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput>
  }

  export type UserActivityCreateManyUserInputEnvelope = {
    data: UserActivityCreateManyUserInput | UserActivityCreateManyUserInput[]
  }

  export type EmergencyContactCreateWithoutUserInput = {
    id?: string
    encryptedName: Uint8Array
    encryptedPhone: Uint8Array
    encryptedEmail?: Uint8Array | null
    relationship: string
    priority?: number
    contactMethod?: string
    timezone?: string | null
    availableHours?: NullableJsonNullValueInput | InputJsonValue
    preferredMethod?: string | null
    autoNotify?: boolean
    crisisOnly?: boolean
    hasConsent?: boolean
    consentDate?: Date | string | null
    keyDerivationSalt: Uint8Array
    isVerified?: boolean
    verifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContacted?: Date | string | null
    notifications?: EmergencyNotificationCreateNestedManyWithoutEmergencyContactInput
  }

  export type EmergencyContactUncheckedCreateWithoutUserInput = {
    id?: string
    encryptedName: Uint8Array
    encryptedPhone: Uint8Array
    encryptedEmail?: Uint8Array | null
    relationship: string
    priority?: number
    contactMethod?: string
    timezone?: string | null
    availableHours?: NullableJsonNullValueInput | InputJsonValue
    preferredMethod?: string | null
    autoNotify?: boolean
    crisisOnly?: boolean
    hasConsent?: boolean
    consentDate?: Date | string | null
    keyDerivationSalt: Uint8Array
    isVerified?: boolean
    verifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContacted?: Date | string | null
    notifications?: EmergencyNotificationUncheckedCreateNestedManyWithoutEmergencyContactInput
  }

  export type EmergencyContactCreateOrConnectWithoutUserInput = {
    where: EmergencyContactWhereUniqueInput
    create: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput>
  }

  export type EmergencyContactCreateManyUserInputEnvelope = {
    data: EmergencyContactCreateManyUserInput | EmergencyContactCreateManyUserInput[]
  }

  export type JournalEntryCreateWithoutUserInput = {
    id?: string
    title?: string | null
    promptId?: string | null
    promptText?: string | null
    entryType?: $Enums.JournalType
    encryptedContent: Uint8Array
    contentHash: string
    keyDerivationSalt: Uint8Array
    mood?: number | null
    sentimentScore?: number | null
    emotions?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    isPrivate?: boolean
    shareWithTherapist?: boolean
    wordCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryUncheckedCreateWithoutUserInput = {
    id?: string
    title?: string | null
    promptId?: string | null
    promptText?: string | null
    entryType?: $Enums.JournalType
    encryptedContent: Uint8Array
    contentHash: string
    keyDerivationSalt: Uint8Array
    mood?: number | null
    sentimentScore?: number | null
    emotions?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    isPrivate?: boolean
    shareWithTherapist?: boolean
    wordCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryCreateOrConnectWithoutUserInput = {
    where: JournalEntryWhereUniqueInput
    create: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput>
  }

  export type JournalEntryCreateManyUserInputEnvelope = {
    data: JournalEntryCreateManyUserInput | JournalEntryCreateManyUserInput[]
  }

  export type BreathingSessionCreateWithoutUserInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    cyclesCompleted?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    averageBreathRate?: number | null
    heartRateBefore?: number | null
    heartRateAfter?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    exercise: BreathingExerciseCreateNestedOneWithoutSessionsInput
  }

  export type BreathingSessionUncheckedCreateWithoutUserInput = {
    id?: string
    exerciseId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    cyclesCompleted?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    averageBreathRate?: number | null
    heartRateBefore?: number | null
    heartRateAfter?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
  }

  export type BreathingSessionCreateOrConnectWithoutUserInput = {
    where: BreathingSessionWhereUniqueInput
    create: XOR<BreathingSessionCreateWithoutUserInput, BreathingSessionUncheckedCreateWithoutUserInput>
  }

  export type BreathingSessionCreateManyUserInputEnvelope = {
    data: BreathingSessionCreateManyUserInput | BreathingSessionCreateManyUserInput[]
  }

  export type GroundingSessionCreateWithoutUserInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    triggerType?: string | null
    severityBefore?: number | null
    severityAfter?: number | null
    panicBefore?: number | null
    panicAfter?: number | null
    dissociationBefore?: number | null
    dissociationAfter?: number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    wouldUseAgain?: boolean | null
    technique: GroundingTechniqueCreateNestedOneWithoutSessionsInput
  }

  export type GroundingSessionUncheckedCreateWithoutUserInput = {
    id?: string
    techniqueId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    triggerType?: string | null
    severityBefore?: number | null
    severityAfter?: number | null
    panicBefore?: number | null
    panicAfter?: number | null
    dissociationBefore?: number | null
    dissociationAfter?: number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    wouldUseAgain?: boolean | null
  }

  export type GroundingSessionCreateOrConnectWithoutUserInput = {
    where: GroundingSessionWhereUniqueInput
    create: XOR<GroundingSessionCreateWithoutUserInput, GroundingSessionUncheckedCreateWithoutUserInput>
  }

  export type GroundingSessionCreateManyUserInputEnvelope = {
    data: GroundingSessionCreateManyUserInput | GroundingSessionCreateManyUserInput[]
  }

  export type SelfHelpInteractionCreateWithoutUserInput = {
    id?: string
    interactionType: $Enums.InteractionType
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    moodBefore?: number | null
    moodAfter?: number | null
    resource: SelfHelpResourceCreateNestedOneWithoutInteractionsInput
  }

  export type SelfHelpInteractionUncheckedCreateWithoutUserInput = {
    id?: string
    resourceId: string
    interactionType: $Enums.InteractionType
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    moodBefore?: number | null
    moodAfter?: number | null
  }

  export type SelfHelpInteractionCreateOrConnectWithoutUserInput = {
    where: SelfHelpInteractionWhereUniqueInput
    create: XOR<SelfHelpInteractionCreateWithoutUserInput, SelfHelpInteractionUncheckedCreateWithoutUserInput>
  }

  export type SelfHelpInteractionCreateManyUserInputEnvelope = {
    data: SelfHelpInteractionCreateManyUserInput | SelfHelpInteractionCreateManyUserInput[]
  }

  export type MoodEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: MoodEntryWhereUniqueInput
    update: XOR<MoodEntryUpdateWithoutUserInput, MoodEntryUncheckedUpdateWithoutUserInput>
    create: XOR<MoodEntryCreateWithoutUserInput, MoodEntryUncheckedCreateWithoutUserInput>
  }

  export type MoodEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: MoodEntryWhereUniqueInput
    data: XOR<MoodEntryUpdateWithoutUserInput, MoodEntryUncheckedUpdateWithoutUserInput>
  }

  export type MoodEntryUpdateManyWithWhereWithoutUserInput = {
    where: MoodEntryScalarWhereInput
    data: XOR<MoodEntryUpdateManyMutationInput, MoodEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type MoodEntryScalarWhereInput = {
    AND?: MoodEntryScalarWhereInput | MoodEntryScalarWhereInput[]
    OR?: MoodEntryScalarWhereInput[]
    NOT?: MoodEntryScalarWhereInput | MoodEntryScalarWhereInput[]
    id?: StringFilter<"MoodEntry"> | string
    userId?: StringFilter<"MoodEntry"> | string
    mood?: IntFilter<"MoodEntry"> | number
    emotions?: JsonFilter<"MoodEntry">
    triggers?: JsonFilter<"MoodEntry">
    activities?: JsonFilter<"MoodEntry">
    sleepHours?: FloatNullableFilter<"MoodEntry"> | number | null
    notes?: StringNullableFilter<"MoodEntry"> | string | null
    weather?: StringNullableFilter<"MoodEntry"> | string | null
    medication?: BoolNullableFilter<"MoodEntry"> | boolean | null
    socialInteraction?: IntNullableFilter<"MoodEntry"> | number | null
    timestamp?: DateTimeFilter<"MoodEntry"> | Date | string
  }

  export type SafetyPlanUpsertWithWhereUniqueWithoutUserInput = {
    where: SafetyPlanWhereUniqueInput
    update: XOR<SafetyPlanUpdateWithoutUserInput, SafetyPlanUncheckedUpdateWithoutUserInput>
    create: XOR<SafetyPlanCreateWithoutUserInput, SafetyPlanUncheckedCreateWithoutUserInput>
  }

  export type SafetyPlanUpdateWithWhereUniqueWithoutUserInput = {
    where: SafetyPlanWhereUniqueInput
    data: XOR<SafetyPlanUpdateWithoutUserInput, SafetyPlanUncheckedUpdateWithoutUserInput>
  }

  export type SafetyPlanUpdateManyWithWhereWithoutUserInput = {
    where: SafetyPlanScalarWhereInput
    data: XOR<SafetyPlanUpdateManyMutationInput, SafetyPlanUncheckedUpdateManyWithoutUserInput>
  }

  export type SafetyPlanScalarWhereInput = {
    AND?: SafetyPlanScalarWhereInput | SafetyPlanScalarWhereInput[]
    OR?: SafetyPlanScalarWhereInput[]
    NOT?: SafetyPlanScalarWhereInput | SafetyPlanScalarWhereInput[]
    id?: StringFilter<"SafetyPlan"> | string
    userId?: StringFilter<"SafetyPlan"> | string
    title?: StringFilter<"SafetyPlan"> | string
    version?: IntFilter<"SafetyPlan"> | number
    isActive?: BoolFilter<"SafetyPlan"> | boolean
    encryptedContent?: BytesFilter<"SafetyPlan"> | Uint8Array
    contentHash?: StringFilter<"SafetyPlan"> | string
    sharedWith?: JsonNullableFilter<"SafetyPlan">
    emergencyShare?: BoolFilter<"SafetyPlan"> | boolean
    createdAt?: DateTimeFilter<"SafetyPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SafetyPlan"> | Date | string
  }

  export type UserProfileUpsertWithoutUserInput = {
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    preferences?: JsonNullValueInput | InputJsonValue
    stats?: JsonNullValueInput | InputJsonValue
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    preferences?: JsonNullValueInput | InputJsonValue
    stats?: JsonNullValueInput | InputJsonValue
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutUserInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAchievementScalarWhereInput = {
    AND?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    OR?: UserAchievementScalarWhereInput[]
    NOT?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    progress?: FloatFilter<"UserAchievement"> | number
    isUnlocked?: BoolFilter<"UserAchievement"> | boolean
    unlockedAt?: DateTimeNullableFilter<"UserAchievement"> | Date | string | null
    createdAt?: DateTimeFilter<"UserAchievement"> | Date | string
  }

  export type UserChallengeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserChallengeWhereUniqueInput
    update: XOR<UserChallengeUpdateWithoutUserInput, UserChallengeUncheckedUpdateWithoutUserInput>
    create: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput>
  }

  export type UserChallengeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserChallengeWhereUniqueInput
    data: XOR<UserChallengeUpdateWithoutUserInput, UserChallengeUncheckedUpdateWithoutUserInput>
  }

  export type UserChallengeUpdateManyWithWhereWithoutUserInput = {
    where: UserChallengeScalarWhereInput
    data: XOR<UserChallengeUpdateManyMutationInput, UserChallengeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserChallengeScalarWhereInput = {
    AND?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
    OR?: UserChallengeScalarWhereInput[]
    NOT?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
    id?: StringFilter<"UserChallenge"> | string
    userId?: StringFilter<"UserChallenge"> | string
    challengeId?: StringFilter<"UserChallenge"> | string
    progress?: FloatFilter<"UserChallenge"> | number
    isCompleted?: BoolFilter<"UserChallenge"> | boolean
    completedAt?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
    startedAt?: DateTimeFilter<"UserChallenge"> | Date | string
    data?: JsonNullableFilter<"UserChallenge">
  }

  export type UserActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: UserActivityWhereUniqueInput
    update: XOR<UserActivityUpdateWithoutUserInput, UserActivityUncheckedUpdateWithoutUserInput>
    create: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput>
  }

  export type UserActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: UserActivityWhereUniqueInput
    data: XOR<UserActivityUpdateWithoutUserInput, UserActivityUncheckedUpdateWithoutUserInput>
  }

  export type UserActivityUpdateManyWithWhereWithoutUserInput = {
    where: UserActivityScalarWhereInput
    data: XOR<UserActivityUpdateManyMutationInput, UserActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type UserActivityScalarWhereInput = {
    AND?: UserActivityScalarWhereInput | UserActivityScalarWhereInput[]
    OR?: UserActivityScalarWhereInput[]
    NOT?: UserActivityScalarWhereInput | UserActivityScalarWhereInput[]
    id?: StringFilter<"UserActivity"> | string
    userId?: StringFilter<"UserActivity"> | string
    type?: EnumActivityTypeFilter<"UserActivity"> | $Enums.ActivityType
    description?: StringFilter<"UserActivity"> | string
    xpEarned?: IntFilter<"UserActivity"> | number
    pointsEarned?: IntFilter<"UserActivity"> | number
    metadata?: JsonNullableFilter<"UserActivity">
    timestamp?: DateTimeFilter<"UserActivity"> | Date | string
  }

  export type EmergencyContactUpsertWithWhereUniqueWithoutUserInput = {
    where: EmergencyContactWhereUniqueInput
    update: XOR<EmergencyContactUpdateWithoutUserInput, EmergencyContactUncheckedUpdateWithoutUserInput>
    create: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput>
  }

  export type EmergencyContactUpdateWithWhereUniqueWithoutUserInput = {
    where: EmergencyContactWhereUniqueInput
    data: XOR<EmergencyContactUpdateWithoutUserInput, EmergencyContactUncheckedUpdateWithoutUserInput>
  }

  export type EmergencyContactUpdateManyWithWhereWithoutUserInput = {
    where: EmergencyContactScalarWhereInput
    data: XOR<EmergencyContactUpdateManyMutationInput, EmergencyContactUncheckedUpdateManyWithoutUserInput>
  }

  export type EmergencyContactScalarWhereInput = {
    AND?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
    OR?: EmergencyContactScalarWhereInput[]
    NOT?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
    id?: StringFilter<"EmergencyContact"> | string
    userId?: StringFilter<"EmergencyContact"> | string
    encryptedName?: BytesFilter<"EmergencyContact"> | Uint8Array
    encryptedPhone?: BytesFilter<"EmergencyContact"> | Uint8Array
    encryptedEmail?: BytesNullableFilter<"EmergencyContact"> | Uint8Array | null
    relationship?: StringFilter<"EmergencyContact"> | string
    priority?: IntFilter<"EmergencyContact"> | number
    contactMethod?: StringFilter<"EmergencyContact"> | string
    timezone?: StringNullableFilter<"EmergencyContact"> | string | null
    availableHours?: JsonNullableFilter<"EmergencyContact">
    preferredMethod?: StringNullableFilter<"EmergencyContact"> | string | null
    autoNotify?: BoolFilter<"EmergencyContact"> | boolean
    crisisOnly?: BoolFilter<"EmergencyContact"> | boolean
    hasConsent?: BoolFilter<"EmergencyContact"> | boolean
    consentDate?: DateTimeNullableFilter<"EmergencyContact"> | Date | string | null
    keyDerivationSalt?: BytesFilter<"EmergencyContact"> | Uint8Array
    isVerified?: BoolFilter<"EmergencyContact"> | boolean
    verifiedAt?: DateTimeNullableFilter<"EmergencyContact"> | Date | string | null
    isActive?: BoolFilter<"EmergencyContact"> | boolean
    createdAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    lastContacted?: DateTimeNullableFilter<"EmergencyContact"> | Date | string | null
  }

  export type JournalEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: JournalEntryWhereUniqueInput
    update: XOR<JournalEntryUpdateWithoutUserInput, JournalEntryUncheckedUpdateWithoutUserInput>
    create: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput>
  }

  export type JournalEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: JournalEntryWhereUniqueInput
    data: XOR<JournalEntryUpdateWithoutUserInput, JournalEntryUncheckedUpdateWithoutUserInput>
  }

  export type JournalEntryUpdateManyWithWhereWithoutUserInput = {
    where: JournalEntryScalarWhereInput
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type JournalEntryScalarWhereInput = {
    AND?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
    OR?: JournalEntryScalarWhereInput[]
    NOT?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
    id?: StringFilter<"JournalEntry"> | string
    userId?: StringFilter<"JournalEntry"> | string
    title?: StringNullableFilter<"JournalEntry"> | string | null
    promptId?: StringNullableFilter<"JournalEntry"> | string | null
    promptText?: StringNullableFilter<"JournalEntry"> | string | null
    entryType?: EnumJournalTypeFilter<"JournalEntry"> | $Enums.JournalType
    encryptedContent?: BytesFilter<"JournalEntry"> | Uint8Array
    contentHash?: StringFilter<"JournalEntry"> | string
    keyDerivationSalt?: BytesFilter<"JournalEntry"> | Uint8Array
    mood?: IntNullableFilter<"JournalEntry"> | number | null
    sentimentScore?: FloatNullableFilter<"JournalEntry"> | number | null
    emotions?: JsonNullableFilter<"JournalEntry">
    tags?: JsonNullableFilter<"JournalEntry">
    isPrivate?: BoolFilter<"JournalEntry"> | boolean
    shareWithTherapist?: BoolFilter<"JournalEntry"> | boolean
    wordCount?: IntNullableFilter<"JournalEntry"> | number | null
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"JournalEntry"> | Date | string
  }

  export type BreathingSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: BreathingSessionWhereUniqueInput
    update: XOR<BreathingSessionUpdateWithoutUserInput, BreathingSessionUncheckedUpdateWithoutUserInput>
    create: XOR<BreathingSessionCreateWithoutUserInput, BreathingSessionUncheckedCreateWithoutUserInput>
  }

  export type BreathingSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: BreathingSessionWhereUniqueInput
    data: XOR<BreathingSessionUpdateWithoutUserInput, BreathingSessionUncheckedUpdateWithoutUserInput>
  }

  export type BreathingSessionUpdateManyWithWhereWithoutUserInput = {
    where: BreathingSessionScalarWhereInput
    data: XOR<BreathingSessionUpdateManyMutationInput, BreathingSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type BreathingSessionScalarWhereInput = {
    AND?: BreathingSessionScalarWhereInput | BreathingSessionScalarWhereInput[]
    OR?: BreathingSessionScalarWhereInput[]
    NOT?: BreathingSessionScalarWhereInput | BreathingSessionScalarWhereInput[]
    id?: StringFilter<"BreathingSession"> | string
    userId?: StringFilter<"BreathingSession"> | string
    exerciseId?: StringFilter<"BreathingSession"> | string
    startedAt?: DateTimeFilter<"BreathingSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"BreathingSession"> | Date | string | null
    duration?: IntNullableFilter<"BreathingSession"> | number | null
    cyclesCompleted?: IntFilter<"BreathingSession"> | number
    moodBefore?: IntNullableFilter<"BreathingSession"> | number | null
    moodAfter?: IntNullableFilter<"BreathingSession"> | number | null
    anxietyBefore?: IntNullableFilter<"BreathingSession"> | number | null
    anxietyAfter?: IntNullableFilter<"BreathingSession"> | number | null
    averageBreathRate?: FloatNullableFilter<"BreathingSession"> | number | null
    heartRateBefore?: IntNullableFilter<"BreathingSession"> | number | null
    heartRateAfter?: IntNullableFilter<"BreathingSession"> | number | null
    wasHelpful?: BoolNullableFilter<"BreathingSession"> | boolean | null
    rating?: IntNullableFilter<"BreathingSession"> | number | null
    notes?: StringNullableFilter<"BreathingSession"> | string | null
  }

  export type GroundingSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: GroundingSessionWhereUniqueInput
    update: XOR<GroundingSessionUpdateWithoutUserInput, GroundingSessionUncheckedUpdateWithoutUserInput>
    create: XOR<GroundingSessionCreateWithoutUserInput, GroundingSessionUncheckedCreateWithoutUserInput>
  }

  export type GroundingSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: GroundingSessionWhereUniqueInput
    data: XOR<GroundingSessionUpdateWithoutUserInput, GroundingSessionUncheckedUpdateWithoutUserInput>
  }

  export type GroundingSessionUpdateManyWithWhereWithoutUserInput = {
    where: GroundingSessionScalarWhereInput
    data: XOR<GroundingSessionUpdateManyMutationInput, GroundingSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type GroundingSessionScalarWhereInput = {
    AND?: GroundingSessionScalarWhereInput | GroundingSessionScalarWhereInput[]
    OR?: GroundingSessionScalarWhereInput[]
    NOT?: GroundingSessionScalarWhereInput | GroundingSessionScalarWhereInput[]
    id?: StringFilter<"GroundingSession"> | string
    userId?: StringFilter<"GroundingSession"> | string
    techniqueId?: StringFilter<"GroundingSession"> | string
    startedAt?: DateTimeFilter<"GroundingSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"GroundingSession"> | Date | string | null
    duration?: IntNullableFilter<"GroundingSession"> | number | null
    triggerType?: StringNullableFilter<"GroundingSession"> | string | null
    severityBefore?: IntNullableFilter<"GroundingSession"> | number | null
    severityAfter?: IntNullableFilter<"GroundingSession"> | number | null
    panicBefore?: IntNullableFilter<"GroundingSession"> | number | null
    panicAfter?: IntNullableFilter<"GroundingSession"> | number | null
    dissociationBefore?: IntNullableFilter<"GroundingSession"> | number | null
    dissociationAfter?: IntNullableFilter<"GroundingSession"> | number | null
    stepsCompleted?: JsonNullableFilter<"GroundingSession">
    completionRate?: FloatNullableFilter<"GroundingSession"> | number | null
    wasHelpful?: BoolNullableFilter<"GroundingSession"> | boolean | null
    rating?: IntNullableFilter<"GroundingSession"> | number | null
    notes?: StringNullableFilter<"GroundingSession"> | string | null
    wouldUseAgain?: BoolNullableFilter<"GroundingSession"> | boolean | null
  }

  export type SelfHelpInteractionUpsertWithWhereUniqueWithoutUserInput = {
    where: SelfHelpInteractionWhereUniqueInput
    update: XOR<SelfHelpInteractionUpdateWithoutUserInput, SelfHelpInteractionUncheckedUpdateWithoutUserInput>
    create: XOR<SelfHelpInteractionCreateWithoutUserInput, SelfHelpInteractionUncheckedCreateWithoutUserInput>
  }

  export type SelfHelpInteractionUpdateWithWhereUniqueWithoutUserInput = {
    where: SelfHelpInteractionWhereUniqueInput
    data: XOR<SelfHelpInteractionUpdateWithoutUserInput, SelfHelpInteractionUncheckedUpdateWithoutUserInput>
  }

  export type SelfHelpInteractionUpdateManyWithWhereWithoutUserInput = {
    where: SelfHelpInteractionScalarWhereInput
    data: XOR<SelfHelpInteractionUpdateManyMutationInput, SelfHelpInteractionUncheckedUpdateManyWithoutUserInput>
  }

  export type SelfHelpInteractionScalarWhereInput = {
    AND?: SelfHelpInteractionScalarWhereInput | SelfHelpInteractionScalarWhereInput[]
    OR?: SelfHelpInteractionScalarWhereInput[]
    NOT?: SelfHelpInteractionScalarWhereInput | SelfHelpInteractionScalarWhereInput[]
    id?: StringFilter<"SelfHelpInteraction"> | string
    userId?: StringFilter<"SelfHelpInteraction"> | string
    resourceId?: StringFilter<"SelfHelpInteraction"> | string
    interactionType?: EnumInteractionTypeFilter<"SelfHelpInteraction"> | $Enums.InteractionType
    startedAt?: DateTimeFilter<"SelfHelpInteraction"> | Date | string
    completedAt?: DateTimeNullableFilter<"SelfHelpInteraction"> | Date | string | null
    duration?: IntNullableFilter<"SelfHelpInteraction"> | number | null
    wasHelpful?: BoolNullableFilter<"SelfHelpInteraction"> | boolean | null
    rating?: IntNullableFilter<"SelfHelpInteraction"> | number | null
    notes?: StringNullableFilter<"SelfHelpInteraction"> | string | null
    moodBefore?: IntNullableFilter<"SelfHelpInteraction"> | number | null
    moodAfter?: IntNullableFilter<"SelfHelpInteraction"> | number | null
  }

  export type UserCreateWithoutMoodEntriesInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    safetyPlans?: SafetyPlanCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    challenges?: UserChallengeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMoodEntriesInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    safetyPlans?: SafetyPlanUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    challenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionUncheckedCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionUncheckedCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMoodEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMoodEntriesInput, UserUncheckedCreateWithoutMoodEntriesInput>
  }

  export type UserUpsertWithoutMoodEntriesInput = {
    update: XOR<UserUpdateWithoutMoodEntriesInput, UserUncheckedUpdateWithoutMoodEntriesInput>
    create: XOR<UserCreateWithoutMoodEntriesInput, UserUncheckedCreateWithoutMoodEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMoodEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMoodEntriesInput, UserUncheckedUpdateWithoutMoodEntriesInput>
  }

  export type UserUpdateWithoutMoodEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    safetyPlans?: SafetyPlanUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMoodEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    safetyPlans?: SafetyPlanUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUncheckedUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUncheckedUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSafetyPlansInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    challenges?: UserChallengeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSafetyPlansInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    challenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionUncheckedCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionUncheckedCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSafetyPlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSafetyPlansInput, UserUncheckedCreateWithoutSafetyPlansInput>
  }

  export type SafetyPlanVersionCreateWithoutSafetyPlanInput = {
    id?: string
    version: number
    changeLog?: string | null
    encryptedContent: Uint8Array
    contentHash: string
    createdAt?: Date | string
    createdBy: string
  }

  export type SafetyPlanVersionUncheckedCreateWithoutSafetyPlanInput = {
    id?: string
    version: number
    changeLog?: string | null
    encryptedContent: Uint8Array
    contentHash: string
    createdAt?: Date | string
    createdBy: string
  }

  export type SafetyPlanVersionCreateOrConnectWithoutSafetyPlanInput = {
    where: SafetyPlanVersionWhereUniqueInput
    create: XOR<SafetyPlanVersionCreateWithoutSafetyPlanInput, SafetyPlanVersionUncheckedCreateWithoutSafetyPlanInput>
  }

  export type SafetyPlanVersionCreateManySafetyPlanInputEnvelope = {
    data: SafetyPlanVersionCreateManySafetyPlanInput | SafetyPlanVersionCreateManySafetyPlanInput[]
  }

  export type UserUpsertWithoutSafetyPlansInput = {
    update: XOR<UserUpdateWithoutSafetyPlansInput, UserUncheckedUpdateWithoutSafetyPlansInput>
    create: XOR<UserCreateWithoutSafetyPlansInput, UserUncheckedCreateWithoutSafetyPlansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSafetyPlansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSafetyPlansInput, UserUncheckedUpdateWithoutSafetyPlansInput>
  }

  export type UserUpdateWithoutSafetyPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSafetyPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUncheckedUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUncheckedUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SafetyPlanVersionUpsertWithWhereUniqueWithoutSafetyPlanInput = {
    where: SafetyPlanVersionWhereUniqueInput
    update: XOR<SafetyPlanVersionUpdateWithoutSafetyPlanInput, SafetyPlanVersionUncheckedUpdateWithoutSafetyPlanInput>
    create: XOR<SafetyPlanVersionCreateWithoutSafetyPlanInput, SafetyPlanVersionUncheckedCreateWithoutSafetyPlanInput>
  }

  export type SafetyPlanVersionUpdateWithWhereUniqueWithoutSafetyPlanInput = {
    where: SafetyPlanVersionWhereUniqueInput
    data: XOR<SafetyPlanVersionUpdateWithoutSafetyPlanInput, SafetyPlanVersionUncheckedUpdateWithoutSafetyPlanInput>
  }

  export type SafetyPlanVersionUpdateManyWithWhereWithoutSafetyPlanInput = {
    where: SafetyPlanVersionScalarWhereInput
    data: XOR<SafetyPlanVersionUpdateManyMutationInput, SafetyPlanVersionUncheckedUpdateManyWithoutSafetyPlanInput>
  }

  export type SafetyPlanVersionScalarWhereInput = {
    AND?: SafetyPlanVersionScalarWhereInput | SafetyPlanVersionScalarWhereInput[]
    OR?: SafetyPlanVersionScalarWhereInput[]
    NOT?: SafetyPlanVersionScalarWhereInput | SafetyPlanVersionScalarWhereInput[]
    id?: StringFilter<"SafetyPlanVersion"> | string
    safetyPlanId?: StringFilter<"SafetyPlanVersion"> | string
    version?: IntFilter<"SafetyPlanVersion"> | number
    changeLog?: StringNullableFilter<"SafetyPlanVersion"> | string | null
    encryptedContent?: BytesFilter<"SafetyPlanVersion"> | Uint8Array
    contentHash?: StringFilter<"SafetyPlanVersion"> | string
    createdAt?: DateTimeFilter<"SafetyPlanVersion"> | Date | string
    createdBy?: StringFilter<"SafetyPlanVersion"> | string
  }

  export type SafetyPlanCreateWithoutVersionsInput = {
    id?: string
    title: string
    version?: number
    isActive?: boolean
    encryptedContent: Uint8Array
    contentHash: string
    sharedWith?: NullableJsonNullValueInput | InputJsonValue
    emergencyShare?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSafetyPlansInput
  }

  export type SafetyPlanUncheckedCreateWithoutVersionsInput = {
    id?: string
    userId: string
    title: string
    version?: number
    isActive?: boolean
    encryptedContent: Uint8Array
    contentHash: string
    sharedWith?: NullableJsonNullValueInput | InputJsonValue
    emergencyShare?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SafetyPlanCreateOrConnectWithoutVersionsInput = {
    where: SafetyPlanWhereUniqueInput
    create: XOR<SafetyPlanCreateWithoutVersionsInput, SafetyPlanUncheckedCreateWithoutVersionsInput>
  }

  export type SafetyPlanUpsertWithoutVersionsInput = {
    update: XOR<SafetyPlanUpdateWithoutVersionsInput, SafetyPlanUncheckedUpdateWithoutVersionsInput>
    create: XOR<SafetyPlanCreateWithoutVersionsInput, SafetyPlanUncheckedCreateWithoutVersionsInput>
    where?: SafetyPlanWhereInput
  }

  export type SafetyPlanUpdateToOneWithWhereWithoutVersionsInput = {
    where?: SafetyPlanWhereInput
    data: XOR<SafetyPlanUpdateWithoutVersionsInput, SafetyPlanUncheckedUpdateWithoutVersionsInput>
  }

  export type SafetyPlanUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    sharedWith?: NullableJsonNullValueInput | InputJsonValue
    emergencyShare?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSafetyPlansNestedInput
  }

  export type SafetyPlanUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    sharedWith?: NullableJsonNullValueInput | InputJsonValue
    emergencyShare?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUserProfileInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    challenges?: UserChallengeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserProfileInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    challenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionUncheckedCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionUncheckedCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
  }

  export type UserUpsertWithoutUserProfileInput = {
    update: XOR<UserUpdateWithoutUserProfileInput, UserUncheckedUpdateWithoutUserProfileInput>
    create: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserProfileInput, UserUncheckedUpdateWithoutUserProfileInput>
  }

  export type UserUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUncheckedUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUncheckedUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserAchievementCreateWithoutAchievementInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutAchievementInput = {
    id?: string
    userId: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserAchievementCreateOrConnectWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementCreateManyAchievementInputEnvelope = {
    data: UserAchievementCreateManyAchievementInput | UserAchievementCreateManyAchievementInput[]
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutAchievementInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutAchievementInput>
  }

  export type UserCreateWithoutAchievementsInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    challenges?: UserChallengeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    challenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionUncheckedCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionUncheckedCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type AchievementCreateWithoutUserAchievementsInput = {
    id?: string
    name: string
    description: string
    category: $Enums.AchievementCategory
    rarity?: $Enums.AchievementRarity
    requirements: JsonNullValueInput | InputJsonValue
    xpReward?: number
    pointReward?: number
    icon?: string | null
    color?: string | null
    isActive?: boolean
  }

  export type AchievementUncheckedCreateWithoutUserAchievementsInput = {
    id?: string
    name: string
    description: string
    category: $Enums.AchievementCategory
    rarity?: $Enums.AchievementRarity
    requirements: JsonNullValueInput | InputJsonValue
    xpReward?: number
    pointReward?: number
    icon?: string | null
    color?: string | null
    isActive?: boolean
  }

  export type AchievementCreateOrConnectWithoutUserAchievementsInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    challenges?: UserChallengeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    challenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUncheckedUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUncheckedUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AchievementUpsertWithoutUserAchievementsInput = {
    update: XOR<AchievementUpdateWithoutUserAchievementsInput, AchievementUncheckedUpdateWithoutUserAchievementsInput>
    create: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    where?: AchievementWhereInput
  }

  export type AchievementUpdateToOneWithWhereWithoutUserAchievementsInput = {
    where?: AchievementWhereInput
    data: XOR<AchievementUpdateWithoutUserAchievementsInput, AchievementUncheckedUpdateWithoutUserAchievementsInput>
  }

  export type AchievementUpdateWithoutUserAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    rarity?: EnumAchievementRarityFieldUpdateOperationsInput | $Enums.AchievementRarity
    requirements?: JsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    pointReward?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AchievementUncheckedUpdateWithoutUserAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    rarity?: EnumAchievementRarityFieldUpdateOperationsInput | $Enums.AchievementRarity
    requirements?: JsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    pointReward?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserChallengeCreateWithoutChallengeInput = {
    id?: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    startedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutChallengesInput
  }

  export type UserChallengeUncheckedCreateWithoutChallengeInput = {
    id?: string
    userId: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    startedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserChallengeCreateOrConnectWithoutChallengeInput = {
    where: UserChallengeWhereUniqueInput
    create: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput>
  }

  export type UserChallengeCreateManyChallengeInputEnvelope = {
    data: UserChallengeCreateManyChallengeInput | UserChallengeCreateManyChallengeInput[]
  }

  export type UserChallengeUpsertWithWhereUniqueWithoutChallengeInput = {
    where: UserChallengeWhereUniqueInput
    update: XOR<UserChallengeUpdateWithoutChallengeInput, UserChallengeUncheckedUpdateWithoutChallengeInput>
    create: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput>
  }

  export type UserChallengeUpdateWithWhereUniqueWithoutChallengeInput = {
    where: UserChallengeWhereUniqueInput
    data: XOR<UserChallengeUpdateWithoutChallengeInput, UserChallengeUncheckedUpdateWithoutChallengeInput>
  }

  export type UserChallengeUpdateManyWithWhereWithoutChallengeInput = {
    where: UserChallengeScalarWhereInput
    data: XOR<UserChallengeUpdateManyMutationInput, UserChallengeUncheckedUpdateManyWithoutChallengeInput>
  }

  export type UserCreateWithoutChallengesInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChallengesInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionUncheckedCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionUncheckedCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChallengesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChallengesInput, UserUncheckedCreateWithoutChallengesInput>
  }

  export type ChallengeCreateWithoutUserChallengesInput = {
    id?: string
    name: string
    description: string
    type: $Enums.ChallengeType
    difficulty?: $Enums.ChallengeDifficulty
    requirements: JsonNullValueInput | InputJsonValue
    duration: number
    xpReward?: number
    pointReward?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
  }

  export type ChallengeUncheckedCreateWithoutUserChallengesInput = {
    id?: string
    name: string
    description: string
    type: $Enums.ChallengeType
    difficulty?: $Enums.ChallengeDifficulty
    requirements: JsonNullValueInput | InputJsonValue
    duration: number
    xpReward?: number
    pointReward?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
  }

  export type ChallengeCreateOrConnectWithoutUserChallengesInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutUserChallengesInput, ChallengeUncheckedCreateWithoutUserChallengesInput>
  }

  export type UserUpsertWithoutChallengesInput = {
    update: XOR<UserUpdateWithoutChallengesInput, UserUncheckedUpdateWithoutChallengesInput>
    create: XOR<UserCreateWithoutChallengesInput, UserUncheckedCreateWithoutChallengesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChallengesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChallengesInput, UserUncheckedUpdateWithoutChallengesInput>
  }

  export type UserUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUncheckedUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUncheckedUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChallengeUpsertWithoutUserChallengesInput = {
    update: XOR<ChallengeUpdateWithoutUserChallengesInput, ChallengeUncheckedUpdateWithoutUserChallengesInput>
    create: XOR<ChallengeCreateWithoutUserChallengesInput, ChallengeUncheckedCreateWithoutUserChallengesInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutUserChallengesInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutUserChallengesInput, ChallengeUncheckedUpdateWithoutUserChallengesInput>
  }

  export type ChallengeUpdateWithoutUserChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    difficulty?: EnumChallengeDifficultyFieldUpdateOperationsInput | $Enums.ChallengeDifficulty
    requirements?: JsonNullValueInput | InputJsonValue
    duration?: IntFieldUpdateOperationsInput | number
    xpReward?: IntFieldUpdateOperationsInput | number
    pointReward?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChallengeUncheckedUpdateWithoutUserChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    difficulty?: EnumChallengeDifficultyFieldUpdateOperationsInput | $Enums.ChallengeDifficulty
    requirements?: JsonNullValueInput | InputJsonValue
    duration?: IntFieldUpdateOperationsInput | number
    xpReward?: IntFieldUpdateOperationsInput | number
    pointReward?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateWithoutActivitiesInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    challenges?: UserChallengeCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    challenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionUncheckedCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionUncheckedCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUncheckedUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUncheckedUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutJournalEntriesInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    challenges?: UserChallengeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutJournalEntriesInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    challenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionUncheckedCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionUncheckedCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutJournalEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJournalEntriesInput, UserUncheckedCreateWithoutJournalEntriesInput>
  }

  export type UserUpsertWithoutJournalEntriesInput = {
    update: XOR<UserUpdateWithoutJournalEntriesInput, UserUncheckedUpdateWithoutJournalEntriesInput>
    create: XOR<UserCreateWithoutJournalEntriesInput, UserUncheckedCreateWithoutJournalEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJournalEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJournalEntriesInput, UserUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type UserUpdateWithoutJournalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutJournalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUncheckedUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUncheckedUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BreathingSessionCreateWithoutExerciseInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    cyclesCompleted?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    averageBreathRate?: number | null
    heartRateBefore?: number | null
    heartRateAfter?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    user: UserCreateNestedOneWithoutBreathingSessionsInput
  }

  export type BreathingSessionUncheckedCreateWithoutExerciseInput = {
    id?: string
    userId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    cyclesCompleted?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    averageBreathRate?: number | null
    heartRateBefore?: number | null
    heartRateAfter?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
  }

  export type BreathingSessionCreateOrConnectWithoutExerciseInput = {
    where: BreathingSessionWhereUniqueInput
    create: XOR<BreathingSessionCreateWithoutExerciseInput, BreathingSessionUncheckedCreateWithoutExerciseInput>
  }

  export type BreathingSessionCreateManyExerciseInputEnvelope = {
    data: BreathingSessionCreateManyExerciseInput | BreathingSessionCreateManyExerciseInput[]
  }

  export type BreathingSessionUpsertWithWhereUniqueWithoutExerciseInput = {
    where: BreathingSessionWhereUniqueInput
    update: XOR<BreathingSessionUpdateWithoutExerciseInput, BreathingSessionUncheckedUpdateWithoutExerciseInput>
    create: XOR<BreathingSessionCreateWithoutExerciseInput, BreathingSessionUncheckedCreateWithoutExerciseInput>
  }

  export type BreathingSessionUpdateWithWhereUniqueWithoutExerciseInput = {
    where: BreathingSessionWhereUniqueInput
    data: XOR<BreathingSessionUpdateWithoutExerciseInput, BreathingSessionUncheckedUpdateWithoutExerciseInput>
  }

  export type BreathingSessionUpdateManyWithWhereWithoutExerciseInput = {
    where: BreathingSessionScalarWhereInput
    data: XOR<BreathingSessionUpdateManyMutationInput, BreathingSessionUncheckedUpdateManyWithoutExerciseInput>
  }

  export type UserCreateWithoutBreathingSessionsInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    challenges?: UserChallengeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBreathingSessionsInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    challenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionUncheckedCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBreathingSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBreathingSessionsInput, UserUncheckedCreateWithoutBreathingSessionsInput>
  }

  export type BreathingExerciseCreateWithoutSessionsInput = {
    id?: string
    name: string
    description: string
    technique: $Enums.BreathingTechnique
    difficulty?: $Enums.ExerciseDifficulty
    inhaleSeconds: number
    holdSeconds?: number | null
    exhaleSeconds: number
    pauseSeconds?: number | null
    cyclesRecommended?: number
    instructions: JsonNullValueInput | InputJsonValue
    visualGuideUrl?: string | null
    audioGuideUrl?: string | null
    benefits: JsonNullValueInput | InputJsonValue
    bestFor: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
  }

  export type BreathingExerciseUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    description: string
    technique: $Enums.BreathingTechnique
    difficulty?: $Enums.ExerciseDifficulty
    inhaleSeconds: number
    holdSeconds?: number | null
    exhaleSeconds: number
    pauseSeconds?: number | null
    cyclesRecommended?: number
    instructions: JsonNullValueInput | InputJsonValue
    visualGuideUrl?: string | null
    audioGuideUrl?: string | null
    benefits: JsonNullValueInput | InputJsonValue
    bestFor: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
  }

  export type BreathingExerciseCreateOrConnectWithoutSessionsInput = {
    where: BreathingExerciseWhereUniqueInput
    create: XOR<BreathingExerciseCreateWithoutSessionsInput, BreathingExerciseUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutBreathingSessionsInput = {
    update: XOR<UserUpdateWithoutBreathingSessionsInput, UserUncheckedUpdateWithoutBreathingSessionsInput>
    create: XOR<UserCreateWithoutBreathingSessionsInput, UserUncheckedCreateWithoutBreathingSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBreathingSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBreathingSessionsInput, UserUncheckedUpdateWithoutBreathingSessionsInput>
  }

  export type UserUpdateWithoutBreathingSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBreathingSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUncheckedUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BreathingExerciseUpsertWithoutSessionsInput = {
    update: XOR<BreathingExerciseUpdateWithoutSessionsInput, BreathingExerciseUncheckedUpdateWithoutSessionsInput>
    create: XOR<BreathingExerciseCreateWithoutSessionsInput, BreathingExerciseUncheckedCreateWithoutSessionsInput>
    where?: BreathingExerciseWhereInput
  }

  export type BreathingExerciseUpdateToOneWithWhereWithoutSessionsInput = {
    where?: BreathingExerciseWhereInput
    data: XOR<BreathingExerciseUpdateWithoutSessionsInput, BreathingExerciseUncheckedUpdateWithoutSessionsInput>
  }

  export type BreathingExerciseUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    technique?: EnumBreathingTechniqueFieldUpdateOperationsInput | $Enums.BreathingTechnique
    difficulty?: EnumExerciseDifficultyFieldUpdateOperationsInput | $Enums.ExerciseDifficulty
    inhaleSeconds?: IntFieldUpdateOperationsInput | number
    holdSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    exhaleSeconds?: IntFieldUpdateOperationsInput | number
    pauseSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    cyclesRecommended?: IntFieldUpdateOperationsInput | number
    instructions?: JsonNullValueInput | InputJsonValue
    visualGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: JsonNullValueInput | InputJsonValue
    bestFor?: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreathingExerciseUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    technique?: EnumBreathingTechniqueFieldUpdateOperationsInput | $Enums.BreathingTechnique
    difficulty?: EnumExerciseDifficultyFieldUpdateOperationsInput | $Enums.ExerciseDifficulty
    inhaleSeconds?: IntFieldUpdateOperationsInput | number
    holdSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    exhaleSeconds?: IntFieldUpdateOperationsInput | number
    pauseSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    cyclesRecommended?: IntFieldUpdateOperationsInput | number
    instructions?: JsonNullValueInput | InputJsonValue
    visualGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: JsonNullValueInput | InputJsonValue
    bestFor?: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroundingSessionCreateWithoutTechniqueInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    triggerType?: string | null
    severityBefore?: number | null
    severityAfter?: number | null
    panicBefore?: number | null
    panicAfter?: number | null
    dissociationBefore?: number | null
    dissociationAfter?: number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    wouldUseAgain?: boolean | null
    user: UserCreateNestedOneWithoutGroundingSessionsInput
  }

  export type GroundingSessionUncheckedCreateWithoutTechniqueInput = {
    id?: string
    userId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    triggerType?: string | null
    severityBefore?: number | null
    severityAfter?: number | null
    panicBefore?: number | null
    panicAfter?: number | null
    dissociationBefore?: number | null
    dissociationAfter?: number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    wouldUseAgain?: boolean | null
  }

  export type GroundingSessionCreateOrConnectWithoutTechniqueInput = {
    where: GroundingSessionWhereUniqueInput
    create: XOR<GroundingSessionCreateWithoutTechniqueInput, GroundingSessionUncheckedCreateWithoutTechniqueInput>
  }

  export type GroundingSessionCreateManyTechniqueInputEnvelope = {
    data: GroundingSessionCreateManyTechniqueInput | GroundingSessionCreateManyTechniqueInput[]
  }

  export type GroundingSessionUpsertWithWhereUniqueWithoutTechniqueInput = {
    where: GroundingSessionWhereUniqueInput
    update: XOR<GroundingSessionUpdateWithoutTechniqueInput, GroundingSessionUncheckedUpdateWithoutTechniqueInput>
    create: XOR<GroundingSessionCreateWithoutTechniqueInput, GroundingSessionUncheckedCreateWithoutTechniqueInput>
  }

  export type GroundingSessionUpdateWithWhereUniqueWithoutTechniqueInput = {
    where: GroundingSessionWhereUniqueInput
    data: XOR<GroundingSessionUpdateWithoutTechniqueInput, GroundingSessionUncheckedUpdateWithoutTechniqueInput>
  }

  export type GroundingSessionUpdateManyWithWhereWithoutTechniqueInput = {
    where: GroundingSessionScalarWhereInput
    data: XOR<GroundingSessionUpdateManyMutationInput, GroundingSessionUncheckedUpdateManyWithoutTechniqueInput>
  }

  export type UserCreateWithoutGroundingSessionsInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    challenges?: UserChallengeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGroundingSessionsInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    challenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionUncheckedCreateNestedManyWithoutUserInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGroundingSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroundingSessionsInput, UserUncheckedCreateWithoutGroundingSessionsInput>
  }

  export type GroundingTechniqueCreateWithoutSessionsInput = {
    id?: string
    name: string
    description: string
    type: $Enums.GroundingType
    category: $Enums.GroundingCategory
    instructions: JsonNullValueInput | InputJsonValue
    duration: number
    materials?: NullableJsonNullValueInput | InputJsonValue
    audioGuideUrl?: string | null
    videoGuideUrl?: string | null
    imageGuides?: NullableJsonNullValueInput | InputJsonValue
    evidenceLevel?: $Enums.EvidenceLevel
    bestFor: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
  }

  export type GroundingTechniqueUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    description: string
    type: $Enums.GroundingType
    category: $Enums.GroundingCategory
    instructions: JsonNullValueInput | InputJsonValue
    duration: number
    materials?: NullableJsonNullValueInput | InputJsonValue
    audioGuideUrl?: string | null
    videoGuideUrl?: string | null
    imageGuides?: NullableJsonNullValueInput | InputJsonValue
    evidenceLevel?: $Enums.EvidenceLevel
    bestFor: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
  }

  export type GroundingTechniqueCreateOrConnectWithoutSessionsInput = {
    where: GroundingTechniqueWhereUniqueInput
    create: XOR<GroundingTechniqueCreateWithoutSessionsInput, GroundingTechniqueUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutGroundingSessionsInput = {
    update: XOR<UserUpdateWithoutGroundingSessionsInput, UserUncheckedUpdateWithoutGroundingSessionsInput>
    create: XOR<UserCreateWithoutGroundingSessionsInput, UserUncheckedCreateWithoutGroundingSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGroundingSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGroundingSessionsInput, UserUncheckedUpdateWithoutGroundingSessionsInput>
  }

  export type UserUpdateWithoutGroundingSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGroundingSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUncheckedUpdateManyWithoutUserNestedInput
    selfHelpInteractions?: SelfHelpInteractionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GroundingTechniqueUpsertWithoutSessionsInput = {
    update: XOR<GroundingTechniqueUpdateWithoutSessionsInput, GroundingTechniqueUncheckedUpdateWithoutSessionsInput>
    create: XOR<GroundingTechniqueCreateWithoutSessionsInput, GroundingTechniqueUncheckedCreateWithoutSessionsInput>
    where?: GroundingTechniqueWhereInput
  }

  export type GroundingTechniqueUpdateToOneWithWhereWithoutSessionsInput = {
    where?: GroundingTechniqueWhereInput
    data: XOR<GroundingTechniqueUpdateWithoutSessionsInput, GroundingTechniqueUncheckedUpdateWithoutSessionsInput>
  }

  export type GroundingTechniqueUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumGroundingTypeFieldUpdateOperationsInput | $Enums.GroundingType
    category?: EnumGroundingCategoryFieldUpdateOperationsInput | $Enums.GroundingCategory
    instructions?: JsonNullValueInput | InputJsonValue
    duration?: IntFieldUpdateOperationsInput | number
    materials?: NullableJsonNullValueInput | InputJsonValue
    audioGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageGuides?: NullableJsonNullValueInput | InputJsonValue
    evidenceLevel?: EnumEvidenceLevelFieldUpdateOperationsInput | $Enums.EvidenceLevel
    bestFor?: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroundingTechniqueUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumGroundingTypeFieldUpdateOperationsInput | $Enums.GroundingType
    category?: EnumGroundingCategoryFieldUpdateOperationsInput | $Enums.GroundingCategory
    instructions?: JsonNullValueInput | InputJsonValue
    duration?: IntFieldUpdateOperationsInput | number
    materials?: NullableJsonNullValueInput | InputJsonValue
    audioGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoGuideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageGuides?: NullableJsonNullValueInput | InputJsonValue
    evidenceLevel?: EnumEvidenceLevelFieldUpdateOperationsInput | $Enums.EvidenceLevel
    bestFor?: JsonNullValueInput | InputJsonValue
    contraindications?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SelfHelpInteractionCreateWithoutResourceInput = {
    id?: string
    interactionType: $Enums.InteractionType
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    moodBefore?: number | null
    moodAfter?: number | null
    user: UserCreateNestedOneWithoutSelfHelpInteractionsInput
  }

  export type SelfHelpInteractionUncheckedCreateWithoutResourceInput = {
    id?: string
    userId: string
    interactionType: $Enums.InteractionType
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    moodBefore?: number | null
    moodAfter?: number | null
  }

  export type SelfHelpInteractionCreateOrConnectWithoutResourceInput = {
    where: SelfHelpInteractionWhereUniqueInput
    create: XOR<SelfHelpInteractionCreateWithoutResourceInput, SelfHelpInteractionUncheckedCreateWithoutResourceInput>
  }

  export type SelfHelpInteractionCreateManyResourceInputEnvelope = {
    data: SelfHelpInteractionCreateManyResourceInput | SelfHelpInteractionCreateManyResourceInput[]
  }

  export type SelfHelpInteractionUpsertWithWhereUniqueWithoutResourceInput = {
    where: SelfHelpInteractionWhereUniqueInput
    update: XOR<SelfHelpInteractionUpdateWithoutResourceInput, SelfHelpInteractionUncheckedUpdateWithoutResourceInput>
    create: XOR<SelfHelpInteractionCreateWithoutResourceInput, SelfHelpInteractionUncheckedCreateWithoutResourceInput>
  }

  export type SelfHelpInteractionUpdateWithWhereUniqueWithoutResourceInput = {
    where: SelfHelpInteractionWhereUniqueInput
    data: XOR<SelfHelpInteractionUpdateWithoutResourceInput, SelfHelpInteractionUncheckedUpdateWithoutResourceInput>
  }

  export type SelfHelpInteractionUpdateManyWithWhereWithoutResourceInput = {
    where: SelfHelpInteractionScalarWhereInput
    data: XOR<SelfHelpInteractionUpdateManyMutationInput, SelfHelpInteractionUncheckedUpdateManyWithoutResourceInput>
  }

  export type UserCreateWithoutSelfHelpInteractionsInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    challenges?: UserChallengeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSelfHelpInteractionsInput = {
    id?: string
    anonymousId?: string | null
    email?: string | null
    username?: string | null
    isAnonymous?: boolean
    lastLogin?: Date | string | null
    dataSharing?: $Enums.UserDataSharing
    allowAnalytics?: boolean
    dataRetentionDays?: number | null
    verificationStatus?: $Enums.VerificationStatus
    professionalType?: string | null
    licenseNumber?: string | null
    verifiedAt?: Date | string | null
    encryptedProfile?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    safetyPlans?: SafetyPlanUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    challenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    breathingSessions?: BreathingSessionUncheckedCreateNestedManyWithoutUserInput
    groundingSessions?: GroundingSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSelfHelpInteractionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSelfHelpInteractionsInput, UserUncheckedCreateWithoutSelfHelpInteractionsInput>
  }

  export type SelfHelpResourceCreateWithoutInteractionsInput = {
    id?: string
    title: string
    description: string
    category: $Enums.SelfHelpCategory
    type: $Enums.ResourceType
    content?: string | null
    url?: string | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    duration?: number | null
    difficulty?: $Enums.ExerciseDifficulty
    evidenceLevel?: $Enums.EvidenceLevel
    tags: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    symptoms?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: number
    helpfulCount?: number
    averageRating?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SelfHelpResourceUncheckedCreateWithoutInteractionsInput = {
    id?: string
    title: string
    description: string
    category: $Enums.SelfHelpCategory
    type: $Enums.ResourceType
    content?: string | null
    url?: string | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    duration?: number | null
    difficulty?: $Enums.ExerciseDifficulty
    evidenceLevel?: $Enums.EvidenceLevel
    tags: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    symptoms?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: number
    helpfulCount?: number
    averageRating?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SelfHelpResourceCreateOrConnectWithoutInteractionsInput = {
    where: SelfHelpResourceWhereUniqueInput
    create: XOR<SelfHelpResourceCreateWithoutInteractionsInput, SelfHelpResourceUncheckedCreateWithoutInteractionsInput>
  }

  export type UserUpsertWithoutSelfHelpInteractionsInput = {
    update: XOR<UserUpdateWithoutSelfHelpInteractionsInput, UserUncheckedUpdateWithoutSelfHelpInteractionsInput>
    create: XOR<UserCreateWithoutSelfHelpInteractionsInput, UserUncheckedCreateWithoutSelfHelpInteractionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSelfHelpInteractionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSelfHelpInteractionsInput, UserUncheckedUpdateWithoutSelfHelpInteractionsInput>
  }

  export type UserUpdateWithoutSelfHelpInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSelfHelpInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataSharing?: EnumUserDataSharingFieldUpdateOperationsInput | $Enums.UserDataSharing
    allowAnalytics?: BoolFieldUpdateOperationsInput | boolean
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    professionalType?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encryptedProfile?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    safetyPlans?: SafetyPlanUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    challenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    breathingSessions?: BreathingSessionUncheckedUpdateManyWithoutUserNestedInput
    groundingSessions?: GroundingSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SelfHelpResourceUpsertWithoutInteractionsInput = {
    update: XOR<SelfHelpResourceUpdateWithoutInteractionsInput, SelfHelpResourceUncheckedUpdateWithoutInteractionsInput>
    create: XOR<SelfHelpResourceCreateWithoutInteractionsInput, SelfHelpResourceUncheckedCreateWithoutInteractionsInput>
    where?: SelfHelpResourceWhereInput
  }

  export type SelfHelpResourceUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: SelfHelpResourceWhereInput
    data: XOR<SelfHelpResourceUpdateWithoutInteractionsInput, SelfHelpResourceUncheckedUpdateWithoutInteractionsInput>
  }

  export type SelfHelpResourceUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSelfHelpCategoryFieldUpdateOperationsInput | $Enums.SelfHelpCategory
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: EnumExerciseDifficultyFieldUpdateOperationsInput | $Enums.ExerciseDifficulty
    evidenceLevel?: EnumEvidenceLevelFieldUpdateOperationsInput | $Enums.EvidenceLevel
    tags?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    symptoms?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SelfHelpResourceUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumSelfHelpCategoryFieldUpdateOperationsInput | $Enums.SelfHelpCategory
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: EnumExerciseDifficultyFieldUpdateOperationsInput | $Enums.ExerciseDifficulty
    evidenceLevel?: EnumEvidenceLevelFieldUpdateOperationsInput | $Enums.EvidenceLevel
    tags?: JsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    symptoms?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AITherapySessionCreateWithoutTherapistInput = {
    id?: string
    sessionToken: string
    userId: string
    sessionType: $Enums.AISessionType
    status?: $Enums.AISessionStatus
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    pausedAt?: Date | string | null
    pausedDuration?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    encryptedNotes?: Uint8Array | null
    encryptedInsights?: Uint8Array | null
    encryptedHomework?: Uint8Array | null
    encryptedGoals?: Uint8Array | null
    topics?: string | null
    techniques?: string | null
    interventions?: string | null
    breakthroughs?: string | null
    crisisDetected?: boolean
    crisisLevel?: number | null
    crisisInterventions?: string | null
    messages?: AITherapyMessageCreateNestedManyWithoutSessionInput
    exercises?: AIExerciseSessionCreateNestedManyWithoutSessionInput
  }

  export type AITherapySessionUncheckedCreateWithoutTherapistInput = {
    id?: string
    sessionToken: string
    userId: string
    sessionType: $Enums.AISessionType
    status?: $Enums.AISessionStatus
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    pausedAt?: Date | string | null
    pausedDuration?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    encryptedNotes?: Uint8Array | null
    encryptedInsights?: Uint8Array | null
    encryptedHomework?: Uint8Array | null
    encryptedGoals?: Uint8Array | null
    topics?: string | null
    techniques?: string | null
    interventions?: string | null
    breakthroughs?: string | null
    crisisDetected?: boolean
    crisisLevel?: number | null
    crisisInterventions?: string | null
    messages?: AITherapyMessageUncheckedCreateNestedManyWithoutSessionInput
    exercises?: AIExerciseSessionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AITherapySessionCreateOrConnectWithoutTherapistInput = {
    where: AITherapySessionWhereUniqueInput
    create: XOR<AITherapySessionCreateWithoutTherapistInput, AITherapySessionUncheckedCreateWithoutTherapistInput>
  }

  export type AITherapySessionCreateManyTherapistInputEnvelope = {
    data: AITherapySessionCreateManyTherapistInput | AITherapySessionCreateManyTherapistInput[]
  }

  export type AIPersonalizationCreateWithoutTherapistInput = {
    id?: string
    userId: string
    preferredStyle?: string | null
    preferredTechniques?: string | null
    preferredTopics?: string | null
    avoidTopics?: string | null
    responseLength?: string
    responseComplexity?: string
    empathyLevel?: string
    directness?: string
    culturalBackground?: string | null
    languagePreference?: string
    timezone?: string
    pronouns?: string | null
    learnedPatterns?: string | null
    effectiveTechniques?: string | null
    triggerPatterns?: string | null
    copingStrategies?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIPersonalizationUncheckedCreateWithoutTherapistInput = {
    id?: string
    userId: string
    preferredStyle?: string | null
    preferredTechniques?: string | null
    preferredTopics?: string | null
    avoidTopics?: string | null
    responseLength?: string
    responseComplexity?: string
    empathyLevel?: string
    directness?: string
    culturalBackground?: string | null
    languagePreference?: string
    timezone?: string
    pronouns?: string | null
    learnedPatterns?: string | null
    effectiveTechniques?: string | null
    triggerPatterns?: string | null
    copingStrategies?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIPersonalizationCreateOrConnectWithoutTherapistInput = {
    where: AIPersonalizationWhereUniqueInput
    create: XOR<AIPersonalizationCreateWithoutTherapistInput, AIPersonalizationUncheckedCreateWithoutTherapistInput>
  }

  export type AIPersonalizationCreateManyTherapistInputEnvelope = {
    data: AIPersonalizationCreateManyTherapistInput | AIPersonalizationCreateManyTherapistInput[]
  }

  export type AITherapySessionUpsertWithWhereUniqueWithoutTherapistInput = {
    where: AITherapySessionWhereUniqueInput
    update: XOR<AITherapySessionUpdateWithoutTherapistInput, AITherapySessionUncheckedUpdateWithoutTherapistInput>
    create: XOR<AITherapySessionCreateWithoutTherapistInput, AITherapySessionUncheckedCreateWithoutTherapistInput>
  }

  export type AITherapySessionUpdateWithWhereUniqueWithoutTherapistInput = {
    where: AITherapySessionWhereUniqueInput
    data: XOR<AITherapySessionUpdateWithoutTherapistInput, AITherapySessionUncheckedUpdateWithoutTherapistInput>
  }

  export type AITherapySessionUpdateManyWithWhereWithoutTherapistInput = {
    where: AITherapySessionScalarWhereInput
    data: XOR<AITherapySessionUpdateManyMutationInput, AITherapySessionUncheckedUpdateManyWithoutTherapistInput>
  }

  export type AITherapySessionScalarWhereInput = {
    AND?: AITherapySessionScalarWhereInput | AITherapySessionScalarWhereInput[]
    OR?: AITherapySessionScalarWhereInput[]
    NOT?: AITherapySessionScalarWhereInput | AITherapySessionScalarWhereInput[]
    id?: StringFilter<"AITherapySession"> | string
    sessionToken?: StringFilter<"AITherapySession"> | string
    userId?: StringFilter<"AITherapySession"> | string
    therapistId?: StringFilter<"AITherapySession"> | string
    sessionType?: EnumAISessionTypeFilter<"AITherapySession"> | $Enums.AISessionType
    status?: EnumAISessionStatusFilter<"AITherapySession"> | $Enums.AISessionStatus
    startedAt?: DateTimeFilter<"AITherapySession"> | Date | string
    endedAt?: DateTimeNullableFilter<"AITherapySession"> | Date | string | null
    duration?: IntNullableFilter<"AITherapySession"> | number | null
    pausedAt?: DateTimeNullableFilter<"AITherapySession"> | Date | string | null
    pausedDuration?: IntFilter<"AITherapySession"> | number
    moodBefore?: IntNullableFilter<"AITherapySession"> | number | null
    moodAfter?: IntNullableFilter<"AITherapySession"> | number | null
    anxietyBefore?: IntNullableFilter<"AITherapySession"> | number | null
    anxietyAfter?: IntNullableFilter<"AITherapySession"> | number | null
    energyBefore?: IntNullableFilter<"AITherapySession"> | number | null
    energyAfter?: IntNullableFilter<"AITherapySession"> | number | null
    encryptedNotes?: BytesNullableFilter<"AITherapySession"> | Uint8Array | null
    encryptedInsights?: BytesNullableFilter<"AITherapySession"> | Uint8Array | null
    encryptedHomework?: BytesNullableFilter<"AITherapySession"> | Uint8Array | null
    encryptedGoals?: BytesNullableFilter<"AITherapySession"> | Uint8Array | null
    topics?: StringNullableFilter<"AITherapySession"> | string | null
    techniques?: StringNullableFilter<"AITherapySession"> | string | null
    interventions?: StringNullableFilter<"AITherapySession"> | string | null
    breakthroughs?: StringNullableFilter<"AITherapySession"> | string | null
    crisisDetected?: BoolFilter<"AITherapySession"> | boolean
    crisisLevel?: IntNullableFilter<"AITherapySession"> | number | null
    crisisInterventions?: StringNullableFilter<"AITherapySession"> | string | null
  }

  export type AIPersonalizationUpsertWithWhereUniqueWithoutTherapistInput = {
    where: AIPersonalizationWhereUniqueInput
    update: XOR<AIPersonalizationUpdateWithoutTherapistInput, AIPersonalizationUncheckedUpdateWithoutTherapistInput>
    create: XOR<AIPersonalizationCreateWithoutTherapistInput, AIPersonalizationUncheckedCreateWithoutTherapistInput>
  }

  export type AIPersonalizationUpdateWithWhereUniqueWithoutTherapistInput = {
    where: AIPersonalizationWhereUniqueInput
    data: XOR<AIPersonalizationUpdateWithoutTherapistInput, AIPersonalizationUncheckedUpdateWithoutTherapistInput>
  }

  export type AIPersonalizationUpdateManyWithWhereWithoutTherapistInput = {
    where: AIPersonalizationScalarWhereInput
    data: XOR<AIPersonalizationUpdateManyMutationInput, AIPersonalizationUncheckedUpdateManyWithoutTherapistInput>
  }

  export type AIPersonalizationScalarWhereInput = {
    AND?: AIPersonalizationScalarWhereInput | AIPersonalizationScalarWhereInput[]
    OR?: AIPersonalizationScalarWhereInput[]
    NOT?: AIPersonalizationScalarWhereInput | AIPersonalizationScalarWhereInput[]
    id?: StringFilter<"AIPersonalization"> | string
    userId?: StringFilter<"AIPersonalization"> | string
    therapistId?: StringNullableFilter<"AIPersonalization"> | string | null
    preferredStyle?: StringNullableFilter<"AIPersonalization"> | string | null
    preferredTechniques?: StringNullableFilter<"AIPersonalization"> | string | null
    preferredTopics?: StringNullableFilter<"AIPersonalization"> | string | null
    avoidTopics?: StringNullableFilter<"AIPersonalization"> | string | null
    responseLength?: StringFilter<"AIPersonalization"> | string
    responseComplexity?: StringFilter<"AIPersonalization"> | string
    empathyLevel?: StringFilter<"AIPersonalization"> | string
    directness?: StringFilter<"AIPersonalization"> | string
    culturalBackground?: StringNullableFilter<"AIPersonalization"> | string | null
    languagePreference?: StringFilter<"AIPersonalization"> | string
    timezone?: StringFilter<"AIPersonalization"> | string
    pronouns?: StringNullableFilter<"AIPersonalization"> | string | null
    learnedPatterns?: StringNullableFilter<"AIPersonalization"> | string | null
    effectiveTechniques?: StringNullableFilter<"AIPersonalization"> | string | null
    triggerPatterns?: StringNullableFilter<"AIPersonalization"> | string | null
    copingStrategies?: StringNullableFilter<"AIPersonalization"> | string | null
    createdAt?: DateTimeFilter<"AIPersonalization"> | Date | string
    updatedAt?: DateTimeFilter<"AIPersonalization"> | Date | string
  }

  export type AITherapistCreateWithoutSessionsInput = {
    id?: string
    therapistId: string
    name: string
    avatar: string
    personality: string
    description: string
    specialties: string
    approaches: string
    bestFor: string
    features: string
    availability: string
    sessionsCompleted?: number
    userRating?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    personalizations?: AIPersonalizationCreateNestedManyWithoutTherapistInput
  }

  export type AITherapistUncheckedCreateWithoutSessionsInput = {
    id?: string
    therapistId: string
    name: string
    avatar: string
    personality: string
    description: string
    specialties: string
    approaches: string
    bestFor: string
    features: string
    availability: string
    sessionsCompleted?: number
    userRating?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    personalizations?: AIPersonalizationUncheckedCreateNestedManyWithoutTherapistInput
  }

  export type AITherapistCreateOrConnectWithoutSessionsInput = {
    where: AITherapistWhereUniqueInput
    create: XOR<AITherapistCreateWithoutSessionsInput, AITherapistUncheckedCreateWithoutSessionsInput>
  }

  export type AITherapyMessageCreateWithoutSessionInput = {
    id?: string
    messageType: $Enums.AIMessageType
    sender: $Enums.AIMessageSender
    encryptedContent: Uint8Array
    messageHash: string
    timestamp?: Date | string
    edited?: boolean
    editedAt?: Date | string | null
    sentiment?: number | null
    emotion?: string | null
    riskScore?: number | null
    techniques?: string | null
    hasAudio?: boolean
    audioDuration?: number | null
    audioUrl?: string | null
  }

  export type AITherapyMessageUncheckedCreateWithoutSessionInput = {
    id?: string
    messageType: $Enums.AIMessageType
    sender: $Enums.AIMessageSender
    encryptedContent: Uint8Array
    messageHash: string
    timestamp?: Date | string
    edited?: boolean
    editedAt?: Date | string | null
    sentiment?: number | null
    emotion?: string | null
    riskScore?: number | null
    techniques?: string | null
    hasAudio?: boolean
    audioDuration?: number | null
    audioUrl?: string | null
  }

  export type AITherapyMessageCreateOrConnectWithoutSessionInput = {
    where: AITherapyMessageWhereUniqueInput
    create: XOR<AITherapyMessageCreateWithoutSessionInput, AITherapyMessageUncheckedCreateWithoutSessionInput>
  }

  export type AITherapyMessageCreateManySessionInputEnvelope = {
    data: AITherapyMessageCreateManySessionInput | AITherapyMessageCreateManySessionInput[]
  }

  export type AIExerciseSessionCreateWithoutSessionInput = {
    id?: string
    userId: string
    exerciseType: $Enums.AIExerciseType
    exerciseName: string
    category: string
    difficulty: string
    duration: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    completed?: boolean
    progress?: number
    results?: string | null
    feedback?: string | null
    improvement?: number | null
    moodBefore?: number | null
    moodAfter?: number | null
  }

  export type AIExerciseSessionUncheckedCreateWithoutSessionInput = {
    id?: string
    userId: string
    exerciseType: $Enums.AIExerciseType
    exerciseName: string
    category: string
    difficulty: string
    duration: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    completed?: boolean
    progress?: number
    results?: string | null
    feedback?: string | null
    improvement?: number | null
    moodBefore?: number | null
    moodAfter?: number | null
  }

  export type AIExerciseSessionCreateOrConnectWithoutSessionInput = {
    where: AIExerciseSessionWhereUniqueInput
    create: XOR<AIExerciseSessionCreateWithoutSessionInput, AIExerciseSessionUncheckedCreateWithoutSessionInput>
  }

  export type AIExerciseSessionCreateManySessionInputEnvelope = {
    data: AIExerciseSessionCreateManySessionInput | AIExerciseSessionCreateManySessionInput[]
  }

  export type AITherapistUpsertWithoutSessionsInput = {
    update: XOR<AITherapistUpdateWithoutSessionsInput, AITherapistUncheckedUpdateWithoutSessionsInput>
    create: XOR<AITherapistCreateWithoutSessionsInput, AITherapistUncheckedCreateWithoutSessionsInput>
    where?: AITherapistWhereInput
  }

  export type AITherapistUpdateToOneWithWhereWithoutSessionsInput = {
    where?: AITherapistWhereInput
    data: XOR<AITherapistUpdateWithoutSessionsInput, AITherapistUncheckedUpdateWithoutSessionsInput>
  }

  export type AITherapistUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    specialties?: StringFieldUpdateOperationsInput | string
    approaches?: StringFieldUpdateOperationsInput | string
    bestFor?: StringFieldUpdateOperationsInput | string
    features?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    sessionsCompleted?: IntFieldUpdateOperationsInput | number
    userRating?: FloatFieldUpdateOperationsInput | number
    responseTime?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalizations?: AIPersonalizationUpdateManyWithoutTherapistNestedInput
  }

  export type AITherapistUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    specialties?: StringFieldUpdateOperationsInput | string
    approaches?: StringFieldUpdateOperationsInput | string
    bestFor?: StringFieldUpdateOperationsInput | string
    features?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    sessionsCompleted?: IntFieldUpdateOperationsInput | number
    userRating?: FloatFieldUpdateOperationsInput | number
    responseTime?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalizations?: AIPersonalizationUncheckedUpdateManyWithoutTherapistNestedInput
  }

  export type AITherapyMessageUpsertWithWhereUniqueWithoutSessionInput = {
    where: AITherapyMessageWhereUniqueInput
    update: XOR<AITherapyMessageUpdateWithoutSessionInput, AITherapyMessageUncheckedUpdateWithoutSessionInput>
    create: XOR<AITherapyMessageCreateWithoutSessionInput, AITherapyMessageUncheckedCreateWithoutSessionInput>
  }

  export type AITherapyMessageUpdateWithWhereUniqueWithoutSessionInput = {
    where: AITherapyMessageWhereUniqueInput
    data: XOR<AITherapyMessageUpdateWithoutSessionInput, AITherapyMessageUncheckedUpdateWithoutSessionInput>
  }

  export type AITherapyMessageUpdateManyWithWhereWithoutSessionInput = {
    where: AITherapyMessageScalarWhereInput
    data: XOR<AITherapyMessageUpdateManyMutationInput, AITherapyMessageUncheckedUpdateManyWithoutSessionInput>
  }

  export type AITherapyMessageScalarWhereInput = {
    AND?: AITherapyMessageScalarWhereInput | AITherapyMessageScalarWhereInput[]
    OR?: AITherapyMessageScalarWhereInput[]
    NOT?: AITherapyMessageScalarWhereInput | AITherapyMessageScalarWhereInput[]
    id?: StringFilter<"AITherapyMessage"> | string
    sessionId?: StringFilter<"AITherapyMessage"> | string
    messageType?: EnumAIMessageTypeFilter<"AITherapyMessage"> | $Enums.AIMessageType
    sender?: EnumAIMessageSenderFilter<"AITherapyMessage"> | $Enums.AIMessageSender
    encryptedContent?: BytesFilter<"AITherapyMessage"> | Uint8Array
    messageHash?: StringFilter<"AITherapyMessage"> | string
    timestamp?: DateTimeFilter<"AITherapyMessage"> | Date | string
    edited?: BoolFilter<"AITherapyMessage"> | boolean
    editedAt?: DateTimeNullableFilter<"AITherapyMessage"> | Date | string | null
    sentiment?: FloatNullableFilter<"AITherapyMessage"> | number | null
    emotion?: StringNullableFilter<"AITherapyMessage"> | string | null
    riskScore?: IntNullableFilter<"AITherapyMessage"> | number | null
    techniques?: StringNullableFilter<"AITherapyMessage"> | string | null
    hasAudio?: BoolFilter<"AITherapyMessage"> | boolean
    audioDuration?: IntNullableFilter<"AITherapyMessage"> | number | null
    audioUrl?: StringNullableFilter<"AITherapyMessage"> | string | null
  }

  export type AIExerciseSessionUpsertWithWhereUniqueWithoutSessionInput = {
    where: AIExerciseSessionWhereUniqueInput
    update: XOR<AIExerciseSessionUpdateWithoutSessionInput, AIExerciseSessionUncheckedUpdateWithoutSessionInput>
    create: XOR<AIExerciseSessionCreateWithoutSessionInput, AIExerciseSessionUncheckedCreateWithoutSessionInput>
  }

  export type AIExerciseSessionUpdateWithWhereUniqueWithoutSessionInput = {
    where: AIExerciseSessionWhereUniqueInput
    data: XOR<AIExerciseSessionUpdateWithoutSessionInput, AIExerciseSessionUncheckedUpdateWithoutSessionInput>
  }

  export type AIExerciseSessionUpdateManyWithWhereWithoutSessionInput = {
    where: AIExerciseSessionScalarWhereInput
    data: XOR<AIExerciseSessionUpdateManyMutationInput, AIExerciseSessionUncheckedUpdateManyWithoutSessionInput>
  }

  export type AIExerciseSessionScalarWhereInput = {
    AND?: AIExerciseSessionScalarWhereInput | AIExerciseSessionScalarWhereInput[]
    OR?: AIExerciseSessionScalarWhereInput[]
    NOT?: AIExerciseSessionScalarWhereInput | AIExerciseSessionScalarWhereInput[]
    id?: StringFilter<"AIExerciseSession"> | string
    sessionId?: StringNullableFilter<"AIExerciseSession"> | string | null
    userId?: StringFilter<"AIExerciseSession"> | string
    exerciseType?: EnumAIExerciseTypeFilter<"AIExerciseSession"> | $Enums.AIExerciseType
    exerciseName?: StringFilter<"AIExerciseSession"> | string
    category?: StringFilter<"AIExerciseSession"> | string
    difficulty?: StringFilter<"AIExerciseSession"> | string
    duration?: IntFilter<"AIExerciseSession"> | number
    startedAt?: DateTimeFilter<"AIExerciseSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"AIExerciseSession"> | Date | string | null
    completed?: BoolFilter<"AIExerciseSession"> | boolean
    progress?: IntFilter<"AIExerciseSession"> | number
    results?: StringNullableFilter<"AIExerciseSession"> | string | null
    feedback?: StringNullableFilter<"AIExerciseSession"> | string | null
    improvement?: FloatNullableFilter<"AIExerciseSession"> | number | null
    moodBefore?: IntNullableFilter<"AIExerciseSession"> | number | null
    moodAfter?: IntNullableFilter<"AIExerciseSession"> | number | null
  }

  export type AITherapySessionCreateWithoutMessagesInput = {
    id?: string
    sessionToken: string
    userId: string
    sessionType: $Enums.AISessionType
    status?: $Enums.AISessionStatus
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    pausedAt?: Date | string | null
    pausedDuration?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    encryptedNotes?: Uint8Array | null
    encryptedInsights?: Uint8Array | null
    encryptedHomework?: Uint8Array | null
    encryptedGoals?: Uint8Array | null
    topics?: string | null
    techniques?: string | null
    interventions?: string | null
    breakthroughs?: string | null
    crisisDetected?: boolean
    crisisLevel?: number | null
    crisisInterventions?: string | null
    therapist: AITherapistCreateNestedOneWithoutSessionsInput
    exercises?: AIExerciseSessionCreateNestedManyWithoutSessionInput
  }

  export type AITherapySessionUncheckedCreateWithoutMessagesInput = {
    id?: string
    sessionToken: string
    userId: string
    therapistId: string
    sessionType: $Enums.AISessionType
    status?: $Enums.AISessionStatus
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    pausedAt?: Date | string | null
    pausedDuration?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    encryptedNotes?: Uint8Array | null
    encryptedInsights?: Uint8Array | null
    encryptedHomework?: Uint8Array | null
    encryptedGoals?: Uint8Array | null
    topics?: string | null
    techniques?: string | null
    interventions?: string | null
    breakthroughs?: string | null
    crisisDetected?: boolean
    crisisLevel?: number | null
    crisisInterventions?: string | null
    exercises?: AIExerciseSessionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AITherapySessionCreateOrConnectWithoutMessagesInput = {
    where: AITherapySessionWhereUniqueInput
    create: XOR<AITherapySessionCreateWithoutMessagesInput, AITherapySessionUncheckedCreateWithoutMessagesInput>
  }

  export type AITherapySessionUpsertWithoutMessagesInput = {
    update: XOR<AITherapySessionUpdateWithoutMessagesInput, AITherapySessionUncheckedUpdateWithoutMessagesInput>
    create: XOR<AITherapySessionCreateWithoutMessagesInput, AITherapySessionUncheckedCreateWithoutMessagesInput>
    where?: AITherapySessionWhereInput
  }

  export type AITherapySessionUpdateToOneWithWhereWithoutMessagesInput = {
    where?: AITherapySessionWhereInput
    data: XOR<AITherapySessionUpdateWithoutMessagesInput, AITherapySessionUncheckedUpdateWithoutMessagesInput>
  }

  export type AITherapySessionUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumAISessionTypeFieldUpdateOperationsInput | $Enums.AISessionType
    status?: EnumAISessionStatusFieldUpdateOperationsInput | $Enums.AISessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedDuration?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    energyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    encryptedNotes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedInsights?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedHomework?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedGoals?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    topics?: NullableStringFieldUpdateOperationsInput | string | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    interventions?: NullableStringFieldUpdateOperationsInput | string | null
    breakthroughs?: NullableStringFieldUpdateOperationsInput | string | null
    crisisDetected?: BoolFieldUpdateOperationsInput | boolean
    crisisLevel?: NullableIntFieldUpdateOperationsInput | number | null
    crisisInterventions?: NullableStringFieldUpdateOperationsInput | string | null
    therapist?: AITherapistUpdateOneRequiredWithoutSessionsNestedInput
    exercises?: AIExerciseSessionUpdateManyWithoutSessionNestedInput
  }

  export type AITherapySessionUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumAISessionTypeFieldUpdateOperationsInput | $Enums.AISessionType
    status?: EnumAISessionStatusFieldUpdateOperationsInput | $Enums.AISessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedDuration?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    energyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    encryptedNotes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedInsights?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedHomework?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedGoals?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    topics?: NullableStringFieldUpdateOperationsInput | string | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    interventions?: NullableStringFieldUpdateOperationsInput | string | null
    breakthroughs?: NullableStringFieldUpdateOperationsInput | string | null
    crisisDetected?: BoolFieldUpdateOperationsInput | boolean
    crisisLevel?: NullableIntFieldUpdateOperationsInput | number | null
    crisisInterventions?: NullableStringFieldUpdateOperationsInput | string | null
    exercises?: AIExerciseSessionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AITherapistCreateWithoutPersonalizationsInput = {
    id?: string
    therapistId: string
    name: string
    avatar: string
    personality: string
    description: string
    specialties: string
    approaches: string
    bestFor: string
    features: string
    availability: string
    sessionsCompleted?: number
    userRating?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AITherapySessionCreateNestedManyWithoutTherapistInput
  }

  export type AITherapistUncheckedCreateWithoutPersonalizationsInput = {
    id?: string
    therapistId: string
    name: string
    avatar: string
    personality: string
    description: string
    specialties: string
    approaches: string
    bestFor: string
    features: string
    availability: string
    sessionsCompleted?: number
    userRating?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AITherapySessionUncheckedCreateNestedManyWithoutTherapistInput
  }

  export type AITherapistCreateOrConnectWithoutPersonalizationsInput = {
    where: AITherapistWhereUniqueInput
    create: XOR<AITherapistCreateWithoutPersonalizationsInput, AITherapistUncheckedCreateWithoutPersonalizationsInput>
  }

  export type AITherapistUpsertWithoutPersonalizationsInput = {
    update: XOR<AITherapistUpdateWithoutPersonalizationsInput, AITherapistUncheckedUpdateWithoutPersonalizationsInput>
    create: XOR<AITherapistCreateWithoutPersonalizationsInput, AITherapistUncheckedCreateWithoutPersonalizationsInput>
    where?: AITherapistWhereInput
  }

  export type AITherapistUpdateToOneWithWhereWithoutPersonalizationsInput = {
    where?: AITherapistWhereInput
    data: XOR<AITherapistUpdateWithoutPersonalizationsInput, AITherapistUncheckedUpdateWithoutPersonalizationsInput>
  }

  export type AITherapistUpdateWithoutPersonalizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    specialties?: StringFieldUpdateOperationsInput | string
    approaches?: StringFieldUpdateOperationsInput | string
    bestFor?: StringFieldUpdateOperationsInput | string
    features?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    sessionsCompleted?: IntFieldUpdateOperationsInput | number
    userRating?: FloatFieldUpdateOperationsInput | number
    responseTime?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AITherapySessionUpdateManyWithoutTherapistNestedInput
  }

  export type AITherapistUncheckedUpdateWithoutPersonalizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    specialties?: StringFieldUpdateOperationsInput | string
    approaches?: StringFieldUpdateOperationsInput | string
    bestFor?: StringFieldUpdateOperationsInput | string
    features?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    sessionsCompleted?: IntFieldUpdateOperationsInput | number
    userRating?: FloatFieldUpdateOperationsInput | number
    responseTime?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AITherapySessionUncheckedUpdateManyWithoutTherapistNestedInput
  }

  export type AITherapySessionCreateWithoutExercisesInput = {
    id?: string
    sessionToken: string
    userId: string
    sessionType: $Enums.AISessionType
    status?: $Enums.AISessionStatus
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    pausedAt?: Date | string | null
    pausedDuration?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    encryptedNotes?: Uint8Array | null
    encryptedInsights?: Uint8Array | null
    encryptedHomework?: Uint8Array | null
    encryptedGoals?: Uint8Array | null
    topics?: string | null
    techniques?: string | null
    interventions?: string | null
    breakthroughs?: string | null
    crisisDetected?: boolean
    crisisLevel?: number | null
    crisisInterventions?: string | null
    therapist: AITherapistCreateNestedOneWithoutSessionsInput
    messages?: AITherapyMessageCreateNestedManyWithoutSessionInput
  }

  export type AITherapySessionUncheckedCreateWithoutExercisesInput = {
    id?: string
    sessionToken: string
    userId: string
    therapistId: string
    sessionType: $Enums.AISessionType
    status?: $Enums.AISessionStatus
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    pausedAt?: Date | string | null
    pausedDuration?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    encryptedNotes?: Uint8Array | null
    encryptedInsights?: Uint8Array | null
    encryptedHomework?: Uint8Array | null
    encryptedGoals?: Uint8Array | null
    topics?: string | null
    techniques?: string | null
    interventions?: string | null
    breakthroughs?: string | null
    crisisDetected?: boolean
    crisisLevel?: number | null
    crisisInterventions?: string | null
    messages?: AITherapyMessageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AITherapySessionCreateOrConnectWithoutExercisesInput = {
    where: AITherapySessionWhereUniqueInput
    create: XOR<AITherapySessionCreateWithoutExercisesInput, AITherapySessionUncheckedCreateWithoutExercisesInput>
  }

  export type AITherapySessionUpsertWithoutExercisesInput = {
    update: XOR<AITherapySessionUpdateWithoutExercisesInput, AITherapySessionUncheckedUpdateWithoutExercisesInput>
    create: XOR<AITherapySessionCreateWithoutExercisesInput, AITherapySessionUncheckedCreateWithoutExercisesInput>
    where?: AITherapySessionWhereInput
  }

  export type AITherapySessionUpdateToOneWithWhereWithoutExercisesInput = {
    where?: AITherapySessionWhereInput
    data: XOR<AITherapySessionUpdateWithoutExercisesInput, AITherapySessionUncheckedUpdateWithoutExercisesInput>
  }

  export type AITherapySessionUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumAISessionTypeFieldUpdateOperationsInput | $Enums.AISessionType
    status?: EnumAISessionStatusFieldUpdateOperationsInput | $Enums.AISessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedDuration?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    energyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    encryptedNotes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedInsights?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedHomework?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedGoals?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    topics?: NullableStringFieldUpdateOperationsInput | string | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    interventions?: NullableStringFieldUpdateOperationsInput | string | null
    breakthroughs?: NullableStringFieldUpdateOperationsInput | string | null
    crisisDetected?: BoolFieldUpdateOperationsInput | boolean
    crisisLevel?: NullableIntFieldUpdateOperationsInput | number | null
    crisisInterventions?: NullableStringFieldUpdateOperationsInput | string | null
    therapist?: AITherapistUpdateOneRequiredWithoutSessionsNestedInput
    messages?: AITherapyMessageUpdateManyWithoutSessionNestedInput
  }

  export type AITherapySessionUncheckedUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    therapistId?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumAISessionTypeFieldUpdateOperationsInput | $Enums.AISessionType
    status?: EnumAISessionStatusFieldUpdateOperationsInput | $Enums.AISessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedDuration?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    energyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    encryptedNotes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedInsights?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedHomework?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedGoals?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    topics?: NullableStringFieldUpdateOperationsInput | string | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    interventions?: NullableStringFieldUpdateOperationsInput | string | null
    breakthroughs?: NullableStringFieldUpdateOperationsInput | string | null
    crisisDetected?: BoolFieldUpdateOperationsInput | boolean
    crisisLevel?: NullableIntFieldUpdateOperationsInput | number | null
    crisisInterventions?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: AITherapyMessageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CrisisMessageCreateManySessionInput = {
    id?: string
    senderType: $Enums.MessageSender
    senderId: string
    encryptedContent: Uint8Array
    messageHash: string
    timestamp?: Date | string
    messageType?: $Enums.MessageType
    priority?: $Enums.MessagePriority
    sentimentScore?: number | null
    riskScore?: number | null
    riskLevel?: string | null
    keywordsDetected?: string | null
  }

  export type CrisisEscalationCreateManySessionInput = {
    id?: string
    triggeredBy: $Enums.EscalationTrigger
    severity: $Enums.EscalationSeverity
    reason: string
    actionsTaken?: string | null
    emergencyContacted?: boolean
    lifeline988Called?: boolean
    triggeredAt?: Date | string
    resolvedAt?: Date | string | null
    responseTime?: number | null
    handledBy?: string | null
    outcome?: $Enums.EscalationOutcome | null
  }

  export type CrisisResourceUsageCreateManySessionInput = {
    id?: string
    resourceId: string
    accessedAt?: Date | string
    timeSpent?: number | null
    wasHelpful?: boolean | null
    helpfulRating?: number | null
    resourceTitle: string
    resourceType: $Enums.ResourceCategory
  }

  export type CrisisMessageUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderType?: EnumMessageSenderFieldUpdateOperationsInput | $Enums.MessageSender
    senderId?: StringFieldUpdateOperationsInput | string
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    messageHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    keywordsDetected?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CrisisMessageUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderType?: EnumMessageSenderFieldUpdateOperationsInput | $Enums.MessageSender
    senderId?: StringFieldUpdateOperationsInput | string
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    messageHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    keywordsDetected?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CrisisMessageUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderType?: EnumMessageSenderFieldUpdateOperationsInput | $Enums.MessageSender
    senderId?: StringFieldUpdateOperationsInput | string
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    messageHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumMessagePriorityFieldUpdateOperationsInput | $Enums.MessagePriority
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    keywordsDetected?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CrisisEscalationUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggeredBy?: EnumEscalationTriggerFieldUpdateOperationsInput | $Enums.EscalationTrigger
    severity?: EnumEscalationSeverityFieldUpdateOperationsInput | $Enums.EscalationSeverity
    reason?: StringFieldUpdateOperationsInput | string
    actionsTaken?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacted?: BoolFieldUpdateOperationsInput | boolean
    lifeline988Called?: BoolFieldUpdateOperationsInput | boolean
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableEnumEscalationOutcomeFieldUpdateOperationsInput | $Enums.EscalationOutcome | null
  }

  export type CrisisEscalationUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggeredBy?: EnumEscalationTriggerFieldUpdateOperationsInput | $Enums.EscalationTrigger
    severity?: EnumEscalationSeverityFieldUpdateOperationsInput | $Enums.EscalationSeverity
    reason?: StringFieldUpdateOperationsInput | string
    actionsTaken?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacted?: BoolFieldUpdateOperationsInput | boolean
    lifeline988Called?: BoolFieldUpdateOperationsInput | boolean
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableEnumEscalationOutcomeFieldUpdateOperationsInput | $Enums.EscalationOutcome | null
  }

  export type CrisisEscalationUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggeredBy?: EnumEscalationTriggerFieldUpdateOperationsInput | $Enums.EscalationTrigger
    severity?: EnumEscalationSeverityFieldUpdateOperationsInput | $Enums.EscalationSeverity
    reason?: StringFieldUpdateOperationsInput | string
    actionsTaken?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacted?: BoolFieldUpdateOperationsInput | boolean
    lifeline988Called?: BoolFieldUpdateOperationsInput | boolean
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableEnumEscalationOutcomeFieldUpdateOperationsInput | $Enums.EscalationOutcome | null
  }

  export type CrisisResourceUsageUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    helpfulRating?: NullableIntFieldUpdateOperationsInput | number | null
    resourceTitle?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceCategoryFieldUpdateOperationsInput | $Enums.ResourceCategory
  }

  export type CrisisResourceUsageUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    helpfulRating?: NullableIntFieldUpdateOperationsInput | number | null
    resourceTitle?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceCategoryFieldUpdateOperationsInput | $Enums.ResourceCategory
  }

  export type CrisisResourceUsageUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    helpfulRating?: NullableIntFieldUpdateOperationsInput | number | null
    resourceTitle?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceCategoryFieldUpdateOperationsInput | $Enums.ResourceCategory
  }

  export type TetherPulseCreateManyTetherInput = {
    id?: string
    pulseType?: $Enums.PulseType
    strength: number
    mood?: number | null
    status?: $Enums.UserStatus
    message?: string | null
    emergencySignal?: boolean
    urgencyLevel?: $Enums.UrgencyLevel
    timestamp?: Date | string
    acknowledged?: boolean
    acknowledgedAt?: Date | string | null
  }

  export type TetherEmergencyCreateManyTetherInput = {
    id?: string
    triggerUserId: string
    emergencyType: $Enums.EmergencyType
    severity: $Enums.EmergencySeverity
    description: string
    location?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: Date | string
    acknowledgedAt?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    responseTime?: number | null
    actionsTaken?: string | null
    outcome?: $Enums.EmergencyOutcome | null
    helpersNotified?: string | null
    emergencyContacts?: string | null
  }

  export type TetherPulseUpdateWithoutTetherInput = {
    id?: StringFieldUpdateOperationsInput | string
    pulseType?: EnumPulseTypeFieldUpdateOperationsInput | $Enums.PulseType
    strength?: FloatFieldUpdateOperationsInput | number
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    emergencySignal?: BoolFieldUpdateOperationsInput | boolean
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TetherPulseUncheckedUpdateWithoutTetherInput = {
    id?: StringFieldUpdateOperationsInput | string
    pulseType?: EnumPulseTypeFieldUpdateOperationsInput | $Enums.PulseType
    strength?: FloatFieldUpdateOperationsInput | number
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    emergencySignal?: BoolFieldUpdateOperationsInput | boolean
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TetherPulseUncheckedUpdateManyWithoutTetherInput = {
    id?: StringFieldUpdateOperationsInput | string
    pulseType?: EnumPulseTypeFieldUpdateOperationsInput | $Enums.PulseType
    strength?: FloatFieldUpdateOperationsInput | number
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    emergencySignal?: BoolFieldUpdateOperationsInput | boolean
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TetherEmergencyUpdateWithoutTetherInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggerUserId?: StringFieldUpdateOperationsInput | string
    emergencyType?: EnumEmergencyTypeFieldUpdateOperationsInput | $Enums.EmergencyType
    severity?: EnumEmergencySeverityFieldUpdateOperationsInput | $Enums.EmergencySeverity
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    actionsTaken?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableEnumEmergencyOutcomeFieldUpdateOperationsInput | $Enums.EmergencyOutcome | null
    helpersNotified?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TetherEmergencyUncheckedUpdateWithoutTetherInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggerUserId?: StringFieldUpdateOperationsInput | string
    emergencyType?: EnumEmergencyTypeFieldUpdateOperationsInput | $Enums.EmergencyType
    severity?: EnumEmergencySeverityFieldUpdateOperationsInput | $Enums.EmergencySeverity
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    actionsTaken?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableEnumEmergencyOutcomeFieldUpdateOperationsInput | $Enums.EmergencyOutcome | null
    helpersNotified?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TetherEmergencyUncheckedUpdateManyWithoutTetherInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggerUserId?: StringFieldUpdateOperationsInput | string
    emergencyType?: EnumEmergencyTypeFieldUpdateOperationsInput | $Enums.EmergencyType
    severity?: EnumEmergencySeverityFieldUpdateOperationsInput | $Enums.EmergencySeverity
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    actionsTaken?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableEnumEmergencyOutcomeFieldUpdateOperationsInput | $Enums.EmergencyOutcome | null
    helpersNotified?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VolunteerTrainingCreateManyVolunteerInput = {
    id?: string
    moduleId: string
    status?: $Enums.TrainingStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    score?: number | null
    passingScore?: number
    attempts?: number
    moduleTitle: string
    moduleType: $Enums.TrainingType
    duration: number
    content: JsonNullValueInput | InputJsonValue
  }

  export type VolunteerSessionCreateManyVolunteerInput = {
    id?: string
    sessionType: $Enums.VolunteerSessionType
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    crisisSessionId?: string | null
    responseTime?: number | null
    userSatisfaction?: number | null
    outcome?: $Enums.SessionOutcome | null
  }

  export type VolunteerFeedbackCreateManyVolunteerInput = {
    id?: string
    sessionId?: string | null
    feedbackType: $Enums.FeedbackType
    rating: number
    comment?: string | null
    submittedBy?: string | null
    sourceType?: $Enums.FeedbackSource
    submittedAt?: Date | string
    isAnonymous?: boolean
    isApproved?: boolean
    moderatedAt?: Date | string | null
    moderatedBy?: string | null
  }

  export type VolunteerTrainingUpdateWithoutVolunteerInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passingScore?: FloatFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    moduleTitle?: StringFieldUpdateOperationsInput | string
    moduleType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    duration?: IntFieldUpdateOperationsInput | number
    content?: JsonNullValueInput | InputJsonValue
  }

  export type VolunteerTrainingUncheckedUpdateWithoutVolunteerInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passingScore?: FloatFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    moduleTitle?: StringFieldUpdateOperationsInput | string
    moduleType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    duration?: IntFieldUpdateOperationsInput | number
    content?: JsonNullValueInput | InputJsonValue
  }

  export type VolunteerTrainingUncheckedUpdateManyWithoutVolunteerInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passingScore?: FloatFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    moduleTitle?: StringFieldUpdateOperationsInput | string
    moduleType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    duration?: IntFieldUpdateOperationsInput | number
    content?: JsonNullValueInput | InputJsonValue
  }

  export type VolunteerSessionUpdateWithoutVolunteerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumVolunteerSessionTypeFieldUpdateOperationsInput | $Enums.VolunteerSessionType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    crisisSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableEnumSessionOutcomeFieldUpdateOperationsInput | $Enums.SessionOutcome | null
  }

  export type VolunteerSessionUncheckedUpdateWithoutVolunteerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumVolunteerSessionTypeFieldUpdateOperationsInput | $Enums.VolunteerSessionType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    crisisSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableEnumSessionOutcomeFieldUpdateOperationsInput | $Enums.SessionOutcome | null
  }

  export type VolunteerSessionUncheckedUpdateManyWithoutVolunteerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumVolunteerSessionTypeFieldUpdateOperationsInput | $Enums.VolunteerSessionType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    crisisSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableEnumSessionOutcomeFieldUpdateOperationsInput | $Enums.SessionOutcome | null
  }

  export type VolunteerFeedbackUpdateWithoutVolunteerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | $Enums.FeedbackSource
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VolunteerFeedbackUncheckedUpdateWithoutVolunteerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | $Enums.FeedbackSource
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VolunteerFeedbackUncheckedUpdateManyWithoutVolunteerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: EnumFeedbackSourceFieldUpdateOperationsInput | $Enums.FeedbackSource
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmergencyNotificationCreateManyEmergencyContactInput = {
    id?: string
    sessionId?: string | null
    tetherEmergencyId?: string | null
    notificationType: $Enums.EmergencyNotificationType
    severity: $Enums.EmergencySeverity
    message: string
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    acknowledgedAt?: Date | string | null
    responseReceived?: boolean
    responseTime?: number | null
    method: string
    status?: $Enums.NotificationStatus
    attempts?: number
    maxAttempts?: number
    errorMessage?: string | null
    nextRetryAt?: Date | string | null
  }

  export type EmergencyNotificationUpdateWithoutEmergencyContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    tetherEmergencyId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumEmergencyNotificationTypeFieldUpdateOperationsInput | $Enums.EmergencyNotificationType
    severity?: EnumEmergencySeverityFieldUpdateOperationsInput | $Enums.EmergencySeverity
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseReceived?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    method?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyNotificationUncheckedUpdateWithoutEmergencyContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    tetherEmergencyId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumEmergencyNotificationTypeFieldUpdateOperationsInput | $Enums.EmergencyNotificationType
    severity?: EnumEmergencySeverityFieldUpdateOperationsInput | $Enums.EmergencySeverity
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseReceived?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    method?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyNotificationUncheckedUpdateManyWithoutEmergencyContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    tetherEmergencyId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumEmergencyNotificationTypeFieldUpdateOperationsInput | $Enums.EmergencyNotificationType
    severity?: EnumEmergencySeverityFieldUpdateOperationsInput | $Enums.EmergencySeverity
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseReceived?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    method?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MoodEntryCreateManyUserInput = {
    id?: string
    mood: number
    emotions: JsonNullValueInput | InputJsonValue
    triggers: JsonNullValueInput | InputJsonValue
    activities: JsonNullValueInput | InputJsonValue
    sleepHours?: number | null
    notes?: string | null
    weather?: string | null
    medication?: boolean | null
    socialInteraction?: number | null
    timestamp?: Date | string
  }

  export type SafetyPlanCreateManyUserInput = {
    id?: string
    title: string
    version?: number
    isActive?: boolean
    encryptedContent: Uint8Array
    contentHash: string
    sharedWith?: NullableJsonNullValueInput | InputJsonValue
    emergencyShare?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAchievementCreateManyUserInput = {
    id?: string
    achievementId: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserChallengeCreateManyUserInput = {
    id?: string
    challengeId: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    startedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserActivityCreateManyUserInput = {
    id?: string
    type: $Enums.ActivityType
    description: string
    xpEarned?: number
    pointsEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type EmergencyContactCreateManyUserInput = {
    id?: string
    encryptedName: Uint8Array
    encryptedPhone: Uint8Array
    encryptedEmail?: Uint8Array | null
    relationship: string
    priority?: number
    contactMethod?: string
    timezone?: string | null
    availableHours?: NullableJsonNullValueInput | InputJsonValue
    preferredMethod?: string | null
    autoNotify?: boolean
    crisisOnly?: boolean
    hasConsent?: boolean
    consentDate?: Date | string | null
    keyDerivationSalt: Uint8Array
    isVerified?: boolean
    verifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastContacted?: Date | string | null
  }

  export type JournalEntryCreateManyUserInput = {
    id?: string
    title?: string | null
    promptId?: string | null
    promptText?: string | null
    entryType?: $Enums.JournalType
    encryptedContent: Uint8Array
    contentHash: string
    keyDerivationSalt: Uint8Array
    mood?: number | null
    sentimentScore?: number | null
    emotions?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    isPrivate?: boolean
    shareWithTherapist?: boolean
    wordCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreathingSessionCreateManyUserInput = {
    id?: string
    exerciseId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    cyclesCompleted?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    averageBreathRate?: number | null
    heartRateBefore?: number | null
    heartRateAfter?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
  }

  export type GroundingSessionCreateManyUserInput = {
    id?: string
    techniqueId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    triggerType?: string | null
    severityBefore?: number | null
    severityAfter?: number | null
    panicBefore?: number | null
    panicAfter?: number | null
    dissociationBefore?: number | null
    dissociationAfter?: number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    wouldUseAgain?: boolean | null
  }

  export type SelfHelpInteractionCreateManyUserInput = {
    id?: string
    resourceId: string
    interactionType: $Enums.InteractionType
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    moodBefore?: number | null
    moodAfter?: number | null
  }

  export type MoodEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: IntFieldUpdateOperationsInput | number
    emotions?: JsonNullValueInput | InputJsonValue
    triggers?: JsonNullValueInput | InputJsonValue
    activities?: JsonNullValueInput | InputJsonValue
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    medication?: NullableBoolFieldUpdateOperationsInput | boolean | null
    socialInteraction?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: IntFieldUpdateOperationsInput | number
    emotions?: JsonNullValueInput | InputJsonValue
    triggers?: JsonNullValueInput | InputJsonValue
    activities?: JsonNullValueInput | InputJsonValue
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    medication?: NullableBoolFieldUpdateOperationsInput | boolean | null
    socialInteraction?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: IntFieldUpdateOperationsInput | number
    emotions?: JsonNullValueInput | InputJsonValue
    triggers?: JsonNullValueInput | InputJsonValue
    activities?: JsonNullValueInput | InputJsonValue
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    medication?: NullableBoolFieldUpdateOperationsInput | boolean | null
    socialInteraction?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetyPlanUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    sharedWith?: NullableJsonNullValueInput | InputJsonValue
    emergencyShare?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: SafetyPlanVersionUpdateManyWithoutSafetyPlanNestedInput
  }

  export type SafetyPlanUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    sharedWith?: NullableJsonNullValueInput | InputJsonValue
    emergencyShare?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: SafetyPlanVersionUncheckedUpdateManyWithoutSafetyPlanNestedInput
  }

  export type SafetyPlanUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    sharedWith?: NullableJsonNullValueInput | InputJsonValue
    emergencyShare?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserChallengeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    challenge?: ChallengeUpdateOneRequiredWithoutUserChallengesNestedInput
  }

  export type UserChallengeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserChallengeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: StringFieldUpdateOperationsInput | string
    xpEarned?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: StringFieldUpdateOperationsInput | string
    xpEarned?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: StringFieldUpdateOperationsInput | string
    xpEarned?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedName?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedPhone?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    relationship?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    contactMethod?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    availableHours?: NullableJsonNullValueInput | InputJsonValue
    preferredMethod?: NullableStringFieldUpdateOperationsInput | string | null
    autoNotify?: BoolFieldUpdateOperationsInput | boolean
    crisisOnly?: BoolFieldUpdateOperationsInput | boolean
    hasConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keyDerivationSalt?: BytesFieldUpdateOperationsInput | Uint8Array
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContacted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifications?: EmergencyNotificationUpdateManyWithoutEmergencyContactNestedInput
  }

  export type EmergencyContactUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedName?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedPhone?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    relationship?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    contactMethod?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    availableHours?: NullableJsonNullValueInput | InputJsonValue
    preferredMethod?: NullableStringFieldUpdateOperationsInput | string | null
    autoNotify?: BoolFieldUpdateOperationsInput | boolean
    crisisOnly?: BoolFieldUpdateOperationsInput | boolean
    hasConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keyDerivationSalt?: BytesFieldUpdateOperationsInput | Uint8Array
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContacted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifications?: EmergencyNotificationUncheckedUpdateManyWithoutEmergencyContactNestedInput
  }

  export type EmergencyContactUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedName?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedPhone?: BytesFieldUpdateOperationsInput | Uint8Array
    encryptedEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    relationship?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    contactMethod?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    availableHours?: NullableJsonNullValueInput | InputJsonValue
    preferredMethod?: NullableStringFieldUpdateOperationsInput | string | null
    autoNotify?: BoolFieldUpdateOperationsInput | boolean
    crisisOnly?: BoolFieldUpdateOperationsInput | boolean
    hasConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keyDerivationSalt?: BytesFieldUpdateOperationsInput | Uint8Array
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastContacted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JournalEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    promptText?: NullableStringFieldUpdateOperationsInput | string | null
    entryType?: EnumJournalTypeFieldUpdateOperationsInput | $Enums.JournalType
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    keyDerivationSalt?: BytesFieldUpdateOperationsInput | Uint8Array
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    emotions?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    shareWithTherapist?: BoolFieldUpdateOperationsInput | boolean
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    promptText?: NullableStringFieldUpdateOperationsInput | string | null
    entryType?: EnumJournalTypeFieldUpdateOperationsInput | $Enums.JournalType
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    keyDerivationSalt?: BytesFieldUpdateOperationsInput | Uint8Array
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    emotions?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    shareWithTherapist?: BoolFieldUpdateOperationsInput | boolean
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    promptText?: NullableStringFieldUpdateOperationsInput | string | null
    entryType?: EnumJournalTypeFieldUpdateOperationsInput | $Enums.JournalType
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    keyDerivationSalt?: BytesFieldUpdateOperationsInput | Uint8Array
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    emotions?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    shareWithTherapist?: BoolFieldUpdateOperationsInput | boolean
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreathingSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cyclesCompleted?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    averageBreathRate?: NullableFloatFieldUpdateOperationsInput | number | null
    heartRateBefore?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAfter?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    exercise?: BreathingExerciseUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type BreathingSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cyclesCompleted?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    averageBreathRate?: NullableFloatFieldUpdateOperationsInput | number | null
    heartRateBefore?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAfter?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BreathingSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cyclesCompleted?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    averageBreathRate?: NullableFloatFieldUpdateOperationsInput | number | null
    heartRateBefore?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAfter?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroundingSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    severityBefore?: NullableIntFieldUpdateOperationsInput | number | null
    severityAfter?: NullableIntFieldUpdateOperationsInput | number | null
    panicBefore?: NullableIntFieldUpdateOperationsInput | number | null
    panicAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationBefore?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationAfter?: NullableIntFieldUpdateOperationsInput | number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wouldUseAgain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technique?: GroundingTechniqueUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type GroundingSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    techniqueId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    severityBefore?: NullableIntFieldUpdateOperationsInput | number | null
    severityAfter?: NullableIntFieldUpdateOperationsInput | number | null
    panicBefore?: NullableIntFieldUpdateOperationsInput | number | null
    panicAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationBefore?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationAfter?: NullableIntFieldUpdateOperationsInput | number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wouldUseAgain?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type GroundingSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    techniqueId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    severityBefore?: NullableIntFieldUpdateOperationsInput | number | null
    severityAfter?: NullableIntFieldUpdateOperationsInput | number | null
    panicBefore?: NullableIntFieldUpdateOperationsInput | number | null
    panicAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationBefore?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationAfter?: NullableIntFieldUpdateOperationsInput | number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wouldUseAgain?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SelfHelpInteractionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    resource?: SelfHelpResourceUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type SelfHelpInteractionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SelfHelpInteractionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SafetyPlanVersionCreateManySafetyPlanInput = {
    id?: string
    version: number
    changeLog?: string | null
    encryptedContent: Uint8Array
    contentHash: string
    createdAt?: Date | string
    createdBy: string
  }

  export type SafetyPlanVersionUpdateWithoutSafetyPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    changeLog?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type SafetyPlanVersionUncheckedUpdateWithoutSafetyPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    changeLog?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type SafetyPlanVersionUncheckedUpdateManyWithoutSafetyPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    changeLog?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type UserAchievementCreateManyAchievementInput = {
    id?: string
    userId: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserAchievementUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserChallengeCreateManyChallengeInput = {
    id?: string
    userId: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    startedAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserChallengeUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutChallengesNestedInput
  }

  export type UserChallengeUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserChallengeUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BreathingSessionCreateManyExerciseInput = {
    id?: string
    userId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    cyclesCompleted?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    averageBreathRate?: number | null
    heartRateBefore?: number | null
    heartRateAfter?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
  }

  export type BreathingSessionUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cyclesCompleted?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    averageBreathRate?: NullableFloatFieldUpdateOperationsInput | number | null
    heartRateBefore?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAfter?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBreathingSessionsNestedInput
  }

  export type BreathingSessionUncheckedUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cyclesCompleted?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    averageBreathRate?: NullableFloatFieldUpdateOperationsInput | number | null
    heartRateBefore?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAfter?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BreathingSessionUncheckedUpdateManyWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cyclesCompleted?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    averageBreathRate?: NullableFloatFieldUpdateOperationsInput | number | null
    heartRateBefore?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAfter?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroundingSessionCreateManyTechniqueInput = {
    id?: string
    userId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    triggerType?: string | null
    severityBefore?: number | null
    severityAfter?: number | null
    panicBefore?: number | null
    panicAfter?: number | null
    dissociationBefore?: number | null
    dissociationAfter?: number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    wouldUseAgain?: boolean | null
  }

  export type GroundingSessionUpdateWithoutTechniqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    severityBefore?: NullableIntFieldUpdateOperationsInput | number | null
    severityAfter?: NullableIntFieldUpdateOperationsInput | number | null
    panicBefore?: NullableIntFieldUpdateOperationsInput | number | null
    panicAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationBefore?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationAfter?: NullableIntFieldUpdateOperationsInput | number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wouldUseAgain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutGroundingSessionsNestedInput
  }

  export type GroundingSessionUncheckedUpdateWithoutTechniqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    severityBefore?: NullableIntFieldUpdateOperationsInput | number | null
    severityAfter?: NullableIntFieldUpdateOperationsInput | number | null
    panicBefore?: NullableIntFieldUpdateOperationsInput | number | null
    panicAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationBefore?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationAfter?: NullableIntFieldUpdateOperationsInput | number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wouldUseAgain?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type GroundingSessionUncheckedUpdateManyWithoutTechniqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableStringFieldUpdateOperationsInput | string | null
    severityBefore?: NullableIntFieldUpdateOperationsInput | number | null
    severityAfter?: NullableIntFieldUpdateOperationsInput | number | null
    panicBefore?: NullableIntFieldUpdateOperationsInput | number | null
    panicAfter?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationBefore?: NullableIntFieldUpdateOperationsInput | number | null
    dissociationAfter?: NullableIntFieldUpdateOperationsInput | number | null
    stepsCompleted?: NullableJsonNullValueInput | InputJsonValue
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wouldUseAgain?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SelfHelpInteractionCreateManyResourceInput = {
    id?: string
    userId: string
    interactionType: $Enums.InteractionType
    startedAt?: Date | string
    completedAt?: Date | string | null
    duration?: number | null
    wasHelpful?: boolean | null
    rating?: number | null
    notes?: string | null
    moodBefore?: number | null
    moodAfter?: number | null
  }

  export type SelfHelpInteractionUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutSelfHelpInteractionsNestedInput
  }

  export type SelfHelpInteractionUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SelfHelpInteractionUncheckedUpdateManyWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    wasHelpful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AITherapySessionCreateManyTherapistInput = {
    id?: string
    sessionToken: string
    userId: string
    sessionType: $Enums.AISessionType
    status?: $Enums.AISessionStatus
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    pausedAt?: Date | string | null
    pausedDuration?: number
    moodBefore?: number | null
    moodAfter?: number | null
    anxietyBefore?: number | null
    anxietyAfter?: number | null
    energyBefore?: number | null
    energyAfter?: number | null
    encryptedNotes?: Uint8Array | null
    encryptedInsights?: Uint8Array | null
    encryptedHomework?: Uint8Array | null
    encryptedGoals?: Uint8Array | null
    topics?: string | null
    techniques?: string | null
    interventions?: string | null
    breakthroughs?: string | null
    crisisDetected?: boolean
    crisisLevel?: number | null
    crisisInterventions?: string | null
  }

  export type AIPersonalizationCreateManyTherapistInput = {
    id?: string
    userId: string
    preferredStyle?: string | null
    preferredTechniques?: string | null
    preferredTopics?: string | null
    avoidTopics?: string | null
    responseLength?: string
    responseComplexity?: string
    empathyLevel?: string
    directness?: string
    culturalBackground?: string | null
    languagePreference?: string
    timezone?: string
    pronouns?: string | null
    learnedPatterns?: string | null
    effectiveTechniques?: string | null
    triggerPatterns?: string | null
    copingStrategies?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AITherapySessionUpdateWithoutTherapistInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumAISessionTypeFieldUpdateOperationsInput | $Enums.AISessionType
    status?: EnumAISessionStatusFieldUpdateOperationsInput | $Enums.AISessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedDuration?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    energyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    encryptedNotes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedInsights?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedHomework?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedGoals?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    topics?: NullableStringFieldUpdateOperationsInput | string | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    interventions?: NullableStringFieldUpdateOperationsInput | string | null
    breakthroughs?: NullableStringFieldUpdateOperationsInput | string | null
    crisisDetected?: BoolFieldUpdateOperationsInput | boolean
    crisisLevel?: NullableIntFieldUpdateOperationsInput | number | null
    crisisInterventions?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: AITherapyMessageUpdateManyWithoutSessionNestedInput
    exercises?: AIExerciseSessionUpdateManyWithoutSessionNestedInput
  }

  export type AITherapySessionUncheckedUpdateWithoutTherapistInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumAISessionTypeFieldUpdateOperationsInput | $Enums.AISessionType
    status?: EnumAISessionStatusFieldUpdateOperationsInput | $Enums.AISessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedDuration?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    energyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    encryptedNotes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedInsights?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedHomework?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedGoals?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    topics?: NullableStringFieldUpdateOperationsInput | string | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    interventions?: NullableStringFieldUpdateOperationsInput | string | null
    breakthroughs?: NullableStringFieldUpdateOperationsInput | string | null
    crisisDetected?: BoolFieldUpdateOperationsInput | boolean
    crisisLevel?: NullableIntFieldUpdateOperationsInput | number | null
    crisisInterventions?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: AITherapyMessageUncheckedUpdateManyWithoutSessionNestedInput
    exercises?: AIExerciseSessionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AITherapySessionUncheckedUpdateManyWithoutTherapistInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionType?: EnumAISessionTypeFieldUpdateOperationsInput | $Enums.AISessionType
    status?: EnumAISessionStatusFieldUpdateOperationsInput | $Enums.AISessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedDuration?: IntFieldUpdateOperationsInput | number
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    anxietyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    energyBefore?: NullableIntFieldUpdateOperationsInput | number | null
    energyAfter?: NullableIntFieldUpdateOperationsInput | number | null
    encryptedNotes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedInsights?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedHomework?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    encryptedGoals?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    topics?: NullableStringFieldUpdateOperationsInput | string | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    interventions?: NullableStringFieldUpdateOperationsInput | string | null
    breakthroughs?: NullableStringFieldUpdateOperationsInput | string | null
    crisisDetected?: BoolFieldUpdateOperationsInput | boolean
    crisisLevel?: NullableIntFieldUpdateOperationsInput | number | null
    crisisInterventions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AIPersonalizationUpdateWithoutTherapistInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferredStyle?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTopics?: NullableStringFieldUpdateOperationsInput | string | null
    avoidTopics?: NullableStringFieldUpdateOperationsInput | string | null
    responseLength?: StringFieldUpdateOperationsInput | string
    responseComplexity?: StringFieldUpdateOperationsInput | string
    empathyLevel?: StringFieldUpdateOperationsInput | string
    directness?: StringFieldUpdateOperationsInput | string
    culturalBackground?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    learnedPatterns?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    triggerPatterns?: NullableStringFieldUpdateOperationsInput | string | null
    copingStrategies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIPersonalizationUncheckedUpdateWithoutTherapistInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferredStyle?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTopics?: NullableStringFieldUpdateOperationsInput | string | null
    avoidTopics?: NullableStringFieldUpdateOperationsInput | string | null
    responseLength?: StringFieldUpdateOperationsInput | string
    responseComplexity?: StringFieldUpdateOperationsInput | string
    empathyLevel?: StringFieldUpdateOperationsInput | string
    directness?: StringFieldUpdateOperationsInput | string
    culturalBackground?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    learnedPatterns?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    triggerPatterns?: NullableStringFieldUpdateOperationsInput | string | null
    copingStrategies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIPersonalizationUncheckedUpdateManyWithoutTherapistInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferredStyle?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTopics?: NullableStringFieldUpdateOperationsInput | string | null
    avoidTopics?: NullableStringFieldUpdateOperationsInput | string | null
    responseLength?: StringFieldUpdateOperationsInput | string
    responseComplexity?: StringFieldUpdateOperationsInput | string
    empathyLevel?: StringFieldUpdateOperationsInput | string
    directness?: StringFieldUpdateOperationsInput | string
    culturalBackground?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    learnedPatterns?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    triggerPatterns?: NullableStringFieldUpdateOperationsInput | string | null
    copingStrategies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AITherapyMessageCreateManySessionInput = {
    id?: string
    messageType: $Enums.AIMessageType
    sender: $Enums.AIMessageSender
    encryptedContent: Uint8Array
    messageHash: string
    timestamp?: Date | string
    edited?: boolean
    editedAt?: Date | string | null
    sentiment?: number | null
    emotion?: string | null
    riskScore?: number | null
    techniques?: string | null
    hasAudio?: boolean
    audioDuration?: number | null
    audioUrl?: string | null
  }

  export type AIExerciseSessionCreateManySessionInput = {
    id?: string
    userId: string
    exerciseType: $Enums.AIExerciseType
    exerciseName: string
    category: string
    difficulty: string
    duration: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    completed?: boolean
    progress?: number
    results?: string | null
    feedback?: string | null
    improvement?: number | null
    moodBefore?: number | null
    moodAfter?: number | null
  }

  export type AITherapyMessageUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageType?: EnumAIMessageTypeFieldUpdateOperationsInput | $Enums.AIMessageType
    sender?: EnumAIMessageSenderFieldUpdateOperationsInput | $Enums.AIMessageSender
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    messageHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    emotion?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    hasAudio?: BoolFieldUpdateOperationsInput | boolean
    audioDuration?: NullableIntFieldUpdateOperationsInput | number | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AITherapyMessageUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageType?: EnumAIMessageTypeFieldUpdateOperationsInput | $Enums.AIMessageType
    sender?: EnumAIMessageSenderFieldUpdateOperationsInput | $Enums.AIMessageSender
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    messageHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    emotion?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    hasAudio?: BoolFieldUpdateOperationsInput | boolean
    audioDuration?: NullableIntFieldUpdateOperationsInput | number | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AITherapyMessageUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageType?: EnumAIMessageTypeFieldUpdateOperationsInput | $Enums.AIMessageType
    sender?: EnumAIMessageSenderFieldUpdateOperationsInput | $Enums.AIMessageSender
    encryptedContent?: BytesFieldUpdateOperationsInput | Uint8Array
    messageHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    emotion?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    techniques?: NullableStringFieldUpdateOperationsInput | string | null
    hasAudio?: BoolFieldUpdateOperationsInput | boolean
    audioDuration?: NullableIntFieldUpdateOperationsInput | number | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AIExerciseSessionUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exerciseType?: EnumAIExerciseTypeFieldUpdateOperationsInput | $Enums.AIExerciseType
    exerciseName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    progress?: IntFieldUpdateOperationsInput | number
    results?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AIExerciseSessionUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exerciseType?: EnumAIExerciseTypeFieldUpdateOperationsInput | $Enums.AIExerciseType
    exerciseName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    progress?: IntFieldUpdateOperationsInput | number
    results?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AIExerciseSessionUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exerciseType?: EnumAIExerciseTypeFieldUpdateOperationsInput | $Enums.AIExerciseType
    exerciseName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    progress?: IntFieldUpdateOperationsInput | number
    results?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    moodBefore?: NullableIntFieldUpdateOperationsInput | number | null
    moodAfter?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}